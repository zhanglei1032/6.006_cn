1
00:00:00,000 --> 00:00:00,090



2
00:00:00,090 --> 00:00:01,800
The following content is provided
提供以下内容

3
00:00:01,800 --> 00:00:04,040
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,040 --> 00:00:06,879
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,879 --> 00:00:10,740
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,740 --> 00:00:13,349
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,349 --> 00:00:15,800
from hundreds of MIT courses, visit
从数百个麻省理工学院的课程中访问

8
00:00:15,800 --> 00:00:21,993
MIT OpenCourseWare at ocw.mit.edu
麻省理工学院的开放式课件网站ocw.mit.edu 

9
00:00:21,993 --> 00:00:24,850
PROFESSOR: All right, let's get started.
教授：好的，让我们开始吧。 

10
00:00:24,850 --> 00:00:27,609
We return today to graph search.
我们今天返回图搜索。 

11
00:00:27,809 --> 00:00:29,949
Last time we saw breadth-first search, today we're
上次我们看到广度优先搜索时，今天我们是

12
00:00:29,949 --> 00:00:31,672
going to do depth-first search.
将进行深度优先搜索。 

13
00:00:31,672 --> 00:00:34,130
It's a simple algorithm, but you can do lots of cool things
这是一个简单的算法，但是您可以做很多很酷的事情

14
00:00:34,130 --> 00:00:34,570
with it.
用它。 

15
00:00:34,570 --> 00:00:36,235
And that's what I'll spend most of today
这就是我今天大部分时间的时间

16
00:00:36,235 --> 00:00:39,679
on, in particular, telling whether your graph has a cycle,
特别是告诉您的图表是否具有循环， 

17
00:00:39,679 --> 00:00:42,679
and something called topological sort.
以及所谓的拓扑排序

18
00:00:42,679 --> 00:00:45,969
As usual, basically in all graph algorithms
像往常一样，基本上在所有图算法中

19
00:00:45,969 --> 00:00:48,789
in this class, the input, the way the graph is specified
在此类中，输入是指定图形的方式

20
00:00:48,789 --> 00:00:52,839
is as an adjacency list, or I guess adjacency list plural.
是作为邻接表，或者我猜邻接表是复数形式。 

21
00:00:52,840 --> 00:00:56,460
So you have a bunch of lists, each one says for each vertex,
因此，您有一堆清单，每个清单针对每个顶点说， 

22
00:00:56,460 --> 00:00:58,549
what are the vertices I'm connected to?
我连接到的顶点是什么？ 

23
00:00:58,549 --> 00:01:02,899
What are the vertices I can get to in one step via an edge?
我可以通过一条边一步到达哪些顶点？ 

24
00:01:02,899 --> 00:01:05,039
So that's our input and our goal,
这就是我们的投入和目标， 

25
00:01:05,040 --> 00:01:08,429
in general, with graph search is to explore the graph.
通常，使用图搜索是要探索图。 

26
00:01:08,629 --> 00:01:10,390
In particular, the kind of exploration
特别是那种探索

27
00:01:10,390 --> 00:01:13,430
we're going to be doing today is to visit all the vertices,
我们今天要做的是访问所有顶点

28
00:01:13,430 --> 00:01:17,215
in some order, and visit each vertex only once.
以某种顺序访问每个顶点一次。 

29
00:01:17,415 --> 00:01:19,039
So the way we did breadth-first search,
所以我们进行广度优先搜索的方式

30
00:01:19,040 --> 00:01:20,581
breadth-first search was really good.
广度优先搜索的确很好。 

31
00:01:20,581 --> 00:01:22,829
It explored things layer by layer,
它逐层探索事物， 

32
00:01:22,829 --> 00:01:25,340
and that was nice because it gave us shortest paths,
很好，因为它给了我们最短的路径， 

33
00:01:25,340 --> 00:01:28,829
it gave us the fastest way to get to everywhere,
它为我们提供了前往各个地方的最快方式， 

34
00:01:28,829 --> 00:01:31,489
from a particular source, vertex s.
来自特定来源vertex。 

35
00:01:31,489 --> 00:01:34,209
But if you can't get from s to your vertex,
但是，如果您无法从s到达顶点， 

36
00:01:34,209 --> 00:01:37,409
than the shortest way to get there is infinity,
比到达那里的最短方法是无限

37
00:01:37,409 --> 00:01:39,439
there's no way to get there.
没有办法到达那里。 

38
00:01:39,439 --> 00:01:41,789
And BFS is good for detecting that, it can tell you
 BFS可以很好地检测到它，它可以告诉您

39
00:01:41,790 --> 00:01:46,289
which vertices are unreachable from s.
从s不能到达哪个顶点。 

40
00:01:46,489 --> 00:01:50,129
DFS can do that as well, but it's often
 DFS也可以做到这一点，但是通常

41
00:01:50,129 --> 00:01:52,390
used to explore the whole graph, not just
用于探索整个图，而不仅仅是

42
00:01:52,390 --> 00:01:54,134
the part reachable from s, and so
可从s到达的部分，依此类推

43
00:01:54,134 --> 00:01:55,799
we're going to see how to do that today.
我们今天要看看如何做到这一点。 

44
00:01:55,799 --> 00:01:58,579
This trick could be used for be BFS or for DFS,
这个技巧可以用于BFS或DFS， 

45
00:01:58,579 --> 00:02:01,590
but we're going to do it here for DFS, because that's
但是我们将在这里为DFS进行操作，因为那是

46
00:02:01,590 --> 00:02:02,840
more common, let's say.
比方说，更常见。 

47
00:02:02,840 --> 00:02:07,079



48
00:02:07,079 --> 00:02:09,014
So DFS.
所以DFS。 

49
00:02:09,014 --> 00:02:21,110



50
00:02:21,110 --> 00:02:24,930
So depth-first search is kind of like how you solve a maze.
因此，深度优先搜索就像解决迷宫一样。 

51
00:02:24,930 --> 00:02:27,349
Like, the other weekend I was at the big corn
就像，另一个周末我在大玉米

52
00:02:27,349 --> 00:02:32,049
maze in central Massachusetts, and it's
在马萨诸塞州中部的迷宫， 

53
00:02:32,050 --> 00:02:34,584
easy to get lost in there, in particular,
特别容易在那儿迷路

54
00:02:34,584 --> 00:02:36,250
because I didn't bring any bread crumbs.
因为我没有带面包屑

55
00:02:36,250 --> 00:02:39,159
The proper way to solve a maze, if you're in there
解决迷宫的正确方法（如果您在其中） 

56
00:02:39,159 --> 00:02:41,949
and all you can do is see which way to go next and then walk
而您所能做的就是看看下一步该走什么路然后走

57
00:02:41,949 --> 00:02:43,729
a little bit to the next junction,
到下一个路口

58
00:02:43,729 --> 00:02:45,969
and then you have to keep making decisions.
然后你必须继续做决定。 

59
00:02:45,969 --> 00:02:49,490
Unless you have a really good memory, which I do not,
除非你的记忆力真的很好，否则我不会

60
00:02:49,490 --> 00:02:53,780
teaching staff can attest to that, then an easy way to do it
教学人员可以证明这一点，然后便是一种简单的方法

61
00:02:53,780 --> 00:02:55,719
is to leave bread crumbs behind, say,
就是把面包屑留在后面

62
00:02:55,719 --> 00:02:58,710
this is the last way I went from this node,
这是我从该节点出发的最后一条路， 

63
00:02:58,710 --> 00:03:00,774
so that when I reach a deadend, I
这样当我到达死胡同时

64
00:03:00,973 --> 00:03:02,389
have to turn around and backtrack.
必须转身回去。 

65
00:03:02,389 --> 00:03:04,449
I reach a breadcrumb that say, oh, last time you
我碰到面包屑说，哦，上一次你

66
00:03:04,449 --> 00:03:07,159
went this way, next time you should go this way,
这样，下次您应该这样， 

67
00:03:07,159 --> 00:03:10,569
and in particular, keep track at each node, which of the edges
尤其要跟踪每个节点上的哪些边

68
00:03:10,569 --> 00:03:14,889
have I visited, which ones are still left to visit.
我有去过吗，哪些还留着去。 

69
00:03:14,889 --> 00:03:18,909
And this can be done very easily on a computer using recursion.
使用递归可以很容易地在计算机上完成此操作。 

70
00:03:18,909 --> 00:03:30,519



71
00:03:30,520 --> 00:03:31,939
So high-level description is we're
因此，高层次的描述是

72
00:03:32,139 --> 00:03:37,399
going to just recursively explore the graph,
只是递归地浏览图， 

73
00:03:37,400 --> 00:03:42,495
backtracking as necessary, kind of like how you solve a maze.
必要时回溯，就像解决迷宫一样。 

74
00:03:42,495 --> 00:03:54,780



75
00:03:54,979 --> 00:03:59,209
In fact, when I was seven years old,
实际上，我七岁的时候

76
00:03:59,210 --> 00:04:00,960
one of the first computer programs I wrote
我写的第一批计算机程序之一

77
00:04:00,960 --> 00:04:01,918
was for solving a maze.
是为了解决迷宫。 

78
00:04:01,918 --> 00:04:03,939
I didn't know it was depth-first search at the time,
我当时不知道这是深度优先搜索， 

79
00:04:04,139 --> 00:04:04,809
but now I know.
但现在我知道了。 

80
00:04:04,810 --> 00:04:11,050



81
00:04:11,050 --> 00:04:12,689
It was so much harder doing algorithms
做算法要困难得多

82
00:04:12,689 --> 00:04:15,539
when I didn't know what they were.
当我不知道他们是什么时候。 

83
00:04:15,539 --> 00:04:20,778
Anyway, I'm going to write some code for depth-first search,
无论如何，我将为深度优先搜索编写一些代码， 

84
00:04:20,778 --> 00:04:26,899
it is super simple code, the simplest graph algorithm.
它是超级简单的代码，最简单的图形算法。 

85
00:04:26,899 --> 00:04:49,174



86
00:04:49,175 --> 00:04:50,254
It's four lines.
这是四行。 

87
00:04:50,254 --> 00:05:05,589



88
00:05:05,589 --> 00:05:06,089
That's it.
而已。 

89
00:05:06,089 --> 00:05:08,279
I'm going to write a little bit of code after this,
之后，我要写一些代码， 

90
00:05:08,279 --> 00:05:11,500
but this is basic depth-first search.
但这是基本的深度优先搜索。 

91
00:05:11,500 --> 00:05:13,579
This will visit all the vertices reachable
这将访问所有可到达的顶点

92
00:05:13,579 --> 00:05:16,479
from a given source, vertex s.
来自给定来源的顶点s。 

93
00:05:16,480 --> 00:05:19,579
So we're given the adjacency list.
因此，我们得到了邻接表。 

94
00:05:19,779 --> 00:05:22,129
I don't know why I put v here, you could erase it,
我不知道为什么我把v放在这里，你可以删除它， 

95
00:05:22,129 --> 00:05:24,379
it's not necessary.
这不是必需的。 

96
00:05:24,379 --> 00:05:29,029
And all we do is, we have our vertex b, sorry,
我们要做的就是，拥有顶点b，对不起， 

97
00:05:29,029 --> 00:05:31,299
we have our vertex s.
我们有顶点。 

98
00:05:31,300 --> 00:05:35,930
We look at all of the outgoing edges from s.
我们查看s的所有传出边。 

99
00:05:35,930 --> 00:05:40,949
For each one, we'll call it v, we check,
对于每个，我们将其称为v，我们检查一下， 

100
00:05:40,949 --> 00:05:42,769
have I visited this vertex already?
我已经访问过这个顶点了吗？ 

101
00:05:42,769 --> 00:05:45,421



102
00:05:45,422 --> 00:05:46,680
A place where we need to be careful
我们需要注意的地方

103
00:05:46,879 --> 00:05:49,159
is to not repeat vertices.
是不重复顶点。 

104
00:05:49,160 --> 00:05:50,980
We need to do this in BFS as well.
我们也需要在BFS中执行此操作。 

105
00:05:50,980 --> 00:05:56,110



106
00:05:56,110 --> 00:05:58,430
So, the way we're going to do that
所以，我们要做的方式

107
00:05:58,430 --> 00:06:00,449
is by setting the parent of a node,
通过设置节点的父节点， 

108
00:06:00,449 --> 00:06:03,209
we'll see what that actually means later.
我们稍后会看到实际含义。 

109
00:06:03,209 --> 00:06:05,939
But for now, it's just, are you in the parent structure or not?
但是现在，仅仅是，您是否在父结构中？ 

110
00:06:05,939 --> 00:06:09,600
This is initially, we've seen s, so we give it
最初是，我们已经看过s，所以我们给它

111
00:06:09,600 --> 00:06:14,250
a parent of nothing, but it exists in this dictionary.
没有任何东西的父母，但它存在于这本词典中。 

112
00:06:14,250 --> 00:06:16,829
If the vertex b that we're looking at
如果我们正在寻找的顶点b 

113
00:06:16,829 --> 00:06:19,300
is not in our dictionary, we haven't seen it yet,
不在我们的字典中，我们还没有看过， 

114
00:06:19,300 --> 00:06:23,189
we mark it as seen by setting its parent to s,
我们通过将其父级设置为s将其标记为可见， 

115
00:06:23,189 --> 00:06:25,060
and then we recursively visit it.
然后我们递归地访问它。 

116
00:06:25,060 --> 00:06:26,310
That's it.
而已。 

117
00:06:26,310 --> 00:06:29,120
Super simple, just recurse.
超级简单，只需递归即可。 

118
00:06:29,120 --> 00:06:32,129
Sort of the magical part is the preventing yourself
不可思议的部分是预防自己

119
00:06:32,129 --> 00:06:34,069
from repeating.
从重复。 

120
00:06:34,069 --> 00:06:37,250
As you explore the graph, if you reach something
当您浏览图表时，如果达到目标

121
00:06:37,250 --> 00:06:39,949
you've already seen before you just skip it again.
您已经看到了，然后再次跳过。 

122
00:06:39,949 --> 00:06:45,009
So you only visit every vertex once, at most once.
因此，您仅一次访问每个顶点，最多只能访问一次。 

123
00:06:45,009 --> 00:06:47,259
This will not visit the entire graph,
这不会访问整个图， 

124
00:06:47,259 --> 00:06:50,839
it will only visit the vertices reachable from s.
它只会访问从s可达的顶点。 

125
00:06:50,839 --> 00:06:52,939
The next part of the code I'd like to give you
我想给你的代码的下一部分

126
00:06:52,939 --> 00:06:56,920
is for visiting all the vertices, and in the textbook
用于访问所有顶点，并且在教科书中

127
00:06:56,920 --> 00:06:58,819
this is called the DFS, whereas this is just
这称为DFS，而这仅仅是

128
00:06:58,819 --> 00:07:02,180
called DFS visit, that's sort of the recursive part,
称为DFS访问，这是递归部分， 

129
00:07:02,180 --> 00:07:08,329
and this is sort of a top level algorithm.
这是一种顶级算法。 

130
00:07:08,329 --> 00:07:19,839
Here we are going to use the set of vertices, b,
在这里，我们将使用一组顶点b 

131
00:07:19,839 --> 00:07:22,039
and here we're just going to iterate over the s's.
在这里，我们只是要遍历s。 

132
00:07:22,040 --> 00:07:47,759



133
00:07:47,959 --> 00:07:51,149
So it looks almost the same, but what we're iterating over
所以看起来几乎一样，但是我们要迭代的是

134
00:07:51,149 --> 00:07:52,199
is different.
是不同的。 

135
00:07:52,199 --> 00:07:55,719
Here we're iterating over the outgoing edges from s,
在这里，我们迭代s的输出边缘， 

136
00:07:55,720 --> 00:07:57,855
here were iterating over the choices of s.
这里是对s的选择进行迭代。 

137
00:07:57,855 --> 00:08:03,189



138
00:08:03,189 --> 00:08:05,238
So the idea here is we don't really
所以这里的想法是我们不是真的

139
00:08:05,238 --> 00:08:06,529
know where to start our search.
知道从哪里开始搜索。 

140
00:08:06,529 --> 00:08:09,153
If it's a disconnected graph or not a strongly connected graph,
如果它是断开连接的图或不是高度连接的图， 

141
00:08:09,153 --> 00:08:12,329
we might have to start our search multiple times.
我们可能不得不多次开始搜索。 

142
00:08:12,329 --> 00:08:15,519
This DFS algorithm is finding all the possible places
此DFS算法正在查找所有可能的位置

143
00:08:15,519 --> 00:08:19,289
you might start the search and trying them all.
您可以开始搜索并尝试全部操作。 

144
00:08:19,290 --> 00:08:21,319
So it's like, OK, let's try the first vertex.
就像，好吧，让我们尝试第一个顶点。 

145
00:08:21,319 --> 00:08:23,778
If that hasn't been visited, which initially nothing's been
如果没有被访问过，那么最初什么都没有

146
00:08:23,778 --> 00:08:27,379
visited, then visit it, recursively, everything
访问，然后递归访问所有内容

147
00:08:27,379 --> 00:08:29,009
reachable from s.
可从s到达。 

148
00:08:29,009 --> 00:08:30,629
Then you go on to the second vertex.
然后进入第二个顶点。 

149
00:08:30,629 --> 00:08:32,480
Now, you may have already visited it, then you skip it.
现在，您可能已经访问过它，然后跳过它。 

150
00:08:32,480 --> 00:08:34,070
Third vertex, maybe you visited it already.
第三顶点，也许您已经访问过它。 

151
00:08:34,270 --> 00:08:36,250
Third, fourth vertex, keep going,
第三，第四顶点，继续前进， 

152
00:08:36,250 --> 00:08:39,048
until you find some vertex you haven't visited at all.
直到找到某个顶点，您才完全没有访问过。 

153
00:08:39,048 --> 00:08:42,990
And then you recursively visit everything reachable from it,
然后您递归地访问所有可以访问的内容， 

154
00:08:42,990 --> 00:08:45,399
and you repeat.
然后重复

155
00:08:45,399 --> 00:08:48,399
This will find all the different clusters,
这将找到所有不同的集群， 

156
00:08:48,399 --> 00:08:50,480
all the different strongly connected components
所有不同的强连接组件

157
00:08:50,480 --> 00:08:51,629
of your graph.
您的图表。 

158
00:08:51,629 --> 00:08:54,189
Most of the work is being done by this recursion,
大多数工作是通过此递归完成的， 

159
00:08:54,190 --> 00:08:55,970
but then there's this top level, just
但是那里有这个顶级

160
00:08:55,970 --> 00:08:59,090
to make sure that all the vertices get visited.
确保访问所有顶点。 

161
00:08:59,090 --> 00:09:03,379
Let's do a little example, so this is super clear,
让我们做一个例子，这很清楚， 

162
00:09:03,379 --> 00:09:07,409
and then it will also let me do something
然后它也可以让我做点什么

163
00:09:07,409 --> 00:09:09,480
called edge classification.
称为边缘分类。 

164
00:09:09,480 --> 00:09:13,340
Once we see every edge in the graph
一旦我们看到了图中的每个边缘

165
00:09:13,340 --> 00:09:15,870
gets visited by DFS in one way or another,
被DFS以一种或另一种方式访问​​， 

166
00:09:15,870 --> 00:09:18,820
and it's really helpful to think about the different ways
考虑一下不同的方式真的很有帮助

167
00:09:18,820 --> 00:09:20,709
they can be visited.
他们可以被访问。 

168
00:09:20,909 --> 00:09:25,809
So here's a graph.
这是一张图。 

169
00:09:25,809 --> 00:09:29,009
I think its a similar to one from last class.
我认为它与上一堂课相似。 

170
00:09:29,009 --> 00:09:46,159



171
00:09:46,159 --> 00:09:50,219
It's not strongly connected, I don't think,
它没有紧密的联系，我不认为， 

172
00:09:50,220 --> 00:09:53,960
so you can't get from these vertices to c.
因此您无法从这些顶点到达c。 

173
00:09:53,960 --> 00:09:55,509
You can get from c to everywhere,
您可以从c到任何地方， 

174
00:09:55,509 --> 00:10:00,110
it looks like, but not strongly connected.
看起来像，但联系不紧密。 

175
00:10:00,110 --> 00:10:02,820
And we're going to run DFS, and I think, basically
我们将运行DFS，我认为基本上

176
00:10:02,820 --> 00:10:06,480
in alphabetical order is how we're imagining--
我们想像中的字母顺序

177
00:10:06,480 --> 00:10:08,230
these vertices have to be ordered somehow,
这些顶点必须以某种方式排序， 

178
00:10:08,230 --> 00:10:12,479
we don't really care how, but for sake of example I care.
我们并不真正在乎，但是为了举例，我在乎。 

179
00:10:12,679 --> 00:10:15,609
So we're going to start with a, that's
所以我们将从a开始，那就是

180
00:10:15,610 --> 00:10:17,028
the first vertex in here.
这里的第一个顶点。 

181
00:10:17,028 --> 00:10:19,570
We're going to recursively visit everything reachable from a,
我们将递归地访问从

182
00:10:19,570 --> 00:10:22,750
so we enter here with s equals a.
所以我们在这里输入s等于a。 

183
00:10:22,750 --> 00:10:30,274
So I'll mark this s1, to be the first value of s at this level.
因此，我将此s1标记为s在此级别的第一个值。 

184
00:10:30,274 --> 00:10:33,069



185
00:10:33,070 --> 00:10:36,979
So we consider-- I'm going to check the order here--
所以我们考虑-我要在这里检查订单- 

186
00:10:37,179 --> 00:10:39,344
first edge we look at, there's two outgoing edges,
我们看的第一个边缘，有两个向外的边缘， 

187
00:10:39,345 --> 00:10:40,845
let's say we look at this one first.
假设我们先来看这个。 

188
00:10:40,845 --> 00:10:46,230



189
00:10:46,230 --> 00:10:48,950
We look at b, b has not been visited yet,
我们看一下b，b还没有被访问过， 

190
00:10:48,950 --> 00:10:50,570
has no parent pointer.
没有父指针。 

191
00:10:50,570 --> 00:10:53,839
This one has a parent pointer of 0.
该对象的父指针为0。 

192
00:10:54,039 --> 00:10:59,559
B we're going to give a parent pointer of a, that's here.
 B，我们将给它一个父指针。 

193
00:10:59,559 --> 00:11:01,969
Then we recursively visit everything for b.
然后，我们递归地访问b的所有内容。 

194
00:11:01,970 --> 00:11:04,469
So we look at all the outgoing edges from b, there's only one.
因此，我们查看b的所有出局边，只有一个。 

195
00:11:04,669 --> 00:11:05,750
So we visit this edge.
因此，我们访问了此边缘。 

196
00:11:05,750 --> 00:11:09,230



197
00:11:09,230 --> 00:11:11,159
for b to e. e has not been visited,
从b到e。尚未访问过e 

198
00:11:11,159 --> 00:11:15,199
so we set as parent pointer to b, an now we recursively visit
因此我们将其设置为b的父指针，然后递归访问

199
00:11:15,200 --> 00:11:16,451
e.
 e。 

200
00:11:16,451 --> 00:11:22,590
e has only one outgoing edge, so we look at it, over here to d.
 e只有一个向外的边缘，因此我们在d处进行观察。 

201
00:11:22,590 --> 00:11:25,230



202
00:11:25,230 --> 00:11:29,085
d has not been visited, so we set a parent pointer to e,
 d尚未被访问，因此我们将父指针设置为e， 

203
00:11:29,285 --> 00:11:31,159
and we look at all the outgoing edges from d.
我们看一下d的所有出射边。 

204
00:11:31,159 --> 00:11:33,169
d has one outgoing edge, which is
 d有一个传出边，即

205
00:11:33,169 --> 00:11:35,759
to b. b has already been visited,
到b。 b已经被访问过， 

206
00:11:35,759 --> 00:11:38,529
so we skip that one, nothing to do.
因此，我们跳过了那个，无所事事。 

207
00:11:38,529 --> 00:11:42,720
That's the else case of this if, so we
如果这是其他情况，那么我们

208
00:11:42,720 --> 00:11:45,730
do nothing in the else case, we just go to the next edge.
在其他情况下什么也不做，我们只是转到下一个边缘。 

209
00:11:45,730 --> 00:11:48,450
But there's no next edge for d, so we're done.
但是d没有下一个边缘，所以我们完成了。 

210
00:11:48,450 --> 00:11:52,440
So this algorithm returns to the next level up.
因此，该算法返回到更高的层次。 

211
00:11:52,440 --> 00:11:54,220
Next level up was e, we were iterating
下一个升级是e，我们正在迭代

212
00:11:54,220 --> 00:11:55,690
over the outgoing edges from e.
在e的输出边缘上。 

213
00:11:55,690 --> 00:11:59,870
But there was only one, so we're done, so e finishes.
但是只有一个，所以我们完成了，所以结束了。 

214
00:11:59,870 --> 00:12:05,340
Then we backtrack to b, which is always going back
然后我们回溯到b，它总是回溯

215
00:12:05,340 --> 00:12:07,219
along the parent pointer, but it's also just
沿着父指针，但这也只是

216
00:12:07,419 --> 00:12:08,500
in the recursion.
在递归中。 

217
00:12:08,500 --> 00:12:10,914
We know where to go back to.
我们知道该去哪里。 

218
00:12:10,914 --> 00:12:13,539
We were going over the outgoing edges from b, there's only one,
我们正从b移出边缘，只有一个， 

219
00:12:13,539 --> 00:12:15,610
we're done.
我们完成了。 

220
00:12:15,610 --> 00:12:16,960
So we go back to a.
所以我们回到a。 

221
00:12:16,960 --> 00:12:18,709
We only looked at one outgoing edge from a.
我们仅查看了a的一个传出边。 

222
00:12:18,909 --> 00:12:22,129
There's another outgoing edge, which is this one,
还有另一个向外的优势，就是这个

223
00:12:22,129 --> 00:12:24,879
but we've already visited d, so we skip over that one,
但是我们已经访问了d，所以我们跳过了那个， 

224
00:12:24,879 --> 00:12:27,240
too, so we're done recursively visiting
也是如此，所以我们完成了递归访问

225
00:12:27,240 --> 00:12:30,970
everything reachable from a.
一切都可以从一个。 

226
00:12:30,970 --> 00:12:34,190
Now we go back to this loop, the outer loop.
现在我们回到这个循环，外循环。 

227
00:12:34,190 --> 00:12:38,109
So we did a, next we look at b, we say, oh b has been visited,
所以我们做了a，接下来我们看b，说哦，b已经被访问过， 

228
00:12:38,309 --> 00:12:40,000
we don't need to do anything from there.
我们不需要在那里做任何事情。 

229
00:12:40,000 --> 00:12:42,429
Then we go to c, c hasn't been visited
然后我们去c，c还没去过

230
00:12:42,429 --> 00:12:46,209
so we're going to loop from c, and so this
所以我们要从c循环，所以这

231
00:12:46,210 --> 00:12:50,389
is our second choice of s in this recursion,
是此递归中s的第二选择， 

232
00:12:50,389 --> 00:12:53,460
or in this outer loop.
或在此外部循环中。 

233
00:12:53,460 --> 00:12:56,200
And so we look at the outgoing edges from s2,
因此，我们看一下s2的输出边， 

234
00:12:56,200 --> 00:12:59,210
let me match the order in the notes.
让我匹配笔记中的顺序。 

235
00:12:59,210 --> 00:13:03,315
Let's say first we go to f.
假设首先我们转到f。 

236
00:13:03,515 --> 00:13:08,149
f has not been visited, so we set its parent pointer to c.
 f尚未被访问，因此我们将其父指针设置为c。 

237
00:13:08,149 --> 00:13:10,129
Then we look at all the outgoing edges from f.
然后，我们查看f的所有传出边。 

238
00:13:10,129 --> 00:13:13,710
There's one outgoing edge from f, it goes to f.
 f有一个传出边缘，到f。 

239
00:13:13,710 --> 00:13:18,860
I guess I shouldn't really bold this, sorry.
对不起，我想我不应该对此加粗。 

240
00:13:18,860 --> 00:13:21,039
I'll say what the bold edges mean in a moment.
我先说一下粗体字的含义。 

241
00:13:21,039 --> 00:13:23,569



242
00:13:23,570 --> 00:13:25,099
This is just a regular edge.
这只是一个常规的优势。 

243
00:13:25,299 --> 00:13:27,569
We follow the edge from f to f.
我们沿着边缘从f到f。 

244
00:13:27,570 --> 00:13:29,184
We see, oh, f has already been visited,
我们看到哦，f已经被访问过了， 

245
00:13:29,384 --> 00:13:31,399
it already has a parent pointer, so there's
它已经有一个父指针，所以有

246
00:13:31,399 --> 00:13:33,389
no point going down there.
没有意义下去。 

247
00:13:33,389 --> 00:13:35,229
We're done with f, that's the only outgoing edge.
 f做完了，这是唯一的输出边缘。 

248
00:13:35,429 --> 00:13:37,649
We go back to c, there's one other outgoing edge,
回到c，还有另一个输出边， 

249
00:13:37,649 --> 00:13:40,899
but it leads to a vertex we've already visited, namely e,
但这会导致我们已经访问过一个顶点，即e， 

250
00:13:40,899 --> 00:13:44,600
and so we're done with visiting everything reachable from c.
因此，我们完成了访问c可以访问的所有操作的步骤。 

251
00:13:44,600 --> 00:13:46,100
We didn't visit everything reachable
我们没有访问所有可以到达的地方

252
00:13:46,100 --> 00:13:49,250
from c, because some of it was already visited from a.
来自c，因为其中一些已经从a访问过。 

253
00:13:49,250 --> 00:13:51,684
Then we go back to the outer loop, say, OK, what about d?
然后我们回到外循环，说，好，那d呢？ 

254
00:13:51,684 --> 00:13:53,059
D has been visited, what about e?
 D已经被访问过，e呢？ 

255
00:13:53,059 --> 00:13:54,350
E's been visited, what about f?
 E被访问过，f呢？ 

256
00:13:54,350 --> 00:13:55,590
F's been visited.
 F已被访问。 

257
00:13:55,590 --> 00:13:57,589
So we're visiting these vertices again,
所以我们再次访问这些顶点， 

258
00:13:57,789 --> 00:14:03,639
but should only be twice in total, and in the end
但总共应该只有两次，最后

259
00:14:03,639 --> 00:14:06,230
we visit all the vertices, and, in a certain sense,
我们访问所有顶点，在某种意义上， 

260
00:14:06,230 --> 00:14:06,969
all the edges as well.
所有的边缘。 

261
00:14:07,169 --> 00:14:12,439



262
00:14:12,440 --> 00:14:18,070
Let's talk about running time.
让我们谈谈运行时间。 

263
00:14:18,070 --> 00:14:27,396



264
00:14:27,596 --> 00:14:29,929
What do you think the running time of this algorithm is?
您认为该算法的运行时间是多少？ 

265
00:14:29,929 --> 00:14:38,120



266
00:14:38,120 --> 00:14:39,590
Anyone?
任何人？ 

267
00:14:39,590 --> 00:14:42,734
Time to wake up.
起床时间到了。 

268
00:14:42,934 --> 00:14:43,896
AUDIENCE: Upper bound?
听众：上限？ 

269
00:14:43,897 --> 00:14:45,609
PROFESSOR: Upper bound, sure.
教授：当然可以。 

270
00:14:45,809 --> 00:14:46,309
AUDIENCE: V?
听众：V？ 

271
00:14:46,309 --> 00:14:46,850
PROFESSOR: V?
教授：V？ 

272
00:14:46,850 --> 00:14:48,690
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

273
00:14:48,690 --> 00:14:55,690
PROFESSOR: V is a little bit optimistic, plus e, good,
教授：V有点乐观，再加上e，很好， 

274
00:14:55,690 --> 00:14:57,720
collaborative effort.
共同努力。 

275
00:14:57,720 --> 00:15:00,070
It's linear time, just like BFS.
就像BFS一样，它是线性时间。 

276
00:15:00,070 --> 00:15:02,319
This is what we call linear time,
这就是我们所说的线性时间

277
00:15:02,519 --> 00:15:07,549
because this is the size of the input.
因为这是输入的大小。 

278
00:15:07,549 --> 00:15:11,341
It's theta V plus E for the whole thing.
整个过程是theta V +E。 

279
00:15:11,341 --> 00:15:12,799
The size of the input was v plus e.
输入的大小为v加上e。 

280
00:15:12,799 --> 00:15:15,299
We needed v slots in an array, plus we
我们需要阵列中的v插槽，再加上

281
00:15:15,299 --> 00:15:20,399
needed e items in these linked lists, one for each edge.
这些链接列表中需要e个项目，每个边缘一个。 

282
00:15:20,399 --> 00:15:22,559
We have to traverse that whole structure.
我们必须遍历整个结构。 

283
00:15:22,559 --> 00:15:27,029
The reason it's order v plus e is-- first, as you were saying,
之所以加上v和e，是因为-首先，正如您所说的， 

284
00:15:27,029 --> 00:15:30,319
you're visiting every vertex once in this outer loop,
您在此外循环中访问了每个顶点一次， 

285
00:15:30,320 --> 00:15:45,959
so not worrying about the recursion in DFS alone,
因此不必担心仅在DFS中进行递归， 

286
00:15:46,159 --> 00:15:48,480
so that's order b.
这就是命令b。 

287
00:15:48,480 --> 00:15:51,039
Then have to worry about this recursion,
然后要担心这种递归

288
00:15:51,039 --> 00:15:56,159
but we know that whenever we call DFS visit on a vertex,
但是我们知道，每当我们调用顶点上的DFS访问时， 

289
00:15:56,159 --> 00:15:58,961
that it did not have a parent before.
它以前没有父母。 

290
00:15:58,961 --> 00:16:00,830
Right before we called DFS visit,
在我们叫DFS访问之前， 

291
00:16:00,830 --> 00:16:02,969
we set its parent for the first time.
我们是第一次设置它的父对象。 

292
00:16:03,169 --> 00:16:05,589
Right before we called DFS visit on v here,
就在我们在这里调用DFS访问v之前， 

293
00:16:05,590 --> 00:16:07,580
we set as parent for the first time,
我们第一次设置为父级

294
00:16:07,580 --> 00:16:09,729
because it wasn't set before.
因为它不是以前设置的。 

295
00:16:09,929 --> 00:16:17,879
So DFS visit, and I'm going to just write of v,
 DFS访问，我将只写v 

296
00:16:17,879 --> 00:16:19,840
meaning the last argument here.
意思是这里的最后一个论点。 

297
00:16:19,840 --> 00:16:25,519



298
00:16:25,519 --> 00:16:32,659
It's called once, at most once, per vertex b.
每个顶点b最多调用一次。 

299
00:16:32,659 --> 00:16:35,799



300
00:16:35,799 --> 00:16:37,579
But it does not take constant time.
但这并不需要固定的时间。 

301
00:16:37,580 --> 00:16:41,109
This takes constant time per vertex, plus a recursive call.
这需要每个顶点恒定的时间，以及递归调用。 

302
00:16:41,309 --> 00:16:44,319
This thing, this takes constant time, but there's a for loop
这个东西，这需要恒定的时间，但是有一个for循环

303
00:16:44,320 --> 00:16:44,820
here.
这里。 

304
00:16:44,820 --> 00:16:46,939
We have to pay for however many outgoing edges
但是，我们必须为许多外向的边缘付费

305
00:16:47,139 --> 00:16:49,299
there are from b, that's the part you're missing.
来自b，那是您缺少的部分。 

306
00:16:49,299 --> 00:16:52,879



307
00:16:52,879 --> 00:17:00,559
And we pay length of adjacency of v for that vertex.
我们为该顶点支付v的邻接长度。 

308
00:17:00,559 --> 00:17:03,045
So the total in addition to this v
所以除了这个v 

309
00:17:03,046 --> 00:17:08,299
is going to be the order, sum overall vertices, v in capital
将是顺序，求总顶点之和，v等于大写

310
00:17:08,299 --> 00:17:13,399
V, of length of the adjacency, list for v,
 V，邻接长度，v的列表， 

311
00:17:13,400 --> 00:17:22,150
which is E. This is the handshaking
这是E。这是握手

312
00:17:22,150 --> 00:17:24,592
lemma from last time.
上次的引理。 

313
00:17:24,592 --> 00:17:27,009
It's twice e for undirected graphs,
对于无向图，它是e的两倍， 

314
00:17:27,009 --> 00:17:29,549
it's e for directed graphs.
它是有向图的e。 

315
00:17:29,549 --> 00:17:33,970
I've drawn directed graphs here, it's a little more interesting.
我在这里绘制了有向图，这有点有趣。 

316
00:17:33,970 --> 00:17:37,559
OK, so it's linear time, just like the BFS, so you could say,
好，这是线性时间，就像BFS，所以你可以说， 

317
00:17:37,559 --> 00:17:42,240
who cares, but DFS offers a lot of different properties
谁在乎，但DFS提供了许多不同的属性

318
00:17:42,240 --> 00:17:42,669
than BFS.
比BFS。 

319
00:17:42,869 --> 00:17:44,659
They each have their niche.
他们每个人都有自己的利基。 

320
00:17:44,660 --> 00:17:46,250
BFS is great for shortest paths.
 BFS非常适合最短的路径。 

321
00:17:46,250 --> 00:17:49,079
You want to know the fastest way to solve the Rubik's cube,
您想知道解决魔方的最快方法， 

322
00:17:49,079 --> 00:17:50,559
BFS will find it.
 BFS将找到它。 

323
00:17:50,559 --> 00:17:53,329
You want to find the fastest way to solve the Rubik's cube,
您想找到最快的解决魔方的方法， 

324
00:17:53,329 --> 00:17:55,149
DFS will not find it.
 DFS将找不到它。 

325
00:17:55,150 --> 00:17:56,889
It's not following shortest paths here.
这里没有遵循最短的路径。 

326
00:17:57,089 --> 00:17:59,299
Going from a to d, we use the path
从a到d，我们使用路径

327
00:17:59,299 --> 00:18:01,323
of length 3, that's the bold edges.
长度为3的那是粗体边缘

328
00:18:01,324 --> 00:18:02,740
We could have gone directly from a
我们本来可以直接从

329
00:18:02,740 --> 00:18:05,170
to d, so it's a different kind of search,
到d，这是另一种搜索， 

330
00:18:05,170 --> 00:18:07,139
but sort of the inverse.
但有点相反。 

331
00:18:07,339 --> 00:18:10,559
But it's extremely useful, in particular, in the way
但这非常有用，特别是在

332
00:18:10,559 --> 00:18:13,081
that it classifies edges.
它对边缘进行分类。 

333
00:18:13,082 --> 00:18:14,589
So let me talk about edge classification.
因此，让我谈谈边缘分类。 

334
00:18:14,789 --> 00:18:27,629



335
00:18:27,630 --> 00:18:31,339
You can check every edge in this graph gets visited.
您可以检查该图中的每个边是否都已访问。 

336
00:18:31,539 --> 00:18:34,059
In a directed graph every edge gets visited once,
在有向图中，每个边都会被访问一次， 

337
00:18:34,059 --> 00:18:35,740
in an undirected graph, every edge
在无向图中，每个边

338
00:18:35,740 --> 00:18:37,660
gets visited twice, once from each side.
被两次访问，一次从两侧。 

339
00:18:37,660 --> 00:18:40,200



340
00:18:40,200 --> 00:18:42,240
And when you visit that edge, there's
当您访问该边缘时， 

341
00:18:42,240 --> 00:18:45,710
sort of different categories of what could happen to it.
可能发生的事情的不同类别。 

342
00:18:45,710 --> 00:18:50,920
Maybe the edge led to something unvisited, when you went there.
当您去那里的时候，也许边缘导致了一些未被发现的东西。 

343
00:18:50,920 --> 00:18:52,190
We call those tree edges.
我们称这些树的边缘。 

344
00:18:52,190 --> 00:19:10,159



345
00:19:10,359 --> 00:19:12,919
That's what the parent pointers are specifying
那就是父指针所指定的

346
00:19:12,920 --> 00:19:16,420
and all the bold edges here are called three edges.
此处所有粗体边缘称为三个边缘。 

347
00:19:16,420 --> 00:19:27,410
This is when we visit a new vertex via that edge.
这是当我们通过该边缘访问新顶点时。 

348
00:19:27,410 --> 00:19:29,832



349
00:19:29,832 --> 00:19:31,339
So we look at the other side of the edge,
所以我们看边缘的另一侧， 

350
00:19:31,539 --> 00:19:33,023
we discover a new vertex.
我们发现了一个新的顶点。 

351
00:19:33,023 --> 00:19:34,439
Those are what we call tree edges,
这些就是我们所说的树边缘

352
00:19:34,440 --> 00:19:37,629
it turns out they form a tree, a directed tree.
事实证明它们形成一棵树，一棵定向树。 

353
00:19:37,829 --> 00:19:39,929
That's a lemma you can prove.
您可以证明这是一个引理。 

354
00:19:39,930 --> 00:19:40,609
You can see it here.
在这里你可以看到它。 

355
00:19:40,809 --> 00:19:44,649
We just have a path, actually a forest would be more accurate.
我们只有一条路，实际上森林会更准确。 

356
00:19:44,650 --> 00:19:48,715
We have a path abed, and we have an edge cf,
我们有一条道路，还有一条边cf， 

357
00:19:48,915 --> 00:19:51,208
but, in general, it's a forest.
但总的来说，这是一片森林。 

358
00:19:51,209 --> 00:19:53,250
So for example, if there was another thing coming
例如，如果有另一件事

359
00:19:53,250 --> 00:19:57,539
from e here, let's modify my graph, we would, at some point,
从这里开始，让我们修改我的图表，在某个时候， 

360
00:19:57,539 --> 00:19:59,720
visit that edge and say, oh, here's a new way to go,
拜访那个边缘，然后说，哦，这是一条新路要走， 

361
00:19:59,720 --> 00:20:04,250
and now that bold structure forms an actual tree.
现在，该粗体结构形成了实际的树。 

362
00:20:04,250 --> 00:20:06,849
These are called tree edges, you can call them forest edges
这些称为树边缘，您可以将它们称为森林边缘

363
00:20:06,849 --> 00:20:10,079
if you feel like it.
如果您喜欢的话。 

364
00:20:10,079 --> 00:20:13,119
There are other edges in there, the nonbold edges,
那里还有其他边缘，非粗体边缘， 

365
00:20:13,119 --> 00:20:17,259
and the textbook distinguishes three types, three types?
教科书区分三种，三种？ 

366
00:20:17,259 --> 00:20:19,950
Three types, so many types.
三种类型，那么多类型。 

367
00:20:19,950 --> 00:20:22,500



368
00:20:22,500 --> 00:20:40,579
They are forward edges, backward edges, and cross edges.
它们是前边缘，后边缘和交叉边缘。 

369
00:20:40,579 --> 00:20:44,720



370
00:20:44,720 --> 00:20:47,740
Some of these are more useful to distinguish than others,
其中有些比其他更有用， 

371
00:20:47,740 --> 00:20:51,490
but it doesn't hurt to have them all.
但是拥有它们全部并没有什么坏处。 

372
00:20:51,490 --> 00:20:57,589
So, for example, this edge I'm going to call a forward edge,
例如，我将这个边缘称为前向边缘， 

373
00:20:57,589 --> 00:21:01,259
just write f, that's unambiguous,
只需写f即可， 

374
00:21:01,259 --> 00:21:04,430
because it goes, in some sense, forward along the tree.
因为从某种意义上说，它沿着树前进。 

375
00:21:04,430 --> 00:21:09,730
It goes from the root of this tree to a descendant.
它从树的根到后代。 

376
00:21:09,730 --> 00:21:12,130
There is a path in the tree from a
树上有一条从

377
00:21:12,130 --> 00:21:14,720
to d, so we call it a forward edge.
到d，所以我们称其为前缘。 

378
00:21:14,720 --> 00:21:20,769
By contrast, this edge I'm going to call a backward edge,
相比之下，我将这个边缘称为后向边缘， 

379
00:21:20,769 --> 00:21:24,569
because it goes from a node in the tree
因为它来自树中的一个节点

380
00:21:24,569 --> 00:21:26,389
to an ancestor in the trees.
到树上的祖先。 

381
00:21:26,390 --> 00:21:28,913
If you think of parents, I can go from d to its parent
如果您想到父母，我可以从d转到父母

382
00:21:28,913 --> 00:21:30,829
to its parent, and that's where the edge goes,
到父级，这就是优势所在， 

383
00:21:30,829 --> 00:21:33,460
so that's a backward edge-- double check I
所以这是一个落后的优势-仔细检查我

384
00:21:33,460 --> 00:21:36,669
got these not reversed, yeah, that's right.
这些都没有逆转，是的，没错。 

385
00:21:36,869 --> 00:21:39,333
Forward edge because I could go from d to its parent
前缘，因为我可以从d转到其父级

386
00:21:39,334 --> 00:21:41,000
to its parent to its parent and the edge
到其父级到其父级和边缘

387
00:21:41,000 --> 00:21:44,220
went the other way, that's a forward edge.
相反，这是一个前沿。 

388
00:21:44,220 --> 00:21:49,170
So forward edge goes from a node to a descendant in the tree.
因此，前缘从节点到树中的后代。 

389
00:21:49,170 --> 00:21:52,539



390
00:21:52,539 --> 00:21:56,659
Backward edge goes from a node to an ancestor in the tree.
向后边缘从树的节点到祖先。 

391
00:21:56,660 --> 00:22:02,670



392
00:22:02,670 --> 00:22:04,180
And when I say, tree, I mean forest.
当我说树时，我是指森林。 

393
00:22:04,180 --> 00:22:06,879



394
00:22:07,079 --> 00:22:10,169
And then all the other edges are cross edges.
然后其他所有边都是交叉边。 

395
00:22:10,170 --> 00:22:12,940



396
00:22:12,940 --> 00:22:17,670
So I guess, here, this is a cross edge.
因此，我想这是一个交叉边缘。 

397
00:22:17,670 --> 00:22:20,639
In this case, it goes from one tree to another, doesn't
在这种情况下，它从一棵树到另一棵树

398
00:22:20,839 --> 00:22:22,539
have to go between different trees.
必须在不同的树木之间穿行。 

399
00:22:22,539 --> 00:22:28,539
For example, let's say I'm visiting d, then
例如，假设我要访问d 

400
00:22:28,539 --> 00:22:32,942
I go back to e, I visit g, or there could be this edge.
我回到e，访问g，否则可能会出现这种情况。 

401
00:22:32,942 --> 00:22:37,720
If this edge existed, it would be a cross edge,
如果存在此边缘，则将是交叉边缘， 

402
00:22:37,720 --> 00:22:40,970
because g and d are not ancestor related,
因为g和d与祖先无关， 

403
00:22:40,970 --> 00:22:42,980
neither one is an ancestor of the other,
谁都不是对方的祖先， 

404
00:22:42,980 --> 00:22:46,328
they are siblings actually.
他们实际上是兄弟姐妹。 

405
00:22:46,328 --> 00:22:47,869
So there's, in general, there's going
因此，总的来说， 

406
00:22:47,869 --> 00:22:51,209
to be some subtree over here, some subtree over here,
成为这里的一些子树，这里的一些子树， 

407
00:22:51,210 --> 00:22:55,759
and this is a cross edge between two different subtrees.
这是两个不同子树之间的交叉边缘。 

408
00:22:55,759 --> 00:23:07,960
This cross edge is between two, sort of, non ancestor related,
这个交叉边缘介于两个与祖先无关的事物之间， 

409
00:23:07,960 --> 00:23:16,954
I think is the shortest way to write this, subtrees or nodes.
我认为这是写此子目录或节点的最短方法。 

410
00:23:16,954 --> 00:23:26,519



411
00:23:26,519 --> 00:23:29,065
A little puzzle for you, well, I guess
我想你有点困惑

412
00:23:29,065 --> 00:23:31,419
the first question is, how do you compute this structure?
第一个问题是，如何计算此结构？ 

413
00:23:31,619 --> 00:23:34,211
How do you compute which edges are which?
您如何计算哪些边缘是哪个？ 

414
00:23:34,211 --> 00:23:36,670
This is not hard, although I haven't written it in the code
这并不难，尽管我没有在代码中编写它

415
00:23:36,670 --> 00:23:37,200
here.
这里。 

416
00:23:37,200 --> 00:23:42,289
You can check the textbook for one way to do it.
您可以检查教科书的一种方法。 

417
00:23:42,289 --> 00:23:45,799
The parent structure tells you which edges are tree edges.
父结构告诉您哪些边是树边。 

418
00:23:45,799 --> 00:23:47,980
So that part we have done.
至此我们已经完成了。 

419
00:23:47,980 --> 00:23:52,670
Every parent pointer corresponds to the reverse of a tree edge,
每个父指针对应于树边缘的反向， 

420
00:23:52,670 --> 00:23:55,250
so at the same time you could mark that edge a tree edge,
因此，您可以同时将该边缘标记为树边缘， 

421
00:23:55,250 --> 00:23:56,958
and you'd know which edges are tree edges
而且你会知道哪些边缘是树的边缘

422
00:23:56,958 --> 00:23:58,874
and which edges are nontree edges.
以及哪些边缘是非树边缘。 

423
00:23:58,874 --> 00:24:01,289
If you want to know which are forward, which are backward,
如果您想知道哪些是前进的，哪些是后退的， 

424
00:24:01,289 --> 00:24:06,129
which are cross edges, the key thing you need to know
哪些是交叉边缘，您需要知道的关键

425
00:24:06,130 --> 00:24:14,140
is, well, in particular, for backward edges, one way
尤其是对于后沿，一种方式

426
00:24:14,140 --> 00:24:16,649
to compute them is to mark which nodes
计算它们就是标记哪些节点

427
00:24:16,849 --> 00:24:19,879
you are currently exploring.
您正在探索。 

428
00:24:19,880 --> 00:24:22,660
So when we do a DFS visit on a node,
因此，当我们在节点上进行DFS访问时， 

429
00:24:22,660 --> 00:24:25,160
we could say at the beginning here,
我们可以在这里开始说

430
00:24:25,160 --> 00:24:31,230
basically, we're starting to visit s, say, start s,
基本上，我们开始访问s，例如start， 

431
00:24:31,230 --> 00:24:33,568
and then at the end of this for loop, we write,
然后在此for循环的结尾，我们编写

432
00:24:33,568 --> 00:24:34,484
we're finished with s.
我们以s结尾。 

433
00:24:34,484 --> 00:24:38,189



434
00:24:38,190 --> 00:24:40,130
And you could mark that in the s structure.
您可以在s结构中进行标记。 

435
00:24:40,130 --> 00:24:43,720
You could say s dot in process is true up here,
您可以说这里的过程是真实的， 

436
00:24:43,720 --> 00:24:46,730
s dot in process equals false down here.
此处的s点等于false。 

437
00:24:46,730 --> 00:24:49,470
Keep track of which nodes are currently in the recursion
跟踪当前在递归中的节点

438
00:24:49,470 --> 00:24:52,919
stack, just by marking them and unmarking them
堆栈，只需标记它们并取消标记

439
00:24:53,119 --> 00:24:55,429
at the beginning and the end.
在开始和结束时。 

440
00:24:55,430 --> 00:24:58,210
Then we'll know, if we follow an edge and it's an edge
然后我们就会知道，如果我们跟随一条边缘，那就是一条边缘

441
00:24:58,210 --> 00:25:01,220
to somebody who's already in the stack,
给已经在栈中的人， 

442
00:25:01,220 --> 00:25:06,019
then it's a backward edge, because that's-- everyone
那是一个落后的优势，因为那是-每个人

443
00:25:06,019 --> 00:25:10,690
in the stack is an ancestor from our current node.
在堆栈中是我们当前节点的祖先。 

444
00:25:10,690 --> 00:25:15,400
Detecting forward edges, it's a little trickier.
检测前边缘，有点棘手。 

445
00:25:15,400 --> 00:25:18,940



446
00:25:18,940 --> 00:25:23,129
Forward edges versus cross edges,
前边缘与交叉边缘， 

447
00:25:23,329 --> 00:25:25,220
any suggestions on an easy way to do that?
有什么简单的建议吗？ 

448
00:25:25,220 --> 00:25:28,480



449
00:25:28,480 --> 00:25:31,839
I don't think I know an easy way to do that.
我认为我不知道这样做的简单方法。 

450
00:25:31,839 --> 00:25:33,559
It can be done.
可以办到。 

451
00:25:33,559 --> 00:25:35,750
The way the textbook does it is a little bit more
教科书的处理方式

452
00:25:35,750 --> 00:25:41,029
sophisticated, in that when they start visiting a vertex,
复杂的是，当他们开始访问顶点时， 

453
00:25:41,029 --> 00:25:44,889
they record the time that it got visited.
他们记录访问的时间。 

454
00:25:44,890 --> 00:25:46,419
What's time?
几点了？ 

455
00:25:46,619 --> 00:25:49,219
You could think of it as the clock on your computer,
您可以将其视为计算机上的时钟， 

456
00:25:49,220 --> 00:25:51,140
another way to do it is, every time
另一种方法是每次

457
00:25:51,140 --> 00:25:55,000
you do a step in this algorithm, you increment a counter.
您在此算法中执行了一个步骤，就增加了一个计数器。 

458
00:25:55,000 --> 00:25:58,351
So every time anything happens, you increment a counter,
所以每次发生任何事情时，您都增加一个计数器， 

459
00:25:58,351 --> 00:25:59,649
and then you store the value of that
然后您存储该值

460
00:25:59,849 --> 00:26:02,909
counter here for s, that would be the start time for s,
在这里为s计数，这将是s的开始时间， 

461
00:26:02,910 --> 00:26:05,899
you store the finish time for s down here,
您将s的完成时间存储在这里， 

462
00:26:06,099 --> 00:26:08,039
and then this gives you, this tells you
然后这给你，这告诉你

463
00:26:08,039 --> 00:26:09,970
when a node was visited, and you can
当访问节点时，您可以

464
00:26:09,970 --> 00:26:12,519
use that to compute when an edge is a forward edge
用它来计算一条边何时是一条前边

465
00:26:12,519 --> 00:26:14,923
and otherwise it's a cross edge.
否则就是交叉边缘。 

466
00:26:14,923 --> 00:26:16,839
It's not terribly exciting, though, so I'm not
不过，这并不令人兴奋，所以我没有

467
00:26:16,839 --> 00:26:18,809
going to detail that.
详细说明。 

468
00:26:18,809 --> 00:26:22,450
You can look at the textbook if you're interested.
如果您有兴趣，可以看一下教科书。 

469
00:26:22,450 --> 00:26:24,140
But here's a fun puzzle.
但这是一个有趣的难题。 

470
00:26:24,140 --> 00:26:32,920
In an undirected graph, which of these edges can exist?
在无向图中，哪些边可以存在？ 

471
00:26:32,920 --> 00:26:38,789
We can have a vote, do some democratic mathematics.
我们可以投票，做一些民主数学。 

472
00:26:38,789 --> 00:26:41,909
How many people think tree edges exist in undirected graphs?
有多少人认为树边存在于无向图中？ 

473
00:26:41,910 --> 00:26:44,509



474
00:26:44,509 --> 00:26:46,170
You, OK.
你还好吗。 

475
00:26:46,170 --> 00:26:46,670
Sarini does.
萨里尼做到了。 

476
00:26:46,670 --> 00:26:47,740
That's a good sign.
这是一个好兆头。 

477
00:26:47,740 --> 00:26:49,339
How many people think forward edges
有多少人认为前沿

478
00:26:49,339 --> 00:26:50,919
exist in an undirected graph?
存在于无向图中吗？ 

479
00:26:50,920 --> 00:26:54,109



480
00:26:54,309 --> 00:26:54,869
A couple.
一对夫妇。 

481
00:26:54,869 --> 00:26:56,369
How many people think backward edges
有多少人认为后缘

482
00:26:56,369 --> 00:26:59,500
exist in an undirected graph?
存在于无向图中吗？ 

483
00:26:59,500 --> 00:27:00,000
Couple.
一对。 

484
00:27:00,000 --> 00:27:01,849
How many people think cross edges
有多少人认为交叉边缘

485
00:27:01,849 --> 00:27:03,980
exist in undirected graph?
存在于无向图中？ 

486
00:27:03,980 --> 00:27:05,250
More people, OK.
更多的人，好的。 

487
00:27:05,250 --> 00:27:07,869
I think voting worked.
我认为投票有效。 

488
00:27:07,869 --> 00:27:10,829
They all exist, no, that's not true.
它们都存在，不，那不是真的。 

489
00:27:10,829 --> 00:27:13,216
This one can exist and this one can exist.
这个可以存在，这个可以存在。 

490
00:27:13,217 --> 00:27:14,849
I actually wrote the wrong ones in my notes,
我实际上在笔记中写错了

491
00:27:15,049 --> 00:27:19,019
so it's good to trick you, no, it's I made a mistake.
所以欺骗你很好，不，这是我犯了一个错误。 

492
00:27:19,019 --> 00:27:20,869
It's very easy to get these mixed up
将它们混合起来很容易

493
00:27:20,869 --> 00:27:24,359
and you can think about why this is true,
您可以考虑为什么这是真的， 

494
00:27:24,359 --> 00:27:26,199
maybe I'll draw some pictures to clarify.
也许我会画一些图片来澄清。 

495
00:27:26,200 --> 00:27:29,879



496
00:27:30,079 --> 00:27:35,569
This is something, you remember the-- there was BFS diagram,
您还记得-这是BFS图， 

497
00:27:35,569 --> 00:27:38,460
I talked a little bit about this last class.
我谈到了最后一堂课。 

498
00:27:38,460 --> 00:27:40,650
Tree edges better exist, those are the things
树木边缘更好地存在，这些就是东西

499
00:27:40,650 --> 00:27:42,169
you use to visit new vertices.
您用来访问新顶点。 

500
00:27:42,369 --> 00:27:45,639
So that always happens, undirected or otherwise.
因此，这总是会发生，无论是无向的还是其他原因。 

501
00:27:45,640 --> 00:27:47,640
Forward edges, though, forward edge of
但是，前边缘

502
00:27:47,640 --> 00:27:51,389
would be, OK, I visited this, then I visited this.
好的，我去过这里，然后我去过这里。 

503
00:27:51,589 --> 00:27:52,769
Those were tree edges.
那是树的边缘。 

504
00:27:52,769 --> 00:27:55,369



505
00:27:55,369 --> 00:27:58,551
Then I backtrack and I follow an edge like this.
然后我回溯，然后跟随这样的优势。 

506
00:27:58,551 --> 00:27:59,759
This would be a forward edge.
这将是一个前沿。 

507
00:27:59,759 --> 00:28:03,470
And in a directed graph that can happen.
并且在有向图中可能发生。 

508
00:28:03,470 --> 00:28:11,319
In an undirected graph, it can also happen, right?
在无向图中也可能发生，对吧？ 

509
00:28:11,319 --> 00:28:12,539
Oh, no, it can't, it can't.
哦，不，它不能，它不能。 

510
00:28:12,539 --> 00:28:14,529
OK.
好。 

511
00:28:14,529 --> 00:28:15,720
So confusing.
太混乱了

512
00:28:15,720 --> 00:28:17,970
undirected graph, if you look like this,
无向图，如果您看起来像这样， 

513
00:28:17,970 --> 00:28:20,299
you start-- let's say this is s.
您开始-假设这是s。 

514
00:28:20,299 --> 00:28:24,000
You start here, and suppose we follow this edge.
您从这里开始，并假设我们遵循这一优势。 

515
00:28:24,000 --> 00:28:27,180
We get to here, then we follow this edge, we get to here.
我们到达这里，然后我们沿着这个边缘，我们到达这里。 

516
00:28:27,180 --> 00:28:31,390
Then we will follow this edge in the other direction,
然后，我们将沿着另一个方向走这个边缘， 

517
00:28:31,390 --> 00:28:35,240
and that's guaranteed to finish before we get back to s.
并保证在我们回到s之前完成。 

518
00:28:35,240 --> 00:28:36,970
So, in order to be a forward edge,
因此，为了成为前锋， 

519
00:28:36,970 --> 00:28:38,909
this one has to be visited after this one,
在此之后必须再次访问

520
00:28:39,109 --> 00:28:43,029
from s, but in this scenario, if you follow this one first,
从s开始，但是在这种情况下，如果您先遵循这一点， 

521
00:28:43,029 --> 00:28:44,529
you'll eventually get to this vertex
您最终将到达这个顶点

522
00:28:44,529 --> 00:28:47,440
and then you will come back, and then that will be classified
然后您会回来，然后将其分类

523
00:28:47,440 --> 00:28:49,670
as a backward edge in an undirected graph.
作为无向图中的后沿。 

524
00:28:49,670 --> 00:28:53,335
So you can never have forward edges in an undirected graph.
因此，您永远都不能在无向图中拥有前缘。 

525
00:28:53,335 --> 00:29:00,900



526
00:29:00,900 --> 00:29:04,490
But I have a backward edge here, that would suggest
但是我在这里有一个落后的优势，这表明

527
00:29:04,490 --> 00:29:08,190
I can have backward edges here, and no cross edges.
我可以在这里有后边缘，而没有交叉边缘。 

528
00:29:08,190 --> 00:29:14,410
Well, democracy did not work, I was swayed by the popular vote.
好吧，民主是行不通的，我被民众投票所左右。 

529
00:29:14,410 --> 00:29:17,700
So I claim, apparently, cross edges do not exist.
因此，我声称显然不存在交叉边缘。 

530
00:29:17,700 --> 00:29:18,660
Let's try to draw this.
让我们尝试画这个。 

531
00:29:18,660 --> 00:29:26,240
So a cross edge typical scenario would be either here,
因此，跨边的典型场景要么在这里， 

532
00:29:26,240 --> 00:29:29,900
you follow this edge, you backtrack,
你遵循这一优势，回溯， 

533
00:29:29,900 --> 00:29:31,950
you follow another edge, and then
你跟随另一条边，然后

534
00:29:31,950 --> 00:29:34,670
you discover there's was an edge back to some other subtree
你发现那里有一条回到其他子树的边缘

535
00:29:34,670 --> 00:29:36,019
that you've already visited.
您已经访问过。 

536
00:29:36,019 --> 00:29:38,365
That can happen in an undirected graph.
这可能会在无向图中发生。 

537
00:29:38,365 --> 00:29:41,930
For the same reason, if I follow this one first,
出于同样的原因，如果我先遵循这一点， 

538
00:29:41,930 --> 00:29:46,240
and this edge exists undirected, then I will go down that way.
而且这条边缘是无向的，那么我将沿着这种方式下去。 

539
00:29:46,240 --> 00:29:50,259
So it will be actually tree edge, not a cross edge.
因此实际上是树边缘，而不是交叉边缘。 

540
00:29:50,259 --> 00:29:51,670
OK, phew.
好， 

541
00:29:51,670 --> 00:29:56,293
That means my notes were correct.
那表示我的笔记是正确的。 

542
00:29:56,493 --> 00:29:57,909
I was surprised, because they were
我很惊讶，因为他们

543
00:29:57,910 --> 00:30:04,355
copied from the textbook, uncorrect my correction.
从教科书中抄袭，不正确我的更正。 

544
00:30:04,355 --> 00:30:04,855
Good.
好。 

545
00:30:04,855 --> 00:30:10,079



546
00:30:10,079 --> 00:30:13,139
So what?
所以呢？ 

547
00:30:13,140 --> 00:30:15,930
Why do I care about these edge classifications?
为什么我要关心这些边缘分类？ 

548
00:30:15,930 --> 00:30:21,970
I claim they're super handy for two problems, cycle detection,
我声称它们非常方便解决两个问题，即循环检测， 

549
00:30:21,970 --> 00:30:24,140
which is pretty intuitive problem.
这是非常直观的问题。 

550
00:30:24,140 --> 00:30:26,759
Does my graph have any cycles?
我的图表有周期吗？ 

551
00:30:26,759 --> 00:30:29,890
In the directed case, this is particularly interesting.
在定向情况下，这特别有趣。 

552
00:30:29,890 --> 00:30:33,390
I want to know, does a graph have any directed cycles?
我想知道，图是否有任何有向周期？ 

553
00:30:33,390 --> 00:30:35,159
And another problem called topological sort,
还有另一个问题叫做拓扑排序

554
00:30:35,359 --> 00:30:36,389
which we will get to.
我们会去的。 

555
00:30:36,390 --> 00:30:41,500



556
00:30:41,500 --> 00:30:45,359
So let's start with cycle detection.
因此，让我们从循环检测开始。 

557
00:30:45,359 --> 00:30:48,869
This is actually a warmup for topological sort.
这实际上是对拓扑排序的热身。 

558
00:30:48,869 --> 00:30:52,759



559
00:30:52,759 --> 00:30:55,680
So does my graph have any cycles?
那我的图有周期吗？ 

560
00:30:55,680 --> 00:31:00,399
G has a cycle, I claim.
我声称G有一个循环。 

561
00:31:00,599 --> 00:31:10,659
This happens, if and only if, G has a back edge, or let's say,
当且仅当G具有后边缘，或者说， 

562
00:31:10,660 --> 00:31:13,940
a depth-first search of that graph has a back edge.
该图的深度优先搜索具有后沿。 

563
00:31:13,940 --> 00:31:17,250



564
00:31:17,250 --> 00:31:19,839
So it doesn't matter where I start from
所以我从哪里开始都没关系

565
00:31:19,839 --> 00:31:22,943
or how this algorithm-- I run this top level DFS algorithm,
或该算法的方式-我运行此顶级DFS算法， 

566
00:31:22,943 --> 00:31:24,359
explore the whole graph, because I
探索整个图，因为我

567
00:31:24,359 --> 00:31:26,969
want to know in the whole graph is there a cycle?
想知道整个图中是否存在一个周期？ 

568
00:31:26,970 --> 00:31:29,579
I claim, if there's a back edge, then there's a cycle.
我声称，如果有后缘，那就有一个循环。 

569
00:31:29,579 --> 00:31:33,029



570
00:31:33,029 --> 00:31:35,729
So it all comes down to back edges.
因此，一切都落到了后沿。 

571
00:31:35,729 --> 00:31:38,019
This will work for both directed and undirected graphs.
这将适用于有向图和无向图。 

572
00:31:38,019 --> 00:31:41,069
Detecting cycles is pretty easy in undirected graphs.
在无向图中，检测周期非常容易。 

573
00:31:41,069 --> 00:31:43,369
It's a little more subtle with directed graphs,
有向图稍微有些微妙， 

574
00:31:43,369 --> 00:31:46,750
because you have to worry about the edge directions.
因为您必须担心边缘方向。 

575
00:31:46,750 --> 00:31:49,609
So let's prove this.
因此，让我们证明这一点。 

576
00:31:49,609 --> 00:31:52,769
We haven't done a serious proof in a while,
我们已经有一段时间没有做过认真的证明了， 

577
00:31:52,769 --> 00:31:57,109
so this is still a pretty easy one, let's think about it.
所以这仍然是很简单的，让我们考虑一下。 

578
00:31:57,109 --> 00:31:58,879
What do you think is the easier direction
您认为更容易的方向是什么

579
00:31:58,880 --> 00:32:02,579
to prove here, left or right?
在这里证明是左还是右？ 

580
00:32:02,779 --> 00:32:03,720
To more democracy.
为了更多的民主。 

581
00:32:03,720 --> 00:32:07,291
How many people think left is easy?
有多少人认为离开容易？ 

582
00:32:07,291 --> 00:32:08,359
A couple.
一对夫妇。 

583
00:32:08,359 --> 00:32:10,240
How many people think right is easy?
有多少人认为正确很容易？ 

584
00:32:10,240 --> 00:32:12,410
A whole bunch more.
一大堆。 

585
00:32:12,410 --> 00:32:14,890
I disagree with you.
恕我不能赞同。 

586
00:32:14,890 --> 00:32:18,119
I guess it depends what you consider easy.
我想这取决于您认为简单的事情。 

587
00:32:18,319 --> 00:32:21,210
Let me show you how easy left is.
让我向您展示左手有多容易。 

588
00:32:21,210 --> 00:32:25,779
Left is, I have a back edge, I want to claim there's a cycle.
左边是，我有一个后缘，我想声称这是一个循环。 

589
00:32:25,779 --> 00:32:27,609
What is the back edge look like?
后边缘是什么样的？ 

590
00:32:27,609 --> 00:32:34,049
Well, it's an edge to an ancestor in the tree.
好吧，这是树上祖先的优势。 

591
00:32:34,049 --> 00:32:35,796
If this node is a descendant of this node
如果此节点是此节点的后代

592
00:32:35,796 --> 00:32:39,920
and this node is an ancestor of this node, that's
这个节点是这个节点的祖先

593
00:32:39,920 --> 00:32:42,659
saying there are tree edges, there's
说有树的边缘，有

594
00:32:42,859 --> 00:32:45,819
a path, a tree path, that connects one to the other.
连接彼此的路径（树路径）。 

595
00:32:45,819 --> 00:32:49,339



596
00:32:49,339 --> 00:32:54,159
So these are tree edges, because this
这些是树的边缘，因为

597
00:32:54,160 --> 00:32:57,658
is supposed to be an ancestor, and this
应该是一个祖先

598
00:32:57,858 --> 00:32:59,149
is supposed to be a descendant.
应该是后裔。 

599
00:32:59,150 --> 00:33:03,670



600
00:33:03,670 --> 00:33:08,769
And that's the definition of a back edge.
这就是后边缘的定义。 

601
00:33:08,769 --> 00:33:11,539
Do you see a cycle?
你看到一个周期吗？ 

602
00:33:11,539 --> 00:33:12,819
I see a cycle.
我看到一个周期。 

603
00:33:12,819 --> 00:33:17,549
This is a cycle, directed cycle.
这是一个循环，定向循环。 

604
00:33:17,549 --> 00:33:21,970
So if there's a back edge, by definition, it makes a cycle.
因此，根据定义，如果有后边缘，则将形成一个循环。 

605
00:33:21,970 --> 00:33:24,289
Now, it's harder to say if I have 10 back edges,
现在，很难说我是否有10个后缘， 

606
00:33:24,289 --> 00:33:25,399
how many cycles are there?
有多少个周期？ 

607
00:33:25,400 --> 00:33:26,359
Could be many.
可能很多。 

608
00:33:26,559 --> 00:33:28,879
But if there's a back edge, there's
但是如果有后缘， 

609
00:33:28,880 --> 00:33:30,410
definitely at least one cycle.
肯定至少一个周期。 

610
00:33:30,410 --> 00:33:34,082



611
00:33:34,082 --> 00:33:35,589
The other direction is also not too hard,
另一个方向也不太难

612
00:33:35,789 --> 00:33:38,599
but I would hesitate to call it easy.
但我会毫不犹豫地说。 

613
00:33:38,599 --> 00:33:42,689
Any suggestions if, I know there is a cycle,
如果有任何建议，我知道有一个周期， 

614
00:33:42,690 --> 00:33:46,910
how do I prove that there's a back edge somewhere?
如何证明某处有后边缘？ 

615
00:33:46,910 --> 00:33:48,909
Think about that, let me draw a cycle.
考虑一下，让我画一个周期。 

616
00:33:49,109 --> 00:34:11,438



617
00:34:11,438 --> 00:34:12,480
There's a length k cycle.
有一个长度为k的循环。 

618
00:34:12,480 --> 00:34:16,213



619
00:34:16,213 --> 00:34:17,880
Where do you think, which of these edges
您如何看待这些优势中的哪些优势

620
00:34:17,880 --> 00:34:19,260
do you think is going to be a back edge?
您认为这将是后缘吗？ 

621
00:34:19,260 --> 00:34:20,835
Let's hope it's one of these edges.
我们希望它是这些优势之一。 

622
00:34:20,835 --> 00:34:23,349



623
00:34:23,349 --> 00:34:24,190
Sorry?
抱歉？ 

624
00:34:24,190 --> 00:34:25,420
AUDIENCE: Vk to v zero.
听众：Vk到v零。 

625
00:34:25,420 --> 00:34:26,559
PROFESSOR: Vk to v zero.
教授：Vk至v零。 

626
00:34:26,559 --> 00:34:31,000
That's a good idea, maybe this is a back edge.
这是个好主意，也许这是后缘。 

627
00:34:31,000 --> 00:34:34,670
Of course, this is symmetric, why that edge?
当然，这是对称的，为什么具有这种优势？ 

628
00:34:34,670 --> 00:34:36,780
I labeled it in a suggestive way,
我用暗示的方式标记了它

629
00:34:36,780 --> 00:34:39,389
but I need to say something before I know actually which
但我需要先说些什么，然后才能真正知道

630
00:34:39,389 --> 00:34:42,403
edge is going to be the back edge.
边缘将成为后边缘。 

631
00:34:42,403 --> 00:34:44,320
AUDIENCE: You have to say you start to v zero?
听众：你必须说你开始v零？ 

632
00:34:44,320 --> 00:34:45,650
PROFESSOR: Start at v zero.
教授：从v零开始。 

633
00:34:45,849 --> 00:34:48,460
If I started a search of v zero, that
如果我开始搜索v零，那

634
00:34:48,460 --> 00:34:49,838
looks good, because the search is
看起来不错，因为搜索是

635
00:34:49,838 --> 00:34:51,719
kind of going to go in this direction.
会朝这个方向发展。 

636
00:34:51,719 --> 00:34:53,949
vk will maybe be the last thing to be visited,
 vk可能是最后要访问的东西， 

637
00:34:53,949 --> 00:34:55,480
that's not actually true.
这不是真的。 

638
00:34:55,480 --> 00:34:57,710
Could be there's an edge directly from v zero to vk,
从v 0到vk可能存在一条边， 

639
00:34:57,710 --> 00:35:00,699
but intuitively vk will kind of later,
但是直觉上vk会在以后

640
00:35:00,699 --> 00:35:02,469
and then when this edge gets visited,
然后当这个边缘被访问时， 

641
00:35:02,469 --> 00:35:05,349
this will be an ancestor and it will be a back edge.
这将是祖先，将是后缘。 

642
00:35:05,349 --> 00:35:10,269
Of course, we may not start a search here,
当然，我们可能不会在这里开始搜索， 

643
00:35:10,269 --> 00:35:12,239
so calling it the start of the search
所以称它为搜索的开始

644
00:35:12,239 --> 00:35:16,078
is not quite right, a little different.
不太正确，有点不同。 

645
00:35:16,079 --> 00:35:18,800
AUDIENCE: First vertex that gets hit [INAUDIBLE].
听众：被击中的第一个顶点[听不清]。 

646
00:35:18,800 --> 00:35:21,550
PROFESSOR: First vertex that gets hit, good.
教授：碰到的第一个顶点，很好。 

647
00:35:21,550 --> 00:35:24,820
I'm going to start the numbering , v zero,
我将开始编号，v为零， 

648
00:35:24,820 --> 00:35:38,460
let's assume v 0 is the first vertex in the cycle,
假设v 0是循环中的第一个顶点， 

649
00:35:38,460 --> 00:35:40,039
visited by the depth-first search.
深度优先搜索访问过。 

650
00:35:40,039 --> 00:35:47,099



651
00:35:47,099 --> 00:35:54,059
Together, if you want some pillows if you like them,
在一起，如果您想要一些枕头，如果您愿意， 

652
00:35:54,059 --> 00:35:56,639
especially convenient that they're in front.
他们在前面特别方便。 

653
00:35:56,639 --> 00:35:59,129
So right, if it's not v zero, say
好吧，如果它不是v零，说

654
00:35:59,130 --> 00:36:00,269
v3 was the first one visited.
 v3是第一个访问的网站。 

655
00:36:00,469 --> 00:36:01,844
We will just change the labeling,
我们只是更改标签， 

656
00:36:01,844 --> 00:36:06,259
so that's v zero, that's v1, that's v, and so on.
所以是v零，就是v1，就是v，依此类推。 

657
00:36:06,260 --> 00:36:09,340
So set this labeling, so that v0 first one,
因此设置该标签，以便v0成为第一个， 

658
00:36:09,340 --> 00:36:12,230
first vertex that gets visited.
被访问的第一个顶点。 

659
00:36:12,429 --> 00:36:20,230
Then, I claim that-- let me just write the claim first.
然后，我声明-让我先写声明。 

660
00:36:20,230 --> 00:36:23,610
This edge vkv0 will be a back edge.
该边缘vkv0将是后边缘。 

661
00:36:23,610 --> 00:36:26,349



662
00:36:26,349 --> 00:36:29,251
We'll just say, is back edge.
我们只是说，是后缘。 

663
00:36:29,251 --> 00:36:32,779
And I would say this is not obvious, be a little careful.
我想说这并不明显，请多加注意。 

664
00:36:32,780 --> 00:36:50,420



665
00:36:50,420 --> 00:36:54,460
We have to somehow exploit the depth-first nature of DFS,
我们必须以某种方式利用DFS的深度优先特性， 

666
00:36:54,460 --> 00:36:58,820
the fact that it goes deep-- it goes as deep as it can before
它变得更深的事实-它比以前更深入

667
00:36:58,820 --> 00:37:00,396
backtracking.
回溯。 

668
00:37:00,396 --> 00:37:02,820
If you think about it, we're starting,
如果您考虑一下，我们就开始了， 

669
00:37:02,820 --> 00:37:05,690
at this point we are starting a search relative to this cycle.
在这一点上，我们正在开始相对于该周期的搜索。 

670
00:37:05,690 --> 00:37:08,550
No one has been visited, except v zero just
除v零外，没有人被访问过

671
00:37:08,550 --> 00:37:10,730
got visited, has a parent pointer off somewhere else.
被访问时，将父指针移到其他地方。 

672
00:37:10,929 --> 00:37:15,989



673
00:37:15,989 --> 00:37:16,879
What do we do next?
接下来我们要做什么？ 

674
00:37:16,880 --> 00:37:19,309
Well, we visit all the outgoing edges from v zero,
好吧，我们访问从v零开始的所有传出边， 

675
00:37:19,309 --> 00:37:20,650
there might be many of them. it could
可能有很多。它可以

676
00:37:20,849 --> 00:37:23,480
be edge from v zero to v1, it could an edge from v zero
是从v 0到v1的边，它可能是从v 0的边

677
00:37:23,480 --> 00:37:28,750
to v3, it could be an edge from v zero to something else.
到v3，可能是从v 0到其他值的边缘。 

678
00:37:28,750 --> 00:37:31,980
We don't know which one's going to happen first.
我们不知道哪个会先发生。 

679
00:37:31,980 --> 00:37:39,760
But the one thing I can claim is that v1
但是我可以声称的一件事是v1 

680
00:37:39,760 --> 00:37:46,610
will be visited before we finish visiting v zero.
在完成访问v零之前将被访问。 

681
00:37:46,610 --> 00:37:51,923



682
00:37:52,123 --> 00:37:53,789
From v zero, we might go somewhere else,
从v零开始，我们可能会去其他地方， 

683
00:37:53,789 --> 00:37:55,789
we might go somewhere else that might eventually
我们可能会去其他地方

684
00:37:55,789 --> 00:37:58,130
lead to v1 by some other route, but in particular, we
通过其他途径引向v1，但特别是，我们

685
00:37:58,130 --> 00:38:01,440
look at that edge from v zero to v1.
看一下从v 0到v1的那条边。 

686
00:38:01,440 --> 00:38:03,730
And so, at some point, we're searching,
因此，在某个时候，我们正在搜索， 

687
00:38:03,730 --> 00:38:06,579
we're visiting all the things reachable from v zero, that
我们正在访问从v零可到达的所有事物， 

688
00:38:06,579 --> 00:38:09,829
includes v1, and that will happen,
包括v1，这种情况将会发生， 

689
00:38:09,829 --> 00:38:11,949
we will touch v1 for the first time,
我们将第一次接触v1， 

690
00:38:11,949 --> 00:38:13,799
because it hasn't been touched yet.
因为还没有被触及

691
00:38:13,800 --> 00:38:17,731
We will visit it before we finish visiting v zero.
我们将在完成访问v零之前访问它。 

692
00:38:17,931 --> 00:38:21,659
The same goes actually for all of v i's, because they're all
实际上，所有v i都是一样的，因为它们都是

693
00:38:21,659 --> 00:38:23,509
reachable from v zero.
从v零可达。 

694
00:38:23,510 --> 00:38:25,760
You can prove this by induction.
您可以通过归纳证明这一点。 

695
00:38:25,760 --> 00:38:29,860
You'll have to visit v1 before you finish visiting v zero.
您必须先访问v1，然后才能完成对v零的访问。 

696
00:38:29,860 --> 00:38:32,480
You'll have to visit v2 before you finish visiting
您必须先访问v2，然后才能完成访问

697
00:38:32,480 --> 00:38:35,592
v1, although you might actually visit v2 before v1.
 v1，尽管您实际上可能在v1之前访问过v2。 

698
00:38:35,592 --> 00:38:37,050
You would definitely finish, you'll
你一定会完成，你会

699
00:38:37,050 --> 00:38:41,880
finished v2 before you finish v1, and so on.
在完成v1之前先完成v2，依此类推。 

700
00:38:41,880 --> 00:38:47,423
So vi will be visited before you finish vi minus 1,
因此，在完成vi减去1之前，vi将被访问。 

701
00:38:47,423 --> 00:38:49,090
but in particular, what we care about is
但特别是我们关心的是

702
00:38:49,090 --> 00:38:58,760
that vk is visited before we finish v zero.
在完成v零之前已访问了vk。 

703
00:38:58,760 --> 00:39:01,840



704
00:39:02,039 --> 00:39:03,670
And it will be entirely visited.
它将完全被访问。 

705
00:39:03,670 --> 00:39:05,730
We will finish visiting vk before we
我们将在完成之前访问vk 

706
00:39:05,929 --> 00:39:07,569
finish visiting v zero.
完成访问v零。 

707
00:39:07,570 --> 00:39:10,280
We will start decay vk after we start to v zero,
我们将v设为零后开始衰减vk， 

708
00:39:10,280 --> 00:39:12,130
because v zero is first.
因为v零是第一个。 

709
00:39:12,329 --> 00:39:16,579
So the order is going to look like, start v zero,
因此，顺序看起来像是从v开始为零， 

710
00:39:16,579 --> 00:39:20,940
at some point we will start vk.
在某个时候，我们将启动vk。 

711
00:39:20,940 --> 00:39:27,750
Then we'll finish vk, then we'll finish v zero.
然后我们完成vk，然后我们完成v 0。 

712
00:39:27,949 --> 00:39:30,339
This is something the textbook likes to call,
这是教科书喜欢的东西， 

713
00:39:30,340 --> 00:39:33,000
and I like to call, balanced parentheses.
而且我喜欢用圆括号括起来。 

714
00:39:33,199 --> 00:39:38,689
You can think of it as, we start v zero, then we start vk,
您可以这样想，我们以v零开始，然后以vk开头， 

715
00:39:38,690 --> 00:39:42,389
then we finish vk, then we finish v zero.
然后完成vk，然后完成v 0。 

716
00:39:42,389 --> 00:39:44,289
And these match up and their balanced.
这些匹配并保持平衡。 

717
00:39:44,289 --> 00:39:46,969



718
00:39:46,969 --> 00:39:48,719
Depth-first search always looks like that,
深度优先搜索总是这样， 

719
00:39:48,719 --> 00:39:50,629
because once you start a vertex, you
因为一旦开始顶点， 

720
00:39:50,630 --> 00:39:53,059
keep chugging until you visited all the things reachable
不断努力，直到您访问了所有可以到达的事物

721
00:39:53,059 --> 00:39:54,460
from it.
从中。 

722
00:39:54,460 --> 00:39:55,500
Then you finish it.
然后，您完成它。 

723
00:39:55,500 --> 00:39:57,559
You won't finish v zero before you finish vk,
在完成vk之前，您不会完成v零， 

724
00:39:57,559 --> 00:40:00,114
because it's part of the recursion.
因为它是递归的一部分。 

725
00:40:00,114 --> 00:40:01,530
You can't return at a higher level
你不能再更高的水平了

726
00:40:01,530 --> 00:40:04,942
before you return at the lower levels.
然后再返回较低的级别。 

727
00:40:04,942 --> 00:40:06,400
So we've just argued that the order
所以我们只是争辩说

728
00:40:06,400 --> 00:40:08,025
is like this, because v zero was first,
就像这样，因为v零是第一个， 

729
00:40:08,025 --> 00:40:11,599
so vk starts after v zero, and also we're going to finish vk
所以vk在v零之后开始，而且我们还要完成vk 

730
00:40:11,599 --> 00:40:14,549
before we finish v zero, because it's reachable, and hasn't
在我们完成v零之前，因为它是可到达的，并且没有

731
00:40:14,550 --> 00:40:17,000
been visited before.
曾经被访问过。 

732
00:40:17,000 --> 00:40:25,199
So, in here, we consider vkv zero.
因此，在这里，我们认为vkv为零。 

733
00:40:25,199 --> 00:40:28,000



734
00:40:28,000 --> 00:40:32,070
When we consider that edge, it will be a back edge.
当我们考虑该边缘时，它将是后边缘。 

735
00:40:32,070 --> 00:40:34,750



736
00:40:34,750 --> 00:40:35,710
Why?
为什么？ 

737
00:40:35,710 --> 00:40:39,639
Because v zero is currently on the recursion stack,
由于v零​​当前位于递归堆栈上， 

738
00:40:39,639 --> 00:40:42,426
and so you will have marked v zero as currently in process.
因此您将当前标记为v零。 

739
00:40:42,427 --> 00:40:44,760
So when you look at that edge, you see it's a back edge,
因此，当您查看该边缘时，您会看到它是后边缘， 

740
00:40:44,760 --> 00:40:47,460
it's an edge to your ancestor.
这是您祖先的优势。 

741
00:40:47,659 --> 00:40:48,429
That's the proof.
那就是证明。 

742
00:40:48,429 --> 00:40:51,699



743
00:40:51,699 --> 00:40:52,789
Any questions about that?
对此有任何疑问吗？ 

744
00:40:52,789 --> 00:40:55,489



745
00:40:55,489 --> 00:40:59,459
It's pretty easy once you set up the starting point, which
一旦设置了起点，这很容易

746
00:40:59,460 --> 00:41:01,269
is look at the first time you visit the cycle,
是在您第一次访问周期时

747
00:41:01,469 --> 00:41:03,731
than just think about how you walk around the cycle.
而不是仅仅考虑如何骑单车。 

748
00:41:03,731 --> 00:41:05,940
There's lots of ways you might walk around the cycle,
您可能有很多方法可以解决整个周期， 

749
00:41:05,940 --> 00:41:08,579
but it's guaranteed you'll visit vk at some point,
但可以保证您一定会访问vk， 

750
00:41:08,579 --> 00:41:10,670
then you'll look at the edge. v0 is still in the stack,
然后您将看看边缘。 v0仍在堆栈中， 

751
00:41:10,869 --> 00:41:12,730
so it's a back edge.
所以这是后缘。 

752
00:41:12,730 --> 00:41:14,574
And so this proves that having a cycle
所以这证明有一个循环

753
00:41:14,574 --> 00:41:16,259
is equivalent to having a back edge.
等同于具有后边缘。 

754
00:41:16,260 --> 00:41:18,980
This gives you an easy linear time algorithm to tell,
这为您提供了一种简单的线性时间算法，可以告诉您， 

755
00:41:18,980 --> 00:41:20,902
does my graph have a cycle?
我的图有周期吗？ 

756
00:41:20,902 --> 00:41:22,860
And if it does, it's actually easy to find one,
如果确实如此，实际上很容易找到一个， 

757
00:41:22,860 --> 00:41:25,902
because we find a back edge, just follow the tree edges,
因为我们找到了后边缘，所以只需跟随树的边缘， 

758
00:41:26,101 --> 00:41:27,059
and you get your cycle.
这样你就可以循环。 

759
00:41:27,059 --> 00:41:29,563



760
00:41:29,563 --> 00:41:31,230
So if someone gives you a graph and say,
因此，如果有人给您一个图表并说， 

761
00:41:31,230 --> 00:41:34,349
hey, I think this is acyclic, you can very quickly say,
嘿，我认为这是非周期性的，您可以很快说

762
00:41:34,349 --> 00:41:36,589
no, it's not, here's a cycle, or say,
不，不是，这是一个周期，或者说， 

763
00:41:36,590 --> 00:41:40,289
yeah, I agree, no back edges, I only have tree, forward,
是的，我同意，没有后缘，我只有一棵树，向前， 

764
00:41:40,489 --> 00:41:41,610
and cross edges.
和交叉边缘。 

765
00:41:41,610 --> 00:41:49,150



766
00:41:49,150 --> 00:41:50,545
OK, that was application 1.
好的，那是应用程序1。 

767
00:41:50,545 --> 00:41:56,610



768
00:41:56,610 --> 00:41:58,789
Application 2 is topological sort,
应用2是拓扑排序， 

769
00:41:58,989 --> 00:42:02,789
which we're going to think about in the setting
我们将在环境中考虑

770
00:42:02,789 --> 00:42:04,320
of a problem called job scheduling.
问题称为作业调度。 

771
00:42:04,320 --> 00:42:07,500



772
00:42:07,699 --> 00:42:14,859
So job scheduling, we are given a directed acyclic graph.
因此，在作业调度中，我们得到了有向无环图。 

773
00:42:14,860 --> 00:42:21,769



774
00:42:21,769 --> 00:42:39,090
I want to order the vertices so that all edges point
我想对顶点进行排序，以便所有边都指向

775
00:42:39,090 --> 00:42:46,090
from lower order to high order.
从低阶到高阶。 

776
00:42:46,090 --> 00:42:52,519



777
00:42:52,519 --> 00:42:54,405
Directed acyclic graph is called a DAG,
有向无环图称为DAG， 

778
00:42:54,405 --> 00:42:59,630
you should know that from 042.
您应该从042知道这一点。 

779
00:42:59,829 --> 00:43:02,789
And maybe I'll draw one for kicks.
也许我会抽一踢。 

780
00:43:02,789 --> 00:43:32,029



781
00:43:32,030 --> 00:43:34,760
Now, I've drawn the graph so all the edges go left to right,
现在，我已经绘制了图形，因此所有边缘从左到右， 

782
00:43:34,760 --> 00:43:37,110
so you can see that there's no cycles here,
这样您就可以看到这里没有周期， 

783
00:43:37,110 --> 00:43:41,090
but generally you'd run DFS and you'd detect there's no cycles.
但通常您会运行DFS，并且会发现没有周期。 

784
00:43:41,090 --> 00:43:43,170
And now, imagine these vertices represent
现在，假设这些顶点代表

785
00:43:43,170 --> 00:43:45,746
things you need to do.
您需要做的事情。 

786
00:43:45,746 --> 00:43:49,079
The textbook has a funny example where you're getting dressed,
教科书上有一个有趣的例子，说明您穿衣服的样子， 

787
00:43:49,079 --> 00:43:50,819
so you have these constraints that say,
所以你有这些约束说

788
00:43:50,820 --> 00:43:53,579
well, I've got to put my socks on before put my shoes on.
好吧，我得先穿袜子，然后再穿鞋。 

789
00:43:53,579 --> 00:43:55,420
And then I've got to put my underwear on before I
然后我必须先穿上内衣

790
00:43:55,619 --> 00:43:59,349
put my pants on, and all these kinds of things.
穿上我的裤子，以及所有类似的东西。 

791
00:43:59,349 --> 00:44:01,460
You would code that as a directed acyclic graph.
您可以将其编码为有向无环图。 

792
00:44:01,460 --> 00:44:03,293
You hope there's no cycles, because then you
您希望没有周期，因为那样您

793
00:44:03,293 --> 00:44:05,099
can't get dressed.
不能穿衣服。 

794
00:44:05,099 --> 00:44:06,829
And there's some things, like, well, I
还有一些事情，例如，我

795
00:44:06,829 --> 00:44:09,049
could put my glasses on whenever, although actually I
可以随时戴上眼镜，尽管实际上我

796
00:44:09,050 --> 00:44:11,173
should put my glasses on before I do anything else,
在我做其他事情之前，应该戴上眼镜， 

797
00:44:11,173 --> 00:44:12,730
otherwise there's problems.
否则会有问题。 

798
00:44:12,730 --> 00:44:14,980
I don't know, you could put your watch on at any time,
我不知道，您可以随时戴上手表， 

799
00:44:14,980 --> 00:44:17,110
unless you need to know what time is.
除非您需要知道现在几点。 

800
00:44:17,110 --> 00:44:20,086
So there's some disconnected parts, whatever.
因此，有一些断开的部分，无论如何。 

801
00:44:20,286 --> 00:44:21,869
There's some unrelated things, like, I
有一些无关的东西，例如我

802
00:44:21,869 --> 00:44:24,954
don't care the order between my shirt and my pants
不在乎我的衬衫和裤子之间的顺序

803
00:44:24,954 --> 00:44:28,779
or whatever, some things aren't constrained.
或其他任何东西都不受限制。 

804
00:44:28,780 --> 00:44:31,760
What you'd like to do is choose an actual order to do things.
您要做的是选择实际的订单来做事。 

805
00:44:31,760 --> 00:44:33,275
Say you're a sequential being, you
说你是一个有序的人，你

806
00:44:33,275 --> 00:44:35,630
can only do one thing at a time, so I
一次只能做一件事，所以我

807
00:44:35,630 --> 00:44:37,050
want to compute a total order.
想要计算总订单。 

808
00:44:37,050 --> 00:44:39,510
First I'll do g, then I'll do a, then
首先我会做g，然后我会做a，然后

809
00:44:39,510 --> 00:44:42,900
I can do h, because I've done both of the predecessors.
我可以做h，因为我已经做过两个前任。 

810
00:44:42,900 --> 00:44:44,960
Then I can't do be, because I haven't done d,
那我就做不到，因为我还没做过d， 

811
00:44:45,159 --> 00:44:49,039
so maybe I'll do d first, and then b, and than e, then c,
所以也许我先做d，然后做b，然后再做e，然后做c， 

812
00:44:49,039 --> 00:44:50,090
then f, then i.
然后是f，然后是i。 

813
00:44:50,090 --> 00:44:52,980
That would be a valid order, because all edges point
那将是一个有效的顺序，因为所有边缘都指向

814
00:44:53,179 --> 00:44:55,579
from an earlier number to a later number.
从较早的数字到较新的数字。 

815
00:44:55,579 --> 00:44:56,929
So that's the goal.
这就是目标。 

816
00:44:56,929 --> 00:44:59,299
And these are real job scheduling problems
这些都是真正的工作安排问题

817
00:44:59,300 --> 00:45:01,670
that come up, you'll see more applications
出现，您将看到更多应用程序

818
00:45:01,670 --> 00:45:04,710
in your problem set.
在您的问题集中。 

819
00:45:04,710 --> 00:45:07,199
How do we do this?
我们如何做到这一点？ 

820
00:45:07,199 --> 00:45:08,789
Well, at this point we have two algorithms,
好了，目前我们有两种算法

821
00:45:08,989 --> 00:45:10,879
and I pretty much revealed it is DFS.
我几乎透露它是DFS。 

822
00:45:10,880 --> 00:45:13,099
DFS will do this.
 DFS将执行此操作。 

823
00:45:13,099 --> 00:45:16,650
It's a topological sort, is what this algorithm is usually
这是一种拓扑排序，通常是这种算法

824
00:45:16,650 --> 00:45:17,150
called.
叫。 

825
00:45:17,150 --> 00:45:20,010



826
00:45:20,010 --> 00:45:23,280
Topological sort because you're given a graph, which
拓扑排序，因为您得到了一个图， 

827
00:45:23,280 --> 00:45:25,070
you could think of as a topology.
您可以将其视为拓扑。 

828
00:45:25,070 --> 00:45:26,711
You want to sort it, in a certain sense.
从某种意义上说，您想对其进行排序。 

829
00:45:26,911 --> 00:45:28,369
It's not like sorting numbers, it's
这不像对数字进行排序，而是

830
00:45:28,369 --> 00:45:32,369
sorting vertices in a graph, so, hence, topological sort.
在图中对顶点进行排序，因此是拓扑排序。 

831
00:45:32,369 --> 00:45:34,150
That's the name of the algorithm.
那就是算法的名字。 

832
00:45:34,150 --> 00:45:46,250
And it's run DFS, and output the reverse
然后运行DFS，并输出相反的结果

833
00:45:46,250 --> 00:45:55,192
of the finishing times of vertices.
顶点的整理时间。 

834
00:45:55,192 --> 00:45:57,150
so this is another application where you really
所以这是您真正在其中的另一个应用程序

835
00:45:57,150 --> 00:45:58,983
want to visit all the vertices in the graph,
想要访问图中的所有顶点， 

836
00:45:58,983 --> 00:46:04,900
so we use this top level DFS, so everybody gets visited.
因此我们使用此顶级DFS，因此每个人都可以访问。 

837
00:46:05,099 --> 00:46:07,349
And there are these finishing times,
还有这些完成时间， 

838
00:46:07,349 --> 00:46:11,469
so every time I finish a vertex, I could add it to a list.
因此，每次完成顶点时，都可以将其添加到列表中。 

839
00:46:11,469 --> 00:46:13,293
Say OK, that one was finished next,
说好，那下一个完成了， 

840
00:46:13,293 --> 00:46:15,460
than this one is finished, than this one's finished.
比这完成的还要多。 

841
00:46:15,460 --> 00:46:18,320
I take that order and I reverse it.
我接受该命令，然后我将其撤消。 

842
00:46:18,320 --> 00:46:21,588
That will be a topological order.
那将是一个拓扑顺序。 

843
00:46:21,588 --> 00:46:22,900
Why?
为什么？ 

844
00:46:22,900 --> 00:46:24,190
Who knows.
谁知道。 

845
00:46:24,190 --> 00:46:24,880
Let's prove it.
让我们证明一下。 

846
00:46:24,880 --> 00:46:34,440



847
00:46:34,440 --> 00:46:38,610
We've actually done pretty much the hard work, which
实际上，我们已经做了很多艰苦的工作， 

848
00:46:38,610 --> 00:46:42,559
is to say-- we're assuming our graph has no cycles,
就是说-我们假设我们的图表没有周期， 

849
00:46:42,559 --> 00:46:46,150
so that tells us by this cycle detection
这样通过周期检测可以告诉我们

850
00:46:46,150 --> 00:46:47,210
that there are no back edges.
没有后边缘。 

851
00:46:47,409 --> 00:46:49,779
Back edges are kind of the annoying part.
后边缘有点烦人。 

852
00:46:49,780 --> 00:46:51,500
Now they don't exist here.
现在它们在这里不存在。 

853
00:46:51,500 --> 00:46:56,969
So all the edges are tree edges, forward edges, and cross edges,
所以所有的边都是树边，前边和交叉边， 

854
00:46:56,969 --> 00:47:01,764
and we use that to prove the theorem.
我们用它来证明定理。 

855
00:47:01,764 --> 00:47:05,019



856
00:47:05,019 --> 00:47:10,570
So we want to prove that all the edges point from an earlier
因此，我们想证明所有边缘都指向较早的

857
00:47:10,570 --> 00:47:12,170
number to a later number.
编号到更高的编号。 

858
00:47:12,170 --> 00:47:15,320



859
00:47:15,320 --> 00:47:16,880
So what that means is for an edge,
所以这意味着优势

860
00:47:17,079 --> 00:47:22,829
uv, we want to show that v finishes before u.
 uv，我们想证明v在u之前完成。 

861
00:47:22,829 --> 00:47:32,009



862
00:47:32,010 --> 00:47:34,750
That's the reverse, because what we're taking
恰恰相反，因为我们要采取的是

863
00:47:34,750 --> 00:47:38,610
is the reverse of the finishing order.
是完成顺序的相反顺序。 

864
00:47:38,610 --> 00:47:41,789
So edge uv, I want to make sure v finishes first,
因此，在uv边缘，我想确保v首先完成， 

865
00:47:41,789 --> 00:47:43,594
so that u will be ordered first.
这样您将被首先订购。 

866
00:47:43,594 --> 00:47:45,916



867
00:47:45,916 --> 00:47:47,000
Well, there are two cases.
好吧，有两种情况。 

868
00:47:47,000 --> 00:47:51,289



869
00:47:51,289 --> 00:47:59,009
Case 1 is that u starts before v. Case 2
情况1是u在v之前开始

870
00:47:59,010 --> 00:48:01,460
is that he v before u.
是他在你之前v。 

871
00:48:01,460 --> 00:48:06,690



872
00:48:06,690 --> 00:48:08,019
At some point they start, because we
他们从某个时候开始，因为我们

873
00:48:08,219 --> 00:48:09,135
visit the whole graph.
访问整个图表。 

874
00:48:09,135 --> 00:48:13,159



875
00:48:13,159 --> 00:48:16,399
This top loop guarantees that.
这个顶级循环保证了这一点。 

876
00:48:16,400 --> 00:48:21,440
So consider what order we visit them first, at the beginning,
因此，首先考虑一下我们首先拜访他们的顺序， 

877
00:48:21,440 --> 00:48:23,960
and then we'll think about how they finish.
然后我们将考虑它们如何完成。 

878
00:48:23,960 --> 00:48:27,400
Well, this case is kind of something we've seen before.
好吧，这种情况是我们以前见过的。 

879
00:48:27,400 --> 00:48:31,480
We visit u, we have not yet visited v,
我们访问过您，我们尚未访问过v， 

880
00:48:31,480 --> 00:48:35,440
but v is reachable from u, so maybe via this edge,
但是v可以从u到达，所以也许可以通过这个边， 

881
00:48:35,440 --> 00:48:38,320
or maybe via some other path, we will eventually
或者也许通过其他途径，我们最终

882
00:48:38,320 --> 00:48:41,190
visit v in the recursion for u.
在您的递归中访问v。 

883
00:48:41,190 --> 00:48:48,750
So before u finishes, we will visit v, visit v
因此，在您完成操作之前，我们将访问v，访问v 

884
00:48:48,949 --> 00:48:53,069
before u finishes.
在你完成之前。 

885
00:48:53,070 --> 00:48:58,559
That sentence is just like this sentence,
那句话就像这句话

886
00:48:58,559 --> 00:48:59,849
so same kind of argument.
这样的论点。 

887
00:48:59,849 --> 00:49:01,440
We won't go into detail, because we already
我们不会详细介绍，因为我们已经

888
00:49:01,639 --> 00:49:04,469
did that several times.
做了几次。 

889
00:49:04,469 --> 00:49:07,709
So that means we'll visit v, we will completely visit v,
因此，这意味着我们将访问v，我们将完全访问v， 

890
00:49:07,710 --> 00:49:10,039
we will finish v before we finish u
我们将在完成u之前完成v 

891
00:49:10,039 --> 00:49:12,099
and that's what we wanted to prove.
这就是我们想要证明的。 

892
00:49:12,099 --> 00:49:14,579
So in that case is good.
所以在那种情况下是好的。 

893
00:49:14,579 --> 00:49:18,819
The other cases is that v starts before u.
其他情况是v在u之前开始。 

894
00:49:18,820 --> 00:49:21,764
Here, you might get slightly worried.
在这里，您可能会有些担心。 

895
00:49:21,764 --> 00:49:24,809
So we have an edge, uv, still, same direction.
所以我们有一个边缘，uv，仍然是同一方向。 

896
00:49:24,809 --> 00:49:29,929
But now we start at v, u has not yet been visited.
但是现在我们从v开始，尚未访问过u。 

897
00:49:29,929 --> 00:49:35,645
Well, now we worry that we visit u.
好吧，现在我们担心我们会拜访您。 

898
00:49:35,646 --> 00:49:38,510
If we visit u, we're going to finish u before we finish v,
如果我们访问您，我们将在完成v之前完成u， 

899
00:49:38,510 --> 00:49:40,440
but we want it to be the other way around.
但我们希望反之亦然。 

900
00:49:40,639 --> 00:49:43,096
Why can't that happen?
为什么那不可能发生？ 

901
00:49:43,096 --> 00:49:44,012
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

902
00:49:44,012 --> 00:49:46,261
PROFESSOR: Because there's a back edge somewhere here.
教授：因为这里有后缘。 

903
00:49:46,262 --> 00:49:48,610
In particular, the graph would have to be cyclic.
特别地，该图将必须是循环的。 

904
00:49:48,610 --> 00:49:54,829
This is a cycle, so this can't happen, a contradiction.
这是一个周期，所以这不可能发生，是一个矛盾。 

905
00:49:54,829 --> 00:50:00,349
So v will finish before we visit u at all.
因此v将在我们完全访问您之前完成。 

906
00:50:00,349 --> 00:50:04,690



907
00:50:04,690 --> 00:50:07,829
So v will still finish first, because we don't even touch u,
 v仍然会先完成，因为我们甚至都不会碰你， 

908
00:50:07,829 --> 00:50:10,079
because there's no cycles.
因为没有周期。 

909
00:50:10,079 --> 00:50:13,279
So that's actually the proof that topological sort gives you
所以这实际上是拓扑排序给您的证明

910
00:50:13,280 --> 00:50:18,195
a valid job schedule, and it's kind of-- there
有效的工作时间表，在某种程度上

911
00:50:18,195 --> 00:50:21,000
are even more things you can do with DFS.
您可以使用DFS做更多的事情。 

912
00:50:21,199 --> 00:50:24,519
We'll see some in recitations, more in the textbook.
我们将在背诵中看到一些内容，在教科书中还会更多。 

913
00:50:24,519 --> 00:50:28,280
But simple algorithm, can do a lot of nifty things with it,
但是简单的算法可以用它做很多漂亮的事情， 

914
00:50:28,280 --> 00:50:33,280
very fast, linear time.
非常快的线性时间。 

