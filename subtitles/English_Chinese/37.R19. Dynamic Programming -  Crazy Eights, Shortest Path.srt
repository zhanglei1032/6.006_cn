1
00:00:00,000 --> 00:00:00,090



2
00:00:00,090 --> 00:00:01,800
The following content is provided
提供以下内容

3
00:00:01,800 --> 00:00:04,030
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,030 --> 00:00:06,679
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,879 --> 00:00:10,740
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,740 --> 00:00:13,359
To make a donation, or view additional materials
捐款或查看其他材料

7
00:00:13,359 --> 00:00:17,236
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,236 --> 00:00:17,861
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,861 --> 00:00:21,348



10
00:00:21,349 --> 00:00:22,890
PROFESSOR: OK, so up until now, we've
教授：好的，到目前为止，我们已经

11
00:00:22,890 --> 00:00:26,170
been talking about the shortest path in graphs.
一直在谈论图形中的最短路径。 

12
00:00:26,370 --> 00:00:28,369
And we've been talking about these game problems
我们一直在谈论这些游戏问题

13
00:00:28,370 --> 00:00:34,259
where you came up with a way to represent the state of a game
您想出了一种表示游戏状态的方法

14
00:00:34,259 --> 00:00:35,239
as noting graphs.
作为图表。 

15
00:00:35,240 --> 00:00:39,199
And then we drew edges between those vertices that represented
然后我们在代表这些顶点的那些顶点之间绘制边缘

16
00:00:39,399 --> 00:00:42,210
states, to represent moves that you can do in a game.
状态，以表示您可以在游戏中进行的移动。 

17
00:00:42,210 --> 00:00:44,500
It turns out you can solve a lot of problems this way.
事实证明，您可以通过这种方式解决很多问题。 

18
00:00:44,500 --> 00:00:47,649
And you can do it without thinking of a graph at all.
而且，您完全不需要考虑图表就可以做到。 

19
00:00:47,649 --> 00:00:50,481
So we usually think of a graph, build the graph,
所以我们通常想到一个图，建立一个图， 

20
00:00:50,481 --> 00:00:51,689
then run dynamic programming.
然后运行动态编程。 

21
00:00:51,689 --> 00:00:54,549
You can do better without building the graph.
您可以在不构建图表的情况下做得更好。 

22
00:00:54,549 --> 00:00:59,259
And the good part about that is that your code is smaller,
好处是您的代码较小， 

23
00:00:59,259 --> 00:01:00,629
and it runs faster.
而且运行速度更快。 

24
00:01:00,630 --> 00:01:03,309
The bad part about that is it's harder to understand.
不好的部分是很难理解。 

25
00:01:03,509 --> 00:01:06,259
The dynamic programming code looks like black magic.
动态编程代码看起来像黑魔法。 

26
00:01:06,260 --> 00:01:09,420
And, when we're going to give you dynamic programming
而且，当我们要为您提供动态编程时

27
00:01:09,420 --> 00:01:11,129
problems on the final, you can't say, oh,
决赛中的问题，你不能说，哦， 

28
00:01:11,129 --> 00:01:13,378
we're going to build something and run [? dystring ?].
我们将要构建一些东西并运行[？ dystring？]。 

29
00:01:13,378 --> 00:01:14,459
And get partial credit.
并获得部分信用。 

30
00:01:14,459 --> 00:01:16,969
You actually have to understand the magic,
您实际上必须了解魔术， 

31
00:01:16,969 --> 00:01:21,359
and write the formulas, and hopefully get
并写出公式，并希望得到

32
00:01:21,359 --> 00:01:22,790
something that works.
有用的东西。 

33
00:01:22,790 --> 00:01:26,090
So, we're going to spend all the time that we have left
因此，我们将花所有剩下的时间

34
00:01:26,090 --> 00:01:27,640
in the semester, I think, building up
我认为在这个学期中

35
00:01:27,640 --> 00:01:30,359
your intuition for how to build dynamic programming.
您对如何构建动态编程的直觉。 

36
00:01:30,359 --> 00:01:32,040
So, from lecture, dynamic programming
因此，从讲座开始，动态编程

37
00:01:32,040 --> 00:01:37,659
is just a catchy name for for optimization problems.
只是优化问题的易记名称。 

38
00:01:37,659 --> 00:01:39,450
So, problems where you're trying to compute
因此，您尝试计算的问题

39
00:01:39,450 --> 00:01:42,539
the minimum or the maximum of something.
最小或最大的东西。 

40
00:01:42,739 --> 00:01:44,140
So let's start with a problem.
因此，让我们从一个问题开始。 

41
00:01:44,140 --> 00:01:46,189
And then, see how all the concepts in lecture
然后，看看讲座中的所有概念

42
00:01:46,189 --> 00:01:47,289
relate to that.
与此有关。 

43
00:01:47,290 --> 00:01:49,650
So this problem is called Crazy Eights.
因此，这个问题称为“疯狂八人”。 

44
00:01:49,650 --> 00:01:55,030
And we start out with a deck of cards, randomly shuffled.
我们从随机洗牌的一副纸牌开始。 

45
00:01:55,030 --> 00:01:57,310
And then some of the cards are pulled out.
然后将其中一些卡拔出。 

46
00:01:57,310 --> 00:01:59,049
Did everyone see playing cards?
大家都看过扑克牌吗？ 

47
00:01:59,049 --> 00:02:00,519
Poker cards?
扑克牌？ 

48
00:02:00,519 --> 00:02:04,420
Does everyone know what they are or do I have to define them?
每个人都知道它们是什么还是我必须定义它们？ 

49
00:02:04,420 --> 00:02:06,739
Does anyone need me to define poker cards?
有人需要我定义扑克牌吗？ 

50
00:02:06,739 --> 00:02:08,210
Let's put it that way.
让我们这样说。 

51
00:02:08,210 --> 00:02:08,740
OK.
好。 

52
00:02:08,740 --> 00:02:10,639
Cool.
凉。 

53
00:02:10,639 --> 00:02:13,270
So, suppose we have a bunch of these.
因此，假设我们有一堆。 

54
00:02:13,270 --> 00:02:17,086



55
00:02:17,086 --> 00:02:18,912
AUDIENCE: I don't know what Crazy Eights is.
听众：我不知道什么是疯八。 

56
00:02:19,111 --> 00:02:20,319
PROFESSOR: We'll get to that.
教授：我们会解决的。 

57
00:02:20,319 --> 00:02:21,449
AUDIENCE: OK.
听众：好的。 

58
00:02:21,449 --> 00:02:22,383
It's an 8.
是8。 

59
00:02:22,383 --> 00:02:23,883
AUDIENCE: I know what an 8 is, but I
听众：我知道8是什么，但是我

60
00:02:23,883 --> 00:02:24,879
don't know how the game works.
不知道游戏如何运作。 

61
00:02:24,879 --> 00:02:25,139
PROFESSOR: OK.
教授：好的。 

62
00:02:25,139 --> 00:02:25,929
We'll get to it.
我们会解决的。 

63
00:02:25,930 --> 00:02:28,000
So, let's see.
所以，让我们看看。 

64
00:02:28,000 --> 00:02:31,009



65
00:02:31,009 --> 00:02:31,879
4 of spades.
黑桃4。 

66
00:02:31,879 --> 00:02:55,250



67
00:02:55,250 --> 00:02:58,354
OK, so this is a bunch of cards that
好，这是一堆卡片

68
00:02:58,354 --> 00:02:59,520
were pulled out of the deck.
被从甲板上拉出来。 

69
00:02:59,520 --> 00:03:03,659
And we want the longest crazy subsequence.
我们想要最长的疯狂子序列。 

70
00:03:03,659 --> 00:03:05,669
And the crazy subsequence is a subsequence
疯狂的子序列是一个子序列

71
00:03:05,669 --> 00:03:09,089
where two cards are like each other.
两张卡彼此相似的地方。 

72
00:03:09,090 --> 00:03:13,370
The way we define like is that either they
我们定义的方式是

73
00:03:13,370 --> 00:03:16,370
have the same number.
具有相同的编号。 

74
00:03:16,370 --> 00:03:19,280
Or they have the same suit.
或者他们有同样的衣服。 

75
00:03:19,479 --> 00:03:21,699
Or one of them is an 8.
或其中之一是8。 

76
00:03:21,699 --> 00:03:23,699
So an 8 is like anything else.
所以8就像其他任何东西一样。 

77
00:03:23,699 --> 00:03:31,159



78
00:03:31,159 --> 00:03:31,659
OK.
好。 

79
00:03:31,659 --> 00:03:32,650
So 4 and 8.
所以4和8。 

80
00:03:32,650 --> 00:03:35,171
Are they like each other?
他们彼此喜欢吗？ 

81
00:03:35,171 --> 00:03:37,960
AUDIENCE: Yes.
听众：是的。 

82
00:03:37,960 --> 00:03:39,610
PROFESSOR: 8 and 5.
教授：8和5。 

83
00:03:39,610 --> 00:03:41,055
Are they like each other?
他们彼此喜欢吗？ 

84
00:03:41,055 --> 00:03:43,477
AUDIENCE: Yep.
听众：是的。 

85
00:03:43,676 --> 00:03:44,259
PROFESSOR: OK.
教授：好的。 

86
00:03:44,259 --> 00:03:47,780



87
00:03:47,780 --> 00:03:50,469
this 5, 5 of hearts and 9 of diamonds.
这5、5颗心和9颗钻石。 

88
00:03:50,469 --> 00:03:52,210
Are they like each other?
他们彼此喜欢吗？ 

89
00:03:52,210 --> 00:03:53,610
No.
没有。 

90
00:03:53,610 --> 00:03:56,649
5 of hearts and 7 of hearts.
 5心和7心。 

91
00:03:56,649 --> 00:03:57,689
Are they like each other?
他们彼此喜欢吗？ 

92
00:03:57,689 --> 00:04:00,199
AUDIENCE: Yes.
听众：是的。 

93
00:04:00,199 --> 00:04:03,000
PROFESSOR: 5 of spades and 7 of hearts, like each other?
教授：黑桃5和红心7，彼此喜欢吗？ 

94
00:04:03,000 --> 00:04:03,500
No.
没有。 

95
00:04:03,500 --> 00:04:04,330
OK.
好。 

96
00:04:04,330 --> 00:04:06,400
So we have some cards that are like each other.
所以我们有一些彼此相似的卡片。 

97
00:04:06,599 --> 00:04:09,849
We want the longest possible subsequence.
我们想要最长的子序列。 

98
00:04:09,849 --> 00:04:11,057
AUDIENCE: What about 5 and 5?
听众：5和5怎么样？ 

99
00:04:11,057 --> 00:04:12,239
Those are like each other.
那些彼此一样。 

100
00:04:12,240 --> 00:04:14,864
PROFESSOR: They're like each other, yep.
教授：是的，彼此一样。 

101
00:04:15,063 --> 00:04:17,480
They are more cards that are like each other than the ones
他们是比彼此更多相似的卡片

102
00:04:17,480 --> 00:04:18,069
I drew here.
我在这里画

103
00:04:18,069 --> 00:04:24,262
For example, this guy is like everything else.
例如，这个家伙就像其他一切一样。 

104
00:04:24,262 --> 00:04:25,741
Oh, we already drew that one.
哦，我们已经画了那个。 

105
00:04:25,742 --> 00:04:28,500



106
00:04:28,699 --> 00:04:29,439
OK.
好。 

107
00:04:29,439 --> 00:04:31,879
So how do we model this problem using graphs?
那么我们如何使用图形对这个问题建模呢？ 

108
00:04:31,879 --> 00:04:36,310
So, stuff that we knew before the last lecture.
因此，我们在上一堂课之前就知道了一些东西。 

109
00:04:36,310 --> 00:04:37,997
AUDIENCE: Those could all be nodes.
听众：这些全都是节点。 

110
00:04:37,997 --> 00:04:38,379
PROFESSOR: OK.
教授：好的。 

111
00:04:38,579 --> 00:04:39,579
All the cards are nodes.
所有卡都是节点。 

112
00:04:39,579 --> 00:04:41,180
That's good.
那很好。 

113
00:04:41,180 --> 00:04:46,860
And, I want the longest path between what and what?
而且，我想要什么和什么之间的最长路径？ 

114
00:04:46,860 --> 00:04:49,557



115
00:04:49,757 --> 00:04:52,916
AUDIENCE: One node to another?
听众：一个节点到另一个？ 

116
00:04:52,916 --> 00:04:53,500
PROFESSOR: OK.
教授：好的。 

117
00:04:53,500 --> 00:04:54,930
AUDIENCE: The longest path in the graph.
受众：图形中的最长路径。 

118
00:04:54,930 --> 00:04:55,250
PROFESSOR: Yeah.
教授：是的。 

119
00:04:55,250 --> 00:04:56,750
The longest path in the graph.
图中的最长路径。 

120
00:04:56,750 --> 00:04:59,509
One trick to reduce it to a known problem
将其简化为已知问题的一个技巧

121
00:04:59,509 --> 00:05:02,879
is to add the fake source.
是添加假货。 

122
00:05:02,879 --> 00:05:04,084
So this is a fake source.
因此，这是一个虚假来源。 

123
00:05:04,084 --> 00:05:05,750
And it's going to connect to everything.
并且它将连接到所有内容。 

124
00:05:05,750 --> 00:05:11,983



125
00:05:11,983 --> 00:05:14,649
And this way, I want the longest path, starting from the source.
这样，我便希望从源头开始走最长的路。 

126
00:05:14,649 --> 00:05:17,524



127
00:05:17,524 --> 00:05:19,564
AUDIENCE: And the other source?
听众：另一个来源？ 

128
00:05:19,564 --> 00:05:20,230
PROFESSOR: Nope.
教授：不。 

129
00:05:20,230 --> 00:05:22,487
The longest path, starting from the source, ending anywhere
最长的路径，从源头开始，到任何地方结束

130
00:05:22,687 --> 00:05:24,991
in the graph.
在图中。 

131
00:05:24,992 --> 00:05:28,684
AUDIENCE: Such that it doesn't go touch another card again?
听众：这样就不会再碰另一张卡了吗？ 

132
00:05:28,684 --> 00:05:29,350
PROFESSOR: Yeah.
教授：是的。 

133
00:05:29,350 --> 00:05:30,860
So, if I want a longer subsequence,
所以，如果我想要更长的子序列， 

134
00:05:30,860 --> 00:05:31,617
that's a good question.
这是个好问题。 

135
00:05:31,817 --> 00:05:33,883
How would the edges look?
边缘看起来如何？ 

136
00:05:33,884 --> 00:05:34,785
AUDIENCE: Directed.
听众：导演。 

137
00:05:34,785 --> 00:05:35,410
PROFESSOR: Yep.
教授：是的。 

138
00:05:35,410 --> 00:05:35,819
Directed.
导演。 

139
00:05:36,019 --> 00:05:37,569
And which direction?
哪个方向？ 

140
00:05:37,569 --> 00:05:40,353



141
00:05:40,353 --> 00:05:43,139
AUDIENCE: Arbitrary [INAUDIBLE].
听众：任意[听不清]。 

142
00:05:43,139 --> 00:05:46,349
PROFESSOR: So, if I choose this one and this one,
教授：所以，如果我选择这个和这个， 

143
00:05:46,350 --> 00:05:48,490
can I go back afterwards?
我可以回去吗？ 

144
00:05:48,690 --> 00:05:50,439
AUDIENCE: You just can't go back to the 4.
听众：您就是无法回到4。 

145
00:05:50,439 --> 00:05:52,480
PROFESSOR: So, in the longest common subsequence,
教授：因此，在最长的公共子序列中， 

146
00:05:52,480 --> 00:05:54,389
all the cards have to be in increasing order.
所有卡片必须按升序排列。 

147
00:05:54,389 --> 00:05:57,360
So I can say I'm going to choose this one, this one,
所以我可以说我要选择这个，这个， 

148
00:05:57,360 --> 00:05:58,420
and this one.
还有这个。 

149
00:05:58,420 --> 00:06:00,949
And they have to match in this order.
他们必须按此顺序进行匹配。 

150
00:06:01,149 --> 00:06:03,949
So I can only go forward.
所以我只能前进。 

151
00:06:03,949 --> 00:06:05,490
So I can't reorder the cards.
所以我不能重新排序卡。 

152
00:06:05,490 --> 00:06:13,269
My answer has to be, say, 4 of diamonds, 8 of diamonds.
我的答案必须是4颗钻石，8颗钻石。 

153
00:06:13,269 --> 00:06:15,889
And then, what else would match that?
然后，还有什么可以匹配的呢？ 

154
00:06:15,889 --> 00:06:16,500
9 of diamonds.
 9颗钻石。 

155
00:06:16,500 --> 00:06:18,399
AUDIENCE: You can put the 8 anywhere, though, right?
听众：不过您可以将8放在任何地方，对吗？ 

156
00:06:18,399 --> 00:06:18,983
PROFESSOR: No.
教授：不。 

157
00:06:18,983 --> 00:06:21,180
I can't move them.
我不能动他们。 

158
00:06:21,180 --> 00:06:23,249
So the cards have to be in the initial order.
因此，卡片必须处于初始顺序。 

159
00:06:23,249 --> 00:06:24,790
I don't have to choose all the cards,
我不必选择所有卡片

160
00:06:24,790 --> 00:06:26,581
but the cards that I choose have to respect
但是我选择的卡必须要尊重

161
00:06:26,581 --> 00:06:27,473
the initial ordering.
初始订购。 

162
00:06:27,673 --> 00:06:29,289
AUDIENCE: So everything points right.
听众：所以一切都正确。 

163
00:06:29,290 --> 00:06:30,699
PROFESSOR: Everything points right.
教授：一切都正确。 

164
00:06:30,899 --> 00:06:31,762
Forward.
向前。 

165
00:06:31,762 --> 00:06:32,262
Yep.
是的

166
00:06:32,262 --> 00:06:39,329



167
00:06:39,329 --> 00:06:41,890
And, I need one more edge from here to here.
而且，从这里到这里，我还需要一个优势。 

168
00:06:41,891 --> 00:06:43,641
AUDIENCE: Oh, so you're saying in the game
听众：哦，所以你在游戏中说

169
00:06:43,641 --> 00:06:45,170
you get an initial order.
您会收到初始订单。 

170
00:06:45,170 --> 00:06:46,379
And you can't reorder it.
而且您无法重新排序。 

171
00:06:46,579 --> 00:06:48,709
PROFESSOR: Yeah.
教授：是的。 

172
00:06:48,709 --> 00:06:51,349
But otherwise I can, if I have all the cards,
但是如果我有所有的卡片，我可以

173
00:06:51,350 --> 00:06:52,610
I'm just going to order them.
我要点菜。 

174
00:06:52,610 --> 00:06:55,391
AUDIENCE: Well, that's the point right?
听众：是的，对吗？ 

175
00:06:55,591 --> 00:06:57,719
I was picturing more like you get a set of cards
我在想像更多像是你得到了一套卡片

176
00:06:57,720 --> 00:06:59,000
and you try to figure out--
然后您尝试找出- 

177
00:06:59,000 --> 00:06:59,779
PROFESSOR: No.
教授：不。 

178
00:06:59,779 --> 00:07:01,259
So, that's a different game.
因此，那是另一种游戏。 

179
00:07:01,259 --> 00:07:03,860
That might be harder to solve, so let's stick with this.
这可能很难解决，所以让我们坚持下去。 

180
00:07:03,860 --> 00:07:04,607
Yes?
是？ 

181
00:07:04,607 --> 00:07:07,939
AUDIENCE: Why is 8 in there, with 7?
听众：为什么8个在里面，而7个在里面呢？ 

182
00:07:08,139 --> 00:07:09,639
PROFESSOR: 8 is similar to anything.
教授：8类似于任何东西。 

183
00:07:09,639 --> 00:07:12,240



184
00:07:12,240 --> 00:07:13,466
Just for the heck of it.
只是为了它。 

185
00:07:13,466 --> 00:07:14,300
These are the rules.
这些是规则。 

186
00:07:14,300 --> 00:07:17,139



187
00:07:17,339 --> 00:07:18,899
OK, so we have a graph and we want
好，我们有一个图，我们想要

188
00:07:18,899 --> 00:07:21,359
to compute the longest path.
计算最长路径。 

189
00:07:21,360 --> 00:07:24,250
We do not have an algorithm to compute the longest path.
我们没有算法来计算最长路径。 

190
00:07:24,250 --> 00:07:26,480
We only have algorithms to compute shortest paths.
我们只有用于计算最短路径的算法。 

191
00:07:26,480 --> 00:07:28,509
So how do I deal with that?
那么我该如何处理呢？ 

192
00:07:28,709 --> 00:07:30,927
We had that in problem set six.
我们在第六个问题中遇到了问题。 

193
00:07:30,927 --> 00:07:32,386
AUDIENCE: Make all weights negative
观众：将所有权重设为负

194
00:07:32,386 --> 00:07:34,757
because there's no cycle [INAUDIBLE].
因为没有周期[听不清]。 

195
00:07:34,956 --> 00:07:35,540
PROFESSOR: OK.
教授：好的。 

196
00:07:35,540 --> 00:07:36,980
We know it's negative.
我们知道这是负面的。 

197
00:07:36,980 --> 00:07:39,370
And, I guess these ones don't matter.
而且，我猜这些都不重要。 

198
00:07:39,370 --> 00:07:41,870
But all these are going to be, instead of being 1,
但是所有这些将成为，而不是成为1 

199
00:07:41,870 --> 00:07:43,189
they're all going to be -1.
他们都将是-1。 

200
00:07:43,189 --> 00:07:45,069
Very good.
很好。 

201
00:07:45,069 --> 00:07:47,519
And there are no cycles in this graph,
此图中没有周期， 

202
00:07:47,519 --> 00:07:51,390
so we know that the answer will be well defined.
因此我们知道答案会很明确。 

203
00:07:51,391 --> 00:07:51,689
OK.
好。 

204
00:07:51,889 --> 00:07:54,779
Everyone with me so far?
到目前为止和我在一起的每个人？ 

205
00:07:54,779 --> 00:07:55,479
Happy nods?
高兴点头？ 

206
00:07:55,480 --> 00:07:57,389
Yes.
是。 

207
00:07:57,589 --> 00:08:00,951
So, what algorithm do I know that solves this problem?
那么，我知道哪种算法可以解决此问题？ 

208
00:08:00,951 --> 00:08:01,910
AUDIENCE: Bellman-Ford.
听众：贝尔曼·福特。 

209
00:08:01,910 --> 00:08:02,689
PROFESSOR: Bellman-Ford.
教授：贝尔曼·福特。 

210
00:08:02,689 --> 00:08:03,189
Good.
好。 

211
00:08:03,189 --> 00:08:09,259



212
00:08:09,259 --> 00:08:11,289
What is the running time of Bellman-Ford?
贝尔曼福特的运行时间是几点？ 

213
00:08:11,290 --> 00:08:14,230
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

214
00:08:14,230 --> 00:08:15,420
PROFESSOR: Cool.
教授：太好了。 

215
00:08:15,420 --> 00:08:17,199
Suppose I have N cards.
假设我有N张卡。 

216
00:08:17,399 --> 00:08:20,584
How many vertices do I have?
我有多少个顶点？ 

217
00:08:20,584 --> 00:08:23,419
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

218
00:08:23,420 --> 00:08:25,439
PROFESSOR: Plus the source.
教授：再加上源代码。 

219
00:08:25,439 --> 00:08:26,350
It's ordering.
正在订购。 

220
00:08:26,350 --> 00:08:27,740
So you're right.
所以你是对的。 

221
00:08:27,740 --> 00:08:29,009
How many edges do I have?
我有多少条边？ 

222
00:08:29,009 --> 00:08:33,529



223
00:08:33,529 --> 00:08:34,615
Worst case.
最差的情况。 

224
00:08:34,615 --> 00:08:35,529
AUDIENCE: N squared.
听众：N平方。 

225
00:08:35,529 --> 00:08:36,381
PROFESSOR: Yep.
教授：是的。 

226
00:08:36,381 --> 00:08:42,079
AUDIENCE: [INAUDIBLE] you mean, like, the directed [INAUDIBLE]?
听众：[听不清]你是说像导演[听不清]？ 

227
00:08:42,080 --> 00:08:43,449
PROFESSOR: No, I mean Bellman-Ford.
教授：不，我是说贝尔曼·福特。 

228
00:08:43,649 --> 00:08:45,357
Then, we're going to go to that algorithm
然后，我们将转到该算法

229
00:08:45,357 --> 00:08:47,500
and get the better running time.
并获得更好的运行时间。 

230
00:08:47,500 --> 00:08:50,647
AUDIENCE: Cause isn't Bellman-Ford e times e?
听众：是不是贝尔曼福特e倍e？ 

231
00:08:50,647 --> 00:08:51,230
PROFESSOR: Oh.
教授：哦。 

232
00:08:51,230 --> 00:08:52,625
What?
什么？ 

233
00:08:52,625 --> 00:08:53,250
AUDIENCE: Yeah.
听众：是的。 

234
00:08:53,250 --> 00:08:56,370
PROFESSOR: Yeah, that's what I-- Did someone say, v plus e?
教授：是的，我就是-有人说v加e吗？ 

235
00:08:56,370 --> 00:09:00,210
Or did I write v plus e?
还是我写了v加e？ 

236
00:09:00,210 --> 00:09:00,710
Yep.
是的

237
00:09:00,710 --> 00:09:01,089
You did.
你做到了

238
00:09:01,289 --> 00:09:02,775
Thank you.
谢谢。 

239
00:09:02,775 --> 00:09:03,669
So it's v times e.
所以是e的v倍。 

240
00:09:03,669 --> 00:09:07,259



241
00:09:07,259 --> 00:09:09,662
So the total running time is.
因此，总运行时间为。 

242
00:09:09,662 --> 00:09:12,091
aUDIENCE: N squared.
听众：N平方。 

243
00:09:12,091 --> 00:09:13,063
aUDIENCE: N cubed.
听众：N立方。 

244
00:09:13,063 --> 00:09:13,980
AUDIENCE: Or, n cubed.
听众：或者，n立方。 

245
00:09:13,980 --> 00:09:16,951
Yeah, it's multiplying [INAUDIBLE], too.
是的，它也乘以[音频不清晰]。 

246
00:09:16,951 --> 00:09:20,120
PROFESSOR: You guys are mean today.
教授：你们今天很刻薄。 

247
00:09:20,120 --> 00:09:24,490
OK, so n cubed applying Bellman-Ford.
好的，因此可以应用Bellman-Ford。 

248
00:09:24,490 --> 00:09:27,440
There is a better way of solving this problem, right?
有解决这个问题的更好方法，对吗？ 

249
00:09:27,440 --> 00:09:30,429
The Directed Acyclic Graph Bellman-Ford.
有向无环图Bellman-Ford。 

250
00:09:30,629 --> 00:09:33,950
So let's look at the Directed Acyclic Graph, not the one
因此，让我们看看有向无环图，而不是一个

251
00:09:33,950 --> 00:09:36,600
to be generated by this because that might be a bit messy.
生成此文件，因为这可能有点混乱。 

252
00:09:36,600 --> 00:09:38,225
And let's try to compute shortest path.
让我们尝试计算最短路径。 

253
00:09:38,225 --> 00:09:40,509



254
00:09:40,509 --> 00:09:42,409
s, a, b, c.
 s，a，b，c。 

255
00:09:42,409 --> 00:10:27,199



256
00:10:27,200 --> 00:10:28,860
OK, so let's see how we'd compute
好，让我们看看如何计算

257
00:10:28,860 --> 00:10:30,690
the shortest path in this graph.
此图中最短的路径。 

258
00:10:30,690 --> 00:10:31,570
It's Acyclic, right?
它是非循环的，对不对？ 

259
00:10:31,570 --> 00:10:35,266
All the the edges are pointing downwards.
所有的边缘都指向下方。 

260
00:10:35,466 --> 00:10:37,049
So let's try to compute them directly.
因此，让我们尝试直接计算它们。 

261
00:10:37,049 --> 00:10:38,359
I'm not going to write pseudocode first.
我不会先编写伪代码。 

262
00:10:38,360 --> 00:10:39,599
I'm going to write the formulas, and that
我要写公式， 

263
00:10:39,799 --> 00:10:41,049
will get the intuition for it.
会得到直觉的。 

264
00:10:41,049 --> 00:10:43,240
Then, maybe right psuedocode.
然后，也许是正确的伪代码。 

265
00:10:43,240 --> 00:10:46,066
So what is the distance from the source to itself?
那么，从源到自身的距离是多少？ 

266
00:10:46,066 --> 00:10:47,730
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

267
00:10:47,730 --> 00:10:50,019
PROFESSOR: Good.
教授：很好。 

268
00:10:50,019 --> 00:10:52,819
The first ones are easy, so I'm going to do them myself.
第一个很简单，所以我要自己做。 

269
00:10:52,820 --> 00:10:54,110
sa is 1.
 sa是1。 

270
00:10:54,110 --> 00:10:57,009
sb is 2.
 sb是2。 

271
00:10:57,009 --> 00:10:58,439
sc is 3.
 sc是3。 

272
00:10:58,440 --> 00:11:01,360
And, of course, you guys get to do the hard ones.
而且，当然，你们要努力去做。 

273
00:11:01,360 --> 00:11:05,154
So the distance from s to d is what?
那么从s到d的距离是多少？ 

274
00:11:05,154 --> 00:11:08,701
How would I compute it?
我将如何计算？ 

275
00:11:08,701 --> 00:11:11,509
AUDIENCE: There's two paths to get to [INAUDIBLE].
听众：有两种途径可以到达[听不清]。 

276
00:11:11,509 --> 00:11:12,629
PROFESSOR: OK.
教授：好的。 

277
00:11:12,629 --> 00:11:16,740
So, I would want the shortest path from those, right?
所以，我想要最短的路径，对吧？ 

278
00:11:16,740 --> 00:11:17,240
OK.
好。 

279
00:11:17,240 --> 00:11:17,960
So it's 4.
所以是4。 

280
00:11:17,960 --> 00:11:22,700
And the formula for it is the minimum of two paths, right?
它的公式是两条路径中的最小值，对吗？ 

281
00:11:22,700 --> 00:11:27,220
AUDIENCE: [INAUDIBLE] S to b, and then b to b.
听众：[听不清] S到b，然后b到b。 

282
00:11:27,220 --> 00:11:28,740
PROFESSOR: So, one path is--
教授：所以，一条路是- 

283
00:11:28,740 --> 00:11:30,658
AUDIENCE: [INAUDIBLE] and s [? and b ?].
听众：[听不清]和s [？和b？]。 

284
00:11:30,658 --> 00:11:33,423
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

285
00:11:33,423 --> 00:11:34,090
PROFESSOR: Wait.
教授：等等。 

286
00:11:34,090 --> 00:11:35,219
sa.
萨

287
00:11:35,419 --> 00:11:37,929
So, first there's a path from s to a.
因此，首先存在从s到a的路径。 

288
00:11:37,929 --> 00:11:40,019
And the edge a to d.
和边缘a到d。 

289
00:11:40,019 --> 00:11:43,139
And then, there's a path from s to b.
然后，有一条从s到b的路径。 

290
00:11:43,139 --> 00:11:47,169
And the 8 from b to d, right?
从b到d的8对吧？ 

291
00:11:47,169 --> 00:11:50,219



292
00:11:50,220 --> 00:11:52,349
And I already know the values for sa and sb,
我已经知道sa和sb的值， 

293
00:11:52,549 --> 00:11:54,549
so this is well defined.
所以这是很好的定义。 

294
00:11:54,549 --> 00:11:56,539
We can compute it right away.
我们可以立即进行计算。 

295
00:11:56,539 --> 00:11:58,149
No recursion.
没有递归。 

296
00:11:58,149 --> 00:12:00,329
No metrics.
没有指标。 

297
00:12:00,330 --> 00:12:04,960
I mean, there's recursion, but there's no infinite recursion.
我的意思是，有递归，但没有无限递归。 

298
00:12:04,960 --> 00:12:06,859
Does this make sense?
这有意义吗？ 

299
00:12:07,059 --> 00:12:12,094
So, in order to get to d, there are two edges pointing into d.
因此，为了到达d，有两个指向d的边。 

300
00:12:12,095 --> 00:12:12,979
One of them coming from a.
其中之一来自。 

301
00:12:13,179 --> 00:12:14,469
One of them coming from b.
其中一个来自b。 

302
00:12:14,470 --> 00:12:16,620
So I can either get to a and take this edge.
所以我可以走到a并占据优势。 

303
00:12:16,620 --> 00:12:19,249
Or get to b and take this edge.
或到b并抓住这个优势。 

304
00:12:19,249 --> 00:12:20,589
This is what the formulas are saying.
这就是公式所说的。 

305
00:12:20,789 --> 00:12:25,620



306
00:12:25,620 --> 00:12:28,745
How about se?s What's the formula?
 SE怎么样？公式是什么？ 

307
00:12:28,745 --> 00:12:33,302



308
00:12:33,302 --> 00:12:36,169
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

309
00:12:36,169 --> 00:12:37,189
PROFESSOR: OK.
教授：好的。 

310
00:12:37,190 --> 00:12:39,319
What are they?
这些是什么？ 

311
00:12:39,519 --> 00:12:40,545
AUDIENCE: s3.
听众：s3。 

312
00:12:40,546 --> 00:12:44,305
AUDIENCE: Yeah, sa, sb, sc.
听众：是的，sa，sb，sc。 

313
00:12:44,505 --> 00:12:45,422
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

314
00:12:45,422 --> 00:12:45,922
Aed's.
艾德的

315
00:12:45,922 --> 00:12:57,269



316
00:12:57,269 --> 00:12:58,509
PROFESSOR: And the number?
教授：还有那个？ 

317
00:12:58,509 --> 00:13:07,009
AUDIENCE: [INAUDIBLE] 3?
听众：[听不清] 3？ 

318
00:13:07,009 --> 00:13:09,509
I think.
我认为。 

319
00:13:09,509 --> 00:13:11,679
e to e.
从e到e。 

320
00:13:11,679 --> 00:13:13,681
PROFESSOR: OK.
教授：好的。 

321
00:13:13,682 --> 00:13:14,182
f.
 F。 

322
00:13:14,182 --> 00:13:17,969



323
00:13:18,169 --> 00:13:20,500
Someone that hasn't spoken today.
今天没有说话的人。 

324
00:13:20,500 --> 00:13:24,549
So that I can see that everyone gets it.
这样我就可以看到每个人都明白了。 

325
00:13:24,549 --> 00:13:26,359
Please.
请。 

326
00:13:26,360 --> 00:13:27,807
AUDIENCE: dsb--
观众：dsb-- 

327
00:13:27,807 --> 00:13:28,389
PROFESSOR: OK.
教授：好的。 

328
00:13:28,389 --> 00:13:32,539
AUDIENCE: --plus wef.
听众：-加上我们。 

329
00:13:32,539 --> 00:13:33,849
PROFESSOR: OK.
教授：好的。 

330
00:13:33,850 --> 00:13:42,029
AUDIENCE: And dsc plus wcf.
听众：还有dsc加wcf。 

331
00:13:42,029 --> 00:13:43,439
PROFESSOR: Awesome.
教授：太好了。 

332
00:13:43,440 --> 00:13:45,185
And that is--
那就是 - 

333
00:13:45,385 --> 00:13:46,256
PROFESSOR: 4.
教授：4。 

334
00:13:46,256 --> 00:13:47,839
PROFESSOR: I'll take your word for it.
教授：我会相信你的。 

335
00:13:47,840 --> 00:13:50,899



336
00:13:50,899 --> 00:13:52,459
OK, so now the last one.
好，现在是最后一个。 

337
00:13:52,460 --> 00:13:53,836
Distance from std.
与标准距离。 

338
00:13:53,836 --> 00:14:04,748



339
00:14:04,748 --> 00:14:05,250
AUDIENCE: 5.
听众：5。 

340
00:14:05,250 --> 00:14:05,639
Wait.
等待。 

341
00:14:05,639 --> 00:14:06,139
No.
没有。 

342
00:14:06,139 --> 00:14:10,240



343
00:14:10,240 --> 00:14:13,676
PROFESSOR: So, let's write a formula.
教授：那么，让我们写一个公式。 

344
00:14:13,676 --> 00:14:14,653
AUDIENCE: Oh, g, not a.
听众：哦，克，不是。 

345
00:14:14,653 --> 00:14:15,445
AUDIENCE: That's 5.
听众：5。 

346
00:14:15,445 --> 00:14:16,225
AUDIENCE: 5.
听众：5。 

347
00:14:16,225 --> 00:14:17,850
PROFESSOR: OK, so let's write a formula
教授：好的，让我们写一个公式

348
00:14:17,850 --> 00:14:19,440
to make sure that you guys are computing it
确保你们正在计算

349
00:14:19,640 --> 00:14:21,569
in the fastest possible way for me.
以最快的方式对我来说。 

350
00:14:21,570 --> 00:14:22,599
So--
所以 - 

351
00:14:22,799 --> 00:14:25,859
sd plus sd to g.
 SD加SD到g。 

352
00:14:25,860 --> 00:14:30,047



353
00:14:30,047 --> 00:14:30,629
PROFESSOR: OK.
教授：好的。 

354
00:14:30,629 --> 00:14:33,689



355
00:14:33,690 --> 00:14:34,559
Does anyone else?
还有其他人吗？ 

356
00:14:34,759 --> 00:14:36,840
Is this the only path?
这是唯一的途径吗？ 

357
00:14:36,840 --> 00:14:38,166
AUDIENCE: No.
听众：不。 

358
00:14:38,166 --> 00:14:39,570
There's more.
还有更多。 

359
00:14:39,570 --> 00:14:40,325
PROFESSOR: OK.
教授：好的。 

360
00:14:40,325 --> 00:14:42,925
AUDIENCE: Plus e as to f.
听众：对f加e。 

361
00:14:43,125 --> 00:14:45,333
PROFESSOR: Plus e as f.
教授：加e为f。 

362
00:14:45,333 --> 00:14:46,000
AUDIENCE: And n.
听众：而且。 

363
00:14:46,000 --> 00:14:47,437
AUDIENCE: c to f.
听众：c至f。 

364
00:14:47,437 --> 00:14:48,210
I mean, c to g.
我的意思是c到g。 

365
00:14:48,210 --> 00:14:50,139
Or, No. no.
或者，没有。 

366
00:14:50,139 --> 00:14:51,937
s to c.
 s到c。 

367
00:14:51,937 --> 00:14:52,519
PROFESSOR: OK.
教授：好的。 

368
00:14:52,519 --> 00:14:53,389
See, there's a trick.
看，有个把戏。 

369
00:14:53,389 --> 00:14:53,889
OK.
好。 

370
00:14:53,889 --> 00:14:54,970
Cool.
凉。 

371
00:14:54,970 --> 00:14:58,475
And then, what are the weights?
然后，权重是多少？ 

372
00:14:58,475 --> 00:15:01,200
AUDIENCE: w e to g.
听众：我们要克。 

373
00:15:01,200 --> 00:15:01,950
PROFESSOR: e to g.
教授：e至g。 

374
00:15:01,950 --> 00:15:02,449
Very good.
很好。 

375
00:15:02,649 --> 00:15:03,456
AUDIENCE: fg.
听众：fg。 

376
00:15:03,456 --> 00:15:04,039
PROFESSOR: fg.
教授：fg。 

377
00:15:04,039 --> 00:15:05,791
AUDIENCE: cg.
观众：cg。 

378
00:15:05,792 --> 00:15:06,375
PROFESSOR: cg.
教授：cg。 

379
00:15:06,375 --> 00:15:12,990



380
00:15:12,990 --> 00:15:15,797
AUDIENCE: Why are you adding in c?
听众：为什么要添加c？ 

381
00:15:15,797 --> 00:15:17,379
AUDIENCE: Because there's the extra c.
听众：因为还有多余的c。 

382
00:15:17,379 --> 00:15:18,712
AUDIENCE: Oh, I didn't see that.
听众：哦，我没看到。 

383
00:15:18,712 --> 00:15:21,250



384
00:15:21,250 --> 00:15:24,339
PROFESSOR: So, the point of this guy's, is that if you do bfs,
教授：所以，这个家伙的意思是，如果您做bfs， 

385
00:15:24,339 --> 00:15:24,929
you'll get tricked.
你会被骗的。 

386
00:15:25,129 --> 00:15:28,129



387
00:15:28,129 --> 00:15:30,730
Because bfs would put g on the same level as these.
因为bfs会将g置于与这些相同的级别。 

388
00:15:30,730 --> 00:15:32,450
And might compute the value for g
并可能计算g的值

389
00:15:32,450 --> 00:15:34,144
before it has the values for these.
在拥有这些值之前。 

390
00:15:34,144 --> 00:15:38,320



391
00:15:38,320 --> 00:15:41,449
OK, so what order do I need to compute these numbers in,
好的，所以我需要按什么顺序计算这些数字， 

392
00:15:41,649 --> 00:15:42,584
for this to work?
为了这个工作？ 

393
00:15:42,585 --> 00:15:45,964



394
00:15:45,964 --> 00:15:47,940
AUDIENCE: That way you computed them?
听众：以这种方式计算它们？ 

395
00:15:47,940 --> 00:15:53,701
PROFESSOR: So, that is a, that is a, something of the graph.
教授：因此，这就是图中的某物。 

396
00:15:53,701 --> 00:15:54,200
Yeah.
是的

397
00:15:54,200 --> 00:15:55,360
AUDIENCE: Oh, topological.
听众：哦，拓扑。 

398
00:15:55,360 --> 00:15:55,825
PROFESSOR: Yeah.
教授：是的。 

399
00:15:56,025 --> 00:15:57,099
Stole your answer.
偷了你的答案。 

400
00:15:57,100 --> 00:16:01,019



401
00:16:01,019 --> 00:16:04,710
Topological sort.
拓扑排序。 

402
00:16:04,710 --> 00:16:07,330
So, any of the topological sorts works.
因此，任何拓扑排序都可以。 

403
00:16:07,330 --> 00:16:09,599
The one we used this time is sabcdefg.
我们这次使用的是sabcdefg。 

404
00:16:09,799 --> 00:16:14,209



405
00:16:14,210 --> 00:16:17,383
Why am I using a topological sort?
为什么要使用拓扑排序？ 

406
00:16:17,383 --> 00:16:19,230
AUDIENCE: Because there's dependency.
听众：因为有依赖性。 

407
00:16:19,230 --> 00:16:20,350
PROFESSOR: Yep.
教授：是的。 

408
00:16:20,350 --> 00:16:25,700
So, this depends on this and this, right?
所以，这取决于这个，对吧？ 

409
00:16:25,700 --> 00:16:28,879
As c depends on sa, as b as c.
因为c取决于sa，所以b取决于c。 

410
00:16:28,879 --> 00:16:32,225
So basically, every edge here indicates a dependency.
因此，基本上，这里的每个边缘都表示依赖性。 

411
00:16:32,225 --> 00:16:34,600
In order to compute the shortest distance from the source
为了计算到源的最短距离

412
00:16:34,600 --> 00:16:36,359
to here, I need to know the shortest
到这里，我需要知道最短的

413
00:16:36,559 --> 00:16:38,629
distance from the source to these two.
从源到这两个的距离。 

414
00:16:38,629 --> 00:16:41,649
And then I can look at the edges.
然后我可以看看边缘。 

415
00:16:41,649 --> 00:16:43,725
So, the nice thing about a topological sort
因此，关于拓扑排序的好处

416
00:16:43,725 --> 00:16:45,850
is, after I write the vertices this way,
就是这样写完顶点之后

417
00:16:45,850 --> 00:16:48,470
all the edges point forward.
所有的边缘都指向前方。 

418
00:16:48,470 --> 00:16:50,479
Right? s to a. s to b.
对？到从s到b 

419
00:16:50,679 --> 00:16:52,284
s to c.
 s到c。 

420
00:16:52,284 --> 00:16:54,149
a to d.
从a到d。 

421
00:16:54,149 --> 00:16:55,491
a to e.
从a到e 

422
00:16:55,491 --> 00:16:57,125
b to d.
 b至d。 

423
00:16:57,125 --> 00:16:58,470
b to e.
从b到e。 

424
00:16:58,470 --> 00:16:58,970
b to f.
从b到f。 

425
00:16:58,970 --> 00:16:59,740
I can keep going.
我可以继续。 

426
00:16:59,740 --> 00:17:02,440
But the point is, there's no such thing as a backward edge.
但是关键是，没有后退之类的东西。 

427
00:17:02,440 --> 00:17:05,400



428
00:17:05,400 --> 00:17:09,138
So if I compute the numbers in this order, when I get to se,
因此，如果我按此顺序计算数字，当我得出结论时， 

429
00:17:09,338 --> 00:17:13,179
I know that I computed the distance from s to abcd.
我知道我计算了从s到abcd的距离。 

430
00:17:13,180 --> 00:17:15,799
And if I have any edge coming into e,
如果我对e有任何优势， 

431
00:17:15,799 --> 00:17:18,279
I know that I've already computed the shortest distance
我知道我已经计算出最短距离

432
00:17:18,279 --> 00:17:19,828
to the node that it is coming from.
到它来自的节点。 

433
00:17:19,828 --> 00:17:22,809



434
00:17:22,809 --> 00:17:24,108
yes?
是？ 

435
00:17:24,108 --> 00:17:24,949
Did I lose you guys?
我失去了你们吗？ 

436
00:17:24,950 --> 00:17:26,230
Was this too--
也是吗？ 

437
00:17:26,230 --> 00:17:28,750
AUDIENCE: So basically, like, at a,
听众：所以基本上，就像在

438
00:17:28,750 --> 00:17:32,559
you relaxed all the edges going out of it.
您放松了所有的边缘。 

439
00:17:32,559 --> 00:17:34,200
PROFESSOR: You can look at it that way.
教授：您可以这样看。 

440
00:17:34,200 --> 00:17:38,149
But what we're doing here is I'm looking at a node
但是我们在这里要做的是我正在查看一个节点

441
00:17:38,349 --> 00:17:41,000
and I'm relaxing all the edges coming into a node.
我正在放松进入节点的所有边缘。 

442
00:17:41,000 --> 00:17:42,027
AUDIENCE: OK.
听众：好的。 

443
00:17:42,027 --> 00:17:43,409
PROFESSOR: So this matches this order.
教授：所以这符合这个顺序。 

444
00:17:43,609 --> 00:17:44,326
AUDIENCE: OK.
听众：好的。 

445
00:17:44,326 --> 00:17:46,410
PROFESSOR: What you said doesn't match this order.
教授：您说的与这个命令不符。 

446
00:17:46,410 --> 00:17:47,710
But it's exactly the same thing.
但这是完全一样的。 

447
00:17:47,710 --> 00:17:48,029
AUDIENCE: Oh.
听众：哦。 

448
00:17:48,029 --> 00:17:49,779
PROFESSOR: It'll give you the same result.
教授：它将为您带来相同的结果。 

449
00:17:49,779 --> 00:17:52,789
AUDIENCE: You'd get the first value at g when you reach c.
听众：达到c时，您将在g处获得第一个值。 

450
00:17:52,789 --> 00:17:54,565
But, like, end up with the same answer.
但是，最终得到相同的答案。 

451
00:17:54,565 --> 00:17:55,190
PROFESSOR: Yep.
教授：是的。 

452
00:17:55,190 --> 00:17:58,709
AUDIENCE: We're still going backwards then, instead of--
听众：那时我们仍然倒退，而不是- 

453
00:17:58,709 --> 00:18:00,750
PROFESSOR: As long as you're processing the nodes
教授：只要您正在处理节点

454
00:18:00,750 --> 00:18:04,009
in the topological sort order, all the algorithms
按照拓扑排序顺序，所有算法

455
00:18:04,009 --> 00:18:06,190
will work because you're just computing
可以工作，因为您只是在计算

456
00:18:06,190 --> 00:18:07,880
these terms in a different order.
这些术语以不同的顺序排列。 

457
00:18:07,880 --> 00:18:10,450
But as long as the dependencies are satisfied,
但是只要满足依赖关系

458
00:18:10,450 --> 00:18:14,129
you're still going to get the right thing.
您仍然会得到正确的东西。 

459
00:18:14,329 --> 00:18:17,078
OK, so what's the running time of this?
好的，那么这是什么时间？ 

460
00:18:17,078 --> 00:18:18,619
How many people know the running time
有多少人知道跑步时间

461
00:18:18,619 --> 00:18:24,029
without having to write pseudocode for this?
不必为此编写伪代码？ 

462
00:18:24,029 --> 00:18:26,600
I know the answer beforehand, so I cheated, obviously.
我事先知道答案，所以很明显我被骗了。 

463
00:18:26,601 --> 00:18:26,899
OK.
好。 

464
00:18:27,099 --> 00:18:28,569
AUDIENCE: Is it a?
听众：是吗？ 

465
00:18:28,569 --> 00:18:29,599
[INAUDIBLE] edges.
 [听不清]边缘。 

466
00:18:29,599 --> 00:18:30,349
PROFESSOR: Almost.
教授：差不多了。 

467
00:18:30,349 --> 00:18:30,980
Very close.
很接近。 

468
00:18:30,980 --> 00:18:31,814
[INTERPOSING VOICES]
 [插入语音] 

469
00:18:31,814 --> 00:18:38,750



470
00:18:38,750 --> 00:18:40,250
PROFESSOR: So, it's the topological.
教授：这就是拓扑。 

471
00:18:40,250 --> 00:18:42,099
So, running time plus the running time
因此，运行时间加上运行时间

472
00:18:42,099 --> 00:18:43,109
for evaluating this.
对此进行评估。 

473
00:18:43,109 --> 00:18:45,740
The running time for evaluating this is v plus e because you
评估它的运行时间是v加e，因为您

474
00:18:45,740 --> 00:18:49,200
have every h shows up exactly once in here.
每个h都只在这里出现一次。 

475
00:18:49,200 --> 00:18:50,509
So you have e terms.
所以你有e条款。 

476
00:18:50,509 --> 00:18:53,129
And you have v vertices, even if you don't have any edge,
而且您有v个顶点，即使您没有任何边缘， 

477
00:18:53,130 --> 00:18:55,160
you have to initialize the verdicts.
您必须初始化判决。 

478
00:18:55,160 --> 00:18:57,272
So that's why it's v plus e.
这就是为什么它是v加e的原因。 

479
00:18:57,472 --> 00:19:00,629
AUDIENCE: It's also topological sort.
听众：这也是拓扑排序。 

480
00:19:00,630 --> 00:19:04,149
PROFESSOR: So, this is the order in which we process this.
教授：因此，这就是我们处理该问题的顺序。 

481
00:19:04,349 --> 00:19:06,849
So everything is v plus e.
所以一切都是v加e。 

482
00:19:06,849 --> 00:19:09,740
If we use this algorithm to solve this problem,
如果我们使用这种算法来解决这个问题， 

483
00:19:09,740 --> 00:19:11,317
what will the running time be?
运行时间是多少？ 

484
00:19:11,317 --> 00:19:14,375



485
00:19:14,375 --> 00:19:15,480
AUDIENCE: n.
听众： 

486
00:19:15,480 --> 00:19:16,970
AUDIENCE: n squared.
听众：n平方。 

487
00:19:16,970 --> 00:19:17,845
AUDIENCE: It's an no.
听众：不可以。 

488
00:19:17,845 --> 00:19:21,319
PROFESSOR: So, it's v prime plus u prime, which
教授：所以，是v素数加上u素数， 

489
00:19:21,319 --> 00:19:31,809
is n squared plus [INAUDIBLE] squared, which is n squared.
是n平方加[音频不清]平方，即n平方。 

490
00:19:31,809 --> 00:19:34,839
So, by observing that this graph is acyclic,
因此，通过观察该图是非循环的， 

491
00:19:34,839 --> 00:19:38,409
we have a better running time than Bellman-Ford.
我们的运行时间比Bellman-Ford更好。 

492
00:19:38,410 --> 00:19:41,200
Even though we used exactly the same intuition
即使我们使用了完全相同的直觉

493
00:19:41,200 --> 00:19:42,400
that we used up until now.
直到现在我们都用光了。 

494
00:19:42,400 --> 00:19:44,019
Model the problem as a graph.
将问题建模为图形。 

495
00:19:44,019 --> 00:19:46,039
Figure out what the edges are.
弄清楚边缘是什么。 

496
00:19:46,039 --> 00:19:47,980
Run a shortest path algorithm.
运行最短路径算法。 

497
00:19:47,980 --> 00:19:49,900
We have a better shortest path algorithm,
我们有一个更好的最短路径算法， 

498
00:19:49,900 --> 00:19:51,940
which works for Directed Acyclic Graphs,
适用于有向无环图， 

499
00:19:51,940 --> 00:19:53,809
so we get a better running time.
这样我们可以获得更好的运行时间。 

500
00:19:53,809 --> 00:19:56,589



501
00:19:56,589 --> 00:19:58,589
OK, questions for what we did so far?
好，对我们到目前为止所做的事情有疑问吗？ 

502
00:19:58,589 --> 00:20:02,470



503
00:20:02,470 --> 00:20:06,159
AUDIENCE: It's [INAUDIBLE] on this graph here,
观众：这是这张图上的[音频不清晰]， 

504
00:20:06,359 --> 00:20:08,559
then you would do the same thing.
那么您将做同样的事情。 

505
00:20:08,559 --> 00:20:11,579
Take each node and then relax the incoming edges.
取每个节点，然后放宽传入的边缘。 

506
00:20:11,579 --> 00:20:15,299



507
00:20:15,299 --> 00:20:16,700
PROFESSOR: Yeah.
教授：是的。 

508
00:20:16,700 --> 00:20:19,288
So what is the topological sort of this?
那么，这种拓扑是什么呢？ 

509
00:20:19,288 --> 00:20:21,000
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

510
00:20:21,000 --> 00:20:23,000
PROFESSOR: It's exactly the cards in the order
教授：这正是订单中的卡片

511
00:20:23,000 --> 00:20:25,740
that they're on the board, right?
他们是董事会成员，对吗？ 

512
00:20:25,740 --> 00:20:30,049
So, in dynamic programming, the topological sort order
因此，在动态编程中，拓扑排序顺序

513
00:20:30,049 --> 00:20:31,690
is obvious.
很明显。 

514
00:20:31,690 --> 00:20:33,759
So the hard part is representing the state
所以最困难的部分是代表状态

515
00:20:33,759 --> 00:20:35,730
and figuring out what the dependencies are.
并找出依赖项是什么。 

516
00:20:35,730 --> 00:20:36,700
So what the edges are.
那么边缘是什么。 

517
00:20:36,700 --> 00:20:39,328
And after that, the topological sort usually comes,
然后，通常会出现拓扑排序

518
00:20:39,328 --> 00:20:40,494
it's fairly straightforward.
这很简单。 

519
00:20:40,494 --> 00:20:44,369



520
00:20:44,369 --> 00:20:47,909
OK, so what we can do now, we have a few directions
好，所以我们现在可以做的，我们有几个指示

521
00:20:47,910 --> 00:20:49,239
in which we can go.
在其中我们可以去。 

522
00:20:49,239 --> 00:20:50,779
We can write the pseudocode for this.
我们可以为此编写伪代码。 

523
00:20:50,779 --> 00:20:56,250



524
00:20:56,250 --> 00:21:00,099
I mean, it's basically, it's just,
我的意思是，基本上就是

525
00:21:00,099 --> 00:21:02,899
we're going to write abstract things instead of this.
我们将写抽象的东西代替这个。 

526
00:21:02,900 --> 00:21:06,240
So we're going to write one piece of pseudocode that
所以我们要编写一段伪代码

527
00:21:06,240 --> 00:21:07,500
evaluates these.
评估这些。 

528
00:21:07,500 --> 00:21:12,470
So it's just generalizing this thing.
因此，只是概括了这一点。 

529
00:21:12,470 --> 00:21:14,420
Something else we can do is we can
我们可以做的其他事情就是

530
00:21:14,420 --> 00:21:18,789
look at how would these things get computed using memoization?
看看如何使用记忆来计算这些东西？ 

531
00:21:18,789 --> 00:21:24,029



532
00:21:24,029 --> 00:21:28,214
We can look at how we would compute shortest path in graphs
我们可以看看如何计算图中的最短路径

533
00:21:28,214 --> 00:21:29,269
with cycles.
与周期。 

534
00:21:29,269 --> 00:21:30,960
So this assumes we have a DAG.
因此，这假设我们有DAG。 

535
00:21:30,960 --> 00:21:31,920
What if we have cycles?
如果我们有周期怎么办？ 

536
00:21:31,920 --> 00:21:34,359
How do we deal with them?
我们如何处理它们？ 

537
00:21:34,559 --> 00:21:38,379
Or we can do another DP problem, and see how we'd model that.
或者，我们可以做另一个DP问题，然后看看如何建模。 

538
00:21:38,380 --> 00:21:43,220



539
00:21:43,220 --> 00:21:45,160
So, votes?
那么，选票？ 

540
00:21:45,160 --> 00:21:46,389
What do people want to see?
人们想看什么？ 

541
00:21:46,589 --> 00:21:49,419
I think we might have time for two things, out of these four.
我认为我们可能有时间去做四件事中的两件事。 

542
00:21:49,420 --> 00:21:51,159
So, everyone votes for one.
因此，每个人都投一票。 

543
00:21:51,359 --> 00:21:52,490
And we'll start with that.
我们将从此开始。 

544
00:21:52,490 --> 00:21:53,442
Sorry?
抱歉？ 

545
00:21:53,442 --> 00:21:55,161
AUDIENCE: DP problem.
听众：DP问题。 

546
00:21:55,161 --> 00:21:56,910
PROFESSOR: OK, so one vote for DP problem.
教授：好的，所以对DP问题投一票。 

547
00:21:56,910 --> 00:21:59,019
AUDIENCE: Yeah.
听众：是的。 

548
00:21:59,019 --> 00:21:59,831
PROFESSOR: OK.
教授：好的。 

549
00:21:59,832 --> 00:22:00,339
AUDIENCE: Cyclic.
听众：循环的。 

550
00:22:00,539 --> 00:22:04,017



551
00:22:04,017 --> 00:22:05,524
AUDIENCE: Wait, you got two or one votes?
听众：等等，你有两票还是一票？ 

552
00:22:05,724 --> 00:22:06,439
PROFESSOR: One vote.
教授：一票。 

553
00:22:06,440 --> 00:22:06,690
AUDIENCE: OK.
听众：好的。 

554
00:22:06,690 --> 00:22:07,190
I'll DP.
我去DP 

555
00:22:07,190 --> 00:22:10,576
AUDIENCE: I'll stick with [INAUDIBLE].
听众：我会坚持[听不清]。 

556
00:22:10,576 --> 00:22:12,990
AUDIENCE: DP.
听众：DP。 

557
00:22:12,990 --> 00:22:14,810
PROFESSOR: I think we're done here.
教授：我想我们已经完成了。 

558
00:22:14,810 --> 00:22:15,309
All right.
好吧。 

559
00:22:15,309 --> 00:22:16,369
So, new DP problem.
因此，新的DP问题。 

560
00:22:16,369 --> 00:22:19,829



561
00:22:19,829 --> 00:22:22,759
So, suppose you have something like Manhattan's map, which
因此，假设您有类似曼哈顿的地图， 

562
00:22:22,759 --> 00:22:26,210
is basically a lattice.
基本上是一个格子。 

563
00:22:26,210 --> 00:22:28,829
Fancy math term for a grid.
网格的花式数学术语。 

564
00:22:28,829 --> 00:22:36,970



565
00:22:36,970 --> 00:22:41,085
And suppose it we can only go forward and down.
并假设我们只能前进和后退。 

566
00:22:41,085 --> 00:22:43,639



567
00:22:43,839 --> 00:22:46,089
So, all the streets are one way because they
所以，所有街道都是一种方式，因为它们

568
00:22:46,089 --> 00:22:48,419
liked how people drive in San Francisco,
喜欢人们在旧金山开车的方式， 

569
00:22:48,420 --> 00:22:50,545
and decided they're going to do the same craziness.
并决定他们将做同样的疯狂。 

570
00:22:50,545 --> 00:23:04,119



571
00:23:04,319 --> 00:23:08,519
So, we want to go from s to t.
因此，我们想从s转到t。 

572
00:23:08,519 --> 00:23:14,589
And there are different cost on all these edges.
所有这些优势都有不同的成本。 

573
00:23:14,589 --> 00:23:18,449
This is an n by m matrix.
这是一个n×m矩阵。 

574
00:23:18,450 --> 00:23:24,660
And I want to get from s to t in the shortest possible way.
我想以最短的时间从s到t。 

575
00:23:24,660 --> 00:23:27,420
So, let's model the problem.
因此，让我们对问题进行建模。 

576
00:23:27,420 --> 00:23:30,784
And then let's do recursion formulas
然后让我们做递归公式

577
00:23:30,784 --> 00:23:33,200
and make it look like a DP instead of like a graph problem
并使它看起来像DP，而不是图问题

578
00:23:33,200 --> 00:23:35,220
because-- it might be too easy of a graph
因为-绘制图形可能太容易了

579
00:23:35,220 --> 00:23:37,396
problem in hindsight.
后见之明。 

580
00:23:37,396 --> 00:23:38,730
OK, so what's the graph problem?
好，那么图形问题是什么？ 

581
00:23:38,730 --> 00:23:41,134
AUDIENCE: It's not equivalent.
听众：这不是对等的。 

582
00:23:41,134 --> 00:23:42,259
AUDIENCE: Topological sort.
听众：拓扑排序。 

583
00:23:42,259 --> 00:23:44,646
And then bfs.
然后是bfs。 

584
00:23:44,646 --> 00:23:45,230
PROFESSOR: OK.
教授：好的。 

585
00:23:45,230 --> 00:23:46,180
Topological sort.
拓扑排序。 

586
00:23:46,180 --> 00:23:50,139
And then, and then that.
然后，然后那个。 

587
00:23:50,339 --> 00:23:53,529
Well, let's write this as, let's say
好吧，让我们这样写

588
00:23:53,529 --> 00:23:57,889
that each node is so let's say that the nodes have numbers,
假设每个节点都有数字， 

589
00:23:57,890 --> 00:23:58,390
right?
对？ 

590
00:23:58,390 --> 00:24:03,980
So this is 1,1 and this is 5,4.
所以这是1,1，这是5,4。 

591
00:24:03,980 --> 00:24:07,566
And I want to write this using math, so 2,1.
我想用数学写这个，所以2,1。 

592
00:24:07,566 --> 00:24:09,470
3,1.
 3,1。 

593
00:24:09,470 --> 00:24:10,697
4,1.
 4,1。 

594
00:24:10,897 --> 00:24:13,599
5,1.
 5,1。 

595
00:24:13,599 --> 00:24:16,419
And then, 1,2.
然后是1,2。 

596
00:24:16,420 --> 00:24:18,575
1,3.
 1,3。 

597
00:24:18,575 --> 00:24:21,440
1,4.
 1,4。 

598
00:24:21,440 --> 00:24:23,170
OK, so this is the graph.
好，这是图形。 

599
00:24:23,170 --> 00:24:26,019
The shortest path from here to here is obvious.
从这里到这里的最短路径是显而易见的。 

600
00:24:26,019 --> 00:24:27,516
By the way, this is a real problem
顺便说一句，这是一个真正的问题

601
00:24:27,516 --> 00:24:29,140
for people who don't see the connection
对于看不到联系的人

602
00:24:29,140 --> 00:24:31,950
between dynamic programming and graphs.
在动态编程和图形之间。 

603
00:24:31,950 --> 00:24:34,900
I This problem has tripped up people on exams before.
我这个问题以前使人们跳入考试。 

604
00:24:34,900 --> 00:24:36,119
So it's not a toy problem.
因此，这不是玩具问题。 

605
00:24:36,319 --> 00:24:38,914



606
00:24:38,914 --> 00:24:39,414
OK.
好。 

607
00:24:39,414 --> 00:24:40,980
AUDIENCE: So, on an examine, would you
听众：那么，从考核上，你会

608
00:24:40,980 --> 00:24:43,289
have the option of just using a straight up graph algorithm--
可以选择仅使用向上图算法- 

609
00:24:43,289 --> 00:24:45,409
PROFESSOR: Well, we're going to ask you to solve this using DP.
教授：好吧，我们要请您使用DP解决此问题。 

610
00:24:45,410 --> 00:24:48,380
So let's try to solve this using dynamic programming by writing
因此，让我们尝试通过编写动态编程来解决此问题

611
00:24:48,380 --> 00:24:50,430
recursion formulas.
递归公式。 

612
00:24:50,430 --> 00:24:58,389
So, what's the shortest distance to 1,1.
因此，到1,1的最短距离是多少。 

613
00:24:58,589 --> 00:25:01,156
AUDIENCE: 0.
听众：0。 

614
00:25:01,156 --> 00:25:01,990
PROFESSOR: OK, then.
教授：那好。 

615
00:25:01,990 --> 00:25:06,390
If I have a general distance, if I have some random node here,
如果我有一般距离，如果我在这里有一些随机节点， 

616
00:25:06,390 --> 00:25:09,478
dij, how do I compute this?
 dij，我该如何计算？ 

617
00:25:09,478 --> 00:25:11,430
AUDIENCE: It's a minimum distance
听众：这是最小距离

618
00:25:11,430 --> 00:25:15,109
between the distance of law plus weights.
距离与重量之间的距离。 

619
00:25:15,309 --> 00:25:17,789
AUDIENCE: Or the distance of j.
听众：或j的距离。 

620
00:25:17,789 --> 00:25:19,307
i minus one.
我减一。 

621
00:25:19,307 --> 00:25:19,806
Yeah.
是的

622
00:25:19,806 --> 00:25:22,690



623
00:25:22,690 --> 00:25:23,899
PROFESSOR: So, i minus 1 j.
教授：所以我减去1 j。 

624
00:25:24,099 --> 00:25:25,269
AUDIENCE: Yeah.
听众：是的。 

625
00:25:25,269 --> 00:25:27,379
We get it.
我们知道了。 

626
00:25:27,380 --> 00:25:32,444
Plus the weight of the, yeah.
再加上重量，是的。 

627
00:25:32,644 --> 00:25:35,307
AUDIENCE: Going from one to the other.
听众：从一个到另一个。 

628
00:25:35,307 --> 00:25:40,379
PROFESSOR: OK, so the weight from i minus 1 j to ij.
教授：好的，所以权重从i减去1 j到ij。 

629
00:25:40,380 --> 00:25:41,440
OK.
好。 

630
00:25:41,440 --> 00:25:42,490
And?
和？ 

631
00:25:42,490 --> 00:25:45,000
AUDIENCE: j minus 1i.
听众：j减去1i。 

632
00:25:45,000 --> 00:25:49,029
For i, j minus 1.
对于i，j减1。 

633
00:25:49,029 --> 00:25:52,494
PROFESSOR: ij minus 1.
教授：ij减1。 

634
00:25:52,494 --> 00:25:58,183
AUDIENCE: Plus weight of that ij.
听众：加上那个ij的权重。 

635
00:25:58,183 --> 00:26:01,537
ij minus j1 to ij.
 ij减去j1到ij。 

636
00:26:01,537 --> 00:26:04,900
ij [INAUDIBLE]
 ij [听不清] 

637
00:26:04,900 --> 00:26:05,903
PROFESSOR: OK.
教授：好的。 

638
00:26:05,903 --> 00:26:07,069
So these are the recursions.
这些就是递归。 

639
00:26:07,069 --> 00:26:10,450
Now, how would I write the full set of code for this?
现在，我将如何为此编写完整的代码集？ 

640
00:26:10,450 --> 00:26:15,712
So what's a valid topological sort for these guys?
那么，对于这些人来说，什么是有效的拓扑排序？ 

641
00:26:15,712 --> 00:26:16,296
AUDIENCE: 1,1.
听众：1,1。 

642
00:26:16,296 --> 00:26:16,796
2,1.
 2，1。 

643
00:26:16,796 --> 00:26:18,220
3,1.
 3,1。 

644
00:26:18,220 --> 00:26:19,182
AUDIENCE: Dials.
听众：拨号。 

645
00:26:19,182 --> 00:26:20,144
AUDIENCE: 1,2.
观众：1,2。 

646
00:26:20,144 --> 00:26:22,549
AUDIENCE: The right dials.
听众：右拨盘。 

647
00:26:22,549 --> 00:26:25,269
PROFESSOR: That's going to be hard to code.
教授：这将很难编码。 

648
00:26:25,269 --> 00:26:26,734
That's going to be easy to code.
这将很容易编码。 

649
00:26:26,734 --> 00:26:28,109
So I'm going to take your answer.
因此，我将接受您的回答。 

650
00:26:28,109 --> 00:26:28,424
AUDIENCE: OK.
听众：好的。 

651
00:26:28,424 --> 00:26:28,740
AUDIENCE: What?
听众：什么？ 

652
00:26:28,740 --> 00:26:30,420
PROFESSOR: I'm not going to take your answer because your answer
教授：我不会接你的答案，因为你的答案

653
00:26:30,420 --> 00:26:31,947
is correct, but it's hard to code.
是正确的，但是很难编写代码。 

654
00:26:32,147 --> 00:26:34,589
AUDIENCE: But isn't that the same thing [INAUDIBLE]?
听众：但是[听不清]这不是一回事吗？ 

655
00:26:34,589 --> 00:26:36,079
PROFESSOR: She says, go like this.
教授：她说，去吧。 

656
00:26:36,079 --> 00:26:36,620
AUDIENCE: Oh.
听众：哦。 

657
00:26:36,621 --> 00:26:37,419
Oh.
哦。 

658
00:26:37,619 --> 00:26:39,849
PROFESSOR: So, here's how I'm going to code them.
教授：所以，这就是我要编码的方式。 

659
00:26:39,849 --> 00:26:45,745
4i in 1,2n.
 1,2n中的4i。 

660
00:26:45,746 --> 00:26:50,494
4j in 1 to m.
 4j in 1至m 

661
00:26:50,694 --> 00:26:53,359



662
00:26:53,359 --> 00:27:01,259
So, I guess, first off, if i is 1 and j is 1, then d of ij
所以，我想，首先，如果i为1且j为1，则ij的d 

663
00:27:01,259 --> 00:27:02,019
is 0, right?
是0，对吗？ 

664
00:27:02,019 --> 00:27:05,490
This is the base case.
这是基本情况。 

665
00:27:05,490 --> 00:27:12,140
Otherwise, d of ij equals big bad formula
否则，ij的d等于大坏公式

666
00:27:12,140 --> 00:27:12,869
that we have up there.
我们在那里。 

667
00:27:13,069 --> 00:27:17,289



668
00:27:17,289 --> 00:27:17,789
OK.
好。 

669
00:27:17,789 --> 00:27:20,029
Do we need anything else?
我们还需要其他东西吗？ 

670
00:27:20,029 --> 00:27:21,463
AUDIENCE: DP.
听众：DP。 

671
00:27:21,463 --> 00:27:22,379
PROFESSOR: This is DP.
教授：这是DP。 

672
00:27:22,380 --> 00:27:22,743
We're done.
大功告成

673
00:27:22,943 --> 00:27:23,609
AUDIENCE: Is it?
听众：是吗？ 

674
00:27:23,609 --> 00:27:24,219
PROFESSOR: Almost work.
教授：差不多可以了。 

675
00:27:24,220 --> 00:27:24,659
Yeah, this is--
是的，这是- 

676
00:27:24,859 --> 00:27:25,629
AUDIENCE: Over [INAUDIBLE]--
听众：超过[听不清]- 

677
00:27:25,630 --> 00:27:26,826
AUDIENCE: I thought this was just programming.
听众：我以为这只是编程。 

678
00:27:26,826 --> 00:27:27,309
AUDIENCE: --it's a dictionary, though.
听众：-这是一本字典。 

679
00:27:27,309 --> 00:27:27,909
PROFESSOR: Yeah.
教授：是的。 

680
00:27:27,910 --> 00:27:28,400
It's programming.
它正在编程。 

681
00:27:28,400 --> 00:27:30,079
So this is the DP solution to the program
这是该程序的DP解决方案

682
00:27:30,279 --> 00:27:32,399
because, instead of building the graph,
因为，与其建立图表， 

683
00:27:32,400 --> 00:27:34,410
you're writing the recursion.
您正在编写递归。 

684
00:27:34,410 --> 00:27:37,859
And you're writing using this implicit representation
您正在使用此隐式表示形式进行编写

685
00:27:38,059 --> 00:27:40,283
of the graph.
图的

686
00:27:40,284 --> 00:27:41,844
AUDIENCE: Oh.
听众：哦。 

687
00:27:41,844 --> 00:27:42,759
PROFESSOR: This is it.
教授：就是这样。 

688
00:27:42,759 --> 00:27:44,440
This is DP.
这是DP。 

689
00:27:44,440 --> 00:27:45,940
Most people are really afraid of it.
大多数人真的很害怕。 

690
00:27:45,940 --> 00:27:47,159
This is the hardest thing in the course.
这是课程中最难的事情。 

691
00:27:47,359 --> 00:27:49,442
If you get the connection between graphs and this,
如果您获得图与图之间的联系， 

692
00:27:49,442 --> 00:27:51,317
and if you know how to model graphs, that it.
如果您知道如何为图形建模，那就可以了。 

693
00:27:51,317 --> 00:27:52,817
You're one month in the term, you're
你任期一个月，你

694
00:27:52,817 --> 00:27:53,960
done with six double six.
用六双六完成。 

695
00:27:53,960 --> 00:27:57,130
You already know everything to ace the exam.
您已经掌握了考试的所有条件。 

696
00:27:57,130 --> 00:27:57,630
OK.
好。 

697
00:27:57,630 --> 00:27:59,512
AUDIENCE: Aren't graphs just programming, as well?
听众：不仅是图形，还是编程？ 

698
00:27:59,712 --> 00:28:01,466



699
00:28:01,467 --> 00:28:01,849
PROFESSOR: Ah.
教授：嗯。 

700
00:28:02,049 --> 00:28:03,924
But there, you're building a graph structure.
但是在那里，您正在构建一个图形结构。 

701
00:28:03,924 --> 00:28:05,829
Here, we don't need to build that structure.
在这里，我们不需要构建该结构。 

702
00:28:05,829 --> 00:28:07,453
Because we see the connection directly.
因为我们直接看到了连接。 

703
00:28:07,453 --> 00:28:09,740
Like, this code is much smaller, right?
就像，这段代码要小得多，对吧？ 

704
00:28:09,740 --> 00:28:12,057
It's much easier to look at.
它看起来容易得多。 

705
00:28:12,057 --> 00:28:12,640
I mean, sorry.
我是说对不起

706
00:28:12,640 --> 00:28:13,851
It's faster to read.
阅读起来更快。 

707
00:28:13,851 --> 00:28:15,149
But it looks like black magic if you
但是如果你看起来像黑魔法

708
00:28:15,349 --> 00:28:18,840
don't see the underlying graph.
没有看到基础图。 

709
00:28:18,840 --> 00:28:19,339
Yes?
是？ 

710
00:28:19,339 --> 00:28:20,109
Did you have a question?
你有问题吗

711
00:28:20,109 --> 00:28:20,900
AUDIENCE: Yeah, so.
听众：是的。 

712
00:28:20,901 --> 00:28:22,919
What exactly is dynamic programming?
什么是动态编程？ 

713
00:28:23,119 --> 00:28:27,810
Unless they give at least one or two examples of,
除非他们至少给出一个或两个例子， 

714
00:28:27,810 --> 00:28:31,788
like, using something that you had calculated already, or--
例如，使用您已经计算过的内容，或者- 

715
00:28:31,788 --> 00:28:32,454
PROFESSOR: Yeah.
教授：是的。 

716
00:28:32,454 --> 00:28:33,370
AUDIENCE: --Fibinocci.
听众：--Fibinocci。 

717
00:28:33,371 --> 00:28:33,871
So.
所以。 

718
00:28:33,871 --> 00:28:34,537
PROFESSOR: Yeah.
教授：是的。 

719
00:28:34,537 --> 00:28:35,039
So--
所以 - 

720
00:28:35,039 --> 00:28:35,819
AUDIENCE: Ah, so now you just have
听众：啊，所以现在你只有

721
00:28:35,819 --> 00:28:38,016
to have a dictionary to store the minimum cost.
有字典来存储最低费用。 

722
00:28:38,017 --> 00:28:39,274
AUDIENCE: That's what d is, though.
听众：不过，这就是d。 

723
00:28:39,474 --> 00:28:40,304
The d of ij.
 ij的d。 

724
00:28:40,305 --> 00:28:40,930
AUDIENCE: Wait.
听众：等等。 

725
00:28:40,930 --> 00:28:41,899
PROFESSOR: So.
教授：是的。 

726
00:28:42,099 --> 00:28:43,339
So I like your question.
所以我喜欢你的问题。 

727
00:28:43,339 --> 00:28:45,613
And I'm going to address all the other ones first.
我将首先解决所有其他问题。 

728
00:28:45,614 --> 00:28:47,529
And then I'm going to spend about five minutes
然后我要花大约五分钟

729
00:28:47,529 --> 00:28:48,599
addressing your question.
解决您的问题。 

730
00:28:48,599 --> 00:28:51,459
What is dynamic programming, right?
什么是动态编程，对吗？ 

731
00:28:51,460 --> 00:28:52,670
What is the point of this?
这有什么意义呢？ 

732
00:28:52,670 --> 00:29:00,769
Like, what is dynamic programming?
就像什么是动态编程？ 

733
00:29:00,769 --> 00:29:02,759
We're going to come back to this.
我们将回到这一点。 

734
00:29:02,759 --> 00:29:05,685
So any questions about this?
那么对此有任何疑问吗？ 

735
00:29:05,685 --> 00:29:06,309
AUDIENCE: Wait.
听众：等等。 

736
00:29:06,309 --> 00:29:07,350
As you're going through--
当您经历- 

737
00:29:07,351 --> 00:29:10,000
AUDIENCE: Is there a dictionary?
听众：有字典吗？ 

738
00:29:10,000 --> 00:29:11,319
PROFESSOR: Sure.
教授：当然可以。 

739
00:29:11,319 --> 00:29:12,039
This is an array.
这是一个数组。 

740
00:29:12,039 --> 00:29:13,579
Or dictionary.
或字典。 

741
00:29:13,579 --> 00:29:16,627
So, say this is ij.
所以，说这是ij。 

742
00:29:16,627 --> 00:29:18,429
If it's an array, or if it's a dictionary,
如果是数组或字典， 

743
00:29:18,430 --> 00:29:21,210
it would be d of the tuple ij.
这将是元组ij的d。 

744
00:29:21,210 --> 00:29:24,809



745
00:29:24,809 --> 00:29:27,159
So, I can write this in Python, right?
所以，我可以用Python编写，对吧？ 

746
00:29:27,160 --> 00:29:30,140
This is almost Python.
这几乎是Python。 

747
00:29:30,140 --> 00:29:32,084
What am I missing?
我想念什么？ 

748
00:29:32,084 --> 00:29:34,794
AUDIENCE: [INAUDIBLE], or it fits inside.
观众：[听不清]，或适合里面。 

749
00:29:34,994 --> 00:29:35,619
PROFESSOR: Yes.
教授：是的。 

750
00:29:35,619 --> 00:29:37,410
So, I have some boundary conditions, right?
所以，我有一些边界条件，对吗？ 

751
00:29:37,411 --> 00:29:40,755
Because this guy would depend on this guy, which is inside.
因为这个家伙要依靠里面的那个家伙。 

752
00:29:40,755 --> 00:29:42,910
And left to depend on this guy.
并依靠这个家伙。 

753
00:29:42,910 --> 00:29:45,128
Which doesn't exist.
不存在。 

754
00:29:45,328 --> 00:29:45,869
AUDIENCE: Oh.
听众：哦。 

755
00:29:45,869 --> 00:29:46,765
I wasn't-- OK.
我不是-好吧。 

756
00:29:46,766 --> 00:29:47,388
Sure.
当然。 

757
00:29:47,588 --> 00:29:49,379
PROFESSOR: So, we need a few more ifs here,
教授：所以，我们在这里还需要一些其他信息， 

758
00:29:49,380 --> 00:29:50,178
for boundary conditions.
边界条件。 

759
00:29:50,378 --> 00:29:58,593



760
00:29:58,594 --> 00:30:02,139
AUDIENCE: I mean, in theory, though, you could just
听众：我是说，从理论上讲，你可以

761
00:30:02,339 --> 00:30:04,341
run through the new dfs and create
运行新的dfs并创建

762
00:30:04,342 --> 00:30:05,919
a topological of the source.
源的拓扑。 

763
00:30:06,119 --> 00:30:06,619
Right?
对？ 

764
00:30:06,619 --> 00:30:07,869
And just run through that.
并通过运行。 

765
00:30:07,869 --> 00:30:08,009
PROFESSOR: Yeah.
教授：是的。 

766
00:30:08,009 --> 00:30:09,390
But that's so much code to write.
但是，要编写的代码太多了。 

767
00:30:09,390 --> 00:30:09,889
Look at this.
看这个。 

768
00:30:10,089 --> 00:30:11,039
This is five lines.
这是五行。 

769
00:30:11,039 --> 00:30:11,659
AUDIENCE: Well, yeah.
听众：是的。 

770
00:30:11,660 --> 00:30:13,519
For this particular problem, it's five lines.
对于这个特定的问题，有五行内容。 

771
00:30:13,519 --> 00:30:15,228
PROFESSOR: Well, for dynamic programming,
教授：对于动态编程， 

772
00:30:15,228 --> 00:30:17,649
the solutions are 5 to 10 lines in general.
解决方案通常为5至10条生产线。 

773
00:30:17,849 --> 00:30:20,750
And the only hard thing in dynamic programming
而动态编程中唯一困难的事情

774
00:30:20,750 --> 00:30:24,276
is figuring out what is the state going to be.
正在弄清楚状态将是什么。 

775
00:30:24,276 --> 00:30:26,650
So, after you get used to them, after you solve 10 or 20,
因此，当您习惯了它们之后，您解决了10或20个问题之后， 

776
00:30:26,650 --> 00:30:28,660
when people come out of programming contests,
当人们退出编程竞赛时， 

777
00:30:28,660 --> 00:30:31,240
and someone says, my solution's dynamic programming.
有人说，我的解决方案是动态编程。 

778
00:30:31,240 --> 00:30:31,740
Really?
真？ 

779
00:30:31,740 --> 00:30:33,073
Wait, you can solve it that way.
等等，您可以通过这种方式解决。 

780
00:30:33,073 --> 00:30:33,629
And he says, yeah.
他说，是的。 

781
00:30:33,829 --> 00:30:34,579
This is the state.
这是状态。 

782
00:30:34,579 --> 00:30:36,081
And then everything else is obvious.
然后其他所有事情都是显而易见的。 

783
00:30:36,082 --> 00:30:38,089
Like, it's pretty easy to figure out everything else.
就像，找出其他所有内容很容易。 

784
00:30:38,289 --> 00:30:39,428
The hard part is the state.
困难的部分是状态。 

785
00:30:39,429 --> 00:30:40,970
So, it's enough to say my solution is
因此，足以说明我的解决方案是

786
00:30:40,970 --> 00:30:41,803
dynamic programming.
动态编程。 

787
00:30:41,803 --> 00:30:42,541
This is my state.
这是我的状态。 

788
00:30:42,741 --> 00:30:44,200
You guys are probably going to have
你们可能会有

789
00:30:44,200 --> 00:30:46,142
to say a bit more than that on the exam.
说的比考试还多。 

790
00:30:46,142 --> 00:30:47,630
But this is the hard part.
但这是困难的部分。 

791
00:30:47,630 --> 00:30:49,199
AUDIENCE: DP.
听众：DP。 

792
00:30:49,199 --> 00:30:50,740
PROFESSOR: No, you can't just say DP.
教授：不，您不能只说DP。 

793
00:30:50,740 --> 00:30:52,405
You'll definitely need at least a state.
您肯定至少需要一个状态。 

794
00:30:52,405 --> 00:30:56,819



795
00:30:56,819 --> 00:30:57,579
OK.
好。 

796
00:30:57,579 --> 00:30:58,079
So.
所以。 

797
00:30:58,079 --> 00:30:59,620
AUDIENCE: You're also missing a state
听众：您还缺少状态

798
00:30:59,621 --> 00:31:02,101
for deciding stuff in the dictionary, though, right?
决定字典中的内容，对吗？ 

799
00:31:02,301 --> 00:31:04,259
PROFESSOR: Before deciding if my key is already
教授：在确定我的钥匙是否已经存在之前

800
00:31:04,259 --> 00:31:05,879
in the dictionary?
在字典中？ 

801
00:31:05,880 --> 00:31:08,169
Well, so, aside from the boundary conditions here,
好吧，除了这里的边界条件， 

802
00:31:08,369 --> 00:31:12,809
if I compute this here, it depends on theses two, right?
如果我在这里计算，那取决于这两个，对吗？ 

803
00:31:12,809 --> 00:31:16,073
Are they going to be in the dictionary?
他们要去字典里吗？ 

804
00:31:16,074 --> 00:31:16,849
AUDIENCE: Not yet.
听众：还没有。 

805
00:31:17,049 --> 00:31:17,919
PROFESSOR: Why?
教授：为什么？ 

806
00:31:17,920 --> 00:31:20,359
If I'm running this way, so if I'm
如果我以这种方式运行，那么如果

807
00:31:20,559 --> 00:31:23,210
computing all my values in this order.
按此顺序计算我的所有值。 

808
00:31:23,210 --> 00:31:24,082
So the first line one.
所以第一行。 

809
00:31:24,282 --> 00:31:24,865
Then line two.
然后第二行。 

810
00:31:24,865 --> 00:31:26,713
Then line three.
然后第三行。 

811
00:31:26,713 --> 00:31:28,629
They're already going to be in the dictionary.
他们已经在字典中了。 

812
00:31:28,630 --> 00:31:31,440
So this is because I'm doing topological sort.
这是因为我正在进行拓扑排序。 

813
00:31:31,440 --> 00:31:33,170
You don't need memoization if you're not
如果您不需要，则不需要记忆

814
00:31:33,170 --> 00:31:35,009
using the topological sort of the graph.
使用图的拓扑排序。 

815
00:31:35,009 --> 00:31:38,549
You only need memoization if you don't.
如果不需要，则仅需要记忆。 

816
00:31:38,549 --> 00:31:42,876
AUDIENCE: So, why are we doing boundaries commissions if--
听众：那么，如果我们- 

817
00:31:42,876 --> 00:31:43,710
PROFESSOR: Because--
教授：因为- 

818
00:31:43,710 --> 00:31:45,579
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

819
00:31:45,579 --> 00:31:47,809
PROFESSOR: So, I'm doing a boundary condition
教授：所以，我正在做一个边界条件

820
00:31:47,809 --> 00:31:53,500
because if I paste this in if I paste this thing in, then when
因为如果我把它粘贴进去如果我把它粘贴进去

821
00:31:53,500 --> 00:31:56,380
I am here, this is going to refer to this guy.
我在这里，这将是指这个家伙。 

822
00:31:56,380 --> 00:31:57,420
Which is fine.
没关系

823
00:31:57,420 --> 00:31:59,490
But it's also going to refer to 2,0.
但这也将引用2,0。 

824
00:31:59,490 --> 00:32:00,700
Which doesn't exist.
不存在。 

825
00:32:00,700 --> 00:32:06,980



826
00:32:06,980 --> 00:32:09,200
So the code might be a bit obfuscated by the boundary
所以代码可能会被边界混淆

827
00:32:09,200 --> 00:32:09,699
conditions.
条件。 

828
00:32:09,699 --> 00:32:11,140
But it's 10 lines of code.
但这是10行代码。 

829
00:32:11,140 --> 00:32:13,940
It's pretty nice and straightforward.
这非常好，很直接。 

830
00:32:13,940 --> 00:32:15,650
OK, now what is dynamic programming?
好的，什么是动态编程？ 

831
00:32:15,650 --> 00:32:18,099
I like that question.
我喜欢这个问题。 

832
00:32:18,299 --> 00:32:20,059
PROFESSOR: So, a key property, I don't
教授：所以，重要的财产

833
00:32:20,059 --> 00:32:21,279
think it was mentioned in lecture.
认为这是在讲课中提到的。 

834
00:32:21,279 --> 00:32:22,529
Guys, correct me if I'm wrong.
伙计们，如果我错了，请纠正我。 

835
00:32:22,529 --> 00:32:24,569
It's called optimal substructure.
这称为最佳子结构。 

836
00:32:24,569 --> 00:32:26,249
Does that ring a bell?
那会响吗？ 

837
00:32:26,249 --> 00:32:28,164
Probably going to hear about it next time, so.
大概下次会再听到。 

838
00:32:28,164 --> 00:32:32,819



839
00:32:32,819 --> 00:32:37,434
Optimal substructure.
最佳子结构。 

840
00:32:37,434 --> 00:32:43,559



841
00:32:43,559 --> 00:32:45,399
So, the point of optimal substructure
因此，最佳子结构的要点

842
00:32:45,400 --> 00:32:49,599
is, suppose I have a shortest path from s to g.
是，假设我从s到g的路径最短。 

843
00:32:49,799 --> 00:32:50,299
Right?
对？ 

844
00:32:50,299 --> 00:33:01,809



845
00:33:01,809 --> 00:33:11,579
so, suppose I have shortest path from s to g.
因此，假设我从s到g的路径最短。 

846
00:33:11,579 --> 00:33:14,230



847
00:33:14,230 --> 00:33:17,130
And that path is called p.
该路径称为p。 

848
00:33:17,130 --> 00:33:20,660
Now, suppose this path goes through d.
现在，假设此路径经过d。 

849
00:33:20,660 --> 00:33:28,119
So, path from s to g is actually s making a path through d.
因此，从s到g的路径实际上是s穿过d的路径。 

850
00:33:28,319 --> 00:33:32,470
And then there's another path going from d to g.
从d到g还有另一条路。 

851
00:33:32,470 --> 00:33:36,740



852
00:33:36,740 --> 00:33:40,430
This path over here, p1.
这条路径在这里，p1。 

853
00:33:40,430 --> 00:33:48,660
p1 is guaranteed to be the shortest path, or a shortest
保证p1是最短路径或最短路径

854
00:33:48,660 --> 00:33:50,379
path, from s to d.
从s到d的路径。 

855
00:33:50,579 --> 00:33:53,919



856
00:33:53,920 --> 00:33:56,599
So this is the big solution.
所以这是个大解决方案。 

857
00:33:56,799 --> 00:34:00,200
It's optimal because we say it's the solution to the problem.
这是最佳选择，因为我们说这是解决问题的方法。 

858
00:34:00,200 --> 00:34:02,910
This is a part of the solution.
这是解决方案的一部分。 

859
00:34:02,910 --> 00:34:05,660
This part of the solution is optimal for this part
解决方案的这一部分对此部分是最佳的

860
00:34:05,660 --> 00:34:07,099
of the problem.
问题。 

861
00:34:07,299 --> 00:34:11,282
So the part of the problem is getting from s to d.
因此，问题的一部分是从s到d。 

862
00:34:11,282 --> 00:34:14,760
The part of the big optimal solution
最佳解决方案的一部分

863
00:34:14,760 --> 00:34:18,090
is optimal-- so the small part of the big solution
是最佳的-所以大解决方案的一小部分

864
00:34:18,090 --> 00:34:20,900
is optimal with respect to the small problem.
就小问题而言，最佳。 

865
00:34:20,900 --> 00:34:25,269
So p1 has to be a shortest path from s to d.
因此p1必须是从s到d的最短路径。 

866
00:34:25,269 --> 00:34:27,559
Do you guys want to see a proof by contradiction?
你们想看到矛盾的证据吗？ 

867
00:34:27,559 --> 00:34:28,833
Or do take my word for it?
还是相信我的话？ 

868
00:34:28,833 --> 00:34:32,299



869
00:34:32,300 --> 00:34:34,139
Does anyone want to?
有人要吗？ 

870
00:34:34,338 --> 00:34:36,630
So, intuitively, the idea is that if you had the better
因此，从直觉上讲，想法是，如果您有更好的

871
00:34:36,630 --> 00:34:39,360
path here, say that path would be s3,
这里的路径，说路径将是s3， 

872
00:34:39,360 --> 00:34:42,050
then I could replace this, sorry. p3.
那我可以代替它，对不起。 p3。 

873
00:34:42,050 --> 00:34:44,130
I could replace this with p3.
我可以将其替换为p3。 

874
00:34:44,130 --> 00:34:46,594
And I would have a better path overall.
总体而言，我会有一条更好的道路。 

875
00:34:46,594 --> 00:34:48,010
And that would contradict the fact
这与事实相反

876
00:34:48,010 --> 00:34:51,340
that this is the best path.
这是最好的道路。 

877
00:34:51,340 --> 00:34:53,400
So this part of the path has to be a shortest path
所以这部分路径必须是最短的路径

878
00:34:53,599 --> 00:34:56,309
to get from s to d.
从s到d。 

879
00:34:56,309 --> 00:35:00,250
So I've broken up my problem to get from s to g,
所以我把问题分解成从s到g， 

880
00:35:00,250 --> 00:35:03,320
into saying, I want to get from s to d, from s to e.
说，我想从s到d，从s到e。 

881
00:35:03,320 --> 00:35:06,570
Or, from s to f and then cross one edge.
或者，从s到f，然后越过一条边。 

882
00:35:06,570 --> 00:35:09,730
And then the ways I get from s to d from s to e, or from s
然后我从s到d从s到e或从s的方法

883
00:35:09,730 --> 00:35:13,150
to f, have to be optimal.
到f，必须是最优的。 

884
00:35:13,150 --> 00:35:15,829
I've already encoded that here.
我已经在这里编码了。 

885
00:35:15,829 --> 00:35:18,429
And nobody asked me, yo, is this true?
没有人问我，哟，这是真的吗？ 

886
00:35:18,429 --> 00:35:20,329
Can I take a longer path here?
我可以在这里走更长的路吗？ 

887
00:35:20,329 --> 00:35:22,239
And have a better solution?
有更好的解决方案吗？ 

888
00:35:22,239 --> 00:35:23,519
The answer is no.
答案是不。 

889
00:35:23,519 --> 00:35:26,007
In some problems, the answer is yes.
在某些问题上，答案是肯定的。 

890
00:35:26,007 --> 00:35:27,465
Those are not problems that you can
这些不是您可以解决的问题

891
00:35:27,465 --> 00:35:29,789
solve with dynamic programming.
用动态编程解决。 

892
00:35:29,789 --> 00:35:31,449
if, in your problems, that's the case,
如果是这种情况， 

893
00:35:31,449 --> 00:35:36,521
you probably forgot to account for some part of the state.
您可能忘记了占州的一部分。 

894
00:35:36,521 --> 00:35:38,494
AUDIENCE: What kind of problems would it
听众：会出现什么样的问题

895
00:35:38,494 --> 00:35:40,269
be where that wouldn't be true?
在那不是真的吗？ 

896
00:35:40,469 --> 00:35:42,619
PROFESSOR: Well, remember the quiz problem
教授：好吧，请记住测验问题

897
00:35:42,619 --> 00:35:45,219
with the gas stations?
加油站？ 

898
00:35:45,219 --> 00:35:49,279
If you don't account for the gas, if you do Dijkstra, then,
如果您不考虑汽油费用，那么如果您选择Dijkstra，那么， 

899
00:35:49,280 --> 00:35:49,780
well.
好。 

900
00:35:49,780 --> 00:35:51,650
Guess what?
你猜怎么了？ 

901
00:35:51,849 --> 00:35:54,699
Shortest path in the graph, if that
图形中的最短路径（如果这样） 

902
00:35:54,699 --> 00:35:57,069
doesn't account for gas stops, if you start accounting
如果您开始核算，则不代表加油站

903
00:35:57,070 --> 00:36:00,210
for the cost of refilling, this path
为了加油的成本，这条路

904
00:36:00,409 --> 00:36:02,839
might be longer than a path that goes like this.
可能比这样的路径更长。 

905
00:36:02,840 --> 00:36:05,769
So, it's longer in terms of road stalls.
因此，在道路失速方面更长。 

906
00:36:05,969 --> 00:36:11,169
But has fewer, or has cheaper, gas stations on the way.
但途中加油站的数量较少，或更便宜。 

907
00:36:11,170 --> 00:36:13,840
So then, there's no optimal substructure.
因此，就没有最佳的子结构。 

908
00:36:13,840 --> 00:36:17,650
And that's because you didn't account for the fuel states.
那是因为您没有考虑燃油状态。 

909
00:36:17,849 --> 00:36:18,349
OK.
好。 

910
00:36:18,349 --> 00:36:19,639
Probably not the best example.
可能不是最好的例子。 

911
00:36:19,639 --> 00:36:23,379
Sorry for bringing up painful memories.
很抱歉带来痛苦的回忆。 

912
00:36:23,380 --> 00:36:24,900
But the point is, usually when you
但是关键是，通常当你

913
00:36:24,900 --> 00:36:27,483
have this with our problems, you didn't account for the state.
遇到我们的问题时，您并没有说明状态。 

914
00:36:27,483 --> 00:36:31,539
All the problems that are solved with dynamic programming
动态编程解决的所有问题

915
00:36:31,539 --> 00:36:33,519
have this thing called optimal substructure.
这个东西叫做最优子结构。 

916
00:36:33,519 --> 00:36:37,340
And this is sort of how it works.
这就是它的工作方式。 

917
00:36:37,340 --> 00:36:37,839
OK.
好。 

918
00:36:37,840 --> 00:36:40,181
I have no idea how much time I have because my phone crashed.
我不知道有多少时间，因为手机坏了。 

919
00:36:40,380 --> 00:36:42,769
So can anyone help me?
有人可以帮我吗？ 

920
00:36:42,769 --> 00:36:43,610
Five minutes.
 5分钟。 

921
00:36:43,610 --> 00:36:44,980
10 minutes.
 10分钟。 

922
00:36:44,980 --> 00:36:45,480
Sorry.
抱歉。 

923
00:36:45,480 --> 00:36:46,420
AUDIENCE: Seven minutes.
听众：七分钟。 

924
00:36:46,420 --> 00:36:47,003
PROFESSOR: OK.
教授：好的。 

925
00:36:47,003 --> 00:36:49,710



926
00:36:49,710 --> 00:36:53,730
What else do you guys want to see?
你们还想看到什么？ 

927
00:36:53,730 --> 00:36:55,730
AUDIENCE: Cycles.
听众：循环。 

928
00:36:55,730 --> 00:36:58,016
[INAUDIBLE]
 [听不清] 

929
00:36:58,016 --> 00:36:58,599
PROFESSOR: OK.
教授：好的。 

930
00:36:58,599 --> 00:37:01,799
Is everyone happy with cycles?
每个人都对周期感到满意吗？ 

931
00:37:01,800 --> 00:37:02,190
OK.
好。 

932
00:37:02,389 --> 00:37:04,199
Almost everyone, so that's good enough.
几乎所有人，这样就足够了。 

933
00:37:04,199 --> 00:37:08,549



934
00:37:08,550 --> 00:37:09,050
OK.
好。 

935
00:37:09,050 --> 00:37:09,480
Let's do cycles.
让我们做循环。 

936
00:37:09,679 --> 00:37:10,596
We have seven minutes.
我们有七分钟。 

937
00:37:10,596 --> 00:37:25,380



938
00:37:25,380 --> 00:37:28,210
So, suppose I have this graph.
所以，假设我有这张图。 

939
00:37:28,409 --> 00:37:35,440
Source going a going to be going to c.
源将要去c。 

940
00:37:35,440 --> 00:37:38,519



941
00:37:38,519 --> 00:37:43,050
And then the costs are 1 minus 1.
则成本为1减去1。 

942
00:37:43,050 --> 00:37:43,940
1.
 1。 

943
00:37:43,940 --> 00:37:44,440
1.
 1。 

944
00:37:44,440 --> 00:37:47,099



945
00:37:47,099 --> 00:37:49,179
Can I solve it using that method?
我可以用那种方法解决吗？ 

946
00:37:49,179 --> 00:37:53,509



947
00:37:53,509 --> 00:37:54,050
Probably not.
可能不是。 

948
00:37:54,050 --> 00:37:57,690
Let's try to write the recursions
让我们尝试编写递归

949
00:37:57,690 --> 00:38:00,460
to see what we get for the formulas.
看看我们从公式中得到什么。 

950
00:38:00,460 --> 00:38:02,800
So, dsa is--
因此，dsa是- 

951
00:38:02,800 --> 00:38:04,960
AUDIENCE: 1.
听众：1。 

952
00:38:05,159 --> 00:38:06,139
PROFESSOR: --minimum.
教授：-最少。 

953
00:38:06,139 --> 00:38:06,699
Yeah, it's 1.
是的，是1。 

954
00:38:06,699 --> 00:38:14,449
But it's the minimum of dss plus weight sa.
但这是dss加权重sa的最小值。 

955
00:38:14,449 --> 00:38:19,079



956
00:38:19,079 --> 00:38:20,719
ds-- well, almost.
 ds-好吧，差不多。 

957
00:38:20,719 --> 00:38:24,759



958
00:38:24,760 --> 00:38:26,039
Actually, it's not 1.
其实不是1。 

959
00:38:26,239 --> 00:38:27,639
Likely.
有可能

960
00:38:27,639 --> 00:38:28,922
You're confusing me again.
你又让我迷惑了。 

961
00:38:28,922 --> 00:38:31,130
There's one more edges that they have to account for.
他们还需要考虑更多的优势。 

962
00:38:31,130 --> 00:38:33,480
AUDIENCE: Oh.
听众：哦。 

963
00:38:33,480 --> 00:38:37,400
PROFESSOR: dsc plus weight.
教授：DSC加重量。 

964
00:38:37,400 --> 00:38:38,400
I'm going to fail today.
我今天会失败。 

965
00:38:38,400 --> 00:38:39,019
I'm tired.
我累了。 

966
00:38:39,219 --> 00:38:41,299
AUDIENCE: ca.
观众： 

967
00:38:41,300 --> 00:38:41,710
PROFESSOR: OK.
教授：好的。 

968
00:38:41,909 --> 00:38:45,099
So we accounted for both edges coming in now.
因此，我们考虑了现在出现的两个方面。 

969
00:38:45,099 --> 00:38:51,299
dsb is minimum of dsa plus weight ab.
 dsb是dsa加上权重ab的最小值。 

970
00:38:51,300 --> 00:38:54,000



971
00:38:54,199 --> 00:39:00,710
dsc is minimum of dsb plus weight bc.
 dsc是dsb加上权重bc的最小值。 

972
00:39:00,710 --> 00:39:03,360



973
00:39:03,360 --> 00:39:04,329
Right?
对？ 

974
00:39:04,329 --> 00:39:07,741
And dss is 0 because we promised that's how we start.
 dss为0，因为我们保证这就是开始的方式。 

975
00:39:07,742 --> 00:39:10,320



976
00:39:10,320 --> 00:39:10,820
OK.
好。 

977
00:39:10,820 --> 00:39:12,900
Now what if I try evaluate these?
现在，如果我尝试评估这些怎么办？ 

978
00:39:12,900 --> 00:39:17,599
Is there a sane order in which I can evaluate them?
我可以以合理的顺序评估它们吗？ 

979
00:39:17,599 --> 00:39:18,170
Nope.
不。 

980
00:39:18,170 --> 00:39:19,110
Let's see why.
让我们看看为什么。 

981
00:39:19,110 --> 00:39:26,213
If I try to evaluate sa, this depends on sc.
如果我尝试评估sa，则取决于sc。 

982
00:39:26,213 --> 00:39:27,630
AUDIENCE: Which we don't have yet.
听众：我们还没有。 

983
00:39:27,630 --> 00:39:31,809
PROFESSOR: sc is here. sc depends on sb.
教授：sc在这里。 sc取决于sb。 

984
00:39:31,809 --> 00:39:34,079
sb is here.
某人在这里。 

985
00:39:34,079 --> 00:39:36,090
And it depends on sa.
这取决于sa。 

986
00:39:36,090 --> 00:39:38,789
Which was.
是的

987
00:39:38,789 --> 00:39:42,701
So we have this infinite recursion, right?
所以我们有这个无限递归，对吗？ 

988
00:39:42,701 --> 00:39:43,949
They all depend on each other.
他们彼此依赖。 

989
00:39:43,949 --> 00:39:46,099
There's a loop here.
这里有一个循环。 

990
00:39:46,099 --> 00:39:47,719
There's a negative cycle.
有一个负面的周期。 

991
00:39:47,719 --> 00:39:50,449
Can't use this algorithm.
无法使用此算法。 

992
00:39:50,449 --> 00:39:52,569
That's a shame.
真可惜

993
00:39:52,570 --> 00:39:54,802
What can we do instead?
我们该怎么办呢？ 

994
00:39:54,802 --> 00:39:56,135
PROFESSOR: Show a negative node.
教授：显示一个负节点。 

995
00:39:56,135 --> 00:39:57,402
A negative weight.
负重。 

996
00:39:57,601 --> 00:39:58,311
half.
半。 

997
00:39:58,311 --> 00:39:59,019
PROFESSOR: Sorry?
教授：对不起？ 

998
00:39:59,019 --> 00:40:01,940
AUDIENCE: Can we just get rid of the negative weight half?
听众：我们能摆脱负重的一半吗？ 

999
00:40:01,940 --> 00:40:03,090
PROFESSOR: No.
教授：不。 

1000
00:40:03,090 --> 00:40:04,019
That's the best edge.
那是最好的优势。 

1001
00:40:04,019 --> 00:40:06,353
That's probably going to be part of the solution, right?
那可能是解决方案的一部分，对吧？ 

1002
00:40:06,353 --> 00:40:09,184
AUDIENCE: Can we add 1 to all the edges?
听众：我们可以在所有边上加1吗？ 

1003
00:40:09,184 --> 00:40:10,900
PROFESSOR: That's still going to have a cycle.
教授：那仍然会有一个周期。 

1004
00:40:11,099 --> 00:40:12,569
I still won't be able to run this.
我仍然无法运行该程序。 

1005
00:40:12,570 --> 00:40:13,452
AUDIENCE: Oh, yeah.
听众：哦，是的。 

1006
00:40:13,452 --> 00:40:14,210
AUDIENCE: Bellman-Ford.
听众：贝尔曼·福特。 

1007
00:40:14,409 --> 00:40:17,019



1008
00:40:17,019 --> 00:40:18,019
PROFESSOR: Bellman-ford.
教授：贝尔曼福德。 

1009
00:40:18,019 --> 00:40:20,110
AUDIENCE: That's not dynamic.
听众：这不是动态的。 

1010
00:40:20,110 --> 00:40:20,710
PROFESSOR: OK.
教授：好的。 

1011
00:40:20,909 --> 00:40:23,135
Well, one way to do it is Bellman-Ford, right?
好吧，贝尔曼-福特（Bellman-Ford）就是其中一种，对吗？ 

1012
00:40:23,135 --> 00:40:25,009
Another way, which we went through last time,
我们上次经历的另一种方式， 

1013
00:40:25,010 --> 00:40:27,110
is to break the cycle.
是打破周期。 

1014
00:40:27,110 --> 00:40:29,380
And the way we break the cycle is we
我们打破周期的方式是

1015
00:40:29,380 --> 00:40:32,440
add the path length into the equation.
在等式中添加路径长度。 

1016
00:40:32,440 --> 00:40:39,378



1017
00:40:39,378 --> 00:40:40,920
So, I'm going to look at the distance
所以，我要看看距离

1018
00:40:40,920 --> 00:40:44,730
from a source to some node, so the distance
从源到某个节点的距离

1019
00:40:44,730 --> 00:40:51,309
from a source to some node, as the distance from the source
从源到某个节点的距离，即到源的距离

1020
00:40:51,309 --> 00:40:56,279
to some other node plus the edge weight.
到其他节点再加上边缘权重

1021
00:40:56,280 --> 00:40:57,460
This is what I had before, right?
这是我以前的经历，对吧？ 

1022
00:40:57,659 --> 00:40:59,269
Nothing new here.
这里没有新内容。 

1023
00:40:59,269 --> 00:41:05,909
So dsv is the minimum over all the edges of dsu
所以dsv是dsu所有边缘的最小值

1024
00:41:05,909 --> 00:41:08,710
plus weight uv, Right?
再加上紫外线，对吗？ 

1025
00:41:08,710 --> 00:41:11,880
Minimum over all uv.
最低的所有紫外线。 

1026
00:41:11,880 --> 00:41:14,289
That's our edges.
那就是我们的优势。 

1027
00:41:14,489 --> 00:41:14,989
Right?
对？ 

1028
00:41:14,989 --> 00:41:15,905
This is the old stuff.
这是旧的东西。 

1029
00:41:15,905 --> 00:41:17,969
Now, we're going to say this instead.
现在，我们将改为这样说。 

1030
00:41:17,969 --> 00:41:24,149
The distance from s to v, using a path of length k,
 s到v的距离，使用长度为k的路径， 

1031
00:41:24,150 --> 00:41:31,280
is the minimum over all the edges of the distance from s
是距s的距离的所有边的最小值

1032
00:41:31,280 --> 00:41:35,730
to u, using a path of what length?
到您，使用什么长度的路径？ 

1033
00:41:35,929 --> 00:41:40,199
If this path is length k.
如果此路径的长度为k。 

1034
00:41:40,199 --> 00:41:41,139
So k edges.
所以k条边。 

1035
00:41:41,139 --> 00:41:43,000
How many edges do I have here?
我这里有几个边？ 

1036
00:41:43,001 --> 00:41:43,876
AUDIENCE: k equals 1.
听众：k等于1。 

1037
00:41:43,876 --> 00:41:48,360



1038
00:41:48,559 --> 00:41:52,309
PROFESSOR: So this is distance su using k minus 1
教授：这是使用s减去1的距离su 

1039
00:41:52,309 --> 00:41:57,090
plus the weight of uv.
再加上紫外线的重量。 

1040
00:41:57,090 --> 00:42:01,059
AUDIENCE: So what's the difference between the two?
听众：两者之间有什么区别？ 

1041
00:42:01,059 --> 00:42:05,239
PROFESSOR: So, this will always decrease.
教授：因此，这将永远减少。 

1042
00:42:05,239 --> 00:42:10,769
So I guarantee that they will not have an infinite recursion.
因此，我保证它们不会有无限递归。 

1043
00:42:10,769 --> 00:42:12,739
This is the magic that makes it work.
这就是使它起作用的魔力。 

1044
00:42:12,739 --> 00:42:14,869
Now, an equivalent way of looking at this,
现在，以一种等效的方式来看待这一点， 

1045
00:42:14,869 --> 00:42:15,779
is building a graph.
正在建立图表。 

1046
00:42:15,780 --> 00:42:17,280
That's what we've been doing so far.
到目前为止，这就是我们一直在做的事情。 

1047
00:42:17,280 --> 00:42:20,967
So let's build an equivalent graph to this.
因此，让我们为此构建一个等效图。 

1048
00:42:21,166 --> 00:42:22,041
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

1049
00:42:22,041 --> 00:42:26,769



1050
00:42:26,769 --> 00:42:29,349
PROFESSOR: It's going to get to 0 eventually, right?
教授：最终将变为0，对吗？ 

1051
00:42:29,349 --> 00:42:36,219
So when k is 0, the distance from the source to itself is 0.
因此，当k为0时，从源到自身的距离为0。 

1052
00:42:36,219 --> 00:42:42,875
But the distance from the source to any other nodes is infinity.
但是从源到任何其他节点的距离都是无穷大。 

1053
00:42:42,875 --> 00:42:44,250
Because from the source, we can't
因为从源头上讲，我们不能

1054
00:42:44,250 --> 00:42:45,920
get to anywhere else in 0 edges.
到达0边的其他任何地方。 

1055
00:42:45,920 --> 00:42:46,669
We can't teleport.
我们不能传送。 

1056
00:42:46,670 --> 00:42:50,226



1057
00:42:50,226 --> 00:42:52,434
So let's build a graph to get the intuition for this.
因此，让我们建立一个图表来获得直觉。 

1058
00:42:52,434 --> 00:42:54,219
This looks mathy.
这看起来很数学。 

1059
00:42:54,219 --> 00:42:56,769
This looks too mathy.
这看起来太数学了。 

1060
00:42:56,769 --> 00:42:59,391
So, at the first layer, you only have the source.
因此，在第一层，您只有源。 

1061
00:42:59,391 --> 00:43:01,139
You can only get from the source to itself
您只能从源头获取自身

1062
00:43:01,139 --> 00:43:03,849
by not crossing any edges.
不跨越任何边缘。 

1063
00:43:03,849 --> 00:43:06,170
At level one, you potentially have all the nodes.
在第一级，您可能拥有所有节点。 

1064
00:43:06,170 --> 00:43:08,070
If the source is connected to everything,
如果源连接到一切， 

1065
00:43:08,070 --> 00:43:09,077
you might have all the nodes.
您可能拥有所有节点。 

1066
00:43:09,277 --> 00:43:15,769
So, s1, a1, b1, c1.
因此，s1，a1，b1，c1。 

1067
00:43:15,769 --> 00:43:18,655
Where can you get from the source?
您可以从哪里获得信息？ 

1068
00:43:18,655 --> 00:43:19,599
AUDIENCE: To a.
听众：对。 

1069
00:43:19,599 --> 00:43:22,319
PROFESSOR: To a.
教授：要

1070
00:43:22,320 --> 00:43:23,940
What's the cost of the edge?
优势成本是多少？ 

1071
00:43:23,940 --> 00:43:24,519
AUDIENCE: 1.
听众：1。 

1072
00:43:24,719 --> 00:43:25,909
PROFESSOR: OK.
教授：好的。 

1073
00:43:25,909 --> 00:43:27,769
Now, let's build a second layer.
现在，让我们构建第二层。 

1074
00:43:27,769 --> 00:43:35,940
s2, a2, b2, c2.
 s2，a2，b2，c2。 

1075
00:43:35,940 --> 00:43:38,090
So someone tell me the edges.
所以有人告诉我边缘。 

1076
00:43:38,090 --> 00:43:41,130
So, assuming I can get to this node using one
因此，假设我可以使用一个

1077
00:43:41,130 --> 00:43:44,110
edge, how can I get to this other node using two edges?
边缘，如何使用两个边缘到达另一个节点？ 

1078
00:43:44,110 --> 00:43:46,882



1079
00:43:46,882 --> 00:43:47,809
AUDIENCE: A to b.
听众：从A到b。 

1080
00:43:47,809 --> 00:43:48,980
PROFESSOR: OK. a to b.
教授：好的。从a到b。 

1081
00:43:48,980 --> 00:43:50,090
a1 to b2.
 a1至b2。 

1082
00:43:50,090 --> 00:43:51,550
AUDIENCE: 2.
听众：2。 

1083
00:43:51,550 --> 00:43:53,190
PROFESSOR: OK.
教授：好的。 

1084
00:43:53,389 --> 00:43:53,889
Cost?
成本？ 

1085
00:43:53,889 --> 00:43:56,029
AUDIENCE: 1 [INAUDIBLE].
观众：1 [听不清]。 

1086
00:43:56,030 --> 00:43:57,440
A1 to c--
 A1至c-- 

1087
00:43:57,440 --> 00:43:59,320
AUDIENCE: That's negative 1.
听众：这是负面的1。 

1088
00:43:59,320 --> 00:44:00,210
PROFESSOR: a1 to b2.
教授：a1至b2。 

1089
00:44:00,409 --> 00:44:00,909
Thank you.
谢谢。 

1090
00:44:00,909 --> 00:44:04,349



1091
00:44:04,349 --> 00:44:04,849
OK.
好。 

1092
00:44:04,849 --> 00:44:05,942
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

1093
00:44:05,942 --> 00:44:06,650
PROFESSOR: Sorry?
教授：对不起？ 

1094
00:44:06,650 --> 00:44:08,889
AUDIENCE: Are we doing anything else?
听众：我们还有其他事情吗？ 

1095
00:44:08,889 --> 00:44:09,940
PROFESSOR: I think so.
教授：我是这样认为的。 

1096
00:44:09,940 --> 00:44:14,730
So, if I'm at b using one edge, I can get to c using two edges.
因此，如果我使用一条边在b处，则可以使用两条边到达c。 

1097
00:44:14,730 --> 00:44:15,494
Cost?
成本？ 

1098
00:44:15,494 --> 00:44:16,829
AUDIENCE: 1.
听众：1。 

1099
00:44:16,829 --> 00:44:17,509
PROFESSOR: OK.
教授：好的。 

1100
00:44:17,510 --> 00:44:20,320
If I'm at c using one edge--
如果我在c上使用一条边线- 

1101
00:44:20,320 --> 00:44:21,632
AUDIENCE: a.
听众：a。 

1102
00:44:21,632 --> 00:44:22,840
PROFESSOR: --using two edges.
教授：-使用两个边缘。 

1103
00:44:22,840 --> 00:44:23,603
Cost?
成本？ 

1104
00:44:23,802 --> 00:44:25,487
AUDIENCE: 1.
听众：1。 

1105
00:44:25,487 --> 00:44:26,070
PROFESSOR: OK.
教授：好的。 

1106
00:44:26,070 --> 00:44:29,019
And if I'm at s using one edge?
如果我在使用一条边？ 

1107
00:44:29,219 --> 00:44:30,149
AUDIENCE: a.
听众：a。 

1108
00:44:30,150 --> 00:44:32,940
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

1109
00:44:32,940 --> 00:44:33,829
PROFESSOR: Can you?
教授：可以吗？ 

1110
00:44:33,829 --> 00:44:36,121
AUDIENCE: There's now edge.
听众：现在有优势。 

1111
00:44:36,121 --> 00:44:37,245
PROFESSOR: There's no edge.
教授：没有优势。 

1112
00:44:37,246 --> 00:44:38,692
AUDIENCE: I thought it was just like an assumed edge.
听众：我认为这就像一个假定的优势。 

1113
00:44:38,891 --> 00:44:39,557
PROFESSOR: Nope.
教授：不。 

1114
00:44:39,557 --> 00:44:40,599
Nope.
不。 

1115
00:44:40,599 --> 00:44:42,000
Not an edge.
不是优势。 

1116
00:44:42,000 --> 00:44:44,869
As to a, cost?
至于，费用？ 

1117
00:44:44,869 --> 00:44:45,369
AUDIENCE: 1.
听众：1。 

1118
00:44:45,369 --> 00:44:46,040
PROFESSOR: 1.
教授：1。 

1119
00:44:46,041 --> 00:44:46,539
OK.
好。 

1120
00:44:46,539 --> 00:44:48,380
Let's build a third level.
让我们建立第三个层次。 

1121
00:44:48,380 --> 00:44:53,885
s3, a3, b3, c3.
 s3，a3，b3，c3。 

1122
00:44:53,885 --> 00:44:57,360



1123
00:44:57,559 --> 00:44:59,895
Someone dictate the edges please.
请有人指示边缘。 

1124
00:44:59,896 --> 00:45:03,137
AUDIENCE: S2 to a3.
听众：S2到a3。 

1125
00:45:03,137 --> 00:45:04,063
With 1.
用1。 

1126
00:45:04,063 --> 00:45:06,809
I mean, it's going to be the exact same.
我的意思是，它将完全相同。 

1127
00:45:06,809 --> 00:45:08,739
PROFESSOR: Yep.
教授：是的。 

1128
00:45:08,739 --> 00:45:12,439
a2 to b3 minus 1.
 a2至b3减1。 

1129
00:45:12,440 --> 00:45:15,559
b2 to c3 1.
 b2至c3 1。 

1130
00:45:15,559 --> 00:45:20,579
And c2 to a3 1.
和c2到a3 1。 

1131
00:45:20,579 --> 00:45:23,420
So these are exactly the same edges, right?
所以这些边完全一样，对不对？ 

1132
00:45:23,420 --> 00:45:25,420
Because they're the original edges in the graph.
因为它们是图形中的原始边缘。 

1133
00:45:25,420 --> 00:45:28,519
Every edge in the graph can connect to levels here.
图中的每个边都可以连接到此处的层。 

1134
00:45:28,519 --> 00:45:32,780



1135
00:45:32,780 --> 00:45:34,585
So, all edges.
因此，所有边缘。 

1136
00:45:34,585 --> 00:45:37,199



1137
00:45:37,199 --> 00:45:39,829
All edges.
所有边缘。 

1138
00:45:39,829 --> 00:45:45,789
All edges from s.
 s的所有边。 

1139
00:45:45,789 --> 00:45:46,960
How many layers do I need?
我需要几层？ 

1140
00:45:46,960 --> 00:45:49,615



1141
00:45:49,815 --> 00:45:52,366
AUDIENCE: e.
听众：e。 

1142
00:45:52,367 --> 00:45:52,750
PROFESSOR: OK.
教授：好的。 

1143
00:45:52,949 --> 00:45:53,730
Pretty close.
八九不离十。 

1144
00:45:53,730 --> 00:45:56,751
Let's try something smaller.
让我们尝试一些较小的东西。 

1145
00:45:56,751 --> 00:45:57,688
AUDIENCE: a.
听众：a。 

1146
00:45:57,688 --> 00:45:58,423
AUDIENCE: Oh.
听众：哦。 

1147
00:45:58,623 --> 00:46:00,029
That makes no sense.
这是没有意义的。 

1148
00:46:00,030 --> 00:46:03,920
PROFESSOR: So, what's the longest path in a graph?
教授：那么，图中的最长路径是什么？ 

1149
00:46:04,119 --> 00:46:05,210
Graph of v vertices.
 v个顶点的图形。 

1150
00:46:05,210 --> 00:46:06,340
What is the longest path?
最长的路是什么？ 

1151
00:46:06,340 --> 00:46:08,000
AUDIENCE: The number [INAUDIBLE].
听众：数字[听不清]。 

1152
00:46:08,000 --> 00:46:09,619
PROFESSOR: The longest shortest path.
教授：最长最短的路径。 

1153
00:46:09,619 --> 00:46:10,940
AUDIENCE: v minus 1.
听众：v减1。 

1154
00:46:10,940 --> 00:46:12,329
PROFESSOR: v minus 1.
教授：v减1。 

1155
00:46:12,329 --> 00:46:14,799
That's how Bellman-Ford has v minus 1 runs, right?
这就是Bellman-Ford v减1的方式，对吗？ 

1156
00:46:14,800 --> 00:46:16,539
AUDIENCE: Oh.
听众：哦。 

1157
00:46:16,539 --> 00:46:18,779
PROFESSOR: So, a shortest path can't have a cycle.
教授：因此，最短的路径不能有循环。 

1158
00:46:18,780 --> 00:46:21,500
If it has a cycle, then it means it's an infinite cycle.
如果有一个循环，则意味着这是一个无限循环。 

1159
00:46:21,500 --> 00:46:23,150
So there's no solution.
因此，没有解决方案。 

1160
00:46:23,150 --> 00:46:24,942
Shortest paths have no cycles therefore,
因此，最短路径没有循环， 

1161
00:46:24,942 --> 00:46:26,650
even if they go through the entire graph,
即使他们遍历整个图表， 

1162
00:46:26,650 --> 00:46:29,300
they're going to have v minus 1 edges.
他们将有v减去1个边。 

1163
00:46:29,300 --> 00:46:31,690
So I'm going to have v minus 1 layers.
因此，我将拥有v减去1层。 

1164
00:46:31,889 --> 00:46:35,849



1165
00:46:35,849 --> 00:46:38,059
Here, I drew three layers, so I'm done.
在这里，我画了三层，到此为止。 

1166
00:46:38,059 --> 00:46:40,413
That's why I stopped at three.
这就是为什么我三点停下来。 

1167
00:46:40,414 --> 00:46:42,380
So let's see how many nodes and how many edges we're
让我们来看看我们有多少个节点和多少个边缘

1168
00:46:42,579 --> 00:46:44,371
going to have if we do this transformation.
如果我们进行这种转换，将会有。 

1169
00:46:44,371 --> 00:46:46,579



1170
00:46:46,579 --> 00:46:57,891
v prime is-- so, how many times am I going to copy the graph?
 v素数是-那么，我要复制多少次图表？ 

1171
00:46:57,891 --> 00:46:59,057
AUDIENCE: Two or thee times.
听众：两次或两次。 

1172
00:46:59,057 --> 00:47:00,019
AUDIENCE: Three times.
听众：三遍。 

1173
00:47:00,019 --> 00:47:00,603
PROFESSOR: OK.
教授：好的。 

1174
00:47:00,603 --> 00:47:02,081
And in general terms?
一般而言？ 

1175
00:47:02,081 --> 00:47:03,230
AUDIENCE: v minus 1.
听众：v减1。 

1176
00:47:03,230 --> 00:47:04,367
AUDIENCE: v minus 1 times.
听众：v减1倍。 

1177
00:47:04,367 --> 00:47:04,750
PROFESSOR: OK.
教授：好的。 

1178
00:47:04,949 --> 00:47:08,919
So I'm going to copy the graph v minus 1 times.
因此，我将复制图v减1次。 

1179
00:47:08,920 --> 00:47:12,320
And then I'm going to add that one source, right?
然后我要添加一个来源，对吗？ 

1180
00:47:12,320 --> 00:47:14,820
Doesn't really matter because it's order of b squared.
并不重要，因为它是b的平方。 

1181
00:47:14,820 --> 00:47:18,230



1182
00:47:18,429 --> 00:47:19,266
How many edges?
有多少条边？ 

1183
00:47:19,266 --> 00:47:21,800



1184
00:47:21,800 --> 00:47:22,675
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

1185
00:47:22,675 --> 00:47:27,069



1186
00:47:27,070 --> 00:47:28,731
PROFESSOR: Order of v times e.
教授：v乘以e的顺序。 

1187
00:47:28,731 --> 00:47:30,190
We can do the math that's whatever.
我们可以做任何数学运算。 

1188
00:47:30,190 --> 00:47:32,059
Let's say it's something like this.
假设是这样的。 

1189
00:47:32,059 --> 00:47:35,059
So the running time-- this graph is acyclic, right?
所以运行时间-此图是非循环的，对不对？ 

1190
00:47:35,059 --> 00:47:38,829
All the nodes are going forward.
所有节点都在前进。 

1191
00:47:38,829 --> 00:47:40,940
The new graph that I have here.
我在这里的新图。 

1192
00:47:40,940 --> 00:47:41,903
AUDIENCE: Yeah.
听众：是的。 

1193
00:47:41,903 --> 00:47:43,695
PROFESSOR: So, I can use the DAG algorithm.
教授：因此，我可以使用DAG算法。 

1194
00:47:43,695 --> 00:47:46,380



1195
00:47:46,380 --> 00:47:48,539
So the running time, if I use the DAG algorithm,
所以运行时间，如果我使用DAG算法， 

1196
00:47:48,539 --> 00:47:52,219
is v prime plus e prime.
是v素数加上e素数。 

1197
00:47:52,219 --> 00:47:53,139
Which is?
哪一个

1198
00:47:53,139 --> 00:47:57,425



1199
00:47:57,425 --> 00:47:58,904
AUDIENCE: v.
听众：v。 

1200
00:47:58,905 --> 00:47:59,780
PROFESSOR: Thank you.
教授：谢谢。 

1201
00:47:59,780 --> 00:48:01,380
AUDIENCE: Or is it ve?
听众：或者是ve？ 

1202
00:48:01,579 --> 00:48:04,019
PROFESSOR: So, it's v squared plus ve, which is ve,
教授：所以，它是v平方加ve，即ve， 

1203
00:48:04,019 --> 00:48:07,369
for most purposes.
对于大多数目的。 

1204
00:48:07,369 --> 00:48:07,903
And this is?
这是吗？ 

1205
00:48:07,903 --> 00:48:08,862
AUDIENCE: Bellman-Ford.
听众：贝尔曼·福特。 

1206
00:48:08,862 --> 00:48:10,250
PROFESSOR: Bellman-Ford.
教授：贝尔曼·福特。 

1207
00:48:10,449 --> 00:48:12,699
So this is Bellman-Ford.
这就是贝尔曼福特。 

1208
00:48:12,699 --> 00:48:14,059
This is what Bellman-Ford does.
这就是贝尔曼·福特所做的。 

1209
00:48:14,059 --> 00:48:15,529
Except when you're coding it up, it
除非您要对其进行编码， 

1210
00:48:15,530 --> 00:48:18,500
relaxes the edges in a different way.
以另一种方式放松边缘。 

1211
00:48:18,500 --> 00:48:20,699
But this is the intuition behind Bellman-Ford.
但这是贝尔曼福特背后的直觉。 

1212
00:48:20,699 --> 00:48:23,389
And this is an easy way to see why Bellman-Ford works.
这是了解Bellman-Ford工作原理的简便方法。 

1213
00:48:23,389 --> 00:48:30,768



1214
00:48:30,768 --> 00:48:32,268
AUDIENCE: So, practically, we really
听众：所以，实际上，我们真的

1215
00:48:32,268 --> 00:48:34,264
wouldn't want to do dynamic programming.
不想做动态编程。 

1216
00:48:34,264 --> 00:48:37,163
We just want to run Bellman-Ford because that's
我们只想运行Bellman-Ford，因为那是

1217
00:48:37,164 --> 00:48:38,840
less code, right?
更少的代码，对不对？ 

1218
00:48:39,039 --> 00:48:41,449
PROFESSOR: So, this is the dynamic programming
教授：这就是动态编程

1219
00:48:41,449 --> 00:48:42,369
view of Bellman-Ford.
曼-福特的鸟瞰图。 

1220
00:48:42,369 --> 00:48:45,400



1221
00:48:45,400 --> 00:48:46,427
Write Bellman-Ford.
写贝尔曼福特。 

1222
00:48:46,427 --> 00:48:48,760
There's a reason why we taught you to write it that way.
我们教会您以这种方式编写它是有原因的。 

1223
00:48:48,760 --> 00:48:51,047
It's going to be shorter.
它会更短。 

1224
00:48:51,246 --> 00:48:52,704
This just gives you more intuition.
这只是给您更多的直觉。 

1225
00:48:52,704 --> 00:48:54,750
And it shows you how the DAG algorithm
并向您展示DAG算法

1226
00:48:54,750 --> 00:48:56,739
relates to Bellman-Ford.
与Bellman-Ford有关。 

1227
00:48:56,739 --> 00:48:59,379
And this is how we handle cycles, which are removed.
这就是我们处理循环的方式，这些循环被删除了。 

1228
00:48:59,380 --> 00:49:02,869
So, that means I have fulfilled my promise of covering
所以，这意味着我已经兑现了我的承诺

1229
00:49:02,869 --> 00:49:06,259
two of the issues that I had on the board.
我在董事会上遇到的两个问题。 

1230
00:49:06,260 --> 00:49:06,800
Yes.
是。 

1231
00:49:06,800 --> 00:49:08,125
So any questions about this?
那么对此有任何疑问吗？ 

1232
00:49:08,324 --> 00:49:11,439



1233
00:49:11,440 --> 00:49:14,639
So, we didn't do the pseudocode for the shortest
所以，我们没有做最短的伪代码

1234
00:49:14,639 --> 00:49:17,190
path using DAGs.
使用DAG的路径。 

1235
00:49:17,190 --> 00:49:19,420
The code that we gave you in the code handout
我们在代码讲义中提供给您的代码

1236
00:49:19,420 --> 00:49:22,440
matches the pseudocode that you'd write.
与您编写的伪代码匹配。 

1237
00:49:22,440 --> 00:49:23,750
Yes?
是？ 

1238
00:49:23,750 --> 00:49:26,960
AUDIENCE: So, if all edges were negative 1 here,
听众：所以，如果所有边都为负1， 

1239
00:49:26,960 --> 00:49:30,760
except for the top edge, looking at this graph over here,
除了顶部边缘，在这里看这张图， 

1240
00:49:30,760 --> 00:49:34,951
how would the search go through, such that it would find,
搜索将如何进行，以便能够找到， 

1241
00:49:35,150 --> 00:49:39,399
lik,e negative two weight half?
好吧，负二重一半？ 

1242
00:49:39,400 --> 00:49:41,019
PROFESSOR: So these edges are minus 1?
教授：那么这些边是负1？ 

1243
00:49:41,219 --> 00:49:43,199
AUDIENCE: Yeah.
听众：是的。 

1244
00:49:43,199 --> 00:49:45,407
PROFESSOR: Well, do you have a solution in this case?
教授：好吧，在这种情况下，您有解决方案吗？ 

1245
00:49:45,407 --> 00:49:50,163



1246
00:49:50,164 --> 00:49:50,960
AUDIENCE: It's no.
听众：不是。 

1247
00:49:51,159 --> 00:49:51,742
PROFESSOR: No.
教授：不。 

1248
00:49:51,742 --> 00:49:54,539



1249
00:49:54,539 --> 00:49:58,489
But you could have this, right?
但是你可以有这个吧？ 

1250
00:49:58,489 --> 00:50:00,727
And expect the whole thing to work.
并期望整个工作正常。 

1251
00:50:00,728 --> 00:50:03,711
AUDIENCE: No, that's still not, that's not making sense.
听众：不，那不是，那没有道理。 

1252
00:50:03,911 --> 00:50:04,619
PROFESSOR: Is it?
教授：是吗？ 

1253
00:50:04,619 --> 00:50:05,949
AUDIENCE: It's negative 1 cycle.
听众：这是负1个周期。 

1254
00:50:05,949 --> 00:50:06,210
PROFESSOR: Oh, yeah.
教授：哦，是的。 

1255
00:50:06,210 --> 00:50:07,001
That's unfortunate.
那真不幸。 

1256
00:50:07,001 --> 00:50:07,920
OK.
好。 

1257
00:50:07,920 --> 00:50:09,780
Never mind.
没关系。 

1258
00:50:09,780 --> 00:50:10,690
Do like this?
喜欢这个吗

1259
00:50:10,690 --> 00:50:16,630



1260
00:50:16,630 --> 00:50:17,500
OK.
好。 

1261
00:50:17,500 --> 00:50:19,349
AUDIENCE: So, also, looking at the graph,
听众：同样，从图表来看， 

1262
00:50:19,349 --> 00:50:21,375
there's only one natural path that you can take.
您只能采取一种自然的方法。 

1263
00:50:21,375 --> 00:50:22,000
PROFESSOR: Yep.
教授：是的。 

1264
00:50:22,000 --> 00:50:28,590
So, if I go from s to c, like this, sabc,
因此，如果我像这样从s转到c， 

1265
00:50:28,590 --> 00:50:34,650
this is going to be s0, a1, b2, c3.
这将是s0，a1，b2，c3。 

1266
00:50:34,849 --> 00:50:37,246
So, all the paths go ahead.
因此，所有的道路都是前进的。 

1267
00:50:37,246 --> 00:50:39,370
AUDIENCE: So, what if I wanted to find the shortest
听众：所以，如果我想找到最短的

1268
00:50:39,371 --> 00:50:41,280
path to s to b?
 s到b的路径？ 

1269
00:50:41,280 --> 00:50:43,279
Like, in terms of actually writing an algorithm,
就实际编写算法而言， 

1270
00:50:43,280 --> 00:50:46,250
would it be s0, a1, b2, or s1?
是s0，a1，b2还是s1？ 

1271
00:50:46,449 --> 00:50:46,966
a2, b3.
 a2，b3。 

1272
00:50:46,967 --> 00:50:47,550
PROFESSOR: OK.
教授：好的。 

1273
00:50:47,550 --> 00:50:49,675
So, if you actually want to read the shortest path,
因此，如果您实际上想读取最短路径， 

1274
00:50:49,675 --> 00:50:53,710
then the shortest path could have length 1, length 2,
那么最短路径的长度可能为1，长度为2 

1275
00:50:53,909 --> 00:50:55,000
or length 3, right?
或长度3，对不对？ 

1276
00:50:55,000 --> 00:50:55,820
I don't know.
我不知道。 

1277
00:50:55,820 --> 00:50:58,567
So I would have to look at all these.
所以我将不得不看所有这些。 

1278
00:50:58,567 --> 00:50:59,108
AUDIENCE: Oh.
听众：哦。 

1279
00:50:59,108 --> 00:51:01,568
OK.
好。 

1280
00:51:01,568 --> 00:51:04,590
So you just run it from s0 to any b, basically.
因此，基本上，您只需将其从s0运行到任意b。 

1281
00:51:04,789 --> 00:51:08,029
PROFESSOR: So, the algorithm that we have there computes
教授：所以，我们在那里计算的算法

1282
00:51:08,030 --> 00:51:10,769
the path from one source to everything else.
从一种来源到其他一切的路径。 

1283
00:51:10,969 --> 00:51:11,789
So I run it.
所以我运行它。 

1284
00:51:11,789 --> 00:51:12,730
It runs.
它运行。 

1285
00:51:12,730 --> 00:51:14,231
Computes all the shortest paths.
计算所有最短路径。 

1286
00:51:14,431 --> 00:51:15,889
And then I have to read these ones.
然后，我必须阅读这些内容。 

1287
00:51:15,889 --> 00:51:18,279
And get the smallest one.
并得到最小的。 

1288
00:51:18,280 --> 00:51:19,030
That's a question.
这是一个问题。 

1289
00:51:19,030 --> 00:51:21,019
Thank you.
谢谢。 

1290
00:51:21,019 --> 00:51:22,840
Yeah, that is a detail that I left out.
是的，这是我遗漏的细节。 

1291
00:51:22,840 --> 00:51:23,338
Thank you.
谢谢。 

1292
00:51:23,338 --> 00:51:27,960



1293
00:51:27,960 --> 00:51:28,769
So, no more cycles.
因此，不再需要任何周期。 

1294
00:51:28,769 --> 00:51:35,010



1295
00:51:35,010 --> 00:51:35,509
OK.
好。 

1296
00:51:35,510 --> 00:51:36,143
Any other questions?
还有其他问题吗？ 

1297
00:51:36,342 --> 00:51:38,701



1298
00:51:38,701 --> 00:51:39,199
Yes?
是？ 

1299
00:51:39,199 --> 00:51:41,698
AUDIENCE: I'm still, like, on the initial problem and stuff.
听众：我仍然喜欢最初的问题。 

1300
00:51:41,699 --> 00:51:43,550
A bit of a disconnect.
有点断开。 

1301
00:51:43,550 --> 00:51:46,610
When you were underlining stuff, like the sa,
当您强调诸如sa之类的内容时， 

1302
00:51:46,809 --> 00:51:49,889
it seemed to me that, like, in that case,
在我看来，在那种情况下， 

1303
00:51:49,889 --> 00:51:53,289
when you're going forward, you're never
当你前进时，你永远不会

1304
00:51:53,289 --> 00:51:57,429
going to stop because you're doing recursion.
将停止，因为您正在执行递归。 

1305
00:51:57,429 --> 00:52:01,329
So you never have a beginning point, almost.
因此，几乎没有一个起点。 

1306
00:52:01,329 --> 00:52:03,152
Effectively, if you, like--
实际上，如果您喜欢- 

1307
00:52:03,152 --> 00:52:04,289
PROFESSOR: So, do you mean here?
教授：那么，您的意思是这里吗？ 

1308
00:52:04,489 --> 00:52:05,363
AUDIENCE: Well, yeah.
听众：是的。 

1309
00:52:05,364 --> 00:52:08,614
PROFESSOR: So, in that case, this is the beginning point.
教授：那么，这就是起点。 

1310
00:52:08,614 --> 00:52:09,280
AUDIENCE: Right.
听众：对。 

1311
00:52:09,280 --> 00:52:11,780
PROFESSOR: If I go through the nodes in the topological sort
教授：如果我按照拓扑顺序遍历节点

1312
00:52:11,780 --> 00:52:15,070
order, then all I need is one beginning point.
订单，那么我所需要的只是一个起点。 

1313
00:52:15,070 --> 00:52:17,144
Because everything else will refer back to that.
因为其他所有内容都会参考该内容。 

1314
00:52:17,344 --> 00:52:19,569
There has to be a topological sort order.
必须有一个拓扑排序顺序。 

1315
00:52:19,570 --> 00:52:21,460
And the first node in that order is my source.
依次排列的第一个节点是我的来源。 

1316
00:52:21,659 --> 00:52:26,179



1317
00:52:26,179 --> 00:52:32,269
And, if we have cycles, then the beginning conditions are here.
而且，如果我们有周期，那么开始条件就在这里。 

1318
00:52:32,269 --> 00:52:34,190
So that's why I'm only drawing this vertex.
这就是为什么我只绘制此顶点。 

1319
00:52:34,190 --> 00:52:36,189
Because these other vertices wouldn't be useful.
因为这些其他顶点将无用。 

1320
00:52:36,190 --> 00:52:41,849



1321
00:52:41,849 --> 00:52:42,809
OK.
好。 

1322
00:52:42,809 --> 00:52:45,849
So then, that being said, don't forget your quizzes and happy
因此，话虽这么说，别忘了测验和快乐

1323
00:52:45,849 --> 00:52:50,849
Thanksgiving.
感恩。 

