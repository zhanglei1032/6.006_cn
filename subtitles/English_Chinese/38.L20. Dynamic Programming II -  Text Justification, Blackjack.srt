1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:22,536



10
00:00:22,536 --> 00:00:25,119
PROFESSOR: All right, today we continue our exciting adventure
教授：好的，今天我们继续激动人心的冒险

11
00:00:25,120 --> 00:00:27,320
into dynamic programming.
进入动态编程。 

12
00:00:27,320 --> 00:00:28,629
Are you excited?
你兴奋吗？ 

13
00:00:28,629 --> 00:00:31,809
I'm excited, super excited.
我很兴奋，非常兴奋。 

14
00:00:31,809 --> 00:00:34,189
Dynamic programming, as you recall way back
动态编程，回想起来

15
00:00:34,189 --> 00:00:37,919
before Thanksgiving, is a super exciting powerful technique
在感恩节之前，是一种非常令人兴奋的强大技术

16
00:00:37,920 --> 00:00:41,489
to design algorithms, especially to solve optimization problems
设计算法，尤其是解决优化问题

17
00:00:41,689 --> 00:00:44,669
where you want to maximize or minimize something.
您想最大化或最小化某物的地方。 

18
00:00:44,670 --> 00:00:48,500
Last time, we saw how two algorithms we already
上次，我们看到了两种算法

19
00:00:48,500 --> 00:00:52,380
knew-- namely, how to compute the nth Fibonacci number
知道-即如何计算第n个斐波那契数

20
00:00:52,380 --> 00:00:56,130
and how to compute shortest paths via Bellman-Ford--
以及如何通过Bellman-Ford计算最短路径- 

21
00:00:56,130 --> 00:00:58,780
are really dynamic programs in disguise.
是真正变相的动态程序。 

22
00:00:58,780 --> 00:01:01,270
And indeed for, at least for Bellman-Ford,
确实，至少对于贝尔曼·福特来说， 

23
00:01:01,270 --> 00:01:03,700
that's how they were invented, was
那是他们发明的方式

24
00:01:03,700 --> 00:01:05,170
to apply a general technique which
应用通用技术

25
00:01:05,170 --> 00:01:09,159
we're going to see today in full generality,
今天我们将全面了解

26
00:01:09,159 --> 00:01:11,239
more or less-- most of this is generality--
或多或少-其中大部分是笼统性- 

27
00:01:11,239 --> 00:01:13,229
in five easy steps.
只需五个简单步骤。 

28
00:01:13,230 --> 00:01:15,369
And we're going to see that technique applied
我们将看到该技术的应用

29
00:01:15,569 --> 00:01:17,839
to two new problems which are much more
两个新的问题

30
00:01:17,840 --> 00:01:20,399
interesting than the ones we've already solved-- namely,
比我们已经解决的解决方案更有趣- 

31
00:01:20,599 --> 00:01:23,169
how to make your text look nice in a paragraph,
如何使您的文字在段落中看起来不错， 

32
00:01:23,170 --> 00:01:24,659
where to break the lines.
在哪里打破界限。 

33
00:01:24,659 --> 00:01:26,319
That's text justification.
那是文字上的理由。 

34
00:01:26,319 --> 00:01:29,339
And how to win and make loads of money at blackjack.
以及如何在二十一点赢钱并赚钱。 

35
00:01:29,340 --> 00:01:31,950
So lots of practical stuff here, and we're
这里有很多实用的东西，我们

36
00:01:31,950 --> 00:01:35,980
going to see one new technique for
将会看到一种新技术

37
00:01:35,980 --> 00:01:37,619
general dynamic programming.
通用动态编程。 

38
00:01:37,819 --> 00:01:40,469
These are some things I wrote last time.
这些是我上次写的东西。 

39
00:01:40,469 --> 00:01:42,500
Actually, one of them I didn't write last time.
实际上，我上次没有写过其中一个。 

40
00:01:42,500 --> 00:01:44,500
In general, you can think of dynamic programming
通常，您可以想到动态编程

41
00:01:44,500 --> 00:01:47,719
as a carefully executed brute force search.
作为精心执行的蛮力搜索。 

42
00:01:47,719 --> 00:01:49,879
So in some sense, your algorithm is
所以从某种意义上说，您的算法是

43
00:01:49,879 --> 00:01:52,719
going to be trying all the possibilities,
将尝试所有可能性， 

44
00:01:52,719 --> 00:01:54,650
but somehow avoiding the fact that there
但以某种方式避免了存在

45
00:01:54,650 --> 00:01:56,349
are exponentially many of them.
数量成倍增加。 

46
00:01:56,549 --> 00:01:58,599
By thinking of it in a clever way,
通过巧妙的思考， 

47
00:01:58,599 --> 00:02:00,409
you can reduce the exponential search space
您可以减少指数搜索空间

48
00:02:00,409 --> 00:02:02,700
down to a polynomial one, even though you're still
降为多项式，即使您仍然

49
00:02:02,700 --> 00:02:05,289
not being very intelligent you're still blindly trying
不是很聪明，你还在盲目地尝试

50
00:02:05,489 --> 00:02:07,280
all possibilities.
所有的可能性。 

51
00:02:07,280 --> 00:02:10,629
So that's the brute force part.
这就是蛮力部分。 

52
00:02:10,629 --> 00:02:12,969
In more detail, the three main techniques
更详细地说，三种主要技术

53
00:02:12,969 --> 00:02:16,609
in dynamic programming are the idea of guessing, the idea
在动态编程中，是猜测的想法， 

54
00:02:16,610 --> 00:02:20,280
that, oh, I want to find the best way to solve a problem.
哦，我想找到解决问题的最佳方法。 

55
00:02:20,280 --> 00:02:23,740
Let's pick out some feature of the solution
让我们挑选解决方案的一些功能

56
00:02:23,740 --> 00:02:25,340
that I want to know.
我想知道的

57
00:02:25,539 --> 00:02:28,679
I don't know it, so I'll guess the answer--
我不知道，所以我猜答案- 

58
00:02:28,680 --> 00:02:32,340
meaning I'll try all the possibilities for that choice
意思是我会尝试所有可能的选择

59
00:02:32,539 --> 00:02:34,919
and take the best one.
并选出最好的一个。 

60
00:02:34,919 --> 00:02:38,019
So guessing is really central to dynamic programming.
因此，猜测对于动态编程至关重要。 

61
00:02:38,020 --> 00:02:42,240
Then we also use a recursion, some way
然后我们还使用某种方式的递归

62
00:02:42,240 --> 00:02:46,250
to express the solution to our problem in terms of solutions
用解决方案表达对我们问题的解决方案

63
00:02:46,250 --> 00:02:47,969
to sub-problems.
子问题。 

64
00:02:47,969 --> 00:02:50,118
So it's usually very easy to get a recursion
所以通常很容易获得递归

65
00:02:50,118 --> 00:02:51,659
for a lot of problems as long as they
只要有很多问题

66
00:02:51,659 --> 00:02:53,810
have some kind of substructure.
具有某种子结构。 

67
00:02:53,810 --> 00:02:56,189
Like shortest paths, we had that some paths of shortest paths
像最短路径一样，我们有一些最短路径

68
00:02:56,389 --> 00:02:59,309
were also shortest paths, so that was handy.
也是最短的路径，所以很方便。 

69
00:02:59,310 --> 00:03:02,189
Usually the recursion by itself is exponential time,
通常，递归本身就是指数时间， 

70
00:03:02,189 --> 00:03:04,139
like even with Fibonacci numbers.
甚至连斐波那契数也一样。 

71
00:03:04,139 --> 00:03:06,239
But we add in this technique of memoization,
但是我们添加了这种记忆技术， 

72
00:03:06,240 --> 00:03:09,280
which is just once we compute an answer we've stored in a lookup
这只是我们计算出存储在查询中的答案之后

73
00:03:09,479 --> 00:03:11,179
table, if we ever need that answer again
表，如果我们再次需要该答案

74
00:03:11,180 --> 00:03:13,900
we reuse it instead of recomputing it.
我们重用它而不是重新计算它。 

75
00:03:13,900 --> 00:03:14,969
So we store it.
因此，我们将其存储。 

76
00:03:15,169 --> 00:03:19,609
We write down in our memo pad anything that we compute.
我们在记事本中写下我们计算的任何内容。 

77
00:03:19,610 --> 00:03:22,360
Those techniques, all these techniques together
这些技术，所有这些技术加在一起

78
00:03:22,360 --> 00:03:24,610
give you, typically, a polynomial time
通常为您提供多项式时间

79
00:03:24,610 --> 00:03:26,680
dynamic program-- when they work, of course.
动态程序-当然可以。 

80
00:03:26,879 --> 00:03:29,500
Memoization makes the recursion polynomial time.
记忆使递归多项式时间变长。 

81
00:03:29,500 --> 00:03:33,259
The guessing is what is doing a brute force search.
猜测是在进行暴力搜索。 

82
00:03:33,259 --> 00:03:37,609
And magically, it all works if you're careful.
而且，神奇的是，如果您小心翼翼，一切都会奏效。 

83
00:03:37,610 --> 00:03:41,197
Another perspective-- kind of an orthogonal perspective
另一个视角-一种正交视角

84
00:03:41,396 --> 00:03:43,479
or another way of thinking about it, which I think
或另一种思考方式，我认为

85
00:03:43,479 --> 00:03:45,145
should be comfortable for you because we
应该让您感到舒适，因为我们

86
00:03:45,145 --> 00:03:47,429
spent a lot of time doing shortest paths
花了很多时间做最短的路径

87
00:03:47,430 --> 00:03:50,530
and expressing problems that we care about in terms of shortest
并用最短的时间表达我们关心的问题

88
00:03:50,729 --> 00:03:53,750
paths even if they don't look like it at first glance--
路径，即使乍一看也不像， 

89
00:03:53,750 --> 00:03:55,340
dynamic programming in some sense
某种意义上的动态编程

90
00:03:55,340 --> 00:04:00,079
is always computing shortest paths in a DAG.
总是在DAG中计算最短路径。 

91
00:04:00,079 --> 00:04:01,870
So you have some problem you want to solve,
所以您有一些要解决的问题， 

92
00:04:01,870 --> 00:04:05,020
like you have text you want to split up into lines so it looks
就像您要分割成几行的文本一样

93
00:04:05,020 --> 00:04:10,900
nice in a paragraph, you express that problem somehow
一段很不错，您以某种方式表达了这个问题

94
00:04:11,099 --> 00:04:13,530
as a directed acyclic graph.
作为有向无环图。 

95
00:04:13,530 --> 00:04:15,620
And then we know how to compute shortest path
然后我们知道如何计算最短路径

96
00:04:15,620 --> 00:04:18,160
in directed acyclic graphs in linear time.
在线性时间的有向无环图中。 

97
00:04:18,160 --> 00:04:21,019
And that's basically what dynamic programming is doing.
这基本上就是动态编程正在做的事情。 

98
00:04:21,019 --> 00:04:23,759
I didn't realize this until last week,
直到上周我才意识到这一点， 

99
00:04:23,759 --> 00:04:24,990
so this is a new perspective.
所以这是一个新观点。 

100
00:04:24,990 --> 00:04:26,399
It's an experimental perspective.
这是实验性的观点。 

101
00:04:26,399 --> 00:04:27,439
But I think it's helpful.
但我认为这很有帮助。 

102
00:04:27,439 --> 00:04:30,910
It's actually-- dynamic programming is not that new.
实际上，动态编程并不是那么新。 

103
00:04:30,910 --> 00:04:33,500
It's all about how to be clever in setting up that DAG.
这是关于如何聪明地设置DAG的全部内容。 

104
00:04:33,699 --> 00:04:37,680
But in the end, the algorithm is very simple.
但是最后，该算法非常简单。 

105
00:04:37,680 --> 00:04:41,300
And then we had this other perspective--
然后我们有了另一种观点

106
00:04:41,300 --> 00:04:43,579
back to this perspective, I guess.
回到这个角度，我猜。 

107
00:04:43,579 --> 00:04:47,019
In general, we have-- the real problem we want to solve,
总的来说，我们有-我们要解决的真正问题， 

108
00:04:47,019 --> 00:04:50,560
we generalize it in some sense by considering
我们在某种意义上通过考虑

109
00:04:50,560 --> 00:04:53,750
lots of different sub-problems that we might care about.
许多我们可能关心的子问题。 

110
00:04:53,750 --> 00:04:56,699
Like with Fibonacci, we had the nth Fibonacci number.
与斐波那契一样，我们有第n个斐波那契数。 

111
00:04:56,699 --> 00:04:59,081



112
00:04:59,081 --> 00:05:01,040
We really just wanted the nth Fibonacci number.
我们真的只想要第n个斐波那契数。 

113
00:05:01,040 --> 00:05:04,410
But along the way, we're going to compute all f1 up to fn.
但是在此过程中，我们将计算所有f1到fn。 

114
00:05:04,410 --> 00:05:06,430
So those are our sub-problems.
这些就是我们的子问题。 

115
00:05:06,430 --> 00:05:08,180
And if we compute the amount of time
如果我们计算时间量

116
00:05:08,180 --> 00:05:10,389
we need to solve each sub-problem
我们需要解决每个子问题

117
00:05:10,389 --> 00:05:12,680
and multiply that by the number of sub-problems we get,
并乘以我们得到的子问题的数量， 

118
00:05:12,680 --> 00:05:14,699
the total time required by the algorithm.
算法所需的总时间。 

119
00:05:14,899 --> 00:05:18,129
This is a general true fact.
这是一个普遍的真实事实。 

120
00:05:18,129 --> 00:05:21,709
And the fun part here is we get to treat any recursive calls
这里有趣的部分是我们可以处理任何递归调用

121
00:05:21,709 --> 00:05:26,009
in this recursion as free, as constant time,
在此递归中，它是自由的，恒定的时间， 

122
00:05:26,009 --> 00:05:29,310
because we really only pay for it first time.
因为我们真的只是第一次付款。 

123
00:05:29,310 --> 00:05:30,990
That's counted out here.
在这里算出来。 

124
00:05:30,990 --> 00:05:33,360
The second time we call it, it's already memoized,
我们第二次称呼它已经被记住， 

125
00:05:33,360 --> 00:05:36,300
so we don't have to pay for it.
因此我们不必为此付费。 

126
00:05:36,300 --> 00:05:38,430
So this is, in some sense, an amortization,
因此，从某种意义上讲，这是摊销， 

127
00:05:38,430 --> 00:05:42,100
if you remember amortization from table doubling.
如果您还记得表加倍的摊销。 

128
00:05:42,100 --> 00:05:43,829
We're just changing around when we
我们只是在改变时

129
00:05:44,029 --> 00:05:46,000
count the cost of each sub-problem,
计算每个子问题的成本， 

130
00:05:46,000 --> 00:05:49,389
and then this is the total running time.
这就是总的运行时间

131
00:05:49,389 --> 00:05:53,300
OK, so that's the spirit we saw already.
好的，这就是我们已经看到的精神。 

132
00:05:53,300 --> 00:05:55,180
I'm going to give you the five general steps,
我将给您五个一般步骤， 

133
00:05:55,180 --> 00:05:59,699
and then we're going to apply them to two new problems.
然后我们将它们应用于两个新问题。 

134
00:05:59,699 --> 00:06:07,589
So five easy steps to dynamic programming.
因此，进行动态编程的五个简单步骤。 

135
00:06:07,589 --> 00:06:13,973



136
00:06:13,973 --> 00:06:16,389
Unfortunately, these are not necessarily sequential steps.
不幸的是，这些不一定是顺序步骤。 

137
00:06:16,389 --> 00:06:17,979
They're a little bit interdependent,
它们有点相互依存， 

138
00:06:17,980 --> 00:06:21,189
and so "easy" should be in quotes.
因此，“ easy”应该用引号引起来。 

139
00:06:21,389 --> 00:06:26,509
This is how you would express a dynamic program,
这就是表达动态程序的方式， 

140
00:06:26,509 --> 00:06:29,550
and in some sense how you'd invent one,
从某种意义上讲，您将如何发明一个， 

141
00:06:29,550 --> 00:06:32,740
but in particular how you would explain one.
但特别是您将如何解释。 

142
00:06:32,740 --> 00:06:35,800
OK, let me get to the main steps first.
好的，让我先进入主要步骤。 

143
00:06:35,800 --> 00:06:42,889



144
00:06:42,889 --> 00:06:46,229
First step is to figure out what your sub-problems are
第一步是弄清楚您的子问题是什么

145
00:06:46,230 --> 00:06:48,540
going to be.
将。 

146
00:06:48,540 --> 00:06:51,079
Second part is to guess something.
第二部分是猜测。 

147
00:06:51,279 --> 00:06:59,779
Third step is to relate sub-problem solutions, usually
第三步通常是关联子问题解决方案

148
00:06:59,779 --> 00:07:02,609
with a recurrence.
复发。 

149
00:07:02,610 --> 00:07:03,985
I guess always with a recurrence.
我猜总是会复发。 

150
00:07:03,985 --> 00:07:08,100



151
00:07:08,100 --> 00:07:11,595
Fourth step is to actually build an algorithm.
第四步是实际构建算法。 

152
00:07:11,595 --> 00:07:20,730



153
00:07:20,730 --> 00:07:22,500
And we saw two ways to do that last time.
我们上次看到了两种方法来做到这一点。 

154
00:07:22,699 --> 00:07:24,969
One is to use recursion and memoization, which
一种是使用递归和记忆， 

155
00:07:24,970 --> 00:07:26,470
is the way I like to think about it.
是我喜欢考虑的方式。 

156
00:07:26,470 --> 00:07:32,949
But if you prefer, you can follow the bottom up approach.
但是，如果您愿意，可以遵循自下而上的方法。 

157
00:07:33,149 --> 00:07:35,904
And usually that's called building a table.
通常，这称为建立表格。 

158
00:07:35,904 --> 00:07:40,909



159
00:07:40,910 --> 00:07:43,430
And that one's basically to turn our recursion and memoization,
基本上是要改变我们的递归和记忆， 

160
00:07:43,629 --> 00:07:46,680
which is kind of fancy, into a bunch
有点花哨，成一堆

161
00:07:46,680 --> 00:07:48,790
of for loops, which is pretty simple.
 for循环，这非常简单。 

162
00:07:48,790 --> 00:07:52,550
And this is going to be more practical, faster, and so on.
这将更加实用，更快，等等。 

163
00:07:52,550 --> 00:07:54,680
And depending on your preference, one of them
根据您的喜好，其中之一

164
00:07:54,680 --> 00:07:56,290
is more intuitive than the other.
比其他人更直观。 

165
00:07:56,290 --> 00:07:57,060
It doesn't matter.
没关系

166
00:07:57,060 --> 00:08:02,305
They have the same running time, more or less,
它们或多或少具有相同的运行时间， 

167
00:08:02,305 --> 00:08:03,419
in the worst case.
在最坏的情况下。 

168
00:08:03,420 --> 00:08:07,860



169
00:08:07,860 --> 00:08:10,694
Then the fifth step is to solve the original problem.
然后，第五步是解决原始问题。 

170
00:08:10,894 --> 00:08:18,945



171
00:08:18,946 --> 00:08:22,670
All right, so we've sort of seen this before.
好吧，所以我们以前已经看到过这种情况。 

172
00:08:22,670 --> 00:08:25,740
In fact I have, over here, a convenient table.
实际上，我在这里有一张方便的桌子。 

173
00:08:25,740 --> 00:08:28,319



174
00:08:28,319 --> 00:08:30,519
It's called cheating.
这就是所谓的作弊。 

175
00:08:30,519 --> 00:08:32,924
The two problems we saw last time, Fibonacci numbers
我们上次看到的两个问题，斐波那契数

176
00:08:32,924 --> 00:08:34,928
and shortest paths.
和最短的路径。 

177
00:08:34,928 --> 00:08:36,839
And I've got steps one, two, three,
我已经完成了第一，第二，第三步， 

178
00:08:36,840 --> 00:08:39,440
four-- I ran out of room, so I didn't write five yet.
四个-我没房间了，所以我还没写五个。 

179
00:08:39,440 --> 00:08:40,690
But we'll get there.
但是我们会到达那里。 

180
00:08:40,690 --> 00:08:42,689
So what are our sub-problems?
那么我们的子问题是什么？ 

181
00:08:42,889 --> 00:08:47,429
Well, for Fibonacci, they were f1 through fn.
好吧，对于斐波那契来说，他们是f1到fn。 

182
00:08:47,429 --> 00:08:49,299
So there were n different sub-problems.
因此，存在n个不同的子问题。 

183
00:08:49,299 --> 00:08:53,009
And in general because of this formula,
通常，由于这个公式， 

184
00:08:53,009 --> 00:08:57,360
we want to count how many sub-problems are there.
我们要计算那里有多少个子问题。 

185
00:08:57,360 --> 00:09:07,830
So number of sub-problems is-- this
所以子问题的数量是

186
00:09:07,830 --> 00:09:10,610
is what we need to do algorithmically.
这是我们需要做的算法。 

187
00:09:10,610 --> 00:09:13,129
And then for analysis, we want to counter
然后为了分析，我们想对付

188
00:09:13,129 --> 00:09:15,639
number of sub-problems for step one.
第一步的子问题数量。 

189
00:09:15,639 --> 00:09:17,679
And so for Fibonacci there were n of them.
因此，对于斐波那契来说，其中有n个。 

190
00:09:17,679 --> 00:09:24,489
For shortest paths, we defined this delta sub k of sv.
对于最短路径，我们定义了sv的delta sub k。 

191
00:09:24,490 --> 00:09:26,259
This was the shortest path from s
这是距离s的最短路径

192
00:09:26,259 --> 00:09:29,169
to v they uses at most k edges.
到v，他们最多使用k个边。 

193
00:09:29,169 --> 00:09:31,839
That was sort of what Bellman-Ford was doing.
这就是贝尔曼·福特所做的事情。 

194
00:09:31,840 --> 00:09:34,690
And the number of different sub-problems
和不同的子问题数量

195
00:09:34,690 --> 00:09:37,990
here was v squared, because we had to do this for every vertex
这是v平方的，因为我们必须对每个顶点执行此操作

196
00:09:37,990 --> 00:09:41,659
v and we had to do it for every value of k between 0
 v，我们必须对0之间的k的每个值执行此操作

197
00:09:41,659 --> 00:09:44,850
and v minus 1. v minus was is the number of rounds
和v减1。v减是轮数

198
00:09:44,850 --> 00:09:46,970
we need in Bellman-Ford.
我们需要贝尔曼福特公司。 

199
00:09:46,970 --> 00:09:50,720
So it's v times v, different sub-problems,
这是v乘以v，不同的子问题， 

200
00:09:50,720 --> 00:09:52,460
b squared of them.
 b平方它们。 

201
00:09:52,460 --> 00:09:56,339
OK, second thing was we wanted to solve our problem.
好的，第二件事是我们想解决我们的问题。 

202
00:09:56,539 --> 00:10:00,990
And we do that by guessing some feature of the solution.
我们通过猜测解决方案的某些功能来做到这一点。 

203
00:10:00,990 --> 00:10:03,149
In Fibonacci, there was no guessing.
在斐波那契，没有猜测。 

204
00:10:03,149 --> 00:10:06,360
So the number of different choices for your guess is one.
因此，供您猜测的不同选择数是一个。 

205
00:10:06,360 --> 00:10:07,190
There's nothing.
什么也没有。 

206
00:10:07,190 --> 00:10:11,120
There's only one choice, which is to do nothing.
只有一种选择，就是什么都不做。 

207
00:10:11,120 --> 00:10:15,279
And for shortest paths, what we guessed was--
对于最短的路径，我们猜测是- 

208
00:10:15,279 --> 00:10:18,799
we know we're looking for some path from s v. B Let's guess
我们知道我们正在寻找s v。B的一些路径

209
00:10:18,799 --> 00:10:21,219
what the last edge is.
最后的优势是什么。 

210
00:10:21,220 --> 00:10:25,019
There's some last edge from u to v,
从u到v还有最后一个优势， 

211
00:10:25,019 --> 00:10:27,139
assuming the path has more than one edge-- or more
假设路径具有多个边缘-或更多

212
00:10:27,139 --> 00:10:29,330
than zero edges.
比零边缘。 

213
00:10:29,330 --> 00:10:31,230
When could the edge possibly be?
什么时候可能成为优势？ 

214
00:10:31,230 --> 00:10:33,889
Well, it's some incoming edge to v.
好吧，这是v的一些优势。 

215
00:10:33,889 --> 00:10:36,419
So there's going to be indegree of v different choices
所以会有v个不同的选择

216
00:10:36,419 --> 00:10:37,740
for that.
为了那个原因。 

217
00:10:37,740 --> 00:10:41,279
And to account for the case that that's zero, we do a plus 1.
考虑到零的情况，我们加一。 

218
00:10:41,279 --> 00:10:43,789
But that's not a big deal.
但这没什么大不了的。 

219
00:10:43,789 --> 00:10:47,559
So that was the number of different choices.
这就是不同选择的数量。 

220
00:10:47,559 --> 00:10:49,639
In general if we're going to guess something,
一般来说，如果我们要猜测一些东西， 

221
00:10:49,639 --> 00:10:55,456
we need to write down the number of choices.
我们需要写下选择的数量。 

222
00:10:55,456 --> 00:10:59,109
For the guess, how many different possibilities
猜测，有多少种不同的可能性

223
00:10:59,309 --> 00:11:01,250
are there?
在那儿？ 

224
00:11:01,250 --> 00:11:04,620
That's our analysis.
那就是我们的分析。 

225
00:11:04,620 --> 00:11:09,149
OK, the next thing is the recurrence.
好，接下来就是复发了。 

226
00:11:09,149 --> 00:11:10,750
That's step three.
那是第三步。 

227
00:11:10,750 --> 00:11:13,200
We want to relate all the sub-problem solutions
我们要关联所有子问题解决方案

228
00:11:13,200 --> 00:11:14,109
to each other.
对彼此。 

229
00:11:14,309 --> 00:11:15,864
For Fibonacci, that's the definition
对于斐波那契，那就是定义

230
00:11:15,865 --> 00:11:16,740
of Fibonacci numbers.
斐波那契数。 

231
00:11:16,740 --> 00:11:18,979
So it's really easy.
因此，这真的很容易。 

232
00:11:19,179 --> 00:11:22,774
For shortest paths, we wrote this min.
对于最短的路径，我们写了这个分钟。 

233
00:11:22,774 --> 00:11:25,178
In general, typically it's a min or a max,
通常，通常是最小值或最大值， 

234
00:11:25,178 --> 00:11:26,720
whatever you're trying to solve here.
无论您要在这里解决什么。 

235
00:11:26,720 --> 00:11:28,830
We're doing shortest paths.
我们正在做最短的路径。 

236
00:11:28,830 --> 00:11:31,579
You could do longest paths in the same way.
您可以用相同的方式做最长的路径。 

237
00:11:31,779 --> 00:11:36,549
So you compute them in of delta sub sk minus 1 of su.
因此，您用delta sub sk减去su 1来计算它们。 

238
00:11:36,549 --> 00:11:41,245
The idea is we want to compute this part of the path, the s
想法是我们要计算路径的这一部分s 

239
00:11:41,245 --> 00:11:42,450
to u part.
给你一部分。 

240
00:11:42,450 --> 00:11:44,970
And we know that has one fewer edge, because we just
而且我们知道这少了一点优势，因为我们只是

241
00:11:44,970 --> 00:11:46,975
guessed what the last edge was.
猜到最后的优势是什么。 

242
00:11:46,975 --> 00:11:49,100
Except we don't really know what the last edge was,
除非我们真的不知道最后的优势是什么， 

243
00:11:49,100 --> 00:11:50,250
so we have to try them all.
所以我们必须全部尝试。 

244
00:11:50,250 --> 00:11:54,379
We try all the incoming edges into v-- that's this part--
我们将所有传入的边尝试成v-这就是这一部分- 

245
00:11:54,379 --> 00:11:56,809
and for each of them we compute--
我们为每个人计算- 

246
00:11:56,809 --> 00:11:58,769
I forgot something here.
我在这里忘记了一些东西。 

247
00:11:58,769 --> 00:12:01,360
This is the cost of the first part of the path.
这是路径第一部分的成本。 

248
00:12:01,360 --> 00:12:05,470
Then I also need to do plus the weight of the uv edge.
然后，我还需要加上uv边缘的重量。 

249
00:12:05,470 --> 00:12:09,080
That will be the total cost of that path.
那就是那条道路的总成本。 

250
00:12:09,080 --> 00:12:12,350
You add those up, you do it for every incoming edge.
您将这些累加起来，就可以对每个传入的边缘进行处理。 

251
00:12:12,350 --> 00:12:16,250
That is, in some sense, considering all possible paths.
也就是说，在某种意义上，考虑所有可能的路径。 

252
00:12:16,250 --> 00:12:18,250
Assuming you find the shortest path from s to u,
假设您找到了从s到u的最短路径， 

253
00:12:18,250 --> 00:12:20,360
that's going to be the best way to get there.
那将是到达那里的最好方法。 

254
00:12:20,360 --> 00:12:25,379
And then use some edge from u to v for some choice of u.
然后使用从u到v的边来选择u。 

255
00:12:25,379 --> 00:12:26,500
This will try all of them.
这将尝试所有这些。 

256
00:12:26,500 --> 00:12:28,332
So it's really trying all the possibilities.
因此，它确实在尝试所有可能性。 

257
00:12:28,332 --> 00:12:30,635
So it's pretty clear this is correct
所以很明显这是正确的

258
00:12:30,635 --> 00:12:32,259
if there are no negative weight cycles.
如果没有负体重循环。 

259
00:12:32,259 --> 00:12:33,509
You have to prove some things.
你必须证明一些事情。 

260
00:12:33,509 --> 00:12:35,840
We've already proved them.
我们已经证明了它们。 

261
00:12:35,840 --> 00:12:40,389
It's just slow, but once you add memoization, it's fast.
这只是很慢，但是一旦添加了备忘录，它就会很快。 

262
00:12:40,389 --> 00:12:44,299
Now, how long does it take to evaluate this recurrence,
现在，评估这种复发需要多长时间， 

263
00:12:44,299 --> 00:12:46,379
constant time, if you don't count the recursive
固定时间，如果不计算递归

264
00:12:46,379 --> 00:12:48,629
calls or count them as constant?
打电话还是算他们不变？ 

265
00:12:48,629 --> 00:12:52,769
Over here, we're taking a min over n degree of v things.
在这里，我们要花最少的时间处理n个v事物。 

266
00:12:52,769 --> 00:12:56,210
So we have to pay n degree of v time,
因此，我们必须付出n倍的v时间， 

267
00:12:56,210 --> 00:12:58,019
again the recursions as free.
再次将递归视为免费。 

268
00:12:58,019 --> 00:13:00,620
But for each one of them, we have to do an addition.
但是对于其中每个，我们都必须做一个附加。 

269
00:13:00,620 --> 00:13:04,258
So it's constant work per guess.
因此，每个猜测都是不断的工作。 

270
00:13:04,458 --> 00:13:05,500
And this is quite common.
这很普遍。 

271
00:13:05,500 --> 00:13:09,110
Often, the number of guesses and the running time
通常，猜测次数和运行时间

272
00:13:09,110 --> 00:13:11,553
per sub-problem are the same, the constant factors.
每个子问题都相同，是不变的因素。 

273
00:13:11,553 --> 00:13:12,720
Sometimes they're different.
有时它们是不同的。 

274
00:13:12,720 --> 00:13:15,860
We'll see some examples today.
今天我们将看到一些示例。 

275
00:13:15,860 --> 00:13:17,065
OK, step four.
好，第四步。 

276
00:13:17,065 --> 00:13:19,700



277
00:13:19,700 --> 00:13:20,220
Let's see.
让我们来看看。 

278
00:13:20,220 --> 00:13:24,769
So here we evaluate the time per sub-problem.
因此，这里我们评估每个子问题的时间。 

279
00:13:24,769 --> 00:13:26,949
Once you have the recurrence, that becomes clear.
一旦复发，那就很清楚了。 

280
00:13:26,950 --> 00:13:29,129
You want to make sure that's polynomial.
您要确保它是多项式。 

281
00:13:29,129 --> 00:13:30,450
Often these are the same.
通常这些都是一样的。 

282
00:13:30,450 --> 00:13:33,709



283
00:13:33,909 --> 00:13:38,062
And then we add the recursive memorize or build a DP table.
然后我们添加递归记忆或构建一个DP表。 

284
00:13:38,062 --> 00:13:39,269
I'm not going to write those.
我不会写那些。 

285
00:13:39,269 --> 00:13:41,579
We did it for Fibonacci last time, shortest paths.
我们上次为斐波那契做的是最短的路径。 

286
00:13:41,580 --> 00:13:43,579
Pretty easy.
相当容易。 

287
00:13:43,779 --> 00:13:49,470
And in general, what we need to check here
通常，我们需要在此处检查什么

288
00:13:49,470 --> 00:13:55,000
is that the sub problem recurrence is acyclic.
子问题重复发生是非周期性的。 

289
00:13:55,000 --> 00:14:04,750



290
00:14:04,750 --> 00:14:08,259
In other words, that it has a topological order so
换句话说，它具有拓扑顺序

291
00:14:08,259 --> 00:14:11,399
we can use topological sort.
我们可以使用拓扑排序。 

292
00:14:11,399 --> 00:14:14,110
We don't actually use topological algorithm usually.
实际上，通常我们实际上并不使用拓扑算法。 

293
00:14:14,110 --> 00:14:16,225
You can just think about it.
您可以考虑一下。 

294
00:14:16,225 --> 00:14:17,600
In the case of Fibonacci numbers,
对于斐波那契数， 

295
00:14:17,600 --> 00:14:19,229
it's clear you want to start with the smallest one
很明显，您想从最小的一个开始

296
00:14:19,429 --> 00:14:20,429
and end up with the biggest one.
并得到最大的一个。 

297
00:14:20,429 --> 00:14:22,309
You can't do the reverse, because then when
你不能做相反的事情，因为那时候

298
00:14:22,309 --> 00:14:24,683
you're trying to computer the nth you don't have the ones
您正在尝试使用第n台计算机，而没有

299
00:14:24,683 --> 00:14:26,490
you need, the n minus 1 and n minus 2.
您需要n减1和n减2。 

300
00:14:26,490 --> 00:14:28,240
But if you do it in this order, you always
但是，如果按此顺序执行操作， 

301
00:14:28,240 --> 00:14:30,359
have the one you need by the time you get there.
到达目的地时就拥有您需要的那个。 

302
00:14:30,559 --> 00:14:33,629
In general, there's a DAG there--
一般来说，那里有一个DAG 

303
00:14:33,629 --> 00:14:40,450
and for Fibonacci, it was like this.
对斐波那契来说，就是这样。 

304
00:14:40,450 --> 00:14:42,080
Every node depends on the previous
每个节点都取决于前一个

305
00:14:42,080 --> 00:14:44,469
and the second previous.
和第二个。 

306
00:14:44,669 --> 00:14:46,569
But you just choose a topological order,
但是您只需选择一个拓扑顺序， 

307
00:14:46,570 --> 00:14:50,740
which is here left to right, and you're golden.
从左到右，这是您的黄金。 

308
00:14:50,740 --> 00:14:52,240
And these are actually the for loops
这些实际上是for循环

309
00:14:52,240 --> 00:14:54,395
you get in the bottom of DP.
您进入了DP的底部。 

310
00:14:54,395 --> 00:14:56,519
For shortest paths, you have to think a little bit.
对于最短的路径，您必须考虑一下。 

311
00:14:56,519 --> 00:15:00,159
You have to do the for loop over k on the outside,
您必须在外部对k进行for循环， 

312
00:15:00,159 --> 00:15:01,769
the for loop over V on the inside.
内部的V上的for循环。 

313
00:15:01,769 --> 00:15:04,370
The reverse does not work.
反之则不起作用。 

314
00:15:04,370 --> 00:15:07,379
I won't go through that, but we drew the DAG last time.
我不会讲这个，但是上次我们画了DAG。 

315
00:15:07,379 --> 00:15:10,549
And that's the main thing you need to do here.
这就是您在这里要做的主要事情。 

316
00:15:10,549 --> 00:15:12,709
And then, of course, you use this formula
然后，当然，您可以使用以下公式

317
00:15:12,710 --> 00:15:16,820
to compute the overall running time, which is just multiplying
计算总的运行时间，这只是相乘

318
00:15:16,820 --> 00:15:19,309
this quantity with this quantity.
这个数量与此数量。 

319
00:15:19,509 --> 00:15:25,350



320
00:15:25,350 --> 00:15:28,730
Total time.
总时间。 

321
00:15:28,730 --> 00:15:30,601
Then there's just one last step that
然后只有最后一步

322
00:15:30,601 --> 00:15:33,059
usually isn't that big a deal, but you have think about it.
通常没什么大不了的，但是您已经考虑过了。 

323
00:15:33,059 --> 00:15:35,184
You need to make sure that the problem you actually
您需要确保您实际遇到的问题

324
00:15:35,184 --> 00:15:37,819
cared about solving gets solved.
关心解决就解决了。 

325
00:15:37,820 --> 00:15:40,230
In the case of Fibonacci and shortest paths,
对于斐波那契和最短路径， 

326
00:15:40,230 --> 00:15:41,580
this is pretty clear.
这很清楚。 

327
00:15:41,580 --> 00:15:42,330
I didn't write it.
我没写

328
00:15:42,330 --> 00:15:46,623



329
00:15:46,623 --> 00:15:49,710
We can do it on here.
我们可以在这里做。 

330
00:15:49,710 --> 00:15:50,845
Solve the original problem.
解决原来的问题。 

331
00:15:50,845 --> 00:15:54,580



332
00:15:54,580 --> 00:15:55,879
Fibonaci, it is Fn.
斐波那契，是Fn。 

333
00:15:55,879 --> 00:15:57,460
And this is one of our sub-problems,
这是我们的子问题之一， 

334
00:15:57,460 --> 00:15:59,360
so if we solve all of them, we're done.
因此，如果我们解决所有问题，我们就完成了。 

335
00:15:59,360 --> 00:16:01,259
For shortest paths, it's basically
对于最短的路径，基本上

336
00:16:01,259 --> 00:16:10,350
delta sub v minus 1 of sv for all v. That's
所有v的delta sub v减去sv的1。 

337
00:16:10,350 --> 00:16:12,100
single source shortest paths.
单源最短路径。 

338
00:16:12,100 --> 00:16:13,990
And by our Bellman-Ford analysis,
根据我们的Bellman-Ford分析， 

339
00:16:13,990 --> 00:16:15,879
that gives us the right shortest paths.
这给了我们正确的最短路径。 

340
00:16:15,879 --> 00:16:17,590
There are no negative weight cycles.
没有负重量循环。 

341
00:16:17,590 --> 00:16:22,219
And sometimes this requires extra time
有时这需要额外的时间

342
00:16:22,419 --> 00:16:25,000
to combine your solutions to get the real thing.
结合您的解决方案以获得真实的东西。 

343
00:16:25,000 --> 00:16:29,220
Here of course, we just have the answers, so writing them down
当然，在这里，我们只有答案，所以写下来

344
00:16:29,220 --> 00:16:31,609
does not take very long.
不需要很长时间。 

345
00:16:31,809 --> 00:16:35,099
So that's the dominant running time-- which I didn't write,
这就是主要的运行时间-我没有写， 

346
00:16:35,100 --> 00:16:38,779
I should have written in under for here-- this ends up
我应该在下面写下来-这最终

347
00:16:38,779 --> 00:16:42,600
being n, this ends up being VE.
为n，则最终为VE。 

348
00:16:42,600 --> 00:16:45,279



349
00:16:45,279 --> 00:16:47,529
OK, I don't want to spend more time on those examples.
好的，我不想在这些示例上花费更多的时间。 

350
00:16:47,529 --> 00:16:48,487
Let's go to new things.
让我们去看看新事物。 

351
00:16:48,488 --> 00:17:07,410



352
00:17:07,410 --> 00:17:11,210
So first problem we're going to look at today
所以第一个问题我们今天要看

353
00:17:11,210 --> 00:17:12,044
is text justification.
是文本对齐。 

354
00:17:12,244 --> 00:17:21,219



355
00:17:21,220 --> 00:17:23,970
And the informal statement of this problem
关于这个问题的非正式陈述

356
00:17:23,970 --> 00:17:26,309
is you're given some text-- which
给你一些文字吗？ 

357
00:17:26,309 --> 00:17:30,169
means a string, a whole bunch of characters.
表示字符串，一串完整的字符。 

358
00:17:30,170 --> 00:17:32,994
And we want to split them into good lines.
我们希望将它们划分为好线。 

359
00:17:33,194 --> 00:17:36,129



360
00:17:36,130 --> 00:17:39,410
The rules of the game here are we're going to,
我们将要遵循的游戏规则

361
00:17:39,410 --> 00:17:41,720
like in the early lectures of document distance
就像早期文件距离讲座

362
00:17:41,720 --> 00:17:44,319
where you have some definition of splitting
您对拆分有一些定义

363
00:17:44,319 --> 00:17:48,789
a document into words separated by spaces.
将文档分成用空格隔开的单词。 

364
00:17:48,789 --> 00:17:51,980
And what we want to do is cut.
而我们要做的就是削减。 

365
00:17:51,980 --> 00:17:54,970
We can only cut between word boundaries.
我们只能在单词边界之间切换。 

366
00:17:54,970 --> 00:17:58,630
And we want to write some text, it's
我们想写一些文字， 

367
00:17:58,630 --> 00:18:00,160
going to have some spaces in it.
里面会有一些空间。 

368
00:18:00,160 --> 00:18:06,269
Then there's a new line, something like that.
然后有一个新行，像这样。 

369
00:18:06,269 --> 00:18:09,536
And we want to justify our text on the right here.
我们想在这里证明我们的文字正确。 

370
00:18:09,536 --> 00:18:11,910
And so we'd like to avoid big gaps like this because they
因此，我们希望避免这样的巨大差距，因为它们

371
00:18:11,910 --> 00:18:15,129
look ugly, they're hard to read.
看起来很丑，很难看。 

372
00:18:15,329 --> 00:18:20,069
Now, if you use Microsoft Word-- at least
现在，如果您使用Microsoft Word，至少

373
00:18:20,069 --> 00:18:22,399
before the latest versions-- they
在最新版本之前-他们

374
00:18:22,400 --> 00:18:24,440
follow a greedy strategy, which is very simple.
遵循贪婪的策略，这很简单。 

375
00:18:24,440 --> 00:18:26,710
You pack as many words as you can on the first line,
您可以在第一行尽可能多地打包单词， 

376
00:18:26,710 --> 00:18:28,710
then you go to the next line, pack as many words
然后您转到下一行，打包尽可能多的单词

377
00:18:28,710 --> 00:18:30,269
as you can on the second line.
就像您在第二行一样

378
00:18:30,269 --> 00:18:31,720
Keep going like that.
继续这样下去。 

379
00:18:31,720 --> 00:18:34,900
And that strategy is not optimal.
而且这种策略不是最佳的。 

380
00:18:34,900 --> 00:18:37,869
If you use LaTeX-- as some of you
如果您使用LaTeX-- 

381
00:18:38,069 --> 00:18:41,099
have been doing on problem sets, and I think also new versions
一直在做问题集，我想也是新版本

382
00:18:41,099 --> 00:18:43,839
of Word but I'm not sure-- then it
 Word，但我不确定-那么

383
00:18:43,839 --> 00:18:46,139
uses dynamic programming to solve this problem.
使用动态编程来解决此问题。 

384
00:18:46,140 --> 00:18:48,380
And that's what we're going to do here.
这就是我们在这里要做的。 

385
00:18:48,380 --> 00:18:53,359
So let me specify a little bit more about what we mean here.
因此，让我再详细说明一下我们的意思。 

386
00:18:53,559 --> 00:18:57,054
So the text we're going to think of as a list of words.
因此，我们将文本视为单词列表。 

387
00:18:57,055 --> 00:19:01,009



388
00:19:01,009 --> 00:19:05,329
And we're going to define a quantity badness.
我们将定义数量缺陷。 

389
00:19:05,329 --> 00:19:08,589



390
00:19:08,589 --> 00:19:12,529
And this is an anesthetic quantity, if you will.
如果您愿意，这是麻醉药。 

391
00:19:12,529 --> 00:19:15,190
I'm going to tell you what LaTeX uses.
我将告诉您LaTeX的用途。 

392
00:19:15,190 --> 00:19:20,097
But this is sort of how bad it is
但这有点糟

393
00:19:20,097 --> 00:19:31,009
to use-- or let's say, yeah, words i through j as a line.
使用-或者说，是的，将i到j作为一行。 

394
00:19:31,009 --> 00:19:36,410



395
00:19:36,410 --> 00:19:37,700
So this is python notation.
所以这是python表示法。 

396
00:19:37,700 --> 00:19:39,889
So it starts at i and ends at J minus 1.
因此，它从i开始，到J减去1。 

397
00:19:40,089 --> 00:19:42,089
That'll be convenient.
那会很方便。 

398
00:19:42,089 --> 00:19:43,799
So I have this list of words.
所以我有这个词表。 

399
00:19:43,799 --> 00:19:46,440
And if I look at words i through j minus 1
如果我看单词i到j减1 

400
00:19:46,440 --> 00:19:50,630
and I think of what happens if I pack them in a line, well,
我想如果我把它们打包成一行会发生什么， 

401
00:19:50,630 --> 00:19:53,879
they may fit or they may not fit.
他们可能适合或他们可能不适合。 

402
00:19:54,079 --> 00:19:57,000
So there are going to be two cases.
因此，将有两种情况。 

403
00:19:57,000 --> 00:19:59,930
If they don't fit, I'm going to write infinity.
如果它们不合适，我将写无穷大。 

404
00:19:59,930 --> 00:20:00,805
So that's really bad.
所以那真的很糟糕。 

405
00:20:00,805 --> 00:20:07,890



406
00:20:07,890 --> 00:20:13,159
So I have some notion of how wide my line can be.
因此，我对我的业务范围有一定的了解。 

407
00:20:13,359 --> 00:20:15,759
And if the sum of the lengths of those words plus the sum
如果这些单词的长度之和加上

408
00:20:15,759 --> 00:20:18,890
of the lengths of the spaces as small as possible
间距的长度应尽可能小

409
00:20:18,890 --> 00:20:23,169
is bigger than the width of my screen-- or page,
大于屏幕或页面的宽度， 

410
00:20:23,369 --> 00:20:25,295
I guess-- then I say they don't fit,
我想-然后我说它们不合适

411
00:20:25,296 --> 00:20:27,420
and then I define badness to be infinity-- meaning,
然后我将不良定义为无穷大-意思是， 

412
00:20:27,420 --> 00:20:30,210
I never want to do that.
我永远都不想那样做。 

413
00:20:30,210 --> 00:20:32,529
This is actually LaTeX sloppy mode,
这实际上是LaTeX的草率模式， 

414
00:20:32,529 --> 00:20:34,849
if you want to be technical.
如果您想成为技术专家。 

415
00:20:34,849 --> 00:20:49,119
Otherwise, it's going to be page width minus total width cubed.
否则，它将是页面宽度减去总宽度。 

416
00:20:49,119 --> 00:20:52,500



417
00:20:52,500 --> 00:20:53,109
Why cubed?
为什么要立方体？ 

418
00:20:53,109 --> 00:20:54,769
Who knows.
谁知道。 

419
00:20:54,769 --> 00:20:57,700
This is the LaTeX rule.
这是LaTeX规则。 

420
00:20:57,700 --> 00:21:01,419
And squared would probably also be fine.
平方也可能很好。 

421
00:21:01,619 --> 00:21:04,279
So this is the width of the page minus the total width
所以这是页面的宽度减去总宽度

422
00:21:04,279 --> 00:21:06,559
of those words, which you also have
这些话中，你也有

423
00:21:06,559 --> 00:21:08,119
to include the spaces here.
在这里包括空格。 

424
00:21:08,119 --> 00:21:09,119
You take the difference.
你差价了。 

425
00:21:09,119 --> 00:21:10,129
You cube it.
你把它立方体。 

426
00:21:10,130 --> 00:21:12,349
And so when this is small-- I mean,
所以，当这很小的时候，我是说， 

427
00:21:12,549 --> 00:21:14,509
when these are very close-- then this
当这些非常接近时-那么

428
00:21:14,509 --> 00:21:16,549
is going to be close to zero.
将接近零。 

429
00:21:16,549 --> 00:21:17,450
That's good.
那很好。 

430
00:21:17,450 --> 00:21:19,230
That means you use most of the line.
这意味着您将使用大部分线路。 

431
00:21:19,230 --> 00:21:21,605
When the total width is much smaller than the page width,
当总宽度远小于页面宽度时， 

432
00:21:21,605 --> 00:21:22,938
then this will be a large value.
那么这将是一个很大的价值。 

433
00:21:22,938 --> 00:21:24,460
You cube it, it will be even larger.
您将其立方体化，它将更大。 

434
00:21:24,460 --> 00:21:27,930
So this will highly discourage big gaps like this.
因此，这将极大地阻止类似的巨大差距。 

435
00:21:27,930 --> 00:21:30,919
And it will very much discourage not fitting.
这将极大地阻止不适合的人。 

436
00:21:31,119 --> 00:21:32,949
So there's a tradeoff, of course.
因此，当然要进行权衡。 

437
00:21:32,950 --> 00:21:35,519
And the idea is you might-- in the greedy algorithm,
想法是，您可能会在贪婪算法中

438
00:21:35,519 --> 00:21:38,799
you make the first line as good as you can.
您会尽力做好第一行。 

439
00:21:38,799 --> 00:21:40,868
But it might actually be better to leave out
但实际上将其省略可能会更好

440
00:21:40,868 --> 00:21:42,409
some of the words that would fit here
一些适合这里的词

441
00:21:42,410 --> 00:21:44,159
in order to make the next line better.
为了使下一行更好。 

442
00:21:44,359 --> 00:21:46,599
In general, it's hard to tell, where should I
一般来说，很难告诉我应该在哪里

443
00:21:46,599 --> 00:21:51,049
cut the lines in order to get the best overall strategy?
为了获得最佳整体策略而削减界限？ 

444
00:21:51,049 --> 00:21:52,889
What I'd like to minimize is the sum
我想最小化的是总和

445
00:21:52,890 --> 00:21:55,430
of the badnesses of the lines.
的缺点。 

446
00:21:55,430 --> 00:21:57,389
So it's a sum of cubes, and that's really hard
所以这是一个立方体的总和，这真的很难

447
00:21:57,589 --> 00:21:59,578
to think about.
想一下。 

448
00:21:59,578 --> 00:22:01,369
But that's what dynamic programming is for.
但这就是动态编程的目的。 

449
00:22:01,369 --> 00:22:02,799
You don't have to think.
您不必思考。 

450
00:22:02,799 --> 00:22:06,009
It's great because it's brute force.
很棒，因为它是蛮力的。 

451
00:22:06,009 --> 00:22:12,599
OK, so the first thing we need to do is define sub-problems.
好的，所以我们要做的第一件事是定义子问题。 

452
00:22:12,599 --> 00:22:15,029
This is, in some sense, the hard part.
从某种意义上讲，这是最困难的部分。 

453
00:22:15,029 --> 00:22:18,220
The rest will follow easily.
其余的将很容易理解。 

454
00:22:18,220 --> 00:22:21,460
So I think actually it might be easier
所以我认为实际上可能会更容易

455
00:22:21,460 --> 00:22:24,150
to think about, for this problem, what
考虑这个问题

456
00:22:24,150 --> 00:22:26,190
would be the brute force strategy?
会是蛮力策略吗？ 

457
00:22:26,190 --> 00:22:28,440
How would you try all possibilities, exponential
您将如何尝试所有可能性，指数

458
00:22:28,440 --> 00:22:29,129
time?
时间？ 

459
00:22:29,329 --> 00:22:29,829
Suggestions?
有什么建议吗？ 

460
00:22:29,829 --> 00:22:40,413



461
00:22:40,413 --> 00:22:40,913
Yeah?
是啊

462
00:22:40,913 --> 00:22:44,240
AUDIENCE: Try all partitions of the words that don't fit?
听众：尝试对所有不合适的单词进行分区吗？ 

463
00:22:44,240 --> 00:22:45,990
PROFESSOR: Try all partitions of the word,
教授：请尝试单词的所有分区， 

464
00:22:45,990 --> 00:22:48,970
so-- of the string of words.
等等。 

465
00:22:48,970 --> 00:22:51,797
So I mean, it could be it all fits in on one line.
所以我的意思是，这可能全都适合。 

466
00:22:51,797 --> 00:22:53,380
It could be it's split into two lines.
可能分为两行。 

467
00:22:53,380 --> 00:22:55,119
I try all possible splits there.
我在那里尝试所有可能的分割。 

468
00:22:55,319 --> 00:22:57,460
In general, I'm guessing for every word,
总的来说，我猜每个字， 

469
00:22:57,460 --> 00:22:59,649
does this start a line or not?
这是否开始行？ 

470
00:22:59,849 --> 00:23:01,469
That would be all ways.
那将是所有方式。 

471
00:23:01,470 --> 00:23:02,999
And so there are 2 to the n.
因此，n等于2。 

472
00:23:02,999 --> 00:23:05,289
If I have n words, there's 2 to the n different splits.
如果我有n个单词，则n个不同的拆分为2。 

473
00:23:05,289 --> 00:23:08,649
For every word I say yes or no, does this is begin a line?
对于我说的每个单词，是或否，这是一行吗？ 

474
00:23:08,650 --> 00:23:11,130
So what I'd like to figure out is where those lines begin.
所以我想弄清楚的是这些行的起点。 

475
00:23:11,330 --> 00:23:12,829
That was the point of that exercise.
这就是该练习的重点。 

476
00:23:12,829 --> 00:23:16,009



477
00:23:16,009 --> 00:23:17,000
So any suggestions?
有什么建议吗？ 

478
00:23:17,000 --> 00:23:19,289
Maybe it's actually easier to jump ahead and think,
也许实际上前进起来会更容易， 

479
00:23:19,289 --> 00:23:21,799
what would I guess in my solution
我在解决方案中会猜到什么

480
00:23:21,799 --> 00:23:25,450
if I have this big string of words?
如果我有这么大的字眼？ 

481
00:23:25,450 --> 00:23:27,500
What's the natural first thing to guess?
首先要猜测的自然是什么？ 

482
00:23:27,500 --> 00:23:34,200



483
00:23:34,200 --> 00:23:34,700
Yeah?
是啊

484
00:23:34,700 --> 00:23:36,419
AUDIENCE: Guess how long the first line is?
听众：猜猜第一行有多长时间？ 

485
00:23:36,619 --> 00:23:38,739
PROFESSOR: Guess how long the first line is, yeah.
教授：猜猜第一行有多长时间。 

486
00:23:38,740 --> 00:23:40,490
We know that the first word begins a line.
我们知道第一个单词以一行开头。 

487
00:23:40,490 --> 00:23:44,579
But where does the second line begin?
但是第二行从哪里开始？ 

488
00:23:44,579 --> 00:23:47,119
So I'd like to guess where the second line begins.
所以我想猜测第二行的开始位置。 

489
00:23:47,119 --> 00:23:51,000
That's-- so you know, I have the beginning of a line here
那是-所以你知道，我在这里有一行的开始

490
00:23:51,000 --> 00:23:55,819
and then I have a beginning of a line here at the fourth word.
然后我在第四个单词的第一个行开始。 

491
00:23:55,819 --> 00:23:57,809
Where does the second line begin?
第二行从哪里开始？ 

492
00:23:57,809 --> 00:23:58,589
I don't know.
我不知道。 

493
00:23:58,589 --> 00:23:59,179
Guess.
猜测。 

494
00:23:59,180 --> 00:24:01,200
So I'm going to try all the possible words
所以我将尝试所有可能的单词

495
00:24:01,200 --> 00:24:03,009
after the first word.
在第一个字之后。 

496
00:24:03,009 --> 00:24:06,019
And say, well, what if I started my second line here?
然后说，好吧，如果我在这里开始第二行呢？ 

497
00:24:06,019 --> 00:24:07,559
At some point I'm going to be packing
在某个时候，我要打包

498
00:24:07,559 --> 00:24:10,599
too much into the first line, and so I abort.
第一行太多，所以我放弃了。 

499
00:24:10,599 --> 00:24:14,719
But I'll try them all.
但我会全部尝试。 

500
00:24:14,720 --> 00:24:16,309
Why not?
为什么不？ 

501
00:24:16,309 --> 00:24:18,069
OK, that's good.
好那很好

502
00:24:18,069 --> 00:24:19,599
The issue is that once I've chosen
问题是，一旦我选择了

503
00:24:19,599 --> 00:24:21,589
where the second line is, of course the next thing I want
第二行在哪里，当然是我想要的下一件事

504
00:24:21,589 --> 00:24:23,220
to guess is where the third line begins.
猜猜是第三行开始的地方。 

505
00:24:23,220 --> 00:24:25,428
And then I want I guess where the fourth line begins,
然后我想我猜第四行从哪里开始

506
00:24:25,428 --> 00:24:26,230
and so on.
等等。 

507
00:24:26,230 --> 00:24:28,240
In general, I need to set up my sub-problems
通常，我需要设置我的子问题

508
00:24:28,240 --> 00:24:31,150
so that after I do the first guess
这样我做第一个猜测之后

509
00:24:31,150 --> 00:24:34,660
I have the problem of the original type.
我有原始类型的问题。 

510
00:24:34,660 --> 00:24:37,529
So originally I have all the words.
所以原来我有所有的话。 

511
00:24:37,529 --> 00:24:41,210
But after I guess where the second line begins,
但是我猜到第二行的开始

512
00:24:41,210 --> 00:24:43,345
I have the remaining words.
我还有剩下的话。 

513
00:24:43,345 --> 00:24:45,669



514
00:24:45,869 --> 00:24:48,929
What's a good word for the remaining words?
剩下的单词有什么好词？ 

515
00:24:48,930 --> 00:24:52,470
If I give you a list of words and I want from here on,
如果我给你一个单词列表，我想从这里开始， 

516
00:24:52,470 --> 00:24:57,538
it's called-- what?
叫做-什么？ 

517
00:24:57,538 --> 00:24:59,049
A sub-problem, yes.
一个子问题，是的。 

518
00:24:59,049 --> 00:25:02,379
That's what we want to define.
那就是我们要定义的。 

519
00:25:02,380 --> 00:25:04,483
It's called a suffix of the array.
它称为数组的后缀。 

520
00:25:04,683 --> 00:25:06,099
That's the word I was looking for.
那就是我要找的词。 

521
00:25:06,099 --> 00:25:09,209
It's tough when I only have one word answers.
当我只有一个单词的答案时，这很难。 

522
00:25:09,210 --> 00:25:11,169
So my sub-problems are going to be suffixes.
因此，我的子问题将是后缀。 

523
00:25:11,369 --> 00:25:16,079



524
00:25:16,079 --> 00:25:20,569
Which is, in python notation, i colon.
用python表示法是冒号。 

525
00:25:20,569 --> 00:25:21,444
They call it splices.
他们称其为拼接。 

526
00:25:21,444 --> 00:25:24,990



527
00:25:24,990 --> 00:25:29,796
And how many sub-problems are there if I have n words?
如果我有n个单词，有多少个子问题？ 

528
00:25:29,796 --> 00:25:33,509



529
00:25:33,509 --> 00:25:35,869
Two?
二？ 

530
00:25:35,869 --> 00:25:36,682
Sorry?
抱歉？ 

531
00:25:36,682 --> 00:25:37,578
AUDIENCE: 2 to the n.
听众：2到n。 

532
00:25:37,578 --> 00:25:38,369
PROFESSOR: 2 the n?
教授：2个n？ 

533
00:25:38,369 --> 00:25:41,149



534
00:25:41,150 --> 00:25:43,700
That would be a problem if it's 2 to the n.
如果它是2到n，那将是一个问题。 

535
00:25:43,700 --> 00:25:44,690
I hope it's only n.
我希望只有n。 

536
00:25:44,690 --> 00:25:49,980



537
00:25:49,980 --> 00:25:52,819
Originally, we said, OK, for every word, we're going to say,
最初，我们说，好吧，我们要说的每个字， 

538
00:25:52,819 --> 00:25:54,152
is this in our out?
这是我们的吗？ 

539
00:25:54,152 --> 00:25:55,159
Is this the beginning or not?
这是开始吗？ 

540
00:25:55,359 --> 00:25:56,809
That's 2 to the n.
那是2到n。 

541
00:25:56,809 --> 00:25:59,429
But here, the idea is we're only thinking about, well,
但是这里的想法是，我们只是在考虑， 

542
00:25:59,430 --> 00:26:00,741
what are the words that remain?
剩下的词是什么？ 

543
00:26:00,741 --> 00:26:02,950
And it could be you've dealt with the first 100 words
可能是您已经处理了前100个字

544
00:26:02,950 --> 00:26:04,430
and then you've got n minus 100 left,
然后剩下n减100， 

545
00:26:04,430 --> 00:26:06,154
or it could be you've dealt with the first thousand words
或者可能是您已经处理了前一千个单词

546
00:26:06,154 --> 00:26:07,363
and you've got n minus 1,000.
而您的n减为1,000。 

547
00:26:07,363 --> 00:26:10,890
There's only n choices for that.
只有n种选择。 

548
00:26:10,890 --> 00:26:14,339
We're only remembering one line, this is the key.
我们只记得一行，这是关键。 

549
00:26:14,539 --> 00:26:17,289
Even though we may have already guessed several lines,
即使我们可能已经猜到了几行， 

550
00:26:17,289 --> 00:26:19,109
we're just going to remember, well, OK.
我们只是要记住，好吧。 

551
00:26:19,109 --> 00:26:20,769
This is what we have left to do.
这就是我们要做的。 

552
00:26:20,769 --> 00:26:22,900
So let's forget about the past.
因此，让我们忘记过去。 

553
00:26:22,900 --> 00:26:25,960
This is what makes dynamic programming efficient.
这就是使动态编程高效的原因。 

554
00:26:25,960 --> 00:26:29,250
And we're just going to solve it, solve these sub-problems,
我们将要解决它，解决这些子问题， 

555
00:26:29,250 --> 00:26:30,910
forgetting about the past.
忘记过去。 

556
00:26:30,910 --> 00:26:32,529
So the sub-problem-- I'm not going
所以子问题-我不去

557
00:26:32,529 --> 00:26:35,119
to write it here-- is if I give you these words,
在这里写-如果我给你这些话， 

558
00:26:35,119 --> 00:26:38,419
never mind the other words, how do I pack them optimally
没关系，我该如何最佳包装

559
00:26:38,420 --> 00:26:40,289
into a paragraph?
变成一段？ 

560
00:26:40,289 --> 00:26:42,920
I don't care about the other words, just these words.
我不在乎这些词，只在乎这些词。 

561
00:26:42,920 --> 00:26:45,355
So this is a different version of the same problem.
因此，这是同一问题的不同版本。 

562
00:26:45,355 --> 00:26:46,730
Initially, we have n words to do.
最初，我们有n个单词要做。 

563
00:26:46,730 --> 00:26:48,970
Now I have n minus i words to do.
现在我有n减i字要做。 

564
00:26:48,970 --> 00:26:50,980
But it's again text justification.
但这又是文本理由。 

565
00:26:50,980 --> 00:26:54,576
I want to solve this problem on those words.
我想用这些话解决这个问题。 

566
00:26:54,576 --> 00:26:56,200
That's just how I'm going to define it.
这就是我要定义它的方式。 

567
00:26:56,200 --> 00:27:00,890
This will work if I can specify a recurrence relation.
如果我可以指定递归关系，这将起作用。 

568
00:27:00,890 --> 00:27:06,190
As we said, what we guess is where
正如我们所说，我们猜测是在哪里

569
00:27:06,190 --> 00:27:09,450
to break the first line, where to start
打破第一行，从哪里开始

570
00:27:09,450 --> 00:27:16,669
the second line for those words.
这些词的第二行。 

571
00:27:16,869 --> 00:27:23,689
OK, so this is-- it could be the i plus first line.
好的，这是-可能是i加第一行。 

572
00:27:23,690 --> 00:27:26,930
It could be the i plus second line-- or sorry, word.
可能是i加第二行，或者抱歉。 

573
00:27:26,930 --> 00:27:31,740
Some word after i is where we guess the second word.
我之后的一些词是我们猜出第二个词的地方。 

574
00:27:31,740 --> 00:27:39,450
The number of choices for the guess is at most n minus i.
猜测的选择数最多为n减去i。 

575
00:27:39,450 --> 00:27:43,039
I'm just going to think of that as order n.
我只是将其视为n阶。 

576
00:27:43,039 --> 00:27:45,220
It won't matter.
没关系

577
00:27:45,220 --> 00:27:47,680
The third part is we need a recurrence relation.
第三部分是我们需要一个递归关系。 

578
00:27:47,680 --> 00:27:53,539



579
00:27:53,539 --> 00:27:56,450
I claim this is very easy.
我声称这很容易。 

580
00:27:56,450 --> 00:28:02,130
I'm going to-- I didn't give this problem a name,
我要-我没有给这个问题起个名字， 

581
00:28:02,130 --> 00:28:06,781
so I'm just going to write it as DP of i.
所以我只是将其写为i的DP。 

582
00:28:06,981 --> 00:28:09,730



583
00:28:09,730 --> 00:28:13,500
So this is going to be the solution to that suffix, words
所以这将是该后缀的解决方案

584
00:28:13,500 --> 00:28:14,500
from i onward.
从我开始。 

585
00:28:14,500 --> 00:28:18,029



586
00:28:18,029 --> 00:28:21,369
And I'd like to-- what I want to do
我想-我想做什么

587
00:28:21,369 --> 00:28:24,388
is consider all possible guesses.
考虑所有可能的猜测。 

588
00:28:24,388 --> 00:28:26,929
So I mean this is going to be pretty formulaic at this point.
因此，我的意思是，这将是非常明确的公式。 

589
00:28:26,930 --> 00:28:29,289
After I've set up these ideas there's pretty much
设定好这些想法之后， 

590
00:28:29,289 --> 00:28:31,319
only one thing I can write here, which
我只能在这里写一件事

591
00:28:31,319 --> 00:28:36,960
is I want to do a for loop.
我想做一个for循环。 

592
00:28:36,960 --> 00:28:48,079



593
00:28:48,079 --> 00:28:50,379
That would be the for loop of where
那是for循环的地方

594
00:28:50,380 --> 00:28:52,680
the second line can start.
第二行可以开始。 

595
00:28:52,680 --> 00:28:54,140
I can't start at i, because that's
我不能从我开始，因为那是

596
00:28:54,140 --> 00:28:55,379
where the first line starts.
第一行开始的地方。 

597
00:28:55,579 --> 00:28:58,509
But it could start at i plus 1.
但这可以从我加1开始。 

598
00:28:58,509 --> 00:29:02,480
And this special value of n will mean
 n的特殊值意味着

599
00:29:02,480 --> 00:29:06,044
that there is no second line.
没有第二行。 

600
00:29:06,044 --> 00:29:09,420
OK, so DP of i-- now I want to do this for loop
好的，所以我的DP –现在我要进行循环

601
00:29:09,420 --> 00:29:11,119
in order to try all the possible guesses.
为了尝试所有可能的猜测。 

602
00:29:11,319 --> 00:29:14,319
j will be the word where the next thing starts.
 j将是下一个事物开始的词。 

603
00:29:14,319 --> 00:29:16,200
So then what do I write up here?
那我在这里写些什么呢？ 

604
00:29:16,200 --> 00:29:18,890



605
00:29:18,890 --> 00:29:24,649
If I make this guess-- all right, so I have word
如果我做出这个猜测-好吧，我有话要说

606
00:29:24,849 --> 00:29:29,730
i is the first word of the first line.
我是第一行的第一个字。 

607
00:29:29,730 --> 00:29:32,630
And then word j is the first word of the second line.
然后单词j是第二行的第一个单词。 

608
00:29:32,630 --> 00:29:35,105



609
00:29:35,105 --> 00:29:36,730
And then there's more stuff down below.
然后，下面还有更多内容。 

610
00:29:36,730 --> 00:29:39,000
I don't know what that is.
我不知道那是什么

611
00:29:39,000 --> 00:29:44,240
But how can I use recursion to specify this?
但是如何使用递归来指定呢？ 

612
00:29:44,240 --> 00:29:49,480



613
00:29:49,480 --> 00:29:52,170
DP of j, exactly.
 j的DP。 

614
00:29:52,170 --> 00:29:55,650



615
00:29:55,650 --> 00:29:57,339
I guess if I'm doing recursion, I
我想我是否要进行递归， 

616
00:29:57,539 --> 00:30:00,579
should use parentheses instead of brackets.
应该使用括号而不是括号。 

617
00:30:00,579 --> 00:30:02,013
But if you're doing it bottom up,
但是，如果您是自下而上地做， 

618
00:30:02,013 --> 00:30:03,179
it would be square brackets.
这将是方括号。 

619
00:30:03,180 --> 00:30:05,759



620
00:30:05,759 --> 00:30:07,059
So that's just DP of j.
这就是j的DP。 

621
00:30:07,059 --> 00:30:12,169
That's the cost of the rest of the problem.
那就是剩下的问题的代价。 

622
00:30:12,170 --> 00:30:15,140
And I can assume that that's free to compute.
我可以假设这是免费的。 

623
00:30:15,140 --> 00:30:17,129
This is the magic of dynamic programming.
这是动态编程的魔力。 

624
00:30:17,329 --> 00:30:20,490
But then I also have to think about, well,
但是，我还必须考虑一下， 

625
00:30:20,490 --> 00:30:21,900
what about the first line?
第一行呢？ 

626
00:30:21,900 --> 00:30:24,140
How much does that cost?
费用多少？ 

627
00:30:24,140 --> 00:30:26,618
Well, that's just badness of ij.
好吧，这只是ij的缺点。 

628
00:30:26,818 --> 00:30:28,109
And we've already defined that.
我们已经定义了这一点。 

629
00:30:28,109 --> 00:30:29,951
We can compute it in constant time.
我们可以在恒定时间内进行计算。 

630
00:30:29,951 --> 00:30:32,160
Dynamic programming doesn't really care what this is.
动态编程并不真正在乎这是什么。 

631
00:30:32,160 --> 00:30:33,480
It could be anything.
可能是任何东西。 

632
00:30:33,480 --> 00:30:34,980
As long as you're trying to minimize
只要您要尽量减少

633
00:30:34,980 --> 00:30:37,490
the sum of the badnesses, whatever function is in here,
缺点的总和，无论这里有什么功能， 

634
00:30:37,490 --> 00:30:40,163
we just compute it here.
我们只是在这里计算。 

635
00:30:40,163 --> 00:30:41,829
That's the power of dynamic programming.
这就是动态编程的力量。 

636
00:30:41,829 --> 00:30:43,899
It works for all variations of this problem,
它适用于此问题的所有变体， 

637
00:30:43,900 --> 00:30:45,480
however you define badness.
但是，您定义不良。 

638
00:30:45,480 --> 00:30:47,480
So you might say, oh, that's a weird definition.
所以您可能会说，哦，这是一个奇怪的定义。 

639
00:30:47,480 --> 00:30:49,049
I want to use something else instead.
我想改用其他东西。 

640
00:30:49,049 --> 00:30:50,798
That's fine, as long as you can compute it
只要可以计算就可以了

641
00:30:50,798 --> 00:30:55,519
in terms of just i and j and looking at those words.
就我和j而言，看着那些词。 

642
00:30:55,519 --> 00:30:58,491
OK, now I need to do a min over the whole thing.
好的，现在我需要对整个过程进行一分钟的处理。 

643
00:30:58,491 --> 00:31:00,450
So I want to minimize the sum of the badnesses.
因此，我想将弊端的总和最小化。 

644
00:31:00,450 --> 00:31:03,240



645
00:31:03,240 --> 00:31:05,815
So I compute for every guess of j,
所以我计算出j的每个猜测

646
00:31:05,815 --> 00:31:07,690
I compute the cost of the rest of the problem
我计算其余问题的成本

647
00:31:07,690 --> 00:31:10,389
plus the cost of that first line.
加上第一行的费用。 

648
00:31:10,589 --> 00:31:13,705
And this, is in some sense, checking all possible solutions
从某种意义上讲，这是在检查所有可能的解决方案

649
00:31:13,705 --> 00:31:14,204
magically.
神奇地。 

650
00:31:14,204 --> 00:31:16,879



651
00:31:16,880 --> 00:31:18,119
OK.
好。 

652
00:31:18,319 --> 00:31:20,359
That's the recurrence.
这就是复发。 

653
00:31:20,359 --> 00:31:23,369
We need to check some things.
我们需要检查一些事情。 

654
00:31:23,369 --> 00:31:26,429
I guess right now we just want to compute how much time does
我想现在我们只想计算多少时间

655
00:31:26,430 --> 00:31:28,710
this cost, time per sub-problem.
这个成本，每个子问题的时间。 

656
00:31:28,710 --> 00:31:34,909



657
00:31:35,109 --> 00:31:38,559
To do this for loop, basically I do constant work-- all of this
为了进行循环，基本上我会不断工作-所有这些

658
00:31:38,559 --> 00:31:40,909
is constant work-- for each choice.
持续不断的工作-每个选择。 

659
00:31:40,910 --> 00:31:43,960
So there's order n choices, so this is order n.
因此，有n个选择，这就是n个。 

660
00:31:43,960 --> 00:31:51,766



661
00:31:51,766 --> 00:31:53,140
Now we have to check that there's
现在我们要检查

662
00:31:53,140 --> 00:32:00,740
a topological order for this problem
此问题的拓扑顺序

663
00:32:00,740 --> 00:32:02,920
or for these sub-problems.
或针对这些子问题。 

664
00:32:02,920 --> 00:32:06,210
And this is easy, but a little different
这很容易，但是有些不同

665
00:32:06,210 --> 00:32:08,389
from what we've done before because we
从我们之前所做的事情开始，因为我们

666
00:32:08,589 --> 00:32:11,970
have to actually work from the end backwards,
必须从头到尾真正地工作， 

667
00:32:11,970 --> 00:32:13,919
because we're expressing DP of i in terms
因为我们用i表示DP 

668
00:32:14,119 --> 00:32:16,279
of DP of larger values of i.
 i的较大DP的乘积。 

669
00:32:16,279 --> 00:32:18,561
j is always bigger than i.
 j总是比i大。 

670
00:32:18,561 --> 00:32:20,519
And so we have to do it from the right end back
所以我们必须从正确的末端开始

671
00:32:20,519 --> 00:32:21,228
to the beginning.
一开始

672
00:32:21,228 --> 00:32:27,209



673
00:32:27,209 --> 00:32:30,259
And n minus 1 down to 0.
 n减1降至0。 

674
00:32:30,259 --> 00:32:32,670
I didn't actually define DP of n.
我实际上没有定义DP的n。 

675
00:32:32,670 --> 00:32:42,629
There's a base case here which is DP of n equals 0.
这里有一个基本情况，即n的DP等于0。 

676
00:32:42,829 --> 00:32:45,429
Because the meaning of DP of n is I have zero words,
因为n的DP的含义是我有零个单词， 

677
00:32:45,430 --> 00:32:46,740
the nth word onward.
从第n个字开始。 

678
00:32:46,740 --> 00:32:47,920
There is no nth word.
没有第n个字。 

679
00:32:47,920 --> 00:32:50,890
It's 0 to n minus 1 in this notation.
在此符号中，它是0到n减去1。 

680
00:32:50,890 --> 00:32:53,150
So I don't pay anything for a blank line.
因此，我不需要为空白行支付任何费用。 

681
00:32:53,150 --> 00:32:55,829



682
00:32:56,029 --> 00:32:59,410
OK, so that's our top logical order.
好的，这是我们的首要逻辑顺序。 

683
00:32:59,410 --> 00:33:01,720
This one, of course, is instantaneous.
当然，这是瞬时的。 

684
00:33:01,720 --> 00:33:03,240
And then we work backwards.
然后我们倒退。 

685
00:33:03,240 --> 00:33:05,450
And always whenever we need to compute something,
而且总是在每当我们需要计算某些东西时， 

686
00:33:05,450 --> 00:33:08,759
we already have the value.
我们已经拥有了价值。 

687
00:33:08,759 --> 00:33:14,634
The total time we get is going to be
我们得到的总时间将是

688
00:33:14,634 --> 00:33:16,049
the number of sub problems-- which
子问题的数量- 

689
00:33:16,049 --> 00:33:19,819
is n times the running time per sub-problem.
是每个子问题的运行时间的n倍。 

690
00:33:19,819 --> 00:33:23,220
which is order n, which is order n squared.
这是n阶，这是n阶的平方。 

691
00:33:23,220 --> 00:33:26,688
And in the worst case, it is indeed theta n squared.
在最坏的情况下，它的确是平方。 

692
00:33:26,888 --> 00:33:29,429
Although in practice it's going to work better, because lines
尽管实际上它会更好地工作，因为线条

693
00:33:29,430 --> 00:33:32,149
can't be too long.
不能太长。 

694
00:33:32,349 --> 00:33:33,679
So that's the running time.
这就是运行时间。 

695
00:33:33,680 --> 00:33:36,049
Then finally we have to check that the original problem
最后，我们必须检查原始问题

696
00:33:36,049 --> 00:33:38,149
actually gets solved.
实际上得到解决。 

697
00:33:38,150 --> 00:33:40,669
And in this case, the original problem we need to solve
在这种情况下，我们需要解决的原始问题

698
00:33:40,869 --> 00:33:47,849
is DP of 0 because DP of 0 means I take words from 0 onwards.
 DP为0，因为DP为0表示我从0开始接受单词。 

699
00:33:47,849 --> 00:33:49,740
That's everybody.
那就是每个人。 

700
00:33:49,740 --> 00:33:52,500
So that's the actual problem I want to solve.
这就是我要解决的实际问题。 

701
00:33:52,500 --> 00:33:53,410
So we work backwards.
所以我们倒退了。 

702
00:33:53,410 --> 00:33:54,889
We solve all these sub-problems that we don't directly
我们解决了所有这些我们不直接解决的子问题

703
00:33:55,089 --> 00:33:57,490
care about, but then the first one is the one we want.
关心，但是第一个就是我们想要的那个。 

704
00:33:57,490 --> 00:33:58,419
And we're done.
我们完成了。 

705
00:33:58,619 --> 00:34:01,329
So in quadratic time, we can find the best way
所以在二次时代，我们可以找到最好的方法

706
00:34:01,329 --> 00:34:05,139
to pack words into lines.
将单词打包成行。 

707
00:34:05,140 --> 00:34:05,841
Question?
题？ 

708
00:34:06,041 --> 00:34:06,916
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

709
00:34:06,916 --> 00:34:09,739



710
00:34:09,739 --> 00:34:11,329
PROFESSOR: DP of j is returning.
教授：j的DP正在返回。 

711
00:34:11,329 --> 00:34:12,279
It's like this.
就像这样。 

712
00:34:12,280 --> 00:34:14,570
So DP of-- this is a recursive definition.
因此，DP的-是递归定义。 

713
00:34:14,570 --> 00:34:16,570
Imagine this is a recursive function.
想象一下这是一个递归函数。 

714
00:34:16,570 --> 00:34:20,789
I wrote equals, which is Haskell notation, if you will.
如果可以的话，我写了等于，这是Haskell表示法。 

715
00:34:20,789 --> 00:34:23,969
But normally, you think of this as like def DP of i
但是通常，您认为这就像我的def DP 

716
00:34:23,969 --> 00:34:26,380
is return min of this.
是此值的返回最小值。 

717
00:34:26,380 --> 00:34:28,010
This is python.
这是python。 

718
00:34:28,010 --> 00:34:31,880
So it's returning the cost.
因此，它正在退还成本。 

719
00:34:31,880 --> 00:34:35,360
What was the best way to pack those lines from j onwards?
从j开始打包这些行的最佳方法是什么？ 

720
00:34:35,360 --> 00:34:36,670
That's what DP of j returns.
这就是j的DP返回。 

721
00:34:36,869 --> 00:34:38,809
So it's a number.
这是一个数字。 

722
00:34:38,809 --> 00:34:41,440
It's going to be a sum of badness values.
这将是不良值的总和。 

723
00:34:41,440 --> 00:34:43,072
Then we add on one new badness value.
然后，我们添加一个新的不良值。 

724
00:34:43,072 --> 00:34:44,530
It's still a sum of badness values.
它仍然是不良值的总和。 

725
00:34:44,530 --> 00:34:47,260
We return the best one that we find.
我们返回找到的最好的一个。 

726
00:34:47,260 --> 00:34:48,860
Now, this does not actually pack the words.
现在，这实际上并没有包含这些单词。 

727
00:34:49,059 --> 00:34:51,384
That's a good-- maybe your implicit question.
很好-也许是您的隐含问题。 

728
00:34:51,384 --> 00:34:53,420
It's not telling you how to pack the words.
它不是在告诉您如何打包单词。 

729
00:34:53,420 --> 00:34:55,840
It's telling you how much it costs to pack the words.
它告诉您打包单词的费用。 

730
00:34:55,840 --> 00:34:58,960
This is a lot like shortest paths where we didn't-- it was
这很像我们没有的最短路径- 

731
00:34:58,960 --> 00:35:02,385
annoying to actually figure out what the shortest path was.
实际找出最短路径是很烦的。 

732
00:35:02,385 --> 00:35:03,759
Not that annoying, but that's not
没那么烦人，但这不是

733
00:35:03,760 --> 00:35:04,976
what we were usually aiming to do.
我们通常打算做什么。 

734
00:35:05,175 --> 00:35:08,302
We were just trying to figure out the shortest path weight.
我们只是试图找出最短的路径权重。 

735
00:35:08,302 --> 00:35:10,260
And then once we knew the shortest path weight,
然后，一旦我们知道最短路径权重， 

736
00:35:10,260 --> 00:35:13,320
it was pretty easy to reconstruct the paths.
重建路径非常容易。 

737
00:35:13,320 --> 00:35:17,539
So maybe I'll take a little diversion to that
所以也许我会转移一点

738
00:35:17,739 --> 00:35:19,159
and talk about parent pointers.
并讨论父指针。 

739
00:35:19,159 --> 00:35:26,579



740
00:35:26,579 --> 00:35:28,409
The idea with parent pointers is just
父指针的想法仅仅是

741
00:35:28,409 --> 00:35:34,784
remember which guess was best.
记住哪个猜测是最好的。 

742
00:35:34,784 --> 00:35:42,699



743
00:35:42,699 --> 00:35:45,539
it's a very simple idea, but it applies to all dynamic programs
这是一个非常简单的想法，但它适用于所有动态程序

744
00:35:45,539 --> 00:35:47,699
and lets you find the actual solution, not just
并让您找到实际的解决方案，而不仅仅是

745
00:35:47,699 --> 00:35:49,410
the cost of the solution.
解决方案的成本。 

746
00:35:49,411 --> 00:35:51,159
We did the same thing with shortest paths.
我们用最短的路径做了同样的事情。 

747
00:35:51,159 --> 00:35:53,869
We even called them parent.
我们甚至称他们为父母。 

748
00:35:53,869 --> 00:35:59,069
So when we compute this min, were trying all choices of j.
因此，当我们计算此最小值时，正在尝试j的所有选择。 

749
00:35:59,070 --> 00:36:01,769
One of them-- or maybe more than one, but at least one of them
其中之一-或可能不止一个，但至少其中之一

750
00:36:01,769 --> 00:36:03,259
actually gave you the min.
实际上给了你分钟。 

751
00:36:03,260 --> 00:36:05,610
That's usually called the arg min in mathematics.
在数学中通常称为arg min。 

752
00:36:05,809 --> 00:36:08,469
It's what was the value of j that gave you
是j给你的价值是什么

753
00:36:08,469 --> 00:36:11,129
the minimum value of this thing.
这东西的最小值。 

754
00:36:11,130 --> 00:36:12,940
So I mean, when you compute the min,
所以我的意思是，当您计算最小值时， 

755
00:36:12,940 --> 00:36:14,940
you're iterating over every single one.
您正在遍历每一个。 

756
00:36:14,940 --> 00:36:17,539
Just keep track of which one was the best.
只要跟踪哪个是最好的。 

757
00:36:17,739 --> 00:36:18,239
That's it.
而已。 

758
00:36:18,239 --> 00:36:19,489
Call that the parent pointer.
称其为父指针。 

759
00:36:19,489 --> 00:36:22,439



760
00:36:22,440 --> 00:36:23,929
Do I need to write that?
我需要写那个吗？ 

761
00:36:23,929 --> 00:36:30,099
Here, parent-- parent of i is going
在这里，父母-我的父母要去

762
00:36:30,099 --> 00:36:34,900
to be arg min of that same thing.
是同一件事的arg分钟。 

763
00:36:34,900 --> 00:36:38,269
So it's a j value.
所以这是aj值。 

764
00:36:38,269 --> 00:36:41,289
It's the best j value for i.
这是i的最佳j值。 

765
00:36:41,289 --> 00:36:43,190
And so we store that for each i.
因此，我们为每个i存储它。 

766
00:36:43,190 --> 00:36:45,150
It cost no more work, just a constant factor
它无需花费更多的工作，只是一个恒定的因素

767
00:36:45,150 --> 00:36:47,210
more work than computing the min.
比计算最小值需要更多的工作。 

768
00:36:47,210 --> 00:36:49,309
We also write down the arg min.
我们还写下了arg分钟。 

769
00:36:49,309 --> 00:36:52,110
So we're already storing the min in the DP table.
因此，我们已经将最小值存储在DP表中。 

770
00:36:52,110 --> 00:36:54,500
DP of i would get sorted to be that.
我的DP将被排序为那样。 

771
00:36:54,699 --> 00:36:56,399
We also store parent of i.
我们还存储i的父项。 

772
00:36:56,400 --> 00:37:00,260
And then once we're done, we start with our original problem
然后，一旦完成，我们就从最初的问题开始

773
00:37:00,260 --> 00:37:01,940
and we follow parent pointers to figure out
然后按照父指针找出

774
00:37:02,139 --> 00:37:04,039
what the best choices were.
最好的选择是什么。 

775
00:37:04,039 --> 00:37:08,400
So we start at 0 because we know word zero begins a line.
因此我们从0开始，因为我们知道单词零开始一行。 

776
00:37:08,400 --> 00:37:12,119
And then 0 will be the first line.
然后0将是第一行。 

777
00:37:12,119 --> 00:37:15,019
Then we go to parent of 0.
然后我们转到0的父级。 

778
00:37:15,019 --> 00:37:18,190
That will be where the second line begins.
那就是第二行的开始。 

779
00:37:18,190 --> 00:37:20,960
Then we go to parent of parent of 0.
然后我们转到0的父级的父级。 

780
00:37:20,960 --> 00:37:25,010
That will be where the third line begins.
那就是第三行的开始。 

781
00:37:25,010 --> 00:37:26,650
OK, because these were the best choices
好，因为这些是最好的选择

782
00:37:26,849 --> 00:37:28,279
for where the second line begins,
第二行开始的地方

783
00:37:28,280 --> 00:37:31,173
this is the best place where the second line begins.
这是第二行开始的最佳位置。 

784
00:37:31,373 --> 00:37:32,789
Given that this is the first line,
鉴于这是第一行， 

785
00:37:32,789 --> 00:37:34,922
this is the best line where the second line begins
这是第二行开始的最佳行

786
00:37:34,922 --> 00:37:36,380
given that this was the first line.
鉴于这是第一行。 

787
00:37:36,380 --> 00:37:39,460
So that's really the third line given this was the second line.
因此，这实际上是第三行，因为这是第二行。 

788
00:37:39,460 --> 00:37:41,980
Little confusing, but you just a simple for loop.
有点混乱，但是您只是一个简单的for循环。 

789
00:37:41,980 --> 00:37:44,960
You start with 0 because that's our original problem.
您从0开始，因为这是我们的原始问题。 

790
00:37:44,960 --> 00:37:47,809
You keep calling parent of the thing you currently have.
您一直称呼您当前拥有的东西的父母。 

791
00:37:47,809 --> 00:37:49,829
In linear time, you will reconstruct
在线性时间内，您将重建

792
00:37:49,829 --> 00:37:51,630
where the lines break.
断线的地方。 

793
00:37:51,630 --> 00:37:54,539
So you can use this technique in any DP.
因此，您可以在任何DP中使用此技术。 

794
00:37:54,539 --> 00:37:56,239
It's very simple.
非常简单

795
00:37:56,239 --> 00:37:57,969
It's totally automatic.
这是完全自动的。 

796
00:37:57,969 --> 00:38:01,099
Just like memoization is a technique
就像记忆是一种技术

797
00:38:01,099 --> 00:38:02,880
that you can apply without thinking,
你可以不用考虑就可以申请

798
00:38:02,880 --> 00:38:06,246
you could even write a program, given a recursive algorithm,
给定递归算法，您甚至可以编写程序， 

799
00:38:06,246 --> 00:38:08,244
would turn into a memorized recursive algorithm.
会变成一个记忆式递归算法。 

800
00:38:08,244 --> 00:38:10,549
It's totally automated.
它是完全自动化的。 

801
00:38:10,550 --> 00:38:12,210
Same thing with the bottom up DP table.
自下而上的DP表也是如此。 

802
00:38:12,409 --> 00:38:17,567
As long as you know what the topological order is,
只要您知道拓扑顺序是什么， 

803
00:38:17,567 --> 00:38:19,150
just make those for loops and then put
只是让那些for循环，然后把

804
00:38:19,150 --> 00:38:21,945
exactly the recursive call but turn it into an array call.
完全递归调用，但将其转换为数组调用。 

805
00:38:21,945 --> 00:38:23,570
Boom, you've got a bottom up algorithm.
繁荣，您有一个自下而上的算法。 

806
00:38:23,570 --> 00:38:26,150
Totally automatic, no thinking required.
全自动，无需思考。 

807
00:38:26,150 --> 00:38:28,550
Parent pointers also, no thinking required.
父指针也，不需要思考。 

808
00:38:28,550 --> 00:38:31,260
As long as you're following the structure of trial guesses
只要您遵循试验猜测的结构

809
00:38:31,260 --> 00:38:32,820
compute some value-- just remember
计算一些价值-请记住

810
00:38:33,019 --> 00:38:36,440
what the guess was-- you reconstruct your solution.
猜测是什么-您可以重建解决方案。 

811
00:38:36,440 --> 00:38:38,440
That's the great thing about dynamic programming
这是动态编程的伟大之处

812
00:38:38,440 --> 00:38:39,849
is how much of it is automatic.
是多少是自动的。 

813
00:38:39,849 --> 00:38:42,480
The hard part is figuring out what to guess
困难的部分是弄清楚猜出什么

814
00:38:42,480 --> 00:38:45,699
and then what your sub-problems are, or the other order.
然后是您的子问题，或其他顺序。 

815
00:38:45,699 --> 00:38:48,328
Whatever works.
无论如何。 

816
00:38:48,329 --> 00:38:49,420
Any other questions about text?
关于文字还有其他问题吗？ 

817
00:38:49,619 --> 00:38:52,289



818
00:38:52,289 --> 00:38:55,679
I would like to move on to blackjack.
我想继续玩二十一点。 

819
00:38:55,679 --> 00:38:58,339
OK, now I brought some cards, because some of you
好，现在我带了一些卡，因为你们中的一些人

820
00:38:58,340 --> 00:39:00,250
may not know the rules to blackjack.
可能不知道二十一点的规则。 

821
00:39:00,449 --> 00:39:01,989
How many people know blackjack?
有多少人知道二十一点？ 

822
00:39:01,989 --> 00:39:02,654
OK.
好。 

823
00:39:02,655 --> 00:39:04,780
How many people do not and are willing to admit it?
有多少人不愿意接受呢？ 

824
00:39:04,780 --> 00:39:05,690
A few, all right.
几个，好吧。 

825
00:39:05,690 --> 00:39:08,039
So this is for you and for fun, entertainment.
因此，这既适合您，也适合娱乐。 

826
00:39:08,239 --> 00:39:11,599
So I'm going to bring Victor up to help demonstrate
所以我要带维克多来帮助演示

827
00:39:11,599 --> 00:39:13,119
the rules of blackjack.
二十一点的规则。 

828
00:39:13,119 --> 00:39:15,650
We're going to play standard Casino blackjack
我们将玩标准的赌场二十一点

829
00:39:15,650 --> 00:39:18,230
as in the movie 21, or whatever.
就像电影21一样

830
00:39:18,429 --> 00:39:23,442
So I'm going to just do a random cut here so I can't sheet.
因此，我将在这里进行随机切割，以致无法覆盖。 

831
00:39:23,442 --> 00:39:26,139
You have a tablet, that's scary.
你有平板电脑，那太可怕了。 

832
00:39:26,139 --> 00:39:27,724
You're going to look at strategy.
您将要研究策略。 

833
00:39:27,724 --> 00:39:29,319
VICTOR: Nothing special.
胜利者：没什么特别的。 

834
00:39:29,320 --> 00:39:30,250
PROFESSOR: All right.
教授：好的。 

835
00:39:30,250 --> 00:39:32,760
Hopefully you do not have x-ray vision.
希望您没有X光检查。 

836
00:39:32,760 --> 00:39:34,480
So the way it works is there's a dealer
所以它的运作方式是有经销商

837
00:39:34,679 --> 00:39:36,900
player and one or more players.
玩家和一个或多个玩家。 

838
00:39:36,900 --> 00:39:39,399
We're just going to do it with one player to keep it simple.
为了使操作简单，我们只需要和一个玩家一起做即可。 

839
00:39:39,400 --> 00:39:40,525
I'm going to be the dealer.
我将成为经销商。 

840
00:39:40,525 --> 00:39:42,710
So my strategy is actually totally deterministic,
所以我的策略实际上是完全确定性的

841
00:39:42,710 --> 00:39:44,090
there's nothing interesting.
没有什么有趣的。 

842
00:39:44,090 --> 00:39:46,440
Victor has the hard part of winning.
维克多（Victor）难以取胜。 

843
00:39:46,440 --> 00:39:51,130
So to start out, I believe we deal to you first, then
因此，一开始，我相信我们会先与您联系，然后

844
00:39:51,130 --> 00:39:54,710
to me, then to you, then to me.
给我，然后给你，然后给我。 

845
00:39:54,909 --> 00:39:56,599
So let's hold up these cards, Victor,
 Victor，让我们举起这些卡片， 

846
00:39:56,599 --> 00:39:57,958
so that people can see them.
这样人们才能看到它们。 

847
00:39:57,958 --> 00:39:59,500
You don't get to see one of my cards.
您看不到我的一张卡片。 

848
00:39:59,500 --> 00:40:02,309
That's some peculiarity of the rule.
这是该规则的特殊之处。 

849
00:40:02,309 --> 00:40:07,190
And if the sum of our cards goes over 21, we lose the game.
而且，如果我们的卡牌总和超过21，我们就会输掉比赛。 

850
00:40:07,190 --> 00:40:08,420
Victor first.
维克多第一。 

851
00:40:08,420 --> 00:40:12,570
I cannot have a value more than 21 in these hands,
这些手的价值不能超过21， 

852
00:40:12,570 --> 00:40:14,420
because I only have two cards.
因为我只有两张卡。 

853
00:40:14,420 --> 00:40:16,550
You have a value of-- ha, ace.
您的价值-哈哈，王牌。 

854
00:40:16,550 --> 00:40:17,050
Great.
大。 

855
00:40:17,050 --> 00:40:18,480
An ace can be a 1 or an 11.
 ace可以是1或11。 

856
00:40:18,480 --> 00:40:19,539
That's the fun rule.
那是有趣的规则。 

857
00:40:19,539 --> 00:40:22,384
So this is either an 8 or an 18.
所以这是8或18。 

858
00:40:22,384 --> 00:40:24,800
And so Victor has a choice of whether to take another card
所以Victor可以选择是否要再拿一张卡

859
00:40:24,800 --> 00:40:25,480
or not.
或不。 

860
00:40:25,480 --> 00:40:27,284
What would you like to do?
你想干什么？ 

861
00:40:27,284 --> 00:40:28,980
VICTOR: Standard strategy says stand.
胜利者：标准策略表示立场。 

862
00:40:29,179 --> 00:40:30,053
PROFESSOR: He stands.
教授：他站着。 

863
00:40:30,054 --> 00:40:31,644
So he's going to stick to that.
因此，他将坚持这一点。 

864
00:40:31,844 --> 00:40:34,799
At this point, my cards flip over.
此时，我的卡片翻转了。 

865
00:40:34,800 --> 00:40:37,789
I have 17, which is same you, which
我有17岁，与您相同

866
00:40:37,789 --> 00:40:39,612
I believe means-- I forget about tie rules.
我相信手段-我忘记了平局规则。 

867
00:40:39,612 --> 00:40:40,460
VICTOR: I have 18.
威克多：我有18岁。 

868
00:40:40,460 --> 00:40:41,150
PROFESSOR: You have 18.
教授：您有18岁。 

869
00:40:41,150 --> 00:40:41,019
All right.
好吧。 

870
00:40:41,219 --> 00:40:41,401
VICTOR: See?
胜利者：看到了吗？ 

871
00:40:41,402 --> 00:40:42,210
The strategy works.
该策略有效。 

872
00:40:42,210 --> 00:40:43,463
PROFESSOR: So that's good.
教授：那很好。 

873
00:40:43,463 --> 00:40:45,880
I'm going to hit in the hope that I have a small card that
我要击中希望我有一张小卡片

874
00:40:45,880 --> 00:40:47,769
will push me right above you.
会把我推到你的上方。 

875
00:40:47,969 --> 00:40:48,789
But I do not.
但我不。 

876
00:40:48,789 --> 00:40:49,570
I lose.
我输了。 

877
00:40:49,570 --> 00:40:49,929
I'm sad.
我伤心。 

878
00:40:50,128 --> 00:40:51,670
VICTOR: It says always stand on a 17.
威克多：它说总是站在17岁。 

879
00:40:51,670 --> 00:40:52,869
PROFESSOR: Oh, always stand on 17?
教授：哦，总是站在17岁吗？ 

880
00:40:52,869 --> 00:40:53,369
Huh.
嗯

881
00:40:53,369 --> 00:40:54,859
All right, never mind.
好吧，没关系。 

882
00:40:54,860 --> 00:40:55,460
Thanks.
谢谢。 

883
00:40:55,659 --> 00:40:56,719
Yeah, I still lose.
是的，我仍然输。 

884
00:40:56,719 --> 00:40:58,109
The game is over.
游戏结束了。 

885
00:40:58,110 --> 00:41:01,800
My strategy is always stand on a value--
我的策略始终立足于价值观

886
00:41:01,800 --> 00:41:03,360
VICTOR: Stand on 17.
胜利者：站在17。 

887
00:41:03,360 --> 00:41:05,269
PROFESSOR: 17 or higher.
教授：17岁或以上。 

888
00:41:05,269 --> 00:41:09,030
And if I have a value less than 17, I always take another card.
如果我的价值小于17，我总是拿另一张卡。 

889
00:41:09,030 --> 00:41:11,090
So let's do it one more time to get it right.
因此，让我们再做一次以使其正确。 

890
00:41:11,090 --> 00:41:15,880
So I'm going to deal to you, deal to me, deal to you,
所以我要对付你，对付我，对付你， 

891
00:41:15,880 --> 00:41:16,210
deal to me.
给我。 

892
00:41:16,409 --> 00:41:19,449
So hold up your cards.
因此，举起您的卡片。 

893
00:41:19,449 --> 00:41:21,779
You have 18 again.
您又有18个。 

894
00:41:21,780 --> 00:41:22,940
Are you cheating?
你在作弊吗？ 

895
00:41:22,940 --> 00:41:25,599



896
00:41:25,599 --> 00:41:27,989
VICTOR: I still have to stand.
威克多：我还是得站起来。 

897
00:41:27,989 --> 00:41:31,119
PROFESSOR: You still stand, according to tablet.
教授：根据平板电脑，您仍然站着。 

898
00:41:31,119 --> 00:41:33,559
So I, in this case, have a 20.
因此，在这种情况下，我有20。 

899
00:41:33,559 --> 00:41:35,465
And so this I win.
因此，我赢了。 

900
00:41:35,465 --> 00:41:37,309
So you get the idea.
这样您就知道了。 

901
00:41:37,309 --> 00:41:39,068
Let's say in each case we're betting $1.
假设在每种情况下，我们都下注$ 1。 

902
00:41:39,068 --> 00:41:40,360
So at this point, we'd be even.
因此，在这一点上，我们将保持平衡。 

903
00:41:40,360 --> 00:41:43,300
He won $1, I won $1.
他赢了1美元，我赢了1美元。 

904
00:41:43,300 --> 00:41:48,300
But in general, slight-- I think it's balanced.
但总的来说，轻微-我认为它是平衡的。 

905
00:41:48,300 --> 00:41:50,927
VICTOR: For these rules, there's a 1% advantage for the house.
胜利者：按照这些规则，这所房子的优势为1％。 

906
00:41:51,126 --> 00:41:52,710
PROFESSOR: 1% advantage for the house.
教授：房子的优势为1％。 

907
00:41:52,710 --> 00:41:53,210
Interesting.
有趣。 

908
00:41:53,210 --> 00:41:56,119
All right, well, that's beyond this class.
好吧，那超出了这一类。 

909
00:41:56,119 --> 00:42:00,170
What we're going to see is how to cheat in blackjack.
我们将要看到的是如何在二十一点中作弊。 

910
00:42:00,170 --> 00:42:05,039
So this is going to be-- I encourage you to try this out
所以这将是-我鼓励您尝试一下

911
00:42:05,039 --> 00:42:05,750
at casinos.
在赌场。 

912
00:42:05,750 --> 00:42:06,309
Just kidding.
开玩笑。 

913
00:42:06,309 --> 00:42:10,789



914
00:42:10,789 --> 00:42:14,860
This is a little bit difficult to actually do in a casino
在赌场实际上很难做到这一点

915
00:42:14,860 --> 00:42:17,510
unless you have an inside man.
除非你有内心的人。 

916
00:42:17,510 --> 00:42:21,090
So if you have an inside man, go for it.
因此，如果您有内心的人，那就去做吧。 

917
00:42:21,090 --> 00:42:23,500
It's guaranteed to win you lots of money
保证会为您赢得很多钱

918
00:42:23,500 --> 00:42:25,239
because it's going to play optimally.
因为它将发挥最佳效果。 

919
00:42:25,239 --> 00:42:26,829
In perfect information blackjack,
在完美的信息二十一点中， 

920
00:42:26,829 --> 00:42:31,259
I suppose that I already know the entire deck.
我想我已经知道整个甲板了。 

921
00:42:31,260 --> 00:42:34,070
Suppose somehow either I get to put the deck there,
假设我要么把甲板放在那里， 

922
00:42:34,269 --> 00:42:35,989
or I have some x-ray vision.
或者我有一些X射线视力。 

923
00:42:35,989 --> 00:42:38,204
I get to see the entire deck ahead of time.
我可以提前看到整个甲板。 

924
00:42:38,204 --> 00:42:39,579
And then somebody's going to play
然后有人要去玩

925
00:42:39,579 --> 00:42:42,969
through a game over and over with me-- or not over and over,
通过一遍又一遍的游戏-或一遍又一遍， 

926
00:42:42,969 --> 00:42:45,443
but until the deck is depleted-- and I
但是直到甲板耗尽为止

927
00:42:45,443 --> 00:42:47,110
want to know in each case, should I hit,
想知道在每种情况下我应该打

928
00:42:47,110 --> 00:42:49,460
or should I stand?
还是我应该站起来？ 

929
00:42:49,659 --> 00:42:51,159
And I claim with dynamic programming
我声称采用动态编程

930
00:42:51,159 --> 00:42:54,545
you can figure that out-- using exactly the same strategy
您可以使用完全相同的策略弄清楚

931
00:42:54,545 --> 00:42:55,820
as text, actually.
作为文本，实际上。 

932
00:42:55,820 --> 00:42:57,190
It's really for each word, should I
这真的是每个单词，我应该

933
00:42:57,389 --> 00:42:59,980
start a new line or not?
开始新的行还是没有？ 

934
00:42:59,980 --> 00:43:02,150
Same problem here.
这里同样的问题。 

935
00:43:02,150 --> 00:43:04,309
It's slightly more complicated to write down.
写下来要稍微复杂一些。 

936
00:43:04,309 --> 00:43:08,369



937
00:43:08,369 --> 00:43:11,619
So let's say the deck is a sequence of cards.
因此，假设卡片组是一系列纸牌。 

938
00:43:11,619 --> 00:43:19,029
And I'm going to call it c0, c1 up to cn minus 1, n cards.
我将其命名为c0，c1，最多cn减1，n张牌。 

939
00:43:19,030 --> 00:43:23,010
And you are one player.
而且你是一名球员。 

940
00:43:23,010 --> 00:43:25,710
First is the dealer.
首先是经销商。 

941
00:43:25,710 --> 00:43:27,570
I don't know how to solve this for two
我不知道如何解决两个

942
00:43:27,570 --> 00:43:29,539
players, interesting open problem.
玩家，有趣的开放问题。 

943
00:43:29,739 --> 00:43:34,119
But for one player I can do it.
但是对于一个玩家我可以做到。 

944
00:43:34,119 --> 00:43:39,619
Let's say $1 bet per hand, I think they're called.
假设每手下注$ 1，我认为是跟注。 

945
00:43:39,619 --> 00:43:40,480
I'm not sure.
我不确定。 

946
00:43:40,480 --> 00:43:41,949
Per play?
每场比赛？ 

947
00:43:41,949 --> 00:43:42,809
Per box?
每盒？ 

948
00:43:42,809 --> 00:43:43,777
Whatever.
随你。 

949
00:43:43,777 --> 00:43:44,985
You're not allowed to double.
您不可以加倍。 

950
00:43:44,985 --> 00:43:45,951
You're not allowed to split.
您不允许拆分。 

951
00:43:46,150 --> 00:43:48,529
All these fancy rules are harder to think about,
所有这些花哨的规则都很难考虑， 

952
00:43:48,530 --> 00:43:52,480
although you might be able to solve them as well.
尽管您也可以解决它们。 

953
00:43:52,480 --> 00:43:55,278
So the idea is I have some cards.
所以想法是我有一些卡。 

954
00:43:55,278 --> 00:43:56,570
Should I hit or should I stand?
我应该打还是站着？ 

955
00:43:56,570 --> 00:43:57,309
I don't know.
我不知道。 

956
00:43:57,309 --> 00:43:58,549
I'll guess.
我猜

957
00:43:58,550 --> 00:44:05,340
So our guessing-- let's jump ahead to the guessing part--
所以我们的猜测-让我们跳到猜测部分- 

958
00:44:05,340 --> 00:44:10,000
is whether we want to hit or stand given a card.
是我们要击中还是站在卡片旁。 

959
00:44:10,000 --> 00:44:12,469
Actually, it would be easier to think
其实，想起来会更容易

960
00:44:12,469 --> 00:44:15,119
about an entire play, an entire hand.
关于整个游戏，整个手。 

961
00:44:15,119 --> 00:44:17,079
We're going to guess, how many times should I
我们要猜测，我应该多少次

962
00:44:17,079 --> 00:44:28,409
hit in the first play?
打第一部戏？ 

963
00:44:28,409 --> 00:44:30,839
So initially, four cards are dealt.
因此，最初发了四张牌。 

964
00:44:30,840 --> 00:44:32,501
I look at my hands.
我看着我的手。 

965
00:44:32,501 --> 00:44:34,210
Actually, I don't really look at my hand.
实际上，我并不真正看我的手。 

966
00:44:34,210 --> 00:44:36,230
I'm just going to guess ahead of time.
我只是提前猜测。 

967
00:44:36,230 --> 00:44:38,920
I think I'll hit five times this time.
我想这次我会打五次。 

968
00:44:38,920 --> 00:44:40,599
I think I'll hit zero times this time.
我想这次我会打零。 

969
00:44:40,599 --> 00:44:42,489
I mean, I'm just going to try them all.
我的意思是，我将尝试所有这些。 

970
00:44:42,489 --> 00:44:46,269
So I don't really have to be intelligent here, OK?
所以我真的不必在这里变得聪明，好吗？ 

971
00:44:46,269 --> 00:44:50,690
It's kind of crazy but it works.
这有点疯狂，但确实有效。 

972
00:44:50,690 --> 00:44:53,869
Our sub-problems, can anyone tell me
我们的子问题，谁能告诉我

973
00:44:53,869 --> 00:44:58,828
what our sub-problems would be, In one word or less?
一个字或更短的字眼，我们的子问题是什么？ 

974
00:44:58,829 --> 00:44:59,670
Less would be impressive.
少会令人印象深刻。 

975
00:44:59,869 --> 00:45:02,778



976
00:45:02,778 --> 00:45:03,278
Yeah?
是啊

977
00:45:03,278 --> 00:45:04,739
AUDIENCE: Where you start the new hand.
听众：从哪里开始新手。 

978
00:45:04,739 --> 00:45:05,849
PROFESSOR: Where do you start the new hand?
教授：您从哪里开始新手？ 

979
00:45:05,849 --> 00:45:06,348
Yeah.
是的

980
00:45:06,349 --> 00:45:08,980
So it's going to be suffixes of the cards.
因此，它将是卡的后缀。 

981
00:45:08,980 --> 00:45:12,170
So at some point we do a play, and then we get to ith card.
因此，在某个时候我们进行游戏，然后进入ith卡。 

982
00:45:12,170 --> 00:45:15,119
And then the rest of the game will be from the ith card on.
然后其余的游戏将从ith卡上开始。 

983
00:45:15,119 --> 00:45:20,449
So it's going to be suffix ci colon,
所以它将是后缀ci Colon， 

984
00:45:20,449 --> 00:45:22,210
I guess would be the notation here.
我想这是这里的符号。 

985
00:45:22,210 --> 00:45:24,190
It's a bit awkward.
有点尴尬

986
00:45:24,190 --> 00:45:25,639
These are the cards that remain.
这些是剩下的卡。 

987
00:45:25,639 --> 00:45:28,190
And so the sub-problem is, what is the best play?
因此，子问题是，最佳发挥是什么？ 

988
00:45:28,190 --> 00:45:31,400
What's the best outcome given $1 bets?
给定$ 1下注的最佳结果是什么？ 

989
00:45:31,400 --> 00:45:34,789
How much money can I make-- maximize my winning, say--
我可以赚多少钱-最大化我的赢利- 

990
00:45:34,989 --> 00:45:36,799
given these cards onward?
给这些卡以后？ 

991
00:45:36,800 --> 00:45:39,547
Who knows what happened to their earlier cards, but just
谁知道他们以前的卡怎么了，但是

992
00:45:39,547 --> 00:45:40,380
these are the cards.
这些是卡。 

993
00:45:40,380 --> 00:45:42,099
I'm left with.
我留下了。 

994
00:45:42,099 --> 00:45:53,329
Number of sub-problems is-- hmm?
子问题的数量是-嗯？ 

995
00:45:53,329 --> 00:46:00,449



996
00:46:00,449 --> 00:46:01,839
n.
 。 

997
00:46:01,840 --> 00:46:05,019
How many choices of i are there? n choices.
我有多少选择？ n个选择。 

998
00:46:05,219 --> 00:46:06,759
This really important.
这真的很重要。 

999
00:46:06,760 --> 00:46:10,000
It's really useful that we're thinking about suffixes.
我们考虑后缀确实很有用。 

1000
00:46:10,000 --> 00:46:12,476
It's not that some subset of the cards have been played.
不是说纸牌的某些子集已经被玩过。 

1001
00:46:12,476 --> 00:46:14,809
That would be really hard, because there's exponentially
那真的很难，因为

1002
00:46:14,809 --> 00:46:16,889
many different subsets that could be left.
可以保留许多不同的子集。 

1003
00:46:16,889 --> 00:46:18,819
It's always a prefix that gets played,
它总是被播放的前缀， 

1004
00:46:18,820 --> 00:46:19,880
and therefore suffix is left.
因此后缀被保留。 

1005
00:46:20,079 --> 00:46:22,605
And there's only n suffixes, remember that.
而且只有n个后缀，请记住。 

1006
00:46:22,605 --> 00:46:25,889
We're going to use it over and over in dynamic programming.
我们将在动态编程中反复使用它。 

1007
00:46:25,889 --> 00:46:28,309
So now we need to solve the sub-problem.
因此，现在我们需要解决子问题。 

1008
00:46:28,309 --> 00:46:31,000
Starting from ci, what's the best way to play?
从ci开始，最好的玩法是什么？ 

1009
00:46:31,000 --> 00:46:33,480
Well, the first four cards are fixed,
好吧，前四张卡是固定的， 

1010
00:46:33,480 --> 00:46:36,019
and then we guess how many hits are left.
然后我们猜测还剩下多少个匹配

1011
00:46:36,019 --> 00:46:38,239
So it's going to be something like n minus i
所以它将是n减去i 

1012
00:46:38,239 --> 00:46:41,273
minus four different possibilities for-- I mean,
减去以下四种不同的可能性-我的意思是， 

1013
00:46:41,273 --> 00:46:42,940
that would be the maximum number of hits
那将是最大的点击数

1014
00:46:42,940 --> 00:46:45,059
I could take all the remaining cards.
我可以把剩下的所有卡都拿走。 

1015
00:46:45,059 --> 00:46:49,269
That would be the most.
那将是最大的。 

1016
00:46:49,269 --> 00:46:53,670
And let's see, so the number of choices-- I'll just say it's,
让我们看看，选择的数量-我只是说， 

1017
00:46:53,670 --> 00:46:54,619
at most, n.
最多

1018
00:46:54,619 --> 00:46:58,190
I don't have to be fancy here.
我在这里不必花哨。 

1019
00:46:58,190 --> 00:47:02,539
OK, now we go to the recurrence.
好的，现在我们来重复一下。 

1020
00:47:02,539 --> 00:47:08,900



1021
00:47:08,900 --> 00:47:12,599
So I'm going to call this blackjack of i.
所以我要称呼我这个二十一点。 

1022
00:47:12,599 --> 00:47:14,799
It's going to be the solution.
这将是解决方案。 

1023
00:47:14,800 --> 00:47:18,730
I want to solve this sub-problem from i onwards.
我想从i开始解决这个子问题。 

1024
00:47:18,929 --> 00:47:20,849
What's the best play?
最好的玩法是什么？ 

1025
00:47:20,849 --> 00:47:26,849
And I guess it's going to be a max if I'm measuring winnings.
而且我想如果我要衡量奖金的话，那将是一个最大的数目。 

1026
00:47:26,849 --> 00:47:30,469
And what's the winnings if I decide to hit this many times?
如果我决定多次击中冠军，将会获得什么收益？ 

1027
00:47:30,469 --> 00:47:33,529
It's a little bit hard to write down the exact formula.
写下确切的公式有点困难。 

1028
00:47:33,530 --> 00:47:37,269
I'm going to write a rough version which
我要写一个粗略的版本

1029
00:47:37,269 --> 00:47:40,449
is the outcome of that first play.
是第一场比赛的结果。 

1030
00:47:40,449 --> 00:47:47,399
It's going to be either I lose $1, we tie, or I win $1.
要么我输了1美元，我们平手，要么我赢了1美元。 

1031
00:47:47,400 --> 00:47:49,300
So if we end up with the same value,
因此，如果最终得出相同的值， 

1032
00:47:49,300 --> 00:47:51,250
you actually-- in most versions--
您实际上-在大多数版本中- 

1033
00:47:51,449 --> 00:47:53,250
you get your money back, nothing changes.
您取回了您的钱，没有任何变化。 

1034
00:47:53,250 --> 00:47:55,320
The bet is nullified.
下注无效。 

1035
00:47:55,320 --> 00:47:56,822
So that's a zero outcome.
所以这是零结果。 

1036
00:47:57,021 --> 00:47:58,480
But if we're only betting $1, these
但是如果我们只下注$ 1，这些

1037
00:47:58,480 --> 00:47:59,849
are the three possible outcomes.
是三个可能的结果。 

1038
00:47:59,849 --> 00:48:01,250
You can compute this, right?
您可以计算出来，对不对？ 

1039
00:48:01,250 --> 00:48:03,469
If I told you how many times you hit,
如果我告诉你你打了多少次

1040
00:48:03,469 --> 00:48:06,659
then you just execute through those cards
然后您只需通过这些卡执行

1041
00:48:06,659 --> 00:48:08,649
and you compute the values of my hand,
然后你计算出我的手的价值

1042
00:48:08,650 --> 00:48:11,019
of your hand versus the dealer's hand.
与经销商的手。 

1043
00:48:11,019 --> 00:48:13,130
You see, did anyone bust?
你看，有人破产吗？ 

1044
00:48:13,130 --> 00:48:13,789
If so, they lose.
如果是这样，他们输了。 

1045
00:48:13,989 --> 00:48:16,529
Otherwise you compare the values and you
否则，您将比较这些值，然后

1046
00:48:16,530 --> 00:48:19,360
see which is bigger or smaller.
看看哪个更大或更小。 

1047
00:48:19,360 --> 00:48:22,210
This is easy to do in linear time.
这在线性时间内很容易做到。 

1048
00:48:22,210 --> 00:48:22,949
No biggie.
没关系

1049
00:48:22,949 --> 00:48:24,664
What's useful here is that the dealer strategy
这里有用的是经销商策略

1050
00:48:24,864 --> 00:48:25,919
is deterministic.
是确定性的。 

1051
00:48:25,920 --> 00:48:29,217
So after you know how many cards you take, what the dealer does
因此，在知道要取多少张卡之后，发牌人会做什么

1052
00:48:29,217 --> 00:48:30,550
is force, because he just looks.
是力量，因为他只是长相。 

1053
00:48:30,550 --> 00:48:32,289
Do I have 17 or greater?
我是否有17岁或以上？ 

1054
00:48:32,289 --> 00:48:35,840
If not, take another card and keep repeating that.
如果没有，请再拿一张卡并继续重复。 

1055
00:48:35,840 --> 00:48:37,019
So it's a deterministic strategy.
因此，这是一种确定性策略。 

1056
00:48:37,219 --> 00:48:39,939
In linear time, you can figure out what the outcome is.
在线性时间内，您可以确定结果是什么。 

1057
00:48:39,940 --> 00:48:42,909
Then you also have to add the outcome of all the remaining
然后，您还必须添加所有剩余的结果

1058
00:48:42,909 --> 00:48:44,702
cards, which is just BG of j.
卡，仅是j的BG。 

1059
00:48:44,702 --> 00:48:47,949
This is recursion, super easy.
这是递归，超级容易。 

1060
00:48:47,949 --> 00:48:50,230
We do this for all choices of j.
我们对j的所有选择都这样做。 

1061
00:48:50,230 --> 00:48:53,539



1062
00:48:53,739 --> 00:48:59,339
It's like a range of i plus 4 up to n, I think.
我认为这就像是i加4到n的范围。 

1063
00:48:59,340 --> 00:49:06,170



1064
00:49:06,170 --> 00:49:07,639
Sure, that'll work.
当然可以。 

1065
00:49:07,639 --> 00:49:09,920
I should probably put an if here,
我可能应该在这里放一个

1066
00:49:09,920 --> 00:49:11,420
which is if it's a valid play.
这是一个有效的游戏。 

1067
00:49:11,420 --> 00:49:14,067



1068
00:49:14,067 --> 00:49:15,400
There are some constraints here.
这里有一些限制。 

1069
00:49:15,400 --> 00:49:18,532
If I've already busted, I can't hit again.
如果我已经破产，我将无法再打。 

1070
00:49:18,532 --> 00:49:20,289
So in fact what you have to do in this for loop
所以实际上，您在此for循环中必须要做的

1071
00:49:20,489 --> 00:49:22,199
is say, well, maybe I take another hit.
是说，好吧，也许我会再受打击。 

1072
00:49:22,199 --> 00:49:23,240
Maybe I take another hit.
也许我再受打击。 

1073
00:49:23,240 --> 00:49:25,329
At some point I go over 21, and then you
在某个时候我超过21岁，然后你

1074
00:49:25,329 --> 00:49:26,690
have to stop the for loop.
必须停止for循环。 

1075
00:49:26,690 --> 00:49:27,980
So I'm writing that as an if.
所以我写的是一个假设。 

1076
00:49:27,980 --> 00:49:30,679
You can also do it with a break, however you want.
您也可以休息一下，但是可以。 

1077
00:49:30,679 --> 00:49:34,909
But that's-- you're considering all possible options,
但这就是-您正在考虑所有可能的选择， 

1078
00:49:34,909 --> 00:49:36,310
all valid options of play.
所有有效的游戏选项。 

1079
00:49:36,311 --> 00:49:38,059
For each of them, you see what the outcome
对于每个人，您都会看到结果

1080
00:49:38,059 --> 00:49:40,949
was after the dealer takes some more cards.
是在发牌者再拿几张卡之后。 

1081
00:49:40,949 --> 00:49:44,509
This is actually a little bit funny.
这实际上有点有趣。 

1082
00:49:44,510 --> 00:49:49,900
Sorry, this should really be the number of hits in range
抱歉，这确实应该是范围内的点击数

1083
00:49:50,099 --> 00:49:51,880
from, let's say, 0 to n.
从0到n。 

1084
00:49:51,880 --> 00:49:53,559
Maybe you don't hit at all.
也许您根本不打。 

1085
00:49:53,559 --> 00:49:55,500
And then j is a little bit tricky,
然后j有点棘手， 

1086
00:49:55,500 --> 00:50:01,150
because this is actually i plus 4 plus the number of hits
因为这实际上是我加4加上点击数

1087
00:50:01,150 --> 00:50:02,539
plus the number of dealer hits.
加上经销商点击数。 

1088
00:50:02,739 --> 00:50:05,750



1089
00:50:05,750 --> 00:50:07,699
OK, so you have to run this algorithm
好，所以你必须运行这个算法

1090
00:50:07,699 --> 00:50:09,879
to compute what happened, which computes
计算发生了什么，计算

1091
00:50:09,880 --> 00:50:11,769
how many times a dealer took a card.
经销商拿了多少次卡。 

1092
00:50:11,969 --> 00:50:14,659
That's how many cards got consumed.
那就是消耗了多少张卡。 

1093
00:50:14,659 --> 00:50:17,879
And so that's-- if you do i plus 4 plus that plus that,
所以这就是-如果您这样做，我加4加那， 

1094
00:50:17,880 --> 00:50:21,250
that's how many cards are left, or where the cards resume.
那就是剩下多少张卡，或者卡恢复的位置。 

1095
00:50:21,449 --> 00:50:23,199
And then you call BG on that.
然后您致电BG。 

1096
00:50:23,199 --> 00:50:25,699
So we're, in general, from BG of i--
因此，我们通常来自i的BG 

1097
00:50:25,699 --> 00:50:29,919
if you think of the DAG-- there's some position,
如果您想到DAG-有一些立场， 

1098
00:50:29,920 --> 00:50:32,349
maybe i plus 4 happens.
也许我加4发生了。 

1099
00:50:32,349 --> 00:50:33,349
Maybe it doesn't happen.
也许不会发生。 

1100
00:50:33,349 --> 00:50:36,480
It depends on what the dealer does.
这取决于经销商的行为。 

1101
00:50:36,480 --> 00:50:40,650
We're going to depend on i plus 6, i plus 5 maybe.
我们将取决于我加6，也许我加5。 

1102
00:50:40,650 --> 00:50:43,039
It's going to be all of these possibilities.
这将是所有这些可能性。 

1103
00:50:43,039 --> 00:50:46,072
These are all different plays.
这些都是不同的戏剧。 

1104
00:50:46,072 --> 00:50:47,655
And then on each of these edges, we're
然后在每一个边缘上，我们

1105
00:50:47,655 --> 00:50:50,090
going to have plus 1, 0, or minus 1.
将具有加1、0或减1。 

1106
00:50:50,090 --> 00:50:55,019
Those are the outcomes, whether I won or lost or tied.
这些都是结果，无论我是赢还是输，还是并列。 

1107
00:50:55,219 --> 00:50:59,039
And then we're just computing a shortest path in this DAG.
然后，我们只是在计算此DAG中的最短路径。 

1108
00:50:59,039 --> 00:51:02,779
It's actually really easy if you think about it that way.
如果以这种方式考虑，这实际上非常容易。 

1109
00:51:02,780 --> 00:51:04,403
This is just how many cards are left.
这就是剩余的卡数。 

1110
00:51:04,403 --> 00:51:07,070
From that position, you just see what are all the possibilities?
从这个位置，您仅看到所有可能性？ 

1111
00:51:07,070 --> 00:51:09,710
What are all the edges that I could go to?
我可以去找哪些优势？ 

1112
00:51:09,710 --> 00:51:11,340
What states could I to go to next?
我可以进入下一个状态？ 

1113
00:51:11,340 --> 00:51:12,730
How many cards are remaining?
剩余多少张卡？ 

1114
00:51:12,730 --> 00:51:15,329
How much did it cost me or win me?
它花了我多少钱或赢得了我？ 

1115
00:51:15,329 --> 00:51:18,382
And then take longest paths in that DAG.
然后在该DAG中采取最长的路径。 

1116
00:51:18,382 --> 00:51:20,090
That will give you the exact same answer.
那会给你完全相同的答案。 

1117
00:51:20,090 --> 00:51:22,579
That's what this dynamic programming is doing.
这就是这种动态编程的目的。 

1118
00:51:22,579 --> 00:51:25,389
In the lecture notes, there's more details where I actually
在讲义中，我实际上在哪里有更多详细信息

1119
00:51:25,389 --> 00:51:28,000
tried to write out this function, this recurrence
试图写出这个功能，这种重复

1120
00:51:28,000 --> 00:51:29,389
as an algorithm.
作为一种算法。 

1121
00:51:29,389 --> 00:51:31,809
You could do it, assuming I've got everything right.
假设我一切正确，您可以做到。 

1122
00:51:31,809 --> 00:51:33,699
It's not that hard.
没那么难。 

1123
00:51:33,699 --> 00:51:36,409
The order here is just the same as the order we did before.
这里的顺序与我们之前的顺序相同。 

1124
00:51:36,409 --> 00:51:38,960
The running time is going to be cubic in the worst case,
在最坏的情况下，运行时间将是三次的

1125
00:51:38,960 --> 00:51:41,820
because we have-- it's a little non-obvious,
因为我们有-这有点不明显， 

1126
00:51:41,820 --> 00:51:43,530
but we have n sub-problems.
但是我们有n个子问题。 

1127
00:51:43,530 --> 00:51:45,019
For each of them, we have n choices.
对于每个人，我们都有n个选择。 

1128
00:51:45,219 --> 00:51:49,739
And for each choice we have to run the dealer strategy.
对于每种选择，我们都必须执行经销商策略。 

1129
00:51:49,739 --> 00:51:51,869
And so that conceivably could take linear time.
因此，可以想象会花费线性时间。 

1130
00:51:51,869 --> 00:51:53,589
Here I'm assuming a general value of 21.
在这里，我假设一般值为21。 

1131
00:51:53,590 --> 00:51:55,760
If 21 is actually constant, it only
如果21实际上是常数，则仅

1132
00:51:55,760 --> 00:51:57,940
be constant time to play out a single hand,
保持不断发挥单手的时间， 

1133
00:51:57,940 --> 00:51:59,250
and then it's quadratic time.
然后是二次时间。 

1134
00:51:59,449 --> 00:52:03,379
So it depends on your model of generalized blackjack.
因此，这取决于您的广义二十一点模型。 

1135
00:52:03,380 --> 00:52:04,380
But that's it.
就是这样。 

1136
00:52:04,380 --> 00:52:06,940
And get some flavor of the power of dynamic programming,
并获得动态编程的力量， 

1137
00:52:06,940 --> 00:52:09,110
we're going to see it's even more powerful than this
我们将看到它比这更强大

1138
00:52:09,110 --> 00:52:14,110
in the next two lectures.
在接下来的两个讲座中。 

