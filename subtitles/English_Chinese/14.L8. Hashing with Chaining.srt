1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:21,835



10
00:00:21,835 --> 00:00:22,710
PROFESSOR: All right.
教授：好的。 

11
00:00:22,710 --> 00:00:24,980
Let's get started.
让我们开始吧。 

12
00:00:24,980 --> 00:00:27,730
Today we start a brand new section of 006,
今天我们开始一个全新的006部分

13
00:00:27,730 --> 00:00:29,620
which is hashing.
这是哈希。 

14
00:00:29,620 --> 00:00:30,429
Hashing is cool.
哈希很酷。 

15
00:00:30,429 --> 00:00:34,229
It is probably the most used and common and important
它可能是最常用，最常见和最重要的

16
00:00:34,229 --> 00:00:36,494
data structure and all of computer science.
数据结构和所有计算机科学。 

17
00:00:36,494 --> 00:00:41,859
It's in, basically, every system you've ever used, I think.
我认为，基本上，它位于您曾经使用过的每个系统中。 

18
00:00:41,859 --> 00:00:44,219
And in particular, it's in Python
特别是在Python中

19
00:00:44,219 --> 00:00:46,326
as part of what makes Python fun to program in.
是使Python有趣编程的一部分。 

20
00:00:46,326 --> 00:00:49,740
And basically, every modern programming language has it.
基本上，每种现代编程语言都有它。 

21
00:00:49,740 --> 00:00:53,609
So today is about how to make it actually happen.
所以今天是关于如何使其真正实现的。 

22
00:00:53,609 --> 00:00:54,659
So what is it?
那是什么

23
00:00:54,659 --> 00:00:57,229



24
00:00:57,229 --> 00:00:58,689
It is usually called a dictionary.
它通常被称为字典。 

25
00:00:58,689 --> 00:01:01,960



26
00:01:01,960 --> 00:01:04,280
So this is an abstract data if you
所以这是一个抽象数据

27
00:01:04,280 --> 00:01:07,245
remember that term from a couple lectures ago.
记得之前几次演讲中的那个词。 

28
00:01:07,245 --> 00:01:13,079



29
00:01:13,079 --> 00:01:15,450
It's kind of an old term, not so common anymore,
这是一个古老的名词，不再常见了， 

30
00:01:15,450 --> 00:01:18,340
but it's useful to think about.
但是考虑一下很有用。 

31
00:01:18,340 --> 00:01:22,900
So a dictionary is a data structure,
因此，字典是一种数据结构， 

32
00:01:22,900 --> 00:01:26,900
or it's a thing, that can store items,
或者是可以存储物品的东西， 

33
00:01:26,900 --> 00:01:29,194
and it can insert items, delete items and search for items.
它可以插入项目，删除项目和搜索项目。 

34
00:01:29,394 --> 00:01:35,179



35
00:01:35,180 --> 00:01:40,230
So in general, it's going to be a set of items,
所以总的来说，它将是一组项目， 

36
00:01:40,230 --> 00:01:41,359
each item has a key.
每个项目都有一个钥匙。 

37
00:01:41,359 --> 00:01:47,719



38
00:01:47,719 --> 00:01:56,079
And you can insert an item, you can delete an item
您可以插入一个项目，也可以删除一个项目

39
00:01:56,079 --> 00:02:06,719
from the set, and you can search for a key, not an item.
从集合中，您可以搜索密钥，而不是项目。 

40
00:02:06,719 --> 00:02:09,143
And the interesting part is the search.
有趣的部分是搜索。 

41
00:02:09,143 --> 00:02:10,933
I think you know what insert and delete do.
我想您知道插入和删除的作用。 

42
00:02:10,933 --> 00:02:20,359



43
00:02:20,360 --> 00:02:22,814
So there are two outcomes to this kind of search.
因此，这种搜索有两个结果。 

44
00:02:23,014 --> 00:02:25,269
This is what I call an exact search.
这就是我所说的精确搜索。 

45
00:02:25,270 --> 00:02:29,439
Either you find an item with a given key, or there isn't one,
您是否找到了具有给定键的项，或者没有， 

46
00:02:29,439 --> 00:02:32,534
and then you just say key error in Python.
然后您只说Python中的关键错误。 

47
00:02:32,534 --> 00:02:41,949



48
00:02:41,949 --> 00:02:42,449
OK.
好。 

49
00:02:42,449 --> 00:02:44,149
This is a little different from what
这与

50
00:02:44,149 --> 00:02:45,689
we could do with binary search trees.
我们可以使用二叉搜索树。 

51
00:02:45,689 --> 00:02:47,689
Binary search trees, if we didn't find a key,
二进制搜索树，如果我们找不到键， 

52
00:02:47,689 --> 00:02:50,900
we could find the next larger and the next smaller
我们可以找到下一个更大的和下一个较小的

53
00:02:50,900 --> 00:02:52,661
successor and predecessor.
后继者和前任者。 

54
00:02:52,661 --> 00:02:54,659
With dictionaries you're not allowed to do that,
使用字典，您将无法这样做， 

55
00:02:54,659 --> 00:02:56,150
or you're not able to do that.
否则您将无法做到。 

56
00:02:56,150 --> 00:02:57,900
And you're just interested in the question
您只是对这个问题感兴趣

57
00:02:57,900 --> 00:02:58,930
does the key exist?
钥匙是否存在？ 

58
00:02:58,930 --> 00:03:02,090
And if so, give me the item with that key.
如果是这样，请给我带有该钥匙的物品。 

59
00:03:02,090 --> 00:03:04,990
So we're assuming here that the items have unique keys,
因此，我们在这里假设项目具有唯一键， 

60
00:03:04,990 --> 00:03:07,162
no two items have the same key.
没有两个项目具有相同的密钥。 

61
00:03:07,361 --> 00:03:08,819
And one way to enforce that is when
一种实施方法是

62
00:03:08,819 --> 00:03:11,430
you insert an item with an existing key,
您插入具有现有密钥的项目， 

63
00:03:11,430 --> 00:03:12,939
it overwrites whatever key was there.
它会覆盖那里的任何密钥。 

64
00:03:13,139 --> 00:03:15,069
That's the Python behavior.
这就是Python的行为。 

65
00:03:15,069 --> 00:03:18,549
So we'll assume that.
所以我们假设。 

66
00:03:18,550 --> 00:03:25,650
Overwrite any existing key.
覆盖任何现有密钥。 

67
00:03:25,650 --> 00:03:31,530



68
00:03:31,729 --> 00:03:34,479
And so, it's well defined what search does.
因此，定义明确了搜索的作用。 

69
00:03:34,479 --> 00:03:36,115
Either there's one item with that key,
要么有一个带有那个钥匙的物品， 

70
00:03:36,116 --> 00:03:37,490
or there's no item with that key,
或没有带有该钥匙的物品， 

71
00:03:37,490 --> 00:03:41,060
and it tells you what the situation is.
它告诉您情况如何。 

72
00:03:41,259 --> 00:03:41,759
OK.
好。 

73
00:03:41,759 --> 00:03:47,709
So one way to solve dictionaries is
所以解决字典的一种方法是

74
00:03:47,710 --> 00:03:51,150
to use a balanced binary search tree like AVL trees.
使用像AVL树这样的平衡二叉搜索树。 

75
00:03:51,150 --> 00:03:54,710
And so you can do all of these operations on log n time.
因此，您可以在登录n时执行所有这些操作。 

76
00:03:54,710 --> 00:04:01,719



77
00:04:01,719 --> 00:04:04,219
I mean, you can ignore the fact that AVL trees give you
我的意思是，您可以忽略AVL树为您提供的事实

78
00:04:04,219 --> 00:04:06,199
more information when you do a search,
搜索时获得更多信息， 

79
00:04:06,199 --> 00:04:08,539
and still does exact search.
并且仍会进行精确搜索。 

80
00:04:08,539 --> 00:04:12,689
So that's one solution, but it turns out you can do better.
因此，这是一种解决方案，但事实证明您可以做得更好。 

81
00:04:12,689 --> 00:04:16,110
And while last class was about, well, in the comparison model
虽然最后一堂课是关于比较模型的

82
00:04:16,110 --> 00:04:20,120
the best way to sort is n log n and the best way to search
最好的排序方式是n log n和最好的搜索方式

83
00:04:20,120 --> 00:04:21,569
is log n.
是日志n。 

84
00:04:21,569 --> 00:04:23,870
Then we saw in the RAM model, where
然后我们在RAM模型中看到

85
00:04:23,870 --> 00:04:27,600
if you assume your items are integers we can sort faster,
如果您假设您的商品是整数，我们可以更快地进行排序， 

86
00:04:27,600 --> 00:04:29,439
sometimes we can sort in linear time.
有时我们可以按线性时间排序。 

87
00:04:29,439 --> 00:04:33,709
Today's lecture is about how to search faster than log n time.
今天的讲座是关于如何以比登录时间更快的速度进行搜索。 

88
00:04:33,709 --> 00:04:37,680
And we're going to get down to constant time.
而我们将要走到恒定的时间。 

89
00:04:37,680 --> 00:04:41,019
No-- basically, no assumptions except, maybe,
不，基本上没有任何假设，也许

90
00:04:41,019 --> 00:04:43,109
that your keys are integers.
您的键是整数。 

91
00:04:43,110 --> 00:04:45,449
We'll be able to get down to constant time
我们将能够走到恒定的时间

92
00:04:45,449 --> 00:04:46,365
with high probability.
可能性很高。 

93
00:04:46,365 --> 00:04:48,889



94
00:04:48,889 --> 00:04:51,029
It's going to be a randomized data structure.
这将是一个随机的数据结构。 

95
00:04:51,029 --> 00:04:53,489
It's one of the few instances of randomization in 006,
这是006年为数不多的随机化实例之一， 

96
00:04:53,490 --> 00:04:56,259
but it'll be pretty simple to analyze, so don't worry.
但是分析起来非常简单，所以不用担心。 

97
00:04:56,259 --> 00:04:59,331
But we're going to use some probability today.
但是我们今天要使用一些概率。 

98
00:04:59,331 --> 00:05:00,415
Make it a little exciting.
让它变得令人兴奋。 

99
00:05:00,415 --> 00:05:03,290



100
00:05:03,290 --> 00:05:05,470
I think you know how dictionaries work in Python.
我想您知道字典在Python中是如何工作的。 

101
00:05:05,470 --> 00:05:11,810
In Python it's the dict data type.
在Python中，它是dict数据类型。 

102
00:05:11,810 --> 00:05:14,600
We've used it all over the place.
我们在整个地方都用过它。 

103
00:05:14,600 --> 00:05:17,560
The key things you can do are lookup a key
您可以做的关键事情是查找关键

104
00:05:17,759 --> 00:05:24,099
and-- so this is the analog of search--
并且-这就是搜索的类似物- 

105
00:05:24,100 --> 00:05:27,970
you can set a key to a value.
您可以将键设置为值。 

106
00:05:27,970 --> 00:05:30,759
This is the analog of an insert.
这是插入的类似物。 

107
00:05:30,959 --> 00:05:33,169
It overwrites whatever was there.
它会覆盖那里的所有内容。 

108
00:05:33,170 --> 00:05:33,810
And what else?
还有什么？ 

109
00:05:33,810 --> 00:05:34,610
Delete.
删除。 

110
00:05:34,610 --> 00:05:38,129
So you can delete a particular key.
因此，您可以删除特定的密钥。 

111
00:05:38,129 --> 00:05:42,113



112
00:05:42,113 --> 00:05:42,759
OK.
好。 

113
00:05:42,759 --> 00:05:44,593
We'll usually use this notation because it's
我们通常会使用这种表示法，因为

114
00:05:44,593 --> 00:05:46,139
more familiar and intuitive.
更熟悉和直观。 

115
00:05:46,339 --> 00:05:48,689
But the big topic today is how do you actually
但是今天最重要的话题是

116
00:05:48,689 --> 00:05:53,069
implement these operations for a dictionary, D?
为字典实现这些操作，D？ 

117
00:05:53,069 --> 00:05:56,360
The one specific thing about Python dictionaries
关于Python词典的一件事

118
00:05:56,360 --> 00:06:01,264
is that an item is basically a pair
基本上是一对

119
00:06:01,464 --> 00:06:05,379
of two things, a key and a value.
两件事，一个键和一个值。 

120
00:06:05,379 --> 00:06:07,409
And so, in particular, when you call d.items
因此，尤其是当您调用d.items时

121
00:06:07,410 --> 00:06:11,079
you get a whole bunch of ordered pairs, a key and a value.
您会得到一大堆有序的对，一个键和一个值。 

122
00:06:11,279 --> 00:06:13,219
And so the key is always-- the key of an item
因此，关键永远是项目的关键

123
00:06:13,220 --> 00:06:14,951
is always this first part.
始终是第一部分。 

124
00:06:15,151 --> 00:06:16,134
So it's well defined.
因此，它定义明确。 

125
00:06:16,134 --> 00:06:20,034



126
00:06:20,035 --> 00:06:20,535
OK.
好。 

127
00:06:20,535 --> 00:06:22,870



128
00:06:23,069 --> 00:06:28,120
So that's Python dictionaries.
这就是Python字典。 

129
00:06:28,120 --> 00:06:32,329
So one obvious motivation for building dictionaries
因此，建立字典的一个明显动机

130
00:06:32,529 --> 00:06:34,979
is you need them in Python.
您在Python中需要它们吗？ 

131
00:06:34,980 --> 00:06:37,379
And in fact, people use them all the time.
实际上，人们一直在使用它们。 

132
00:06:37,379 --> 00:06:39,829
We used them in docdist.
我们在docdist中使用了它们。 

133
00:06:39,829 --> 00:06:43,889
All of the fastest versions of the document distance problem
所有最快版本的文档距离问题

134
00:06:43,889 --> 00:06:48,079
used dictionaries for counting words, how many times each word
用字典来计数单词，每个单词多少次

135
00:06:48,079 --> 00:06:51,469
occurs in a document, and for computing inner products,
出现在文档中，对于计算内部产品， 

136
00:06:51,470 --> 00:06:54,439
for finding common words between two documents.
查找两个文档之间的常用词。 

137
00:06:54,639 --> 00:06:57,034
And it's just it's the best way to do things,
这是做事的最好方法， 

138
00:06:57,035 --> 00:07:00,266
it's the easiest way to do things , and the fastest.
这是做事的最简单方法，也是最快的方法。 

139
00:07:00,466 --> 00:07:02,800
As a result, dictionaries are built into basically every
结果，基本上每个字典都内置了字典

140
00:07:02,800 --> 00:07:06,980
modern programming language, Python, Perl, Ruby, JavaScript,
现代编程语言，Python，Perl，Ruby，JavaScript， 

141
00:07:06,980 --> 00:07:08,110
Java, C++, C#.
 Java，C ++，C＃。 

142
00:07:08,110 --> 00:07:10,970
In modern versions, all have some version of dictionaries.
在现代版本中，所有版本都有一些版本的词典。 

143
00:07:10,970 --> 00:07:13,790
And they all run in, basically, constant time
它们基本上都在恒定的时间内运行

144
00:07:13,790 --> 00:07:16,615
using the stuff that's in this lecture and the next two
使用本讲座中的内容以及接下来的两个

145
00:07:16,615 --> 00:07:17,115
lectures.
讲座。 

146
00:07:17,115 --> 00:07:20,129



147
00:07:20,129 --> 00:07:21,300
Let's see.
让我们来看看。 

148
00:07:21,300 --> 00:07:23,884
It's also, in, basically, every database.
基本上，它也在每个数据库中。 

149
00:07:24,084 --> 00:07:26,894



150
00:07:26,894 --> 00:07:29,310
There are essentially two kinds of databases in the world,
世界上基本上有两种数据库， 

151
00:07:29,310 --> 00:07:30,684
there are those that use hashing,
有些使用散列， 

152
00:07:30,684 --> 00:07:32,800
and there are those that use search trees.
还有一些使用搜索树的网站。 

153
00:07:32,800 --> 00:07:33,759
Sometimes you need one.
有时您需要一个。 

154
00:07:33,759 --> 00:07:35,094
Sometimes you need the other.
有时您需要另一个。 

155
00:07:35,095 --> 00:07:37,470
There are a lot of situations in databases where you just
数据库中有很多情况， 

156
00:07:37,470 --> 00:07:38,882
need hashing.
需要哈希。 

157
00:07:39,081 --> 00:07:40,540
So if you've ever used Berkeley DB,
因此，如果您曾经使用过Berkeley DB， 

158
00:07:40,540 --> 00:07:44,250
there's a hash type of a database.
数据库的哈希类型。 

159
00:07:44,449 --> 00:07:48,459
So if things like, when you go to Merriam-Webster,
因此，如果发生类似情况，当您去Merriam-Webster时， 

160
00:07:48,459 --> 00:07:51,199
and you look up a word, how do you
你抬头一句话，你怎么样

161
00:07:51,199 --> 00:07:53,860
find the definition of that word?
找到那个词的定义？ 

162
00:07:53,860 --> 00:07:57,889
You use a hash table, you use a dictionary, I should say.
我应该说，您使用哈希表，使用字典。 

163
00:07:58,089 --> 00:08:02,099
How do you-- when you spell check your document,
您如何-拼写检查文件时， 

164
00:08:02,100 --> 00:08:04,360
how do you tell whether a word is correctly spelled?
您如何判断一个单词的拼写是否正确？ 

165
00:08:04,360 --> 00:08:05,593
You look it up in a dictionary.
您在字典中查找它。 

166
00:08:05,793 --> 00:08:07,209
If it's not correctly spelled, how
如果拼写不正确，如何

167
00:08:07,209 --> 00:08:11,519
do you find the closest related, correct spelling?
您找到最接近的相关正确拼写吗？ 

168
00:08:11,519 --> 00:08:12,894
You try tweaking one the letters,
您尝试调整一个字母， 

169
00:08:12,894 --> 00:08:15,103
and look it up in a dictionary and see if it's there.
并在字典中查找它是否存在。 

170
00:08:15,103 --> 00:08:17,600
You do that for all possible letters, or maybe two letters.
您对所有可能的字母或两个字母执行此操作。 

171
00:08:17,600 --> 00:08:21,899
That is a state of the art way to do spelling correction.
这是进行拼写校正的最新方式。 

172
00:08:21,899 --> 00:08:23,439
Just keep looking up in a dictionary.
只是继续查字典。 

173
00:08:23,439 --> 00:08:25,445
Because dictionaries are so fast you
因为字典这么快，你

174
00:08:25,446 --> 00:08:27,745
can afford to do things like trial perturbations of letters.
有能力做一些尝试，例如对信件进行骚扰。 

175
00:08:27,944 --> 00:08:30,819



176
00:08:30,819 --> 00:08:32,038
What else.
还有什么。 

177
00:08:32,038 --> 00:08:34,769
In the old days, which means pre-Google,
在过去，这意味着在Google之前， 

178
00:08:34,769 --> 00:08:38,029
every search engine on the web would
网络上的每个搜索引擎都会

179
00:08:38,029 --> 00:08:41,259
have a dictionary that says, for given word,
有一本字典说，对于给定的单词， 

180
00:08:41,259 --> 00:08:44,120
give me all of the documents containing that word.
给我所有包含该词的文件。 

181
00:08:44,120 --> 00:08:48,759
Google doesn't do it that way, but that's another story.
 Google不会那样做，但这是另一回事。 

182
00:08:48,759 --> 00:08:50,870
It's less fancy, actually.
实际上，它不那么花哨。 

183
00:08:50,870 --> 00:08:52,960
Or when you log into a system, you
或者，当您登录系统时， 

184
00:08:52,960 --> 00:08:54,940
type your username and password.
输入您的用户名和密码。 

185
00:08:54,940 --> 00:08:57,561
You look in a dictionary that stores a username
您在存储用户名的字典中查找

186
00:08:57,761 --> 00:08:59,219
and, associated with that username,
并且与该用户名相关联， 

187
00:08:59,220 --> 00:09:00,956
all the information of that user.
该用户的所有信息。 

188
00:09:00,956 --> 00:09:03,039
Every time you log into a web system, or whatever,
每次您登录网络系统时， 

189
00:09:03,039 --> 00:09:05,439
it is going through a dictionary.
它正在通过字典。 

190
00:09:05,440 --> 00:09:07,319
So they're all over the place.
所以他们到处都是。 

191
00:09:07,519 --> 00:09:09,329
One of the original applications is
原始应用之一是

192
00:09:09,330 --> 00:09:11,211
in writing programming languages.
编写编程语言。 

193
00:09:11,211 --> 00:09:12,669
Some of the first computer programs
一些最初的计算机程序

194
00:09:12,669 --> 00:09:15,075
were programming languages, so you could actually
是编程语言，所以您实际上可以

195
00:09:15,076 --> 00:09:16,450
program them in a reasonable way.
以合理的方式对它们进行编程。 

196
00:09:16,450 --> 00:09:21,860



197
00:09:21,860 --> 00:09:25,496
Whenever you type a variable name the computer doesn't
每当您键入变量名时，计算机都不会

198
00:09:25,496 --> 00:09:27,079
really think about that variable name,
真正考虑那个变量名， 

199
00:09:27,080 --> 00:09:29,500
it wants to think about an address in memory.
它想考虑内存中的地址。 

200
00:09:29,500 --> 00:09:31,820
And so you've got to translate that variable name
因此，您必须翻译该变量名

201
00:09:31,820 --> 00:09:36,340
into a real, physical address in the machine, or a position
到机器中真实的物理地址或位置

202
00:09:36,340 --> 00:09:39,950
on the stack, or whatever it is in real life.
在堆栈上，或现实生活中的任何东西。 

203
00:09:39,950 --> 00:09:41,950
In the old days of Python, I guess
我想在Python的旧时代

204
00:09:41,950 --> 00:09:45,349
this is pre-Python 2 or so, 2.1, I
这是Python 2之前的版本，2.1，我

205
00:09:45,549 --> 00:09:48,389
don't remember the exact transition it was.
不记得那是确切的过渡了。 

206
00:09:48,389 --> 00:09:50,759
In the interpreter, there was the dictionary
在口译员那里有字典

207
00:09:50,759 --> 00:09:52,099
of all your global variables, there's
在所有全局变量中， 

208
00:09:52,299 --> 00:09:54,419
a dictionary of all your local variables.
所有局部变量的字典。 

209
00:09:54,419 --> 00:09:58,685
And that was-- it was right there.
那就是-就在那儿。 

210
00:09:58,686 --> 00:10:00,109
I mean you could modify the dictionary,
我的意思是你可以修改字典， 

211
00:10:00,309 --> 00:10:01,392
you could do crazy things.
你可以做疯狂的事情。 

212
00:10:01,393 --> 00:10:03,519
And all the variables were there.
所有的变量都在那里。 

213
00:10:03,519 --> 00:10:06,049
And so they'd match the key to the actual value
因此，它们会将密钥与实际值匹配

214
00:10:06,049 --> 00:10:07,519
stored in the variable.
存储在变量中。 

215
00:10:07,519 --> 00:10:09,919
They don't do that anymore because it's a little slow,
他们不再这样做了，因为它有点慢， 

216
00:10:09,919 --> 00:10:12,019
but-- and you could do better in practice.
但是，您可以在实践中做得更好。 

217
00:10:12,019 --> 00:10:14,109
But at the very least, when you're compiling the thing,
但是至少，当您编译事物时， 

218
00:10:14,309 --> 00:10:16,069
you need a dictionary.
你需要一本字典。 

219
00:10:16,070 --> 00:10:20,120
And then, later on, you can do more efficient lookups.
然后，以后可以进行更有效的查找。 

220
00:10:20,120 --> 00:10:20,659
Let's see.
让我们来看看。 

221
00:10:20,659 --> 00:10:23,579



222
00:10:23,580 --> 00:10:26,490
On the internet there are hash tables all over,
互联网上到处都有哈希表， 

223
00:10:26,490 --> 00:10:28,730
like in your router.
就像在您的路由器中一样。 

224
00:10:28,730 --> 00:10:30,480
Router needs to know all the machines that
路由器需要知道所有的机器

225
00:10:30,480 --> 00:10:31,312
are connected to it.
连接到它。 

226
00:10:31,312 --> 00:10:33,875
Each machine has an IP address, so when you get a packet in,
每台机器都有一个IP地址，因此当您收到数据包时， 

227
00:10:33,875 --> 00:10:36,039
and it says, deliver to this IP address, you see,
它说，传递到该IP地址，您会看到， 

228
00:10:36,039 --> 00:10:38,059
oh, is it in my dictionary of all the machines
哦，在我所有机器的字典中

229
00:10:38,059 --> 00:10:39,475
that are directly connected to me?
与我直接相关？ 

230
00:10:39,475 --> 00:10:40,948
If so, send it there.
如果是这样，将其发送到那里。 

231
00:10:40,948 --> 00:10:42,990
If it's not then it has to find the right subnet.
如果不是，则必须找到正确的子网。 

232
00:10:42,990 --> 00:10:44,572
That's not quite a dictionary problem,
那不是字典的问题， 

233
00:10:44,572 --> 00:10:45,819
a little more complicated.
稍微复杂一点。 

234
00:10:45,820 --> 00:10:49,109
But for looking up local machines, it's a dictionary.
但是对于查找本地计算机，这只是一本字典。 

235
00:10:49,309 --> 00:10:51,929
Routers use dictionaries because they need to go really fast.
路由器使用字典是因为它们需要走得很快。 

236
00:10:51,929 --> 00:10:55,449
They're getting a billion packets every second.
他们每秒收到十亿个数据包。 

237
00:10:55,450 --> 00:10:59,190
Also, in the network stack of a machine,
另外，在机器的网络堆栈中， 

238
00:10:59,190 --> 00:11:01,940
when you come in you get it packet delivered
当你进来的时候，你会收到包裹

239
00:11:01,940 --> 00:11:04,980
to a particular port, you need to say, oh, which application,
到特定的端口，您需要说，哦，哪个应用程序， 

240
00:11:04,980 --> 00:11:06,879
or which socket is connected to this port?
或哪个插座连接到该端口？ 

241
00:11:06,879 --> 00:11:08,629
All of these things are dictionaries.
所有这些都是字典。 

242
00:11:08,629 --> 00:11:10,087
The point is they're in, basically,
关键是他们进入了

243
00:11:10,087 --> 00:11:12,689
everything you've ever used, virtual memory,
您曾经使用过的所有内容，虚拟内存， 

244
00:11:12,690 --> 00:11:14,859
I mean, they're all over the place.
我的意思是，他们到处都是。 

245
00:11:15,059 --> 00:11:16,934
There are also some more subtle applications,
还有一些更微妙的应用程序， 

246
00:11:16,934 --> 00:11:18,892
where it is not obvious that's it a dictionary,
不明显是字典， 

247
00:11:18,893 --> 00:11:20,649
but still, we use this idea of hashing
但是我们仍然使用散列的想法

248
00:11:20,649 --> 00:11:22,230
we're going to talk about today.
我们今天要谈。 

249
00:11:22,230 --> 00:11:25,700
Like searching in a string.
就像在字符串中搜索一样。 

250
00:11:25,700 --> 00:11:30,350



251
00:11:30,350 --> 00:11:34,609
So when you hit-- I don't know-- in your favorite editor,
因此，当您在您最喜欢的编辑器中点击-不知道时， 

252
00:11:34,809 --> 00:11:36,849
you do Control-F, or Control-S, or slash,
您执行Control-F或Control-S或斜杠， 

253
00:11:36,850 --> 00:11:39,000
or whatever your way of searching for something
或以任何方式搜寻事物

254
00:11:39,000 --> 00:11:41,529
is, and you type start typing.
是，并且您键入开始键入。 

255
00:11:41,529 --> 00:11:43,929
If your editor is clever, it will
如果您的编辑很聪明，它将

256
00:11:43,929 --> 00:11:46,259
use hashing in order to search for that string.
使用散列来搜索该字符串。 

257
00:11:46,259 --> 00:11:49,769
It's a faster way to do it.
这是一种更快的方法。 

258
00:11:49,769 --> 00:11:54,409
If you use grep, for example, in Unix it does it in a fancy way.
例如，如果您使用grep，则在Unix中它会以一种奇特的方式进行。 

259
00:11:54,409 --> 00:11:56,240
Every time you do a Google search
每次您执行Google搜索

260
00:11:56,240 --> 00:11:58,149
it's essentially using this.
它实际上是在使用它。 

261
00:11:58,149 --> 00:11:59,309
It's solving this problem.
解决了这个问题。 

262
00:11:59,309 --> 00:12:01,329
I don't know what algorithm, but we could guess.
我不知道什么算法，但是我们可以猜测。 

263
00:12:01,330 --> 00:12:04,090
Using the algorithms we'll cover in next lecture.
使用算法，我们将在下一堂课中介绍。 

264
00:12:04,090 --> 00:12:06,649
It wouldn't surprise me.
这不会令我惊讶。 

265
00:12:06,649 --> 00:12:08,659
Also, if you have a couple strings
另外，如果您有几串

266
00:12:08,659 --> 00:12:14,539
and you want to know what they have in common, how similar
你想知道他们有什么共同点，有多相似

267
00:12:14,539 --> 00:12:15,384
they are?
他们是？ 

268
00:12:15,384 --> 00:12:16,599
Example, you have two DNA strings.
例如，您有两个DNA字符串。 

269
00:12:16,799 --> 00:12:20,479
You want to see how similar they are, you use hashing.
您想了解它们的相似程度，可以使用散列。 

270
00:12:20,480 --> 00:12:23,830
And you're going to do that in the next problem set, PS4,
您将在下一个问题集PS4中进行此操作， 

271
00:12:23,830 --> 00:12:27,000
which goes out on Thursday.
星期四出去。 

272
00:12:27,000 --> 00:12:31,990
Also, for things like file and directory synchronization.
同样，用于文件和目录同步。 

273
00:12:31,990 --> 00:12:38,870



274
00:12:38,870 --> 00:12:42,769
So on Unix, if you rsync or unison, or, I guess,
因此，在Unix上，如果您进行rsync或统一，或者，我想， 

275
00:12:42,769 --> 00:12:46,740
modern day-- these days, Dropbox, MIT
现代-这些天，麻省理工学院的Dropbox 

276
00:12:46,740 --> 00:12:49,580
startup-- Whenever you're synchronizing files between two
启动-每当您在两个之间同步文件时

277
00:12:49,580 --> 00:12:51,009
locations, you use hashing to tell
位置，您可以使用散列法来判断

278
00:12:51,009 --> 00:12:53,259
whether a file has changed, or whether a directory has
文件是否已更改，或者目录是否具有

279
00:12:53,259 --> 00:12:53,919
changed.
改变了。 

280
00:12:53,919 --> 00:12:56,939
That's a big idea.
那是个好主意。 

281
00:12:56,940 --> 00:12:59,940
Fairly modern idea.
相当现代的想法。 

282
00:12:59,940 --> 00:13:02,210
And also in cryptography-- this will
而且在密码学中-这将

283
00:13:02,210 --> 00:13:07,480
be a topic of next Tuesday's lecture.
成为下周二演讲的主题。 

284
00:13:07,480 --> 00:13:09,519
If you're transferring a file and you
如果您正在传输文件而您

285
00:13:09,519 --> 00:13:12,069
want to check that you actually transferred that file,
想检查您是否确实传输了该文件， 

286
00:13:12,070 --> 00:13:15,672
and there wasn't some person in the middle corrupting your file
而且中间没有人破坏您的文件

287
00:13:15,672 --> 00:13:18,004
and making it look like it was what you wanted it to be,
并使它看起来像您想要的那样， 

288
00:13:18,004 --> 00:13:21,419
you use something called cryptographic hash functions,
您使用所谓的加密哈希函数

289
00:13:21,419 --> 00:13:24,419
which [INAUDIBLE] will talk about on Tuesday.
 [音频不清晰]将在星期二谈论。 

290
00:13:24,419 --> 00:13:27,229
So tons of motivation for dictionaries.
因此，大量的词典动机。 

291
00:13:27,230 --> 00:13:32,840
Let's actually do it, see how they are done.
让我们实际去做，看看它们是如何完成的。 

292
00:13:32,840 --> 00:13:35,629



293
00:13:35,629 --> 00:13:40,990
We're going to start with sort of a very simple straw man,
我们将从一个非常简单的稻草人开始， 

294
00:13:40,990 --> 00:13:44,089
and then we're going to improve it until, by the end of today,
然后我们将对其进行改进，直到今天年底， 

295
00:13:44,089 --> 00:13:45,929
we have a really good way to solve the dictionary
我们有一个很好的方法来解决字典

296
00:13:46,129 --> 00:13:48,644
problem in constant time for operation.
在恒定的操作时间内出现问题。 

297
00:13:48,644 --> 00:13:54,189



298
00:13:54,190 --> 00:13:56,980
So the really simple approach is called a direct access table.
因此，真正简单的方法称为直接访问表。 

299
00:13:56,980 --> 00:14:00,230



300
00:14:00,230 --> 00:14:05,450
So it's just a big table, an array.
所以这只是一个大表，一个数组。 

301
00:14:05,450 --> 00:14:14,340
You have-- the index into the array is the key.
您拥有-数组的索引是关键。 

302
00:14:14,340 --> 00:14:27,329
So, store items in an array, indexed by key.
因此，将项目存储在按键索引的数组中。 

303
00:14:27,529 --> 00:14:31,990



304
00:14:31,990 --> 00:14:34,200
And in fact, Python kind makes you think about this
实际上，Python种类会让您考虑一下

305
00:14:34,200 --> 00:14:36,319
because the Python notation for accessing dictionaries
因为用于访问字典的Python表示法

306
00:14:36,519 --> 00:14:40,120
is identical to the notation for accessing arrays.
与访问数组的符号相同。 

307
00:14:40,120 --> 00:14:41,609
But with arrays, the keys are restricted
但是对于数组，键是受限制的

308
00:14:41,809 --> 00:14:45,156
to be non-negative integers, 0 through n minus 1.
为非负整数，0到n减1。 

309
00:14:45,157 --> 00:14:46,740
So why not just implement it that way?
那么，为什么不以这种方式实施呢？ 

310
00:14:46,740 --> 00:14:49,139
If your keys happen to be integers
如果您的键碰巧是整数

311
00:14:49,139 --> 00:14:52,409
I could just store all my items in a giant array.
我可以将所有物品存储在一个巨大的阵列中。 

312
00:14:52,409 --> 00:14:56,384
So if I just want to store an item here with key 2,
因此，如果我只想用键2在这里存储项目

313
00:14:56,384 --> 00:15:00,129
call that, maybe, item 2, I just put that there.
称之为，也许，第2项，我只是放在那儿。 

314
00:15:00,129 --> 00:15:03,009
If I want to store something with key 4
如果我想用钥匙4存放东西

315
00:15:03,009 --> 00:15:04,559
I'll just put it there.
我就把它放在那里。 

316
00:15:04,559 --> 00:15:07,949
Everything else is going to be null, or none, or whatever.
其他所有内容都将为null，或者为空，或者其他。 

317
00:15:07,950 --> 00:15:09,089
So lots of blank entries.
大量空白条目。 

318
00:15:09,289 --> 00:15:13,379
Whatever keys I don't use I'll just put a null value there.
无论我不使用什么键，我都会在其中放置一个空值。 

319
00:15:13,379 --> 00:15:16,000
Every key that I want to put into the dictionary
我想放入字典中的每个键

320
00:15:16,000 --> 00:15:19,620
I'll just store it at the corresponding position.
我将其存储在相应的位置。 

321
00:15:19,620 --> 00:15:20,720
What's bad about this?
这有什么不好？ 

322
00:15:20,720 --> 00:15:24,859



323
00:15:25,059 --> 00:15:25,559
Yeah.
是的

324
00:15:25,559 --> 00:15:28,378
AUDIENCE: It's hard to associate something with just an integer.
听众：很难将某事物与一个整数相关联。 

325
00:15:28,379 --> 00:15:30,469
PROFESSOR: Hard to associate something with an integer.
教授：很难将某些东西与整数联系起来。 

326
00:15:30,669 --> 00:15:31,169
Good.
好。 

327
00:15:31,169 --> 00:15:33,360
That's one problem.
那是一个问题。 

328
00:15:33,360 --> 00:15:36,100
There's actually two big problems with this structure.
这种结构实际上存在两个大问题。 

329
00:15:36,100 --> 00:15:37,580
I want both of them.
我要两个

330
00:15:37,580 --> 00:15:47,839
So bad-- badness number one is keys may not be integers.
太糟糕了-坏处之一是键可能不是整数。 

331
00:15:48,039 --> 00:16:00,020



332
00:16:00,020 --> 00:16:00,519
Good.
好。 

333
00:16:00,519 --> 00:16:03,069



334
00:16:03,070 --> 00:16:04,754
Another problem.
另一个问题。 

335
00:16:04,754 --> 00:16:05,254
Yeah.
是的

336
00:16:05,254 --> 00:16:06,750
AUDIENCE: Possibility of collision.
听众：发生碰撞的可能性。 

337
00:16:06,750 --> 00:16:08,249
PROFESSOR: Possibility of collision.
教授：可能发生碰撞。 

338
00:16:08,249 --> 00:16:09,339
So here there's no collisions.
因此，这里没有碰撞。 

339
00:16:09,539 --> 00:16:11,039
We'll get to collisions in a moment,
我们一会儿就会发生碰撞， 

340
00:16:11,039 --> 00:16:13,019
but a collision is when two items
但是碰撞是当两个项目

341
00:16:13,019 --> 00:16:16,329
go to the same slot in this table.
转到此表中的同一插槽。 

342
00:16:16,330 --> 00:16:18,979
And we defined the problem so there weren't collisions.
并且我们定义了问题，因此没有碰撞。 

343
00:16:19,179 --> 00:16:21,389
We said whenever we insert item with the same key you
我们说过，只要我们插入具有相同键的项目

344
00:16:21,389 --> 00:16:22,710
overwrite whatever is there.
覆盖那里的一切。 

345
00:16:22,710 --> 00:16:23,629
So collisions are OK.
所以碰撞就可以了。 

346
00:16:23,629 --> 00:16:26,039
They will be a problem in a moment, so save your answer.
暂时会出现问题，请保存您的答案。 

347
00:16:26,039 --> 00:16:26,539
Yeah?
是啊

348
00:16:26,539 --> 00:16:27,414
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

349
00:16:27,414 --> 00:16:29,510



350
00:16:29,510 --> 00:16:30,509
PROFESSOR: Running time?
教授：运行时间？ 

351
00:16:30,509 --> 00:16:32,069
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

352
00:16:32,070 --> 00:16:33,200
PROFESSOR: For deletion?
教授：要删除吗？ 

353
00:16:33,200 --> 00:16:35,033
Actually, running time is going to be great.
实际上，运行时间将会很棒。 

354
00:16:35,033 --> 00:16:37,860
If I want to insert-- I mean, I do these operations
如果要插入-我是说，我要执行这些操作

355
00:16:37,860 --> 00:16:39,899
but on array instead of a dictionary.
但使用数组而不是字典。 

356
00:16:39,899 --> 00:16:42,429
So if I want insert I just put something there.
因此，如果要插入，请在其中放一些东西。 

357
00:16:42,429 --> 00:16:44,479
If I want to delete I just set it to null.
如果要删除，只需将其设置为null。 

358
00:16:44,480 --> 00:16:46,950
If I want to search I just go there and see is it null?
如果要搜索，我就去那里看看它是否为空？ 

359
00:16:46,950 --> 00:16:47,600
Yeah?
是啊

360
00:16:47,600 --> 00:16:49,100
AUDIENCE: It's a gigantic memory hog
听众：这是一个巨大的记忆猪

361
00:16:49,100 --> 00:16:50,600
PROFESSOR: It's gigantic memory hog.
教授：这是巨大的记忆。 

362
00:16:50,600 --> 00:16:51,835
I like that phrasing.
我喜欢这样的措辞。 

363
00:16:51,835 --> 00:16:57,750



364
00:16:57,750 --> 00:16:58,919
Not always of course.
当然不总是如此。 

365
00:16:58,919 --> 00:17:03,099
If it happens that your keys are-- the set of possible keys
如果碰巧您的密钥是-可能的密钥集

366
00:17:03,100 --> 00:17:06,470
is not too giant then life is good.
不是太庞大，那么生活就是美好的。 

367
00:17:06,470 --> 00:17:08,593
Let's see If I cannot kill somebody today.
让我们看看我今天是否不能杀死某人。 

368
00:17:08,593 --> 00:17:09,658
Oh yes.
哦是的

369
00:17:09,858 --> 00:17:11,649
Very good.
很好。 

370
00:17:11,650 --> 00:17:13,490
But if you have a lot of keys, you
但是，如果您有很多钥匙， 

371
00:17:13,490 --> 00:17:17,848
need one slot in your array per key.
每个键在阵列中需要一个插槽。 

372
00:17:17,848 --> 00:17:19,289
That could be a lot.
可能很多。 

373
00:17:19,289 --> 00:17:23,920
Maybe your keys are 64-bit integers.
也许您的密钥是64位整数。 

374
00:17:23,920 --> 00:17:27,888
Then you need 264 slots just to store one measly dictionary.
然后，您只需要264个插槽即可存储一本麻将字典。 

375
00:17:28,088 --> 00:17:30,210
That's huge.
好大

376
00:17:30,210 --> 00:17:33,000
I guess there's also the running time of initialize that.
我想还有初始化它的运行时间。 

377
00:17:33,000 --> 00:17:35,529
But at the very least, you have huge space hog.
但是至少，您有巨大的太空猪。 

378
00:17:35,529 --> 00:17:37,410
This is bad.
这不好。 

379
00:17:37,410 --> 00:17:40,619
So we're going to fix both of these problems one at a time.
因此，我们将一次解决这两个问题。 

380
00:17:40,819 --> 00:17:43,559
First problem we're going to talk about
我们要谈论的第一个问题

381
00:17:43,559 --> 00:17:45,990
is what if your keys aren't integers?
如果您的密钥不是整数怎么办？ 

382
00:17:45,990 --> 00:17:47,490
Because if your keys aren't integers
因为如果你的钥匙不是整数

383
00:17:47,490 --> 00:17:48,430
you can't use this at all.
您根本无法使用。 

384
00:17:48,430 --> 00:17:50,179
So lets at least get something that works.
因此，至少让我们得到一些有用的东西。 

385
00:17:50,179 --> 00:17:58,419



386
00:17:58,619 --> 00:18:00,409
And this is a notion called prehashing.
这就是所谓的预哈希处理。 

387
00:18:00,410 --> 00:18:02,956



388
00:18:03,156 --> 00:18:05,240
I guess different people call it different things.
我猜不同的人称之为不同的事物。 

389
00:18:05,240 --> 00:18:07,799
Unfortunately Python calls it hash.
不幸的是，Python将其称为哈希。 

390
00:18:07,799 --> 00:18:11,710
It's not hashing, it's prehashing.
它不是散列，而是预散列。 

391
00:18:11,710 --> 00:18:13,960
Emphasized the "pre" here.
这里强调“前置”。 

392
00:18:13,960 --> 00:18:19,250
So prehash function maps whatever keys
因此prehash函数会映射任何键

393
00:18:19,250 --> 00:18:23,105
you have to non-negative integers.
您必须使用非负整数。 

394
00:18:23,105 --> 00:18:28,314



395
00:18:28,314 --> 00:18:30,230
At this point we're not worrying about how big
在这一点上，我们不必担心有多大

396
00:18:30,230 --> 00:18:31,020
those integers are.
这些整数是。 

397
00:18:31,020 --> 00:18:32,269
They could be giant.
他们可能是巨大的。 

398
00:18:32,269 --> 00:18:34,920
We're not going to fix the second problem til later.
直到以后，我们都不会解决第二个问题。 

399
00:18:34,920 --> 00:18:37,609
First problem is if I have some key, maybe it's a string,
第一个问题是，如果我有一些钥匙，也许是字符串， 

400
00:18:37,809 --> 00:18:42,682
it's whatever, it's an object, how do I map it to some integer
无论是什么，都是对象，如何将其映射到某个整数

401
00:18:42,682 --> 00:18:44,390
so I could, at least in principle, put it
所以我至少可以在原则上

402
00:18:44,390 --> 00:18:47,851
in a direct access table.
在直接访问表中。 

403
00:18:48,051 --> 00:18:50,009
There's a theoretical answer to how to do this,
如何做到这一点有一个理论上的答案， 

404
00:18:50,009 --> 00:18:52,559
and then there's the practical answer. how to do this.
然后是实际的答案。这个怎么做。 

405
00:18:52,559 --> 00:18:55,710
I'll start with the mathematical.
我将从数学开始。 

406
00:18:55,710 --> 00:19:04,524
In theory, I like this, keys are finite and discrete.
从理论上讲，我喜欢这样，键是有限且离散的。 

407
00:19:04,724 --> 00:19:08,010



408
00:19:08,010 --> 00:19:08,509
OK.
好。 

409
00:19:08,509 --> 00:19:10,579
We know that anything on the computer
我们知道计算机上的任何东西

410
00:19:10,579 --> 00:19:13,589
could, ultimately, be written down as a string of bits.
最终可以写成一串位。 

411
00:19:13,589 --> 00:19:16,404
So a string of bits represents an integer.
因此，一串比特代表一个整数。 

412
00:19:16,404 --> 00:19:17,539
So we're done.
至此就完成了。 

413
00:19:17,539 --> 00:19:24,159



414
00:19:24,160 --> 00:19:27,639
So in theory, this is easy.
因此，从理论上讲，这很容易。 

415
00:19:27,839 --> 00:19:30,211
And we're going to assume in this class,
我们将在本课中假设

416
00:19:30,211 --> 00:19:31,710
because it's sort of a theory class,
因为这有点像理论课

417
00:19:31,710 --> 00:19:33,201
that this is what's happening.
这就是正在发生的事情。 

418
00:19:33,201 --> 00:19:34,660
At least for analysis, we're always
至少为了分析，我们总是

419
00:19:34,660 --> 00:19:36,839
going to analyze things as if this is what's happening.
去分析事物，好像这是正在发生的事情。 

420
00:19:37,039 --> 00:19:39,069
Now in reality, people don't always do this.
现在实际上，人们并不总是这样做。 

421
00:19:39,069 --> 00:19:44,059
In particular-- I'll go somewhere else.
特别是-我会去别的地方。 

422
00:19:44,059 --> 00:20:05,817
In Python it's not quite so simple,
在Python中并不是那么简单， 

423
00:20:05,817 --> 00:20:07,650
but at least you get to see what's going on.
但至少您可以了解发生了什么。 

424
00:20:07,650 --> 00:20:10,940
There's a function called hash, which should be called prehash,
有一个名为hash的函数，应称为prehash， 

425
00:20:10,940 --> 00:20:13,990
and it, given an object, it produces
它给定一个对象，它产生

426
00:20:13,990 --> 00:20:16,579
a non-- I'm not sure, actually, if it's non-negative.
非-实际上，我不确定是否为非负数。 

427
00:20:16,579 --> 00:20:19,720
It's not a big deal if it has a minus sign because then you
它有负号没什么大不了的，因为那你

428
00:20:19,720 --> 00:20:21,769
could just use this and get rid of the sign.
可以使用它并摆脱标志。 

429
00:20:21,769 --> 00:20:24,589
But it maps every object to an integer,
但是它将每个对象映射到一个整数， 

430
00:20:24,589 --> 00:20:27,216
or every hashable object, technically.
或每个可哈希对象，从技术上讲。 

431
00:20:27,217 --> 00:20:28,599
But pretty much anything can be mapped
但是几乎任何东西都可以映射

432
00:20:28,799 --> 00:20:31,349
to an integer, one way or another.
一个整数或另一种整数。 

433
00:20:31,349 --> 00:20:33,349
And so for example, if you given it an integer
例如，如果您给它一个整数

434
00:20:33,349 --> 00:20:35,039
it just returns the integer.
它只是返回整数。 

435
00:20:35,039 --> 00:20:36,220
So that's pretty easy.
这很容易。 

436
00:20:36,220 --> 00:20:39,299
If you give it a string it does something.
如果给它一个字符串，它将执行某些操作。 

437
00:20:39,299 --> 00:20:40,730
I don't know exactly what it does,
我不知道到底是怎么回事

438
00:20:40,730 --> 00:20:41,813
but there are some issues.
但是有一些问题。 

439
00:20:41,813 --> 00:20:51,467
For example, hash of this string, backslash 0B
例如，此字符串的哈希，反斜杠0B 

440
00:20:51,667 --> 00:21:02,616
is equal to the hash of backslash 0 backslash 0C 64.
等于反斜杠0反斜杠0C 64的哈希值。 

441
00:21:02,616 --> 00:21:04,450
It's a little tricky to find these examples,
找到这些示例有点棘手， 

442
00:21:04,450 --> 00:21:06,140
but they're out there.
但他们在那里。 

443
00:21:06,140 --> 00:21:08,390
And I guess, this is probably the lowest one
我想这可能是最低的

444
00:21:08,390 --> 00:21:10,640
in a certain measure.
在某种程度上。 

445
00:21:10,640 --> 00:21:12,461
So it's a concern.
因此，这是一个问题。 

446
00:21:12,461 --> 00:21:14,670
In practice you have to be careful about these things
在实践中，您必须小心这些事情

447
00:21:14,670 --> 00:21:17,539
because what you'd like-- in an ideal world,
因为您想要的是-在理想的世界中， 

448
00:21:17,539 --> 00:21:25,980
and in the theoretical world-- this prehash function of x,
在理论世界中-x的预哈希函数

449
00:21:25,980 --> 00:21:27,819
if it equals the prehash function of y,
如果它等于y的prehash函数， 

450
00:21:27,819 --> 00:21:31,379
this should only happen when x=y,
只有在x = y时才会发生这种情况

451
00:21:31,380 --> 00:21:32,630
when they're the same thing.
当他们是同一件事时。 

452
00:21:32,630 --> 00:21:35,450



453
00:21:35,450 --> 00:21:39,899
And equals equal sense, I guess, would be the technical version.
我想，相等的意思是技术版本。 

454
00:21:40,099 --> 00:21:42,829
Sadly, in Python this is not quite true.
可悲的是，在Python中这不是真的。 

455
00:21:42,829 --> 00:21:43,960
But mostly true.
但是大部分都是真的。 

456
00:21:43,960 --> 00:21:48,029



457
00:21:48,029 --> 00:21:50,420
Let's see.
让我们来看看。 

458
00:21:50,420 --> 00:21:53,460
If you define a custom object, you may know this,
如果定义自定义对象，您可能会知道， 

459
00:21:53,460 --> 00:21:58,019
there is an __hash__ method you can implement,
您可以实现__hash__方法， 

460
00:21:58,019 --> 00:22:01,740
which tells Python what to do when you call hash
告诉Python调用哈希时该怎么做

461
00:22:01,740 --> 00:22:02,480
of your object.
你的对象。 

462
00:22:02,480 --> 00:22:05,380
If you don't, it uses the default
如果不这样做，它将使用默认值

463
00:22:05,380 --> 00:22:07,859
of id, which is the physical location
 id，即实际位置

464
00:22:08,059 --> 00:22:09,158
of your object in memory.
对象在内存中的大小。 

465
00:22:09,159 --> 00:22:11,450
So as long as your object isn't moving around in memory
因此只要您的对象不在内存中移动

466
00:22:11,450 --> 00:22:13,130
this is a pretty good hash function
这是一个很好的哈希函数

467
00:22:13,130 --> 00:22:17,649
because no two items occupy the same space in memory.
因为没有两个项目占用相同的内存空间。 

468
00:22:17,849 --> 00:22:21,429
So that's just implementation side of things.
因此，这只是实现方面的事情。 

469
00:22:21,430 --> 00:22:28,009
Other implementation side of things is in Python,
其他实现方面是在Python中， 

470
00:22:28,009 --> 00:22:31,069
well, there's this distinction between objects and keys,
好吧，对象和键之间是有区别的， 

471
00:22:31,069 --> 00:22:32,019
I guess you would say.
我想你会说。 

472
00:22:32,019 --> 00:22:33,980
You really don't want this prehash function
您真的不想要此prehash函数

473
00:22:33,980 --> 00:22:36,169
to change value.
改变价值。 

474
00:22:36,369 --> 00:22:38,709
In, say, a direct access table, if you store--
例如，在直接访问表中，如果您存储- 

475
00:22:38,710 --> 00:22:41,259
you take an item, you compute the prehash function
你拿一件东西，你计算prehash函数

476
00:22:41,259 --> 00:22:45,390
of the key in there, and you throw it in, and it says,
里面的钥匙，然后把它扔进去，然后说， 

477
00:22:45,390 --> 00:22:47,615
oh, prehash value is four.
哦，哈希值是4。 

478
00:22:47,615 --> 00:22:48,990
Then you put it in position four.
然后将其放在第四位。 

479
00:22:48,990 --> 00:22:52,279
If that value change, then when you go to search for that key,
如果该值发生变化，那么当您搜索该键时， 

480
00:22:52,279 --> 00:22:54,779
and you call prehash of that thing, and if it give you five,
然后你就把那东西叫prehash，如果它给你五个， 

481
00:22:54,779 --> 00:22:57,569
you look in position five, and you say, oh, it's not there.
你看着第五位，你说，哦，不在那里。 

482
00:22:57,569 --> 00:23:00,069
So prehash really should not change.
因此，prehash确实不应更改。 

483
00:23:00,069 --> 00:23:03,139
If you ever implement this function don't mess with it.
如果您实现了此功能，请不要混淆。 

484
00:23:03,140 --> 00:23:05,259
I mean, make sure it's defined in such a way
我的意思是，确保以这种方式定义

485
00:23:05,259 --> 00:23:06,970
that it doesn't change over time.
它不会随着时间而改变。 

486
00:23:06,970 --> 00:23:10,622
Otherwise, you won't be able to find your items in the table.
否则，您将无法在表格中找到您的商品。 

487
00:23:10,622 --> 00:23:11,879
Python can't protect you from that.
 Python无法保护您。 

488
00:23:12,079 --> 00:23:15,319



489
00:23:15,319 --> 00:23:17,799
This is why, for example, if you have a list,
这就是为什么，例如，如果您有一个列表， 

490
00:23:17,799 --> 00:23:20,529
which is a mutable object, you cannot put it into a hash table
这是一个可变对象，您不能将其放入哈希表

491
00:23:20,529 --> 00:23:25,369
as a key value because it would change over time.
作为键值，因为它会随着时间变化。 

492
00:23:25,369 --> 00:23:29,739
Potentially, you'd append to the list, or whatever.
您可能会追加到列表中，或其他任何内容。 

493
00:23:29,740 --> 00:23:31,680
All right.
好吧。 

494
00:23:31,680 --> 00:23:33,920
So hopefully you're reasonably happy with this.
因此，希望您对此感到满意。 

495
00:23:33,920 --> 00:23:34,990
You could also think of it is we're
您也可以想到这是我们

496
00:23:34,990 --> 00:23:36,948
going to assume keys are non-negative integers.
假设键是非负整数。 

497
00:23:36,948 --> 00:23:38,755
But in practice, anything you have you
但实际上，任何你拥有的东西

498
00:23:38,755 --> 00:23:42,569
can map to an integer, one way or another.
可以以一种或另一种方式映射到整数。 

499
00:23:42,769 --> 00:23:44,379
The bigger problem in a certain sense,
从某种意义上说，更大的问题， 

500
00:23:44,380 --> 00:23:48,579
or the more interesting problem is reducing space.
或更有趣的问题是减少空间。 

501
00:23:48,779 --> 00:23:49,859
So how do we do that?
那么我们该怎么做呢？ 

502
00:23:49,859 --> 00:23:58,419



503
00:23:58,420 --> 00:23:59,740
This would be hashing.
这将是哈希。 

504
00:23:59,740 --> 00:24:03,880



505
00:24:03,880 --> 00:24:06,639
This is sort of the magic part of today's lecture.
这是今天演讲的神奇部分。 

506
00:24:06,839 --> 00:24:09,199
In case you're wondering, hashing
如果您想知道，哈希

507
00:24:09,200 --> 00:24:12,009
has nothing to do with hashish.
与大麻无关。 

508
00:24:12,009 --> 00:24:17,609
Hashish is a Arabic root word unrelated to the Germanic,
哈希是阿拉伯语的根词，与日耳曼语无关， 

509
00:24:17,609 --> 00:24:20,219
which is hachet, I believe.
我相信那是香囊。 

510
00:24:20,220 --> 00:24:20,900
Yeah.
是的

511
00:24:20,900 --> 00:24:23,139
Or hacheh-- I guess, something like that.
还是哈切-我猜是这样的。 

512
00:24:23,339 --> 00:24:24,529
I'm not very good at German.
我不太会德语。 

513
00:24:24,529 --> 00:24:25,910
Which means hatchet.
这意味着柴刀。 

514
00:24:25,910 --> 00:24:26,410
OK
好

515
00:24:26,410 --> 00:24:28,400
It's like you take your key, and you cut it up
就像您拿了钥匙，然后把它剪了一样

516
00:24:28,400 --> 00:24:30,859
into little pieces, and you mix them around and cut and dice,
切成小块，然后将它们混合并切块， 

517
00:24:31,059 --> 00:24:32,569
and it's like cooking.
就像做饭一样

518
00:24:32,569 --> 00:24:33,510
OK.
好。 

519
00:24:33,510 --> 00:24:34,009
What?
什么？ 

520
00:24:34,009 --> 00:24:34,900
AUDIENCE: Hash browns.
观众：薯饼。 

521
00:24:34,900 --> 00:24:36,400
PROFESSOR: Hash browns, for example.
教授：例如，马铃薯煎饼。 

522
00:24:36,400 --> 00:24:38,080
Yeah, same root.
是的，相同的根源。 

523
00:24:38,280 --> 00:24:38,779
OK.
好。 

524
00:24:38,779 --> 00:24:41,610
It's like the only two English words with that kind of hash.
就像只有两个带有这种哈希的英文单词一样。 

525
00:24:41,611 --> 00:24:41,909
OK.
好。 

526
00:24:42,109 --> 00:24:45,129
In our case, it's a verb, to hash.
在我们的例子中，这是一个动词，要进行哈希处理。 

527
00:24:45,130 --> 00:24:47,960
It means to cut into pieces and mix around.
这意味着切成小块并混合在一起。 

528
00:24:47,960 --> 00:24:48,460
OK.
好。 

529
00:24:48,460 --> 00:24:51,130
That won't really be clear until towards the end of today's
直到今天快要结束时，这才真正变得不清楚

530
00:24:51,130 --> 00:24:52,399
lecture, but we will eventually get
讲座，但我们最终会得到

531
00:24:52,599 --> 00:24:55,139
to the etymology of hashing.
散列的词源。 

532
00:24:55,140 --> 00:24:57,859
Or, we've got the etymology, but why it's, actually,
或者，我们有词源，但是为什么呢

533
00:24:58,059 --> 00:24:59,819
why we use that term.
为什么我们使用该术语。 

534
00:24:59,819 --> 00:25:00,369
All right.
好吧。 

535
00:25:00,369 --> 00:25:10,859
So the big idea is we take all possible keys
因此，最大的想法是我们采用所有可能的钥匙

536
00:25:10,859 --> 00:25:13,974
and we want to reduce them down to some small, small set
我们希望将它们减少到一些小的集合

537
00:25:13,974 --> 00:25:14,474
of integers.
整数

538
00:25:14,474 --> 00:25:43,699



539
00:25:43,700 --> 00:25:45,809
Let me draw a picture of that.
让我画一幅画。 

540
00:25:45,809 --> 00:25:55,639



541
00:25:55,640 --> 00:26:01,765
So we have this giant space of all possible keys.
因此，我们拥有所有可能的钥匙的巨大空间。 

542
00:26:01,765 --> 00:26:02,859
We'll call this key space.
我们将其称为关键空间。 

543
00:26:03,059 --> 00:26:06,079



544
00:26:06,079 --> 00:26:08,230
It's like outer space, basically.
基本上，这就像外太空。 

545
00:26:08,230 --> 00:26:10,789
It's giant.
太好了

546
00:26:10,789 --> 00:26:12,670
And if we stored a direct access table,
如果我们存储了直接访问表， 

547
00:26:12,670 --> 00:26:13,730
this would also be giant.
这也将是巨大的。 

548
00:26:13,730 --> 00:26:16,529
And we don't want to do that.
而且我们不想这样做。 

549
00:26:16,529 --> 00:26:21,500
We'd like to somehow map using a hash function h down
我们想以某种方式使用哈希函数h down进行映射

550
00:26:21,500 --> 00:26:22,799
to some smaller set.
到一些较小的集合。 

551
00:26:22,799 --> 00:26:25,309
How do I want to draw this?
我要如何绘制？ 

552
00:26:25,309 --> 00:26:25,980
Like an array.
像数组。 

553
00:26:25,980 --> 00:26:30,819



554
00:26:30,819 --> 00:26:36,960
So we're going to have possible values 0 up to m minus 1.
因此，我们将取0到m减去1的可能值。 

555
00:26:36,960 --> 00:26:38,139
m is a new thing.
 m是新事物。 

556
00:26:38,339 --> 00:26:40,399
It's going to be the size of our hash table.
这将是我们的哈希表的大小。 

557
00:26:40,400 --> 00:26:41,630
Let's call the hash table.
让我们称之为哈希表。 

558
00:26:41,630 --> 00:26:44,906



559
00:26:45,106 --> 00:26:48,200
I think we'll call it t also.
我想我们也称它为t。 

560
00:26:48,200 --> 00:26:51,230
And we'd somehow like to map--
我们想以某种方式映射- 

561
00:26:51,230 --> 00:26:51,730
All right.
好吧。 

562
00:26:51,730 --> 00:26:54,799
So there's a giant space of all possible keys,
因此，所有可能的按键都有巨大的空间， 

563
00:26:54,799 --> 00:26:57,899
but then there's a subset of keys that are actually
但是实际上有一部分键

564
00:26:57,900 --> 00:27:03,109
stored in this set, in this dictionary.
存储在此集合中，在此字典中。 

565
00:27:03,309 --> 00:27:05,159
At any moment in time there's some set
在任何时候都有一些设置

566
00:27:05,160 --> 00:27:07,730
of keys that are present.
存在的密钥。 

567
00:27:07,730 --> 00:27:10,289
That set changes, but at any moment
那个设置改变了，但是在任何时候

568
00:27:10,289 --> 00:27:12,779
there's some keys that are actually there.
实际上有一些键。 

569
00:27:12,779 --> 00:27:17,180
k1, k2, k3, k4.
 k1，k2，k3，k4。 

570
00:27:17,180 --> 00:27:20,890
I'd like to map them to positions in this table.
我想将它们映射到此表中的位置。 

571
00:27:20,890 --> 00:27:26,389
So maybe I store k2-- or actually, item 2 would go here.
因此，也许我存储了k2--或实际上，项目2会放在这里。 

572
00:27:26,589 --> 00:27:34,000
In particular, this is when h of k2, if it equals zero,
特别是k2的h等于零时

573
00:27:34,000 --> 00:27:36,000
then you'd put item 2 there.
然后将项目2放在那里。 

574
00:27:36,000 --> 00:27:39,779
Item 3, let's say, it's at position-- wow,
假设第3项处于正确位置–哇， 

575
00:27:39,779 --> 00:27:42,240
3 would be a bit of a coincidence, but what the hell.
 3有点巧合，但是到底是什么。 

576
00:27:42,240 --> 00:27:46,630
Maybe h or k3 equals 3.
也许h或k3等于3。 

577
00:27:46,630 --> 00:27:47,829
Then you'd put item 3 here.
然后，您将项目3放在这里。 

578
00:27:48,029 --> 00:27:50,539



579
00:27:50,539 --> 00:27:51,039
OK.
好。 

580
00:27:51,039 --> 00:27:51,750
You get the idea.
你明白了。 

581
00:27:51,750 --> 00:27:54,180
So these four items each have a special position
所以这四个项目都有一个特殊的位置

582
00:27:54,180 --> 00:27:55,529
in their table.
在他们的桌子上。 

583
00:27:55,529 --> 00:28:02,879
And the idea is we would like to be, m to be around n.
我们的想法是，我们希望m在n附近。 

584
00:28:02,880 --> 00:28:07,349



585
00:28:07,549 --> 00:28:19,279
n is the number of keys In the dictionary right now.
 n是当前词典中的键数。 

586
00:28:19,279 --> 00:28:21,634
So if we could achieve that, the size of the table
因此，如果我们能够做到这一点，那么表格的大小

587
00:28:21,634 --> 00:28:23,759
was proportional to the number of keys being stored
与存储的密钥数量成正比

588
00:28:23,759 --> 00:28:26,970
in the dictionary, that would be good news because then
在字典中，那将是个好消息，因为

589
00:28:26,970 --> 00:28:29,909
the space is not gigantic and hoggish.
这个空间不是巨大的，也不是时髦的。 

590
00:28:30,109 --> 00:28:33,656
It would just be linear, which is optimal.
它只是线性的，这是最佳的。 

591
00:28:33,656 --> 00:28:35,490
So if we want to store m things, maybe we'll
因此，如果我们要存储m个东西，也许我们会

592
00:28:35,490 --> 00:28:38,630
use 2m space, a 3m space, but not much more.
使用2m空间，即3m空间，但不要更多。 

593
00:28:38,630 --> 00:28:41,740



594
00:28:41,740 --> 00:28:45,140
How the heck are we going to define such a function h?
我们将如何定义这样的函数h？ 

595
00:28:45,140 --> 00:28:47,359
Well, that's the rest of the lecture.
好了，这就是本讲座的其余部分。 

596
00:28:47,559 --> 00:28:49,223
But even before we define a function h,
但即使在定义函数h之前， 

597
00:28:49,223 --> 00:28:50,639
do you see any problems with this?
您看到这个有什么问题吗？ 

598
00:28:50,640 --> 00:28:55,379



599
00:28:55,579 --> 00:28:56,145
Yeah.
是的

600
00:28:56,145 --> 00:28:57,061
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

601
00:28:57,061 --> 00:29:02,763



602
00:29:02,763 --> 00:29:03,429
PROFESSOR: Yeah.
教授：是的。 

603
00:29:03,430 --> 00:29:05,359
This space over here, this is pigeonhole principle.
这里的空间，这是信鸽原理。 

604
00:29:05,559 --> 00:29:07,569
The number of slots for your pigeons over here
您的鸽子在这里的插槽数

605
00:29:07,569 --> 00:29:10,240
is way smaller than the number of possible pigeons.
比可能的鸽子数量少得多。 

606
00:29:10,240 --> 00:29:13,109
So there are going to be two keys that
因此，将有两个关键

607
00:29:13,109 --> 00:29:16,990
map to the same slot in the hash table.
映射到哈希表中的相同插槽。 

608
00:29:16,990 --> 00:29:18,365
This is what we call a collision.
这就是我们所说的碰撞。 

609
00:29:18,365 --> 00:29:21,190



610
00:29:21,190 --> 00:29:24,500
Let's call this, I don't know, ki, kj.
我们称呼它，我不知道，ki，kj。 

611
00:29:24,500 --> 00:29:28,047



612
00:29:28,047 --> 00:29:35,500
h of ki equals h of kj, but the keys are different.
 ki的h等于kj的h，但是键不同。 

613
00:29:35,500 --> 00:29:40,920
So ki does not equal kj, yet their hash functions
所以ki不等于kj，但是它们的哈希函数

614
00:29:40,920 --> 00:29:42,639
are the same, hash values are the same.
相同，哈希值相同。 

615
00:29:42,839 --> 00:29:44,659
We call that a collision.
我们称之为碰撞。 

616
00:29:44,660 --> 00:29:48,990
And that's guaranteed to happen a lot, yet somehow,
这肯定会发生很多，但是无论如何， 

617
00:29:48,990 --> 00:29:51,096
we can still make this work.
我们仍然可以完成这项工作。 

618
00:29:51,096 --> 00:29:51,805
That's the magic.
那就是魔术。 

619
00:29:51,805 --> 00:29:57,640



620
00:29:57,640 --> 00:29:59,149
And that is going to be chaining.
那将是连锁的。 

621
00:29:59,349 --> 00:30:02,079
We've done these guys.
我们已经做了这些家伙。 

622
00:30:02,079 --> 00:30:05,263
Next up is a technique for dealing with collisions.
接下来是处理冲突的技术。 

623
00:30:05,263 --> 00:30:07,429
There are two techniques for dealing with collisions
有两种处理冲突的技术

624
00:30:07,430 --> 00:30:09,561
we're going to talk about in 006.
我们将在006中讨论。 

625
00:30:09,761 --> 00:30:11,720
One is called chaining, and next Tuesday, we'll
一种叫做链接，下周二，我们将

626
00:30:11,720 --> 00:30:15,450
see another method called open addressing.
请参阅另一种称为开放式寻址的方法。 

627
00:30:15,450 --> 00:30:17,170
But let's start with chaining.
但是，让我们从链接开始。 

628
00:30:17,170 --> 00:30:21,220



629
00:30:21,220 --> 00:30:24,730
The idea with chaining a simple.
用链接的想法很简单。 

630
00:30:24,730 --> 00:30:28,400
If you have multiple items here all with the same-- that
如果您在这里有多个相同的项目- 

631
00:30:28,400 --> 00:30:32,659
hash to the same position, just store them as a list.
哈希到相同位置，只需将它们存储为列表即可。 

632
00:30:32,859 --> 00:30:35,049
I'm going to draw it as a linked list.
我将其绘制为链接列表。 

633
00:30:35,049 --> 00:31:02,849



634
00:31:02,849 --> 00:31:06,687
I think I need a big picture here.
我想在这里我需要一幅大图。 

635
00:31:06,688 --> 00:31:27,710



636
00:31:27,710 --> 00:31:35,269
So we have our nice universe, various keys that we actually
因此，我们拥有了一个不错的宇宙，实际上我们拥有各种键

637
00:31:35,269 --> 00:31:37,700
have present.
有礼物。 

638
00:31:37,700 --> 00:31:42,740
So these are the keys in the dictionary,
这些是字典中的键， 

639
00:31:42,740 --> 00:31:44,279
and this is all of key space.
这就是关键空间。 

640
00:31:44,279 --> 00:31:53,170



641
00:31:53,170 --> 00:31:56,170
These guys map to slots in the table.
这些家伙映射到表中的插槽。 

642
00:31:56,170 --> 00:31:58,490
Some of them might map to the same value.
其中一些可能会映射到相同的值。 

643
00:31:58,490 --> 00:32:04,974
So let's say k1 and k2, suppose they collide.
因此，假设k1和k2发生碰撞。 

644
00:32:04,974 --> 00:32:06,619
So they both go this slot.
所以他们俩都去这个位置。 

645
00:32:06,619 --> 00:32:11,229
What we're going to store here is a linked list
我们要在这里存储的是一个链表

646
00:32:11,230 --> 00:32:16,750
that stores item 1, and stores a pointer
存储项1，并存储指针

647
00:32:16,750 --> 00:32:21,450
to the next item, which is item 2.
到下一个项目，即项目2。 

648
00:32:21,450 --> 00:32:23,380
And that's the end of the list.
到此为止。 

649
00:32:23,380 --> 00:32:27,160
Or you could-- however you want to draw a null.
或者，您可以-但是您想绘制一个null。 

650
00:32:27,160 --> 00:32:30,119
So however many items there are, we're
所以不管有多少东西，我们

651
00:32:30,319 --> 00:32:33,700
going to have a linked list of that length in that slot.
在该广告位中将具有该长度的链表。 

652
00:32:33,700 --> 00:32:37,440
So in particular, if there's just one item, like say,
因此，特别是如果只有一项，例如

653
00:32:37,440 --> 00:32:42,430
this k3 here, maybe it just maps to this slot.
这个k3在这里，也许只是映射到这个插槽。 

654
00:32:42,430 --> 00:32:44,149
And maybe that's all that maps to that slot.
也许这就是映射到该插槽的全部。 

655
00:32:44,349 --> 00:32:48,329
In that case, we just say, follow this item 3,
在这种情况下，我们只是说，遵循第3项， 

656
00:32:48,329 --> 00:32:50,369
and there's no other items.
并且没有其他项目。 

657
00:32:50,369 --> 00:32:52,679
Some slots are going to be completely empty.
一些插槽将完全是空的。 

658
00:32:52,680 --> 00:32:56,440
There nothing there so you just store a null pointer.
那里什么都没有，所以您只存储一个空指针。 

659
00:32:56,440 --> 00:32:58,150
That is hashing with chaining.
那就是用链式哈希。 

660
00:32:58,150 --> 00:33:02,149
It's pretty simple, very simple really.
这很简单，真的很简单。 

661
00:33:02,349 --> 00:33:05,549
The only question is why would you expect it to be any good?
唯一的问题是，您为什么期望它会有什么好处？ 

662
00:33:05,549 --> 00:33:08,960
Because, in the worst case, if you fix your hash function
因为在最坏的情况下，如果您修复哈希函数

663
00:33:08,960 --> 00:33:11,920
here, h, there's going to be a whole bunch of keys
在这里，h，将有一堆钥匙

664
00:33:11,920 --> 00:33:13,169
that all map to the same slot.
全部都映射到同一个广告位

665
00:33:13,369 --> 00:33:16,329
And so in the worst case, those are the keys that you insert,
因此，在最坏的情况下，这些就是您要插入的键， 

666
00:33:16,329 --> 00:33:17,746
and they all go here.
他们都去了这里。 

667
00:33:17,747 --> 00:33:19,379
And then you have this fancy data structure.
然后您就拥有了这种奇特的数据结构。 

668
00:33:19,579 --> 00:33:23,099
And in the end, all you have is a linked list of all n items.
最后，您所拥有的只是所有n个项目的链表。 

669
00:33:23,099 --> 00:33:30,949
So the worst case is theta n.
因此，最坏的情况是theta n。 

670
00:33:30,950 --> 00:33:34,519
And this is going to be true for any hashing scheme, actually.
实际上，这对于任何哈希方案都是正确的。 

671
00:33:34,519 --> 00:33:36,710
In the worst case, hashing sucks.
在最坏的情况下，哈希很糟糕。 

672
00:33:36,710 --> 00:33:39,400
Yet in practice, it works really, really well.
但是实际上，它确实非常好。 

673
00:33:39,400 --> 00:33:41,960
And the reason is randomization, essentially,
原因是随机化

674
00:33:41,960 --> 00:33:45,419
that this hash function, unless you're really unlucky,
该哈希函数，除非您真的很不幸， 

675
00:33:45,619 --> 00:33:48,269
the hash function will nicely distribute your items,
哈希函数可以很好地分配您的物品， 

676
00:33:48,269 --> 00:33:52,700
and most of these lists will have constant length.
并且这些列表中的大多数将具有恒定的长度。 

677
00:33:52,700 --> 00:34:00,720
We're going to prove that under an assumption.
我们将在一个假设下证明这一点。 

678
00:34:00,720 --> 00:34:02,380
Well have to warm up a little bit.
好吧，要热身一点。 

679
00:34:02,380 --> 00:34:07,000



680
00:34:07,000 --> 00:34:09,739
But I'm also going to cop out a little m as you'll see.
但正如您所看到的，我还要弥补一点点。 

681
00:34:09,739 --> 00:34:22,960



682
00:34:22,960 --> 00:34:27,250
So in 006 we're going to make an assumption called Simple
因此，在006年，我们将做一个简单的假设

683
00:34:27,250 --> 00:34:29,079
Uniform Hashing.
均匀散列。 

684
00:34:29,079 --> 00:34:31,255
OK.
好。 

685
00:34:31,255 --> 00:34:35,849
And this is an assumption, it's an unrealistic assumption.
这是一个假设，这是不现实的假设。 

686
00:34:35,849 --> 00:34:40,329
I would go so far as to say it's false, a false assumption.
我什至会说这是错误的，是错误的假设。 

687
00:34:40,329 --> 00:34:42,235
But it's really convenient for analysis,
但这真的很方便分析， 

688
00:34:42,235 --> 00:34:43,609
and it's going to make it obvious
这将使其显而易见

689
00:34:43,610 --> 00:34:45,579
why chaining is a good idea.
为什么链接是一个好主意。 

690
00:34:45,579 --> 00:34:48,139
Sadly, the assumption isn't quite true,
可悲的是，这个假设并不完全正确， 

691
00:34:48,139 --> 00:34:49,969
but it gives you a flavor.
但它给你一种味道。 

692
00:34:49,969 --> 00:34:52,079
If you want to see why hashing is actually good,
如果您想了解为什么哈希实际上很好， 

693
00:34:52,079 --> 00:34:53,954
I'm going to hint at it at the end of lecture
我要在课后暗示

694
00:34:53,954 --> 00:34:55,610
but really should take 6.046 Yeah.
但确实应该花6.046对。 

695
00:34:55,610 --> 00:34:56,902
AUDIENCE: [INAUDIBLE] question.
听众：[听不清]问题。 

696
00:34:56,902 --> 00:34:58,981
Is the hashing function [INAUDIBLE]?
哈希函数是[音频不清晰]吗？ 

697
00:34:59,181 --> 00:35:01,347
Like, how do we know the array is still [INAUDIBLE]?
就像，我们怎么知道数组仍然是[音频不清晰]？ 

698
00:35:01,347 --> 00:35:01,931
PROFESSOR: OK.
教授：好的。 

699
00:35:01,931 --> 00:35:07,619
The hashing function-- I guess I didn't specify up here.
哈希函数-我想我没有在这里指定。 

700
00:35:07,619 --> 00:35:14,159
The hashing function maps your universe to 0, 1,
哈希函数将您的Universe映射为0、1 

701
00:35:14,159 --> 00:35:17,519
up to m minus 1, That's the definition.
直到m减1，这就是定义。 

702
00:35:17,519 --> 00:35:23,090
So it's guaranteed to reduce the space of keys to just m slots.
因此，可以保证将键的空间减少到仅m个插槽。 

703
00:35:23,090 --> 00:35:25,467
So your hashing function needs to know what m is.
因此，您的哈希函数需要知道m是什么。 

704
00:35:25,467 --> 00:35:27,800
In reality there's not going to be one hashing function,
实际上，将不会只有一个哈希函数， 

705
00:35:27,800 --> 00:35:30,469
there's going to be 1 for each m, or at least one for each m.
每m将有1，或每m至少有1。 

706
00:35:30,668 --> 00:35:32,460
And so, depending on how big your table is,
因此，根据您的桌子有多大， 

707
00:35:32,460 --> 00:35:34,336
you use the corresponding hash function.
您使用相应的哈希函数。 

708
00:35:34,336 --> 00:35:35,170
Yeah, good question.
是的，很好的问题。 

709
00:35:35,170 --> 00:35:36,545
So the hash function is what does
那么哈希函数是做什么的

710
00:35:36,545 --> 00:35:39,110
the work of reducing your key space down
减少密钥空间的工作

711
00:35:39,110 --> 00:35:40,730
to small set of slots.
到小型插槽。 

712
00:35:40,730 --> 00:35:44,179
So that's what's going to give us low space.
这就是要给我们的空间不足的原因。 

713
00:35:44,179 --> 00:35:44,849
OK.
好。 

714
00:35:44,849 --> 00:35:47,005
But now, how do we get low time?
但是现在，我们如何获得较少的时间？ 

715
00:35:47,005 --> 00:35:49,254
Let me just state this assumption and get to business.
让我只陈述这个假设并开始做生意。 

716
00:35:49,255 --> 00:36:33,300



717
00:36:33,300 --> 00:36:35,510
Simply, uniform hashing is, essentially,
简单来说，统一哈希本质上是

718
00:36:35,510 --> 00:36:38,050
two probabilistic assumptions.
两个概率假设。 

719
00:36:38,050 --> 00:36:41,360
The first one is uniformity.
第一个是均匀性。 

720
00:36:41,360 --> 00:36:44,070
If you take some key in your space
如果您在自己的空间拿一些钥匙

721
00:36:44,070 --> 00:36:46,170
that you want to store the hash function
您想要存储哈希函数的

722
00:36:46,170 --> 00:36:49,230
maps it to a uniform random choice.
将其映射到统一的随机选择。 

723
00:36:49,230 --> 00:36:51,539
This is, of course, is what you want to happen.
当然，这就是您想要发生的事情。 

724
00:36:51,539 --> 00:36:58,271
Each of these slots here is equally likely to be hashed to.
这些插槽中的每个插槽都同样有可能被哈希到。 

725
00:36:58,271 --> 00:36:58,769
OK.
好。 

726
00:36:58,769 --> 00:37:00,019
That's a good start.
这是一个好的开始。 

727
00:37:00,019 --> 00:37:03,550
But to do proper analysis, not only do we uniformity,
但是要进行适当的分析，我们不仅要保持一致， 

728
00:37:03,550 --> 00:37:05,545
we also need independence.
我们还需要独立。 

729
00:37:05,744 --> 00:37:07,869
So not only is this true for each key individually,
因此，不仅对于每个键都是如此， 

730
00:37:07,869 --> 00:37:10,210
but it's true for all the keys together.
但是所有键都正确。 

731
00:37:10,210 --> 00:37:13,500
So if key one maps to a uniform random place,
因此，如果密钥一映射到统一的随机位置， 

732
00:37:13,500 --> 00:37:16,840
no matter where it goes, key two also
无论走到哪里，关键二也是

733
00:37:16,840 --> 00:37:18,269
matches to a uniform random place.
匹配到统一的随机位置。 

734
00:37:18,269 --> 00:37:19,643
And no matter where those two go,
不管那两个去哪

735
00:37:19,643 --> 00:37:22,039
key three maps to a uniform random place.
将三个关键点映射到一个统一的随机位置。 

736
00:37:22,039 --> 00:37:23,639
This really can't be true.
这真的不是真的。 

737
00:37:23,639 --> 00:37:27,829
But if it's true, we can prove that this takes constant time.
但是，如果这是真的，我们可以证明这需要持续的时间。 

738
00:37:27,829 --> 00:37:29,500
So let me do that.
所以让我这样做。 

739
00:37:29,500 --> 00:37:41,179



740
00:37:41,179 --> 00:37:45,659
So under this assumption, we can analyze
所以在这个假设下，我们可以分析

741
00:37:45,659 --> 00:37:51,399
hashing-- hashing with chaining is what this method is called.
散列-使用链接的散列称为此方法。 

742
00:37:51,400 --> 00:37:56,400
So let's do it
所以做吧

743
00:37:56,400 --> 00:37:59,318
I want to know-- I got to cheat, sorry.
我想知道-我必须作弊，对不起。 

744
00:37:59,318 --> 00:38:00,610
I got to remember the notation.
我必须记住这种记法。 

745
00:38:00,610 --> 00:38:03,690



746
00:38:03,690 --> 00:38:05,460
I don't have any good notation here.
我在这里没有任何好的记号。 

747
00:38:05,460 --> 00:38:08,099
All right.
好吧。 

748
00:38:08,099 --> 00:38:12,964
What I'd like to know is the expected length of a chain.
我想知道的是预期的链长。 

749
00:38:12,965 --> 00:38:18,460



750
00:38:18,460 --> 00:38:18,960
OK.
好。 

751
00:38:18,960 --> 00:38:25,159
Now this is if I have n keys that are stored in the table,
现在，如果我有n个键存储在表中， 

752
00:38:25,159 --> 00:38:29,219
and m slots in the table, then what
和表中的m个插槽，然后

753
00:38:29,219 --> 00:38:32,029
is the expected length of a chain?
的预期长度是多少？ 

754
00:38:32,030 --> 00:38:32,931
Any suggestions.
有什么建议么。 

755
00:38:33,130 --> 00:38:33,629
Yeah.
是的

756
00:38:33,630 --> 00:38:35,869
AUDIENCE: 1 over m to the n.
听众：从m到n的1分。 

757
00:38:35,869 --> 00:38:37,480
PROFESSOR: 1 over m to the n?
教授：从1到m到n？ 

758
00:38:37,480 --> 00:38:41,699
That's going to be a probability of something.
那将是某种可能性。 

759
00:38:41,699 --> 00:38:42,199
Not quite.
不完全的。 

760
00:38:42,199 --> 00:38:43,369
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

761
00:38:43,369 --> 00:38:44,786
PROFESSOR: That's between 0 and 1.
教授：介于0和1之间。 

762
00:38:44,786 --> 00:38:47,099
It's probably at least one, or something.
它可能至少是一个或类似的东西。 

763
00:38:47,099 --> 00:38:47,855
Yeah.
是的

764
00:38:47,855 --> 00:38:49,190
AUDIENCE: m over n.
观众：n对n。 

765
00:38:49,190 --> 00:38:51,135
PROFESSOR: n over m, yeah.
教授：是的，胜过m。 

766
00:38:51,135 --> 00:38:54,630



767
00:38:54,630 --> 00:38:56,070
It's really easy.
真的很简单。 

768
00:38:56,070 --> 00:39:00,010
The chance of a key going to a particular slot is 1 over m.
密钥进入特定插槽的机率是1超过m。 

769
00:39:00,010 --> 00:39:02,820
They're all independent, so it's 1 over m, plus 1 over m,
他们都是独立的，所以是1比m加1比m， 

770
00:39:03,019 --> 00:39:05,159
plus 1 over m, n times.
在m上加1，n次。 

771
00:39:05,159 --> 00:39:07,099
So it's n over m.
所以已经超过m了。 

772
00:39:07,099 --> 00:39:10,730
This is really easy when you have independence.
有独立性时，这真的很容易。 

773
00:39:10,730 --> 00:39:13,210
Sadly, in the real world, you don't have independence.
可悲的是，在现实世界中，您没有独立性。 

774
00:39:13,210 --> 00:39:15,806
We're going to call this thing alpha,
我们将其称为alpha， 

775
00:39:15,806 --> 00:39:21,559
and it's also known as the load factor of the table.
并且也称为表格的负载系数。 

776
00:39:21,559 --> 00:39:24,960
So if it's one, n equals m.
因此，如果为1，则n等于m。 

777
00:39:24,960 --> 00:39:27,650
And so the length of a chain is one.
因此，一条链的长度是一个。 

778
00:39:27,650 --> 00:39:31,349
If it's 10, then you have 10 times as many elements
如果是10，则元素的数量是其10倍

779
00:39:31,349 --> 00:39:32,130
as you have slots.
因为你有插槽。 

780
00:39:32,130 --> 00:39:34,559
But still, the expected length of a chain is 10.
但仍然，预期的链长为10。 

781
00:39:34,559 --> 00:39:35,659
That's a constant.
这是一个常数。 

782
00:39:35,659 --> 00:39:36,469
It's OK.
没关系。 

783
00:39:36,469 --> 00:39:38,663
If it's a 12, that's OK.
如果是12，就可以了。 

784
00:39:38,664 --> 00:39:40,880
It means that you have a bigger table than you have items.
这意味着您的桌子比物品更大。 

785
00:39:41,079 --> 00:39:45,210
As long as it's a constant, as long as we have-- I
只要它是常数，只要我们拥有

786
00:39:45,210 --> 00:39:49,817
erased it by now-- as long as m is theta n,
现在将其擦除-只要m为theta n， 

787
00:39:49,817 --> 00:39:51,025
this is going to be constant.
这将是恒定的。 

788
00:39:51,025 --> 00:39:55,730



789
00:39:55,730 --> 00:39:57,710
And so we need to maintain this property.
因此，我们需要维护此属性。 

790
00:39:57,710 --> 00:40:00,289
But as long as you set your table size to the right value,
但是只要您将表格大小设置为正确的值， 

791
00:40:00,289 --> 00:40:04,730
to be roughly n, this will be constant.
大约为n，这将是恒定的。 

792
00:40:04,730 --> 00:40:12,900
And so the running time of an operation, insert, delete,
因此，操作，插入，删除， 

793
00:40:12,900 --> 00:40:17,480
and search-- Well, search is really
搜索-好吧，搜索确实

794
00:40:17,480 --> 00:40:20,429
the hardest because when you want to search for a key,
最难的是因为当您要搜索密钥时， 

795
00:40:20,429 --> 00:40:24,699
you map it into your table, then you walk the linked list
您将其映射到表格中，然后遍历链表

796
00:40:24,699 --> 00:40:26,692
and look for the key that you're searching for.
并查找您要搜索的密钥。 

797
00:40:26,692 --> 00:40:28,400
Now is this the key you're searching for?
现在这是您要搜索的键吗？ 

798
00:40:28,400 --> 00:40:30,349
No, it's not the key you're searching for.
不，这不是您要寻找的钥匙。 

799
00:40:30,349 --> 00:40:31,956
Is this the key you're searching for?
这是您要寻找的钥匙吗？ 

800
00:40:31,956 --> 00:40:33,789
Those are not the keys you're searching for.
这些不是您要搜索的键。 

801
00:40:33,789 --> 00:40:34,509
You keep going.
你继续前进。 

802
00:40:34,510 --> 00:40:36,650
Either you find your key or you don't.
您找到钥匙还是找不到钥匙。 

803
00:40:36,650 --> 00:40:40,067
But in the worst case, you have to walk the entire list.
但是在最坏的情况下，您必须遍历整个列表。 

804
00:40:40,266 --> 00:40:42,349
Sorry for the bad Star Trek reference-- Star Wars.
对不起，《星际迷航》的参考文献-《星球大战》。 

805
00:40:42,349 --> 00:40:45,110
God.
神。 

806
00:40:45,110 --> 00:40:45,730
I'm not awake.
我还没醒

807
00:40:45,929 --> 00:40:48,369
All right.
好吧。 

808
00:40:48,369 --> 00:40:50,819
In general, the running time, in the worst case,
一般来说，最坏情况下的运行时间

809
00:40:50,820 --> 00:40:53,585
is 1 plus the length of your chain.
是1加上您的链的长度。 

810
00:40:53,784 --> 00:40:56,329



811
00:40:56,329 --> 00:40:56,829
OK.
好。 

812
00:40:56,829 --> 00:40:59,340
So it's going to be 1 plus alpha.
因此它将是1加alpha。 

813
00:40:59,340 --> 00:41:00,769
Why do I write one?
我为什么要写一个？ 

814
00:41:00,969 --> 00:41:04,929
Well, because alpha can be much smaller than 1, in general.
好吧，因为alpha通常可以小于1。 

815
00:41:04,929 --> 00:41:06,419
And you always have to pay the cost
而且你总是要付出代价

816
00:41:06,420 --> 00:41:07,809
of computing the hash function.
哈希函数的计算。 

817
00:41:07,809 --> 00:41:10,769
We're going to assume that takes constant time.
我们将假设这需要固定的时间。 

818
00:41:10,769 --> 00:41:13,199
And then you have to follow the first pointer.
然后，您必须遵循第一个指针。 

819
00:41:13,199 --> 00:41:17,589
So you always pay constant time, but then you also pay alpha.
因此，您始终要支付固定的时间，但同时您也要支付Alpha。 

820
00:41:17,590 --> 00:41:20,269
That's your expected life.
那就是你的预期寿命。 

821
00:41:20,469 --> 00:41:20,969
OK.
好。 

822
00:41:20,969 --> 00:41:21,929
That's the analysis.
那就是分析。 

823
00:41:21,929 --> 00:41:23,079
It's super simple.
非常简单。 

824
00:41:23,079 --> 00:41:25,860
If you assume Simple Uniform Hashing,
如果您假设“简单统一哈希”， 

825
00:41:25,860 --> 00:41:30,550
it's clear, as long as your load factor is constant, m theta n,
很明显，只要您的负载系数是常数， 

826
00:41:30,550 --> 00:41:33,289
you get constant running time for all your operations.
您可以在所有操作中获得恒定的运行时间。 

827
00:41:33,489 --> 00:41:34,529
Life is good.
生活很好。 

828
00:41:34,530 --> 00:41:37,010
This is the intuition of why hashing works.
这就是为什么哈希起作用的直觉。 

829
00:41:37,010 --> 00:41:38,940
It's not really why hashing works.
这并不是散列起作用的真正原因。 

830
00:41:39,139 --> 00:41:43,175
But it's about as far as we're going to get in 006.
但这大约是我们将要获得的006。 

831
00:41:43,175 --> 00:41:44,799
I'm going to tell you a little bit more
我要告诉你更多

832
00:41:44,800 --> 00:41:49,380
about why hashing is actually good to practice and in theory.
关于为什么哈希实际上在实践上和理论上都很好的问题。 

833
00:41:49,380 --> 00:42:06,820



834
00:42:06,820 --> 00:42:10,019
What are we up to?
我们在忙什么呢？ 

835
00:42:10,019 --> 00:42:12,739
Last topic is hash functions.
最后一个主题是哈希函数。 

836
00:42:12,739 --> 00:42:16,379
The one remaining thing is how do I construct h?
剩下的一件事是如何构造h？ 

837
00:42:16,380 --> 00:42:19,800
How do I actually map from this giant universe of keys
我实际上是如何从这个巨大的按键范围映射的

838
00:42:19,800 --> 00:42:24,760
to this small set of slots in the table, there's m of them?
在桌子上的这小部分插槽中，有m个？ 

839
00:42:24,960 --> 00:42:29,259



840
00:42:29,260 --> 00:42:33,940
I'm going to give you three hash functions, two of which are,
我将为您提供三个散列函数，其中两个是

841
00:42:34,139 --> 00:42:37,210
let's say, common practice, and the third of which is actually
比方说，通常的做法，其中三分之一是

842
00:42:37,210 --> 00:42:38,710
theoretically good.
理论上很好。 

843
00:42:38,710 --> 00:42:40,929
So the first two are not good theoretically.
因此，前两个理论上并不理想。 

844
00:42:40,929 --> 00:42:43,059
You can prove that they're bad, but at least they
您可以证明它们不好，但是至少它们

845
00:42:43,059 --> 00:42:45,190
give you some flavor, and they're
给你一些味道，他们是

846
00:42:45,190 --> 00:42:51,778
still common in practice because a lot of the time they're OK,
在实践中仍然很常见，因为很多时候他们还可以， 

847
00:42:51,978 --> 00:42:53,769
but you can't really prove much about them.
但是您无法真正证明它们。 

848
00:42:53,769 --> 00:42:56,489



849
00:42:56,489 --> 00:42:56,989
OK.
好。 

850
00:42:56,989 --> 00:43:03,000
So first method, sort of the obvious one,
所以第一种方法，很明显， 

851
00:43:03,000 --> 00:43:04,940
called the division method.
称为除法。 

852
00:43:04,940 --> 00:43:06,820
And if you have a key, this could
如果您有一把钥匙，这可能

853
00:43:06,820 --> 00:43:09,750
be a giant key, huge universe of keys,
成为一个巨大的钥匙，巨大的钥匙宇宙， 

854
00:43:09,949 --> 00:43:14,064
you just take that key, modulo m,
你只要拿那个钥匙，取模m， 

855
00:43:14,065 --> 00:43:16,190
that gives you a number between zero and m minus 1.
给您一个介于0到m减1之间的数字。 

856
00:43:16,190 --> 00:43:17,110
Done.
做完了

857
00:43:17,110 --> 00:43:19,541
It's so easy.
它是如此容易。 

858
00:43:19,541 --> 00:43:21,000
I'm not going to tell you in detail
我不会详细告诉你

859
00:43:21,000 --> 00:43:22,659
why this is a bad method.
为什么这是一个不好的方法。 

860
00:43:22,659 --> 00:43:24,059
Maybe you can think about it.
也许您可以考虑一下。 

861
00:43:24,059 --> 00:43:29,889
It's especially bad if m has some common factors with k.
如果m与k有一些公因数，这尤其糟糕。 

862
00:43:29,889 --> 00:43:32,980
Like, let's say k is even always,
例如，假设k始终是

863
00:43:32,980 --> 00:43:34,974
and m is even also because you say,
 m甚至还因为你说， 

864
00:43:34,974 --> 00:43:36,690
oh, I'd like a table the size of power of two.
哦，我想要一张有2的幂的表。 

865
00:43:36,889 --> 00:43:37,969
That seems natural.
看起来很自然。 

866
00:43:37,969 --> 00:43:39,760
Then that will be really bad because you'll
那真的很不好，因为你会

867
00:43:39,760 --> 00:43:41,650
use only half the table.
只使用一半的桌子。 

868
00:43:41,650 --> 00:43:44,059
There are lots of situations where this is bad.
在很多情况下，这是不好的。 

869
00:43:44,059 --> 00:43:46,639
In practice, it's pretty good.
在实践中，这非常好。 

870
00:43:46,639 --> 00:43:49,435
If m is prime, you always choose a prime table size,
如果m为质数，则始终选择质数表大小， 

871
00:43:49,436 --> 00:43:51,059
so you don't have those common factors.
因此您没有那些共同的因素。 

872
00:43:51,059 --> 00:43:54,610
And it's not very close to a power of 2 or power of 10
而且它不是非常接近2的幂或10的幂

873
00:43:54,610 --> 00:43:57,920
because real world powers of 2's and 10's are common.
因为现实世界中2和10的幂很常见。 

874
00:43:57,920 --> 00:43:59,539
But it's very hackish, OK?
但这很骇人，好吗？ 

875
00:43:59,739 --> 00:44:02,989
It works a lot of the time but not always.
它在很多时候都有效，但并非总是如此。 

876
00:44:02,989 --> 00:44:07,569
A cooler method-- I think it's cooler-- still,
更酷的方法-我认为它更酷- 

877
00:44:07,570 --> 00:44:14,289
you can't prove much about it-- Division didn't
你不能证明太多-部门没有

878
00:44:14,289 --> 00:44:17,289
seem to work so great, so how about multiplication?
看起来效果很好，那么乘法呢？ 

879
00:44:17,289 --> 00:44:18,139
What does that mean?
这意味着什么？ 

880
00:44:18,139 --> 00:44:20,420
Multiply by m, that wouldn't be very good.
乘以m，那不是很好。 

881
00:44:20,420 --> 00:44:24,789
Now, it's a bit different.
现在，有点不同了。 

882
00:44:24,789 --> 00:44:30,779
We're going to take the key, multiply it by an integer, a,
我们要拿钥匙，乘以一个整数， 

883
00:44:30,780 --> 00:44:35,000
and then we're going to do this crazy, crazy stuff.
然后我们将要做这些疯狂的事情。 

884
00:44:35,000 --> 00:44:41,920
Take it mod 2 to the w and then shift it right, w minus r.
将mod 2取到w，然后右移w减去r。 

885
00:44:41,920 --> 00:44:42,250
OK.
好。 

886
00:44:42,449 --> 00:44:43,889
What is w?
什么是w？ 

887
00:44:43,889 --> 00:44:48,379
We're assuming that we're in a w-bit machine.
我们假设我们在w位计算机中。 

888
00:44:48,380 --> 00:44:51,780
Remember way back in models of computation?
还记得计算模型的历史吗？ 

889
00:44:51,780 --> 00:44:54,519
Your machine has a word size, it's w bits.
您的计算机的字大小为w位。 

890
00:44:54,719 --> 00:44:56,449
So let's suppose it's w bits.
因此，我们假设它是w位。 

891
00:44:56,449 --> 00:44:59,529
So we have our key, k.
所以我们有密钥k。 

892
00:44:59,530 --> 00:45:00,050
Here it is.
这里是。 

893
00:45:00,050 --> 00:45:00,960
It's w bits long.
它长w位。 

894
00:45:01,159 --> 00:45:03,929



895
00:45:03,929 --> 00:45:07,339
We take some number, a-- think of a as being
我们取一些数字，a-认为是

896
00:45:07,340 --> 00:45:12,070
a random integer among all possible w bit integers.
所有可能的w位整数中的一个随机整数。 

897
00:45:12,070 --> 00:45:16,940
So it's got some zeros, it's got some ones.
所以它有一些零，有一些零。 

898
00:45:17,139 --> 00:45:18,949
And I multiply these.
我乘以这些。 

899
00:45:18,949 --> 00:45:20,629
What does multiplication mean in binary?
乘法在二进制中是什么意思？ 

900
00:45:20,630 --> 00:45:25,559
Well, I take one of these copies of k for each one that's here.
好吧，我在这里为每个k取一份k的副本。 

901
00:45:25,559 --> 00:45:27,559
So I'm going to take one copy here
所以我要在这里拿一份

902
00:45:27,559 --> 00:45:29,320
because there's a one there.
因为那里有一个。 

903
00:45:29,320 --> 00:45:32,559
I'm going to take one copy here because there's a one there.
我要在这里拿一本，因为那里有一本。 

904
00:45:32,559 --> 00:45:35,509
And I'm going to take one copy here
我要在这里复印一份

905
00:45:35,510 --> 00:45:37,860
because there's a one there.
因为那里有一个。 

906
00:45:37,860 --> 00:45:40,789
And on average, half of them will be ones.
平均而言，其中一半会是。 

907
00:45:40,989 --> 00:45:46,149
So I have various copies of k, and then I just add them up.
所以我有k的各种副本，然后我将它们加起来。 

908
00:45:46,150 --> 00:45:47,420
And you know, stuff happens.
而且，事情发生了。 

909
00:45:47,420 --> 00:45:50,079
I get some gobbledygook here.
我在这里有些傻瓜。 

910
00:45:50,079 --> 00:45:50,579
OK.
好。 

911
00:45:50,579 --> 00:45:51,269
How big is it?
它有多大？ 

912
00:45:51,269 --> 00:45:53,710
In general, it's two words long.
通常，这是两个字长。 

913
00:45:53,710 --> 00:45:57,090
When I multiply two words I get two words.
当我将两个单词相乘时，我得到两个单词。 

914
00:45:57,090 --> 00:45:59,190
It could be twice as long, in general.
通常，它的长度可能是它的两倍。 

915
00:45:59,190 --> 00:46:03,480
And what this business is doing is saying take the right word,
而这项业务正在做的是说正确的话， 

916
00:46:03,480 --> 00:46:08,590
this right half here-- let the right word in, I guess,
这右边的一半-我猜，请输入正确的词， 

917
00:46:08,590 --> 00:46:12,519
if you see vampire movies-- and then shift
如果您看到吸血鬼电影-然后移

918
00:46:12,519 --> 00:46:16,704
right-- this is a shift right operation-- by w minus r.
右-这是右移操作-由w减r。 

919
00:46:16,704 --> 00:46:17,670
I didn't even say what r is.
我什至没有说r是什么。 

920
00:46:17,869 --> 00:46:21,130
But basically, what I want is these bits.
但基本上，我想要的是这些位。 

921
00:46:21,130 --> 00:46:24,780
I want r bits here-- this is w bits.
我要在这里r位-这是w位。 

922
00:46:24,780 --> 00:46:29,057
I want the leftmost r bits of the rightmost w bits
我想要最右边的w位中最左边的r位

923
00:46:29,257 --> 00:46:32,509
because I shift right here and get rid of all these guys.
因为我现在就转移到这里，摆脱所有这些家伙。 

924
00:46:32,510 --> 00:46:36,443
r-- I should say, m, is two to the r.
 r--我应该说，m是r的2。 

925
00:46:36,643 --> 00:46:38,059
So I'm going to assume here I have
所以我要假设我有

926
00:46:38,059 --> 00:46:42,369
a table of size a power of 2, and then this number will
一个大小为2的幂的表，然后此数字将

927
00:46:42,369 --> 00:46:47,440
be a number between 0 and m minus 1.
为0到m减1之间的数字。 

928
00:46:47,440 --> 00:46:47,940
OK.
好。 

929
00:46:47,940 --> 00:46:50,260
Why does this work?
为什么这样做？ 

930
00:46:50,260 --> 00:46:52,065
It's intuitive.
很直观

931
00:46:52,264 --> 00:46:54,389
In practice it works quite well because what you're
在实践中，效果很好，因为您是

932
00:46:54,389 --> 00:46:57,089
doing is taking a whole bunch of sort of randomly
做的是随机抽取一大堆

933
00:46:57,090 --> 00:47:00,000
shifted copies of k, adding them up-- you get carries,
转移k的副本，将其加起来-您可以随身携带， 

934
00:47:00,199 --> 00:47:02,689
things get mixed up-- This is hashing.
事情变得混乱了-这是哈希。 

935
00:47:02,690 --> 00:47:04,829
This is-- you're taking k, sort of cutting it up
这是-您要提取k，将其切开

936
00:47:04,829 --> 00:47:08,039
while you're shifting it around, adding things and they collide,
当您移动它，添加东西而它们碰撞时， 

937
00:47:08,039 --> 00:47:09,659
and weird stuff happens.
和奇怪的事情发生。 

938
00:47:09,659 --> 00:47:11,670
You sort of randomize stuff.
您有点随机化的东西。 

939
00:47:11,670 --> 00:47:13,440
Out here, you don't get much randomization
在这里，您不会得到太多随机化

940
00:47:13,440 --> 00:47:15,420
because most-- like the last bit could just
因为大多数-就像最后一点一样

941
00:47:15,420 --> 00:47:16,920
be this one bit of k.
是k的这一位。 

942
00:47:16,920 --> 00:47:19,730
But in the middle, everybody's kind of colliding together.
但是在中间，每个人都在相互碰撞。 

943
00:47:19,730 --> 00:47:21,190
And so intuitively, you're mixing
因此，直观地讲，您在混音

944
00:47:21,190 --> 00:47:22,650
lots of things in the center.
中心有很多东西。 

945
00:47:22,650 --> 00:47:25,309
You take those r bits, roughly, in the center.
您大致将这些r位放在中间。 

946
00:47:25,309 --> 00:47:27,549
That will be nicely mixed up.
那会很好地混合在一起。 

947
00:47:27,550 --> 00:47:29,280
And most of the time this works well.
而且在大多数情况下，这种方法效果很好。 

948
00:47:29,280 --> 00:47:33,750
In practice it works well-- I have some things written here.
实际上，它运作良好-我在这里写了一些东西。 

949
00:47:33,949 --> 00:47:37,379
a better be odd, otherwise you're throwing away stuff.
更好的是奇怪，否则您将扔掉东西。 

950
00:47:37,380 --> 00:47:39,980
And it should not be very close to a power of 2.
而且它不应该非常接近2的幂。 

951
00:47:39,980 --> 00:47:44,840
But it should be in between 2 to the r minus 1 and 2 to the r.
但是它应该在2到r减1和2到r之间。 

952
00:47:44,840 --> 00:47:47,079
Cool.
凉。 

953
00:47:47,079 --> 00:47:47,579
One more.
多一个。 

954
00:47:47,579 --> 00:47:52,750



955
00:47:52,750 --> 00:47:55,230
Again, theoretically, this can be bad.
同样，从理论上讲，这可能是不好的。 

956
00:47:55,230 --> 00:47:57,929
And I leave it as an exercise to find situations, find
我将其作为发现情况，发现问题的练习

957
00:47:57,929 --> 00:48:00,440
key values where this does not do a good job.
不能很好地完成的关键值。 

958
00:48:00,440 --> 00:48:03,789



959
00:48:03,789 --> 00:48:07,539
The cool method is called universal hashing.
很酷的方法称为通用哈希。 

960
00:48:07,539 --> 00:48:11,119



961
00:48:11,119 --> 00:48:14,494
This is something that's a bit beyond the scope of 006.
这超出了006的范围。 

962
00:48:14,494 --> 00:48:17,440
If you want to understand it better you should take 046.
如果您想更好地理解它，则应该采取046。 

963
00:48:17,440 --> 00:48:21,436
But I'll give you the flavor and the method, one of the methods.
但是，我会给您介绍其中一种方法和风味。 

964
00:48:21,436 --> 00:48:23,019
There's actually many ways to do this.
实际上有很多方法可以做到这一点。 

965
00:48:23,019 --> 00:48:33,690



966
00:48:33,690 --> 00:48:34,798
We see a mod m on the outside.
我们在外面看到一个mod m。 

967
00:48:34,998 --> 00:48:37,539
That's just division method just to make the number between 0
那只是使数字介于0之间的除法

968
00:48:37,539 --> 00:48:39,759
and a minus 1.
和减1。 

969
00:48:39,760 --> 00:48:41,045
Here's our key.
这是我们的钥匙。 

970
00:48:41,244 --> 00:48:42,869
And then there's these numbers a and b.
然后是这些数字a和b。 

971
00:48:42,869 --> 00:48:49,219
These are going to be random numbers between 0
这些将是0之间的随机数

972
00:48:49,219 --> 00:48:51,349
and p minus 1.
和p减1。 

973
00:48:51,349 --> 00:48:52,489
What's p?
什么是p？ 

974
00:48:52,489 --> 00:48:58,659
Prime number bigger than the size of the universe.
质数大于宇宙的大小。 

975
00:48:58,659 --> 00:49:00,429
So it's a big prime number.
因此，这是一个很大的素数。 

976
00:49:00,429 --> 00:49:03,869
I think we know how to find prime numbers.
我认为我们知道如何找到质数。 

977
00:49:03,869 --> 00:49:05,769
We don't know in this class, but people
我们这堂课不知道，但是人们

978
00:49:05,769 --> 00:49:07,739
know how to find the prime numbers.
知道如何找到素数。 

979
00:49:07,739 --> 00:49:09,976
So there's a subroutine here, find a big prime number
所以这里有一个子程序，找到一个大素数

980
00:49:09,976 --> 00:49:11,059
bigger than your universe.
比宇宙还大

981
00:49:11,059 --> 00:49:12,268
It's not too hard to do that.
做到这一点并不难。 

982
00:49:12,268 --> 00:49:15,369
We can do it in polynomial time.
我们可以在多项式时间内完成。 

983
00:49:15,369 --> 00:49:15,960
That's just set up.
这就是设置。 

984
00:49:16,159 --> 00:49:19,219
You do that once for a given size table.
对于给定的尺寸表，只需执行一次。 

985
00:49:19,219 --> 00:49:23,915
And then you choose two random numbers, a and b.
然后选择两个随机数a和b。 

986
00:49:23,916 --> 00:49:25,789
And then this is the hash function, a times k
然后是哈希函数，乘以k 

987
00:49:25,789 --> 00:49:28,980
plus b, mod p mod m.
加b，mod p mod m。 

988
00:49:28,980 --> 00:49:29,480
OK.
好。 

989
00:49:29,480 --> 00:49:32,590
What does this do?
这是做什么的？ 

990
00:49:32,590 --> 00:49:35,809
It turns out-- here's the interesting part.
事实证明-这是有趣的部分。 

991
00:49:35,809 --> 00:49:45,259
For worst case keys, k1 and k2, that are distinct,
对于最差的情况，密钥k1和k2是截然不同的， 

992
00:49:45,260 --> 00:49:56,650
the probability of h of k1 equaling h of k2 is 1 over n.
 k1的h等于k2的h的概率是n的1。 

993
00:49:56,650 --> 00:49:59,820
So probability of two keys that are different colliding
所以两个不同碰撞的钥匙的概率

994
00:49:59,820 --> 00:50:03,072
is 1 over m, for the worst case keys.
在最坏的情况下，m大于1。 

995
00:50:03,072 --> 00:50:04,280
What the heck does that mean?
这是什么意思？ 

996
00:50:04,280 --> 00:50:05,769
What's the probability over?
几率超过多少？ 

997
00:50:05,769 --> 00:50:08,389
Any suggestions?
有什么建议么？ 

998
00:50:08,389 --> 00:50:11,449
What's random here?
这是随机的吗？ 

999
00:50:11,449 --> 00:50:12,199
AUDIENCE: a and b.
听众：a和b。 

1000
00:50:12,199 --> 00:50:13,089
PROFESSOR: a and b.
教授：a和b。 

1001
00:50:13,090 --> 00:50:15,250
This is the probability over a and b.
这是在a和b上的概率。 

1002
00:50:15,250 --> 00:50:18,349
This is the probability over the choice of your hash function.
这是选择哈希函数的概率。 

1003
00:50:18,349 --> 00:50:22,029
So it's the worst case inputs, worst case insertions,
因此，这是最坏情况的输入，最坏情况的插入， 

1004
00:50:22,030 --> 00:50:24,730
but random hash function.
但是随机哈希函数。 

1005
00:50:24,730 --> 00:50:26,730
As long as you choose your random hash function,
只要您选择随机哈希函数， 

1006
00:50:26,730 --> 00:50:28,550
the probability of collision is 1 over m.
碰撞的概率是1超过m。 

1007
00:50:28,550 --> 00:50:31,130
This is the ideal situation
这是理想的情况

1008
00:50:31,130 --> 00:50:33,940
And so you can prove, just like we analyzed here--
因此您可以证明，就像我们在这里进行的分析一样- 

1009
00:50:34,139 --> 00:50:35,139
It's a little more work.
还有更多工作。 

1010
00:50:35,139 --> 00:50:35,909
It's in the notes.
在笔记中。 

1011
00:50:35,909 --> 00:50:37,559
You use linearity of expectation.
您使用期望线性。 

1012
00:50:37,559 --> 00:50:39,699
And you can prove, still, that the expected length
您仍然可以证明预期长度

1013
00:50:39,699 --> 00:50:42,619
of a chain-- the expected number of collisions that a key has
链的数量-密钥发生的预期碰撞次数

1014
00:50:42,619 --> 00:50:48,719
with another key is the load factor, in the worst case,
另一个关键是负载系数，在最坏的情况下， 

1015
00:50:48,719 --> 00:50:51,501
but in expectation for a given hash function.
但期望有一个给定的哈希函数。 

1016
00:50:51,501 --> 00:50:53,210
So still, the expected length of a chain,
因此，预期的链长

1017
00:50:53,210 --> 00:50:55,400
and therefore, the expected running time
因此，预期的运行时间

1018
00:50:55,400 --> 00:50:58,134
of hashing with chaining, using this hash function,
使用此哈希函数进行链式哈希处理， 

1019
00:50:58,333 --> 00:51:00,750
or this collection of hash functions, or a randomly chosen
或此哈希函数集合，或随机选择

1020
00:51:00,750 --> 00:51:03,449
one, is constant for constant load factor.
第一，对于恒定的负载系数是恒定的。 

1021
00:51:03,449 --> 00:51:05,688
And that's why hashing really works in theory.
这就是散列理论上真正起作用的原因。 

1022
00:51:05,688 --> 00:51:07,730
We're not going to go into details of this again.
我们将不再赘述。 

1023
00:51:07,730 --> 00:51:09,659
Take 6.046 if you want to know.
如果您想知道，请取6.046。 

1024
00:51:09,659 --> 00:51:12,469
But this should make you feel more comfortable.
但这应该会让您感到更舒适。 

1025
00:51:12,469 --> 00:51:17,469
And we'll see other ways do hashing next class.
我们将看到其他方法对下一个类进行哈希处理。 

