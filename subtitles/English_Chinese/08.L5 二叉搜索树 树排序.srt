1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,320
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,320 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:21,929



10
00:00:22,129 --> 00:00:25,859
PROFESSOR: Today's lecture is about a brand new data
教授：今天的讲座是关于全新数据的

11
00:00:25,859 --> 00:00:29,129
structure that you've probably seen before,
您之前可能已经看到的结构

12
00:00:29,129 --> 00:00:32,490
and we've mentioned earlier in double 06,
我们之前在双06中提到过

13
00:00:32,490 --> 00:00:34,739
called a binary search tree.
称为二叉搜索树。 

14
00:00:34,939 --> 00:00:37,079
We've talked about binary search.
我们已经讨论过二进制搜索。 

15
00:00:37,079 --> 00:00:40,729
It's a fundamental divide and conquer paradigm.
这是根本的分而治之范式。 

16
00:00:40,729 --> 00:00:42,729
There's a data structure associated with it,
有一个与之相关的数据结构， 

17
00:00:42,729 --> 00:00:45,879
called the BST, a binary search tree.
称为BST，即二叉搜索树。 

18
00:00:45,880 --> 00:00:49,310
And what I want to do is motivate this data structure
我想做的就是激发这种数据结构

19
00:00:49,310 --> 00:00:51,390
using a problem.
使用问题。 

20
00:00:51,390 --> 00:00:55,250
It's a bit of a toy problem, but certainly a problem
这是一个玩具问题，但肯定是一个问题

21
00:00:55,250 --> 00:01:01,070
that you could imagine exists in all sorts
你可以想象各种存在

22
00:01:01,070 --> 00:01:04,689
of scheduling problems.
调度问题。 

23
00:01:04,689 --> 00:01:08,310
It's a part of a runway reservation system
这是跑道预定系统的一部分

24
00:01:08,310 --> 00:01:10,159
that you can imagine building.
您可以想象建筑物。 

25
00:01:10,159 --> 00:01:13,909
And what I'll do is define this problem
我要做的就是定义这个问题

26
00:01:13,909 --> 00:01:17,780
and talk about how we could possibly solve it with the data
并讨论如何用数据解决它

27
00:01:17,780 --> 00:01:23,079
structures you've already seen-- so lists and arrays, heaps
您已经看到的结构-列表和数组，堆

28
00:01:23,079 --> 00:01:25,269
as well as, which we saw last time--
以及我们上次看到的

29
00:01:25,269 --> 00:01:32,539
and hopefully motivate you into the reason behind the existence
并希望激发您进入存在背后的原因

30
00:01:32,540 --> 00:01:35,015
of binary search trees, because they
二叉搜索树，因为它们

31
00:01:35,015 --> 00:01:36,849
are kind of the perfect data structure
是一种完美的数据结构

32
00:01:36,849 --> 00:01:40,079
for this particular problem.
对于这个特殊的问题。 

33
00:01:40,079 --> 00:01:45,640
So let's dive into what the runway reservation system looks
因此，让我们深入了解跑道预定系统的外观

34
00:01:45,640 --> 00:01:46,140
like.
喜欢。 

35
00:01:46,140 --> 00:01:49,909



36
00:01:49,909 --> 00:01:53,049
And it's your basic scheduling problem.
这是您的基本计划问题。 

37
00:01:53,049 --> 00:02:00,030
We'll assume an airport with a single runway.
我们假设一个机场只有一条跑道。 

38
00:02:00,030 --> 00:02:04,286



39
00:02:04,286 --> 00:02:06,180
Now Logan has six runways.
现在，洛根有六个跑道。 

40
00:02:06,180 --> 00:02:09,699
But the moment there's any sort of weather you're down to one.
但是，当遇到任何天气时，您都会陷入困境。 

41
00:02:09,699 --> 00:02:13,180
And of course, there's lots of airports with a single runway.
当然，很多机场只有一条跑道。 

42
00:02:13,180 --> 00:02:15,849
And we can imagine that this runway is pretty busy.
我们可以想象这条跑道非常繁忙。 

43
00:02:15,849 --> 00:02:19,669
There's obviously safety issues associated with landing planes,
着陆飞机显然存在安全问题， 

44
00:02:19,669 --> 00:02:21,500
and planes taking off.
和飞机起飞。 

45
00:02:21,500 --> 00:02:23,229
And so there are constraints associated
因此，存在一些约束条件

46
00:02:23,229 --> 00:02:25,840
with the system, that have to be obeyed.
该系统必须遵守。 

47
00:02:25,840 --> 00:02:28,530
And you have to build these constraints in-- and the checks
然后您必须建立这些约束，然后进行检查

48
00:02:28,530 --> 00:02:31,780
for these constraints-- into your data structure.
对于这些约束-进入您的数据结构。 

49
00:02:31,780 --> 00:02:34,520
That's sort of the summary of the context.
这就是上下文的摘要。 

50
00:02:34,520 --> 00:02:36,969



51
00:02:37,169 --> 00:02:43,780
So reservations for future landings
因此，为将来的着陆保留

52
00:02:43,780 --> 00:02:48,240
is really what this system is built for.
确实是该系统的基础。 

53
00:02:48,240 --> 00:02:50,000
There's a notion of time.
有时间观念。 

54
00:02:50,199 --> 00:02:52,789
We'll assume that time is continuous.
我们假设时间是连续的。 

55
00:02:52,789 --> 00:02:58,439
So it could be represented by a real variable,
因此可以用一个实变量表示

56
00:02:58,439 --> 00:03:00,289
or a real quantity.
或实际数量。 

57
00:03:00,289 --> 00:03:14,459
And what we'd like to do is reserve requests for landings.
而我们要做的是保留着陆请求。 

58
00:03:14,460 --> 00:03:20,340
And these are going to specify landing time.
这些将指定登陆时间。 

59
00:03:20,340 --> 00:03:22,629
Each of them is going to specify a landing time.
他们每个人都将指定登陆时间。 

60
00:03:22,629 --> 00:03:26,109
We call it t.
我们称它为t。 

61
00:03:26,110 --> 00:03:33,210
And in particular, we're going to add t
特别是，我们将添加

62
00:03:33,210 --> 00:03:52,370
to the set R of landing times if no other landings are scheduled
如果未安排其他降落，则将其降落为设置的降落时间R 

63
00:03:52,370 --> 00:03:54,594
within k minutes.
在k分钟内。 

64
00:03:54,594 --> 00:03:57,789



65
00:03:57,789 --> 00:04:03,429
And k is a parameter that could vary.
 k是可以变化的参数。 

66
00:04:03,430 --> 00:04:07,810
I mean, it could be statically set to 3 minutes, or maybe 4.
我的意思是，它可以静态设置为3分钟，也可能是4分钟。 

67
00:04:07,810 --> 00:04:10,219
You can imagine it varying it dynamically
您可以想象它会动态变化

68
00:04:10,419 --> 00:04:12,909
depending on weather conditions, things like that.
视天气情况而定。 

69
00:04:12,909 --> 00:04:16,230



70
00:04:16,230 --> 00:04:18,730
For the most of the examples we'll talk about today,
对于我们今天要讨论的大多数示例， 

71
00:04:18,730 --> 00:04:23,129
we'll assume k is 3 minutes, or something like that.
我们假设k是3分钟，或类似的时间。 

72
00:04:23,129 --> 00:04:28,699
So this is about adding to the data structure.
因此，这是关于添加到数据结构中的。 

73
00:04:28,699 --> 00:04:31,289
And so an insert operation, if you will,
因此，如果有插入操作， 

74
00:04:31,290 --> 00:04:34,470
that has a constraint associated with it that you need to check.
有与之相关的约束，需要检查。 

75
00:04:34,470 --> 00:04:37,060
And so you wouldn't insert if the constraint was violated.
因此，如果违反了约束，您将不会插入。 

76
00:04:37,060 --> 00:04:40,759
You would if the constraint was satisfied.
如果满足约束，您将愿意。 

77
00:04:40,759 --> 00:04:45,029
And time, as I said, is something
正如我所说，时间就是

78
00:04:45,029 --> 00:04:47,500
that is part of the system.
这是系统的一部分。 

79
00:04:47,500 --> 00:04:49,300
It needs to be modeled.
它需要建模。 

80
00:04:49,300 --> 00:04:51,560
You have the current notion of time.
您拥有当前的时间观念。 

81
00:04:51,560 --> 00:04:57,240
And every time you have a plane that's already landed,
每当您有一架已经降落的飞机时， 

82
00:04:57,240 --> 00:05:00,370
which means that you can essentially
这意味着您基本上可以

83
00:05:00,370 --> 00:05:03,430
take this particular landing time away
减少这个特殊的着陆时间

84
00:05:03,430 --> 00:05:12,449
from the set R. So this removal, or delete-- we remove
从集合R中删除。因此，删除或删除-我们删除

85
00:05:12,649 --> 00:05:17,729
from set R, which is the set of landing times
从集合R开始，这是着陆时间

86
00:05:17,730 --> 00:05:20,000
after the plane lands.
飞机降落之后。 

87
00:05:20,199 --> 00:05:23,329



88
00:05:23,329 --> 00:05:25,891
So every once in awhile, as time increments,
所以每隔一段时间，随着时间的推移， 

89
00:05:25,891 --> 00:05:27,850
you're going to be checking the data structure.
您将要检查数据结构。 

90
00:05:27,850 --> 00:05:31,439
And you can do this, maybe, every minute, every 30 seconds.
您可以每隔30秒执行一次。 

91
00:05:31,439 --> 00:05:32,810
That isn't really important.
那不是很重要。 

92
00:05:32,810 --> 00:05:34,810
But you have to be able to remove from this data
但是您必须能够从此数据中删除

93
00:05:34,810 --> 00:05:36,060
structure.
结构体。 

94
00:05:36,060 --> 00:05:38,509
So fairly straightforward data structure.
因此，数据结构相当简单。 

95
00:05:38,509 --> 00:05:43,189
It's a set, R. We don't quite know how to implement it yet.
这是一个集合，R。我们还不知道如何实现它。 

96
00:05:43,189 --> 00:05:59,149
But we'd like to do all of these operations in order log n time,
但是我们想按顺序登录n进行所有这些操作， 

97
00:05:59,149 --> 00:06:03,089
where n is the size of the set.
其中n是集合的大小。 

98
00:06:03,089 --> 00:06:04,409
All right?
好吧？ 

99
00:06:04,410 --> 00:06:07,939
So any questions about that?
那么对此有任何疑问吗？ 

100
00:06:07,939 --> 00:06:09,969
Any questions about the definition
有关定义的任何疑问

101
00:06:09,970 --> 00:06:14,790
of the problem before we move on?
我们继续前进之前的问题？ 

102
00:06:14,790 --> 00:06:16,439
Are we good on?
我们好吗？ 

103
00:06:16,439 --> 00:06:17,819
OK.
好。 

104
00:06:17,819 --> 00:06:25,459
So let's look at a real straightforward example,
因此，让我们看一个真正简单的示例， 

105
00:06:25,459 --> 00:06:32,719
and put this up here so you get a better sense of this.
并将其放在此处，以便您对此有更好的了解。 

106
00:06:32,720 --> 00:06:37,370
Let's say that, right now, we are at time 37.
假设现在是37岁。 

107
00:06:37,569 --> 00:06:45,579
And the set R has 41.2, 49, and 53 in it.
集合R中有41.2、49和53。 

108
00:06:45,579 --> 00:06:48,120
And that's time.
那是时候了。 

109
00:06:48,120 --> 00:06:53,040
Now you may get a request for landing time 53.
现在，您可能会收到登陆时间请求53。 

110
00:06:53,040 --> 00:06:54,810
And-- I'm sorry.
而且-很抱歉。 

111
00:06:55,009 --> 00:07:01,500
I want to call this 56.3-- 41.2, 49, and 56.3.
我想将其称为56.3-41.2、49和56.3。 

112
00:07:01,500 --> 00:07:04,629
You may get a request for landing time 53.
您可能会要求登陆时间53。 

113
00:07:04,629 --> 00:07:06,740
And right now the time is 37.
现在时间是37。 

114
00:07:06,740 --> 00:07:10,870
It's in the future, and you say OK because you've
在将来，您说OK，因为您已经

115
00:07:10,870 --> 00:07:11,759
done the check.
完成了检查。 

116
00:07:11,759 --> 00:07:15,339
And let's assume that k equals 3.
并假设k等于3。 

117
00:07:15,339 --> 00:07:24,529
And 53 is four ahead of 49, and 3.3 before 56.3, so you're OK.
 53比49高4，在56.3之前是3.3，所以您还可以。 

118
00:07:24,529 --> 00:07:27,519
44 is not allowed.
不允许44。 

119
00:07:27,519 --> 00:07:30,549



120
00:07:30,550 --> 00:07:33,610
It's too close to 41.2.
太接近41.2。 

121
00:07:33,610 --> 00:07:38,290
And 20, just for completeness, is not
而20仅仅是为了完整性，不是

122
00:07:38,290 --> 00:07:39,475
allowed because it's passed.
允许，因为已通过。 

123
00:07:39,475 --> 00:07:42,509



124
00:07:42,709 --> 00:07:43,954
Can't schedule in the past.
无法安排过去的时间。 

125
00:07:43,954 --> 00:07:45,329
I mean, it could be the next day.
我的意思是，可能是第二天。 

126
00:07:45,329 --> 00:07:46,789
But then you wouldn't call it 20.
但是那样的话你不会叫20。 

127
00:07:46,790 --> 00:07:50,110
Let's assume that time is a monotonically increasing
假设时间在单调增加

128
00:07:50,110 --> 00:07:51,629
function.
功能。 

129
00:07:51,829 --> 00:07:54,019
You have a 64-bit number.
您有一个64位数字。 

130
00:07:54,019 --> 00:07:56,599
It can go to the end of the world, or 2012,
它可以走到世界末日，也可以是2012年， 

131
00:07:56,600 --> 00:07:58,189
or wherever you want.
或您想要的任何地方。 

132
00:07:58,389 --> 00:08:01,389
So you can keep the number a bit smaller,
因此，您可以将数字保持较小， 

133
00:08:01,389 --> 00:08:05,389
and do a little constant factor optimization, I guess.
我想做一些恒定因子优化。 

134
00:08:05,389 --> 00:08:08,430
So that's sort of the set up.
这样就完成了。 

135
00:08:08,430 --> 00:08:12,449
And hopefully you get a sense of what the requirements.
希望您对要求有一个了解。 

136
00:08:12,649 --> 00:08:16,509
And you guys know about a bunch of data structures already.
你们已经知道了一堆数据结构。 

137
00:08:16,509 --> 00:08:19,300
And what I want to do is list each one of them,
我想做的是列出其中每一个， 

138
00:08:19,300 --> 00:08:23,310
and essentially shoot them down with respect
并尊重他们

139
00:08:23,310 --> 00:08:31,519
to not being able to make this efficiency requirement.
无法达到此效率要求。 

140
00:08:31,519 --> 00:08:34,829
And I'd like you guys to help me shoot them down.
我希望你们能帮助我击落他们。 

141
00:08:34,830 --> 00:08:39,235
So let's talk about an easy one first.
因此，让我们先谈一个简单的问题。 

142
00:08:39,235 --> 00:08:42,110



143
00:08:42,110 --> 00:08:44,720
Let's say you have an unsorted list or an array corresponding
假设您有一个未排序的列表或对应的数组

144
00:08:44,720 --> 00:08:49,469
to R. That's all you have.
给R。这就是您所拥有的。 

145
00:08:49,669 --> 00:08:51,990
What's wrong with this data structure
这个数据结构怎么了

146
00:08:51,990 --> 00:08:55,250
from an efficiency standpoint?
从效率的角度来看？ 

147
00:08:55,250 --> 00:08:55,994
Yeah.
是的

148
00:08:55,994 --> 00:08:58,459
AUDIENCE: Pretty much everything you want to do to it is linear.
听众：您要做的几乎所有事情都是线性的。 

149
00:08:58,659 --> 00:08:59,992
PROFESSOR: That's exactly right.
教授：完全正确。 

150
00:08:59,993 --> 00:09:03,230
Pretty much everything you want to do to it is linear.
您要做的几乎所有事情都是线性的。 

151
00:09:03,230 --> 00:09:08,289
And so you want to check the k minute check.
因此，您要检查k分钟检查。 

152
00:09:08,289 --> 00:09:14,360
You can certainly insert into it, and just add to it.
您当然可以插入其中，然后添加即可。 

153
00:09:14,360 --> 00:09:17,070
So that part is not linear, that's constant time.
所以那部分不是线性的，那是恒定的时间。 

154
00:09:17,070 --> 00:09:20,250
But certainly, anything where you
但是可以肯定的是，无论您在哪里

155
00:09:20,250 --> 00:09:25,039
want to go check against other elements of the array,
想去检查数组的其他元素， 

156
00:09:25,039 --> 00:09:26,329
it's unsorted.
它是未分类的。 

157
00:09:26,330 --> 00:09:28,840
You have no idea of where to find these elements.
您不知道在哪里可以找到这些元素。 

158
00:09:28,840 --> 00:09:31,009
You have to scan through the entire array
您必须扫描整个阵列

159
00:09:31,009 --> 00:09:33,929
to check to see whether there's a landing time that's
检查是否有登陆时间

160
00:09:33,929 --> 00:09:38,919
within k of the current time t that you're asking for.
在您要求的当前时间t的k以内。 

161
00:09:38,919 --> 00:09:42,490
And that's going to take order n time.
这将需要n次命令。 

162
00:09:42,490 --> 00:09:53,740
So you can insert in order 1 without a check.
因此，您可以在不检查的情况下按顺序1插入。 

163
00:09:53,740 --> 00:10:03,529
But sadly, the check takes order n time.
但是可悲的是，支票需要n次命令。 

164
00:10:03,529 --> 00:10:04,029
All right?
好吧？ 

165
00:10:04,029 --> 00:10:09,679



166
00:10:09,679 --> 00:10:15,459
Let's do something that is a little more plausible.
让我们做一些看起来更合理的事情。 

167
00:10:15,460 --> 00:10:18,950
Let's talk about a sorted array.
让我们谈谈一个排序数组。 

168
00:10:18,950 --> 00:10:22,720
So this is a little more subtle question.
因此，这是一个更微妙的问题。 

169
00:10:22,720 --> 00:10:25,639
Let's talk about a sorted array.
让我们谈谈一个排序数组。 

170
00:10:25,639 --> 00:10:28,639
What happens with a sorted array?
排序数组会怎样？ 

171
00:10:28,639 --> 00:10:30,225
Someone?
有人吗

172
00:10:30,225 --> 00:10:33,312
What can you do with a sorted array?
您可以对排序数组做什么？ 

173
00:10:33,312 --> 00:10:33,812
Yeah.
是的

174
00:10:33,812 --> 00:10:37,129
AUDIENCE: Do a binary search to find the [INAUDIBLE].
听众：进行二进制搜索以找到[听不清]。 

175
00:10:37,129 --> 00:10:40,899
PROFESSOR: Binary search would find a bad insert.
教授：二进制搜索会发现错误的插入内容。 

176
00:10:40,899 --> 00:10:41,699
OK, good.
好好

177
00:10:41,700 --> 00:10:43,950
So that's good.
这样很好。 

178
00:10:43,950 --> 00:10:47,329
So if you have a sorted array, and just for argument's sake,
因此，如果您有一个已排序的数组，并且仅出于参数考虑， 

179
00:10:47,529 --> 00:10:54,740
it looks like 4, 20, 32, 37, 45.
看起来像是4、20、32、37、45。 

180
00:10:54,740 --> 00:10:56,639
And it's increasing order.
而且它在增加顺序。 

181
00:10:56,639 --> 00:11:02,179
And if you get a particular time t, you can use binary search.
而且，如果获得特定时间t，则可以使用二进制搜索。 

182
00:11:02,179 --> 00:11:07,299
And let's say, in particular, the time is, for example, 34.
具体地说，例如，时间是34。 

183
00:11:07,299 --> 00:11:10,109
Then what you do is you go to the midpoint of the array,
然后，您要做的就是转到数组的中点， 

184
00:11:10,110 --> 00:11:11,860
and maybe you just look at that.
也许您只是看一下。 

185
00:11:11,860 --> 00:11:17,879
And you say oh, 34 is greater than 32.
你说哦，34比32大。 

186
00:11:17,879 --> 00:11:22,870
So I'm going to go check and figure out
所以我要去检查一下

187
00:11:22,870 --> 00:11:26,200
if I need to move to the left or the right.
如果我需要向左或向右移动。 

188
00:11:26,200 --> 00:11:28,450
And since it's greater I'm going to move to the right.
而且由于它更大，所以我将向右移动。 

189
00:11:28,450 --> 00:11:31,879
And within logarithmic time, you'll
在对数时间内，您将

190
00:11:31,879 --> 00:11:37,206
find what we call the insertion point of the sorted array,
找到我们所谓的排序数组的插入点， 

191
00:11:37,206 --> 00:11:40,539
where this 34 is supposed to sit.
这34应该坐的地方。 

192
00:11:40,539 --> 00:11:44,599
And you don't necessarily get to insert there.
而且您不一定要插入那里。 

193
00:11:44,600 --> 00:11:47,330
You need to look, once you've found the insertion point,
找到插入点后，您需要查看一下

194
00:11:47,330 --> 00:11:50,440
to your left and to your right.
在你的左边和右边。 

195
00:11:50,440 --> 00:11:53,340
And do the k minute check.
并进行k分钟检查。 

196
00:11:53,340 --> 00:11:57,259
So finish up the answer to the question,
因此，完成问题的答案， 

197
00:11:57,259 --> 00:12:02,370
tell me how long it's going to take me to find the insertion
告诉我要多长时间才能找到插入内容

198
00:12:02,370 --> 00:12:06,100
point, how long it's going to take me to do the check,
我要花多长时间做支票， 

199
00:12:06,100 --> 00:12:08,210
and how long it's going to take me to actually do
我要花多长时间才能真正完成

200
00:12:08,210 --> 00:12:09,802
the insertion.
插入。 

201
00:12:09,802 --> 00:12:12,325
AUDIENCE: Log n in the search--
听众：在搜索中登录n- 

202
00:12:12,325 --> 00:12:14,450
PROFESSOR: Log n for the search, to find the point.
教授：登录n进行搜索，以找到该点。 

203
00:12:14,450 --> 00:12:16,384
AUDIENCE: Constant for the comparison?
听众：比较的常数吗？ 

204
00:12:16,384 --> 00:12:17,320
PROFESSOR: Constant to the comparison.
教授：一直比较。 

205
00:12:17,320 --> 00:12:18,278
And then the last step?
然后最后一步？ 

206
00:12:18,278 --> 00:12:20,128
AUDIENCE: Do the research [INAUDIBLE].
听众：做研究[听不清]。 

207
00:12:20,128 --> 00:12:23,249
PROFESSOR: Sorry, little louder.
教授：对不起，大声一点。 

208
00:12:23,249 --> 00:12:23,748
Sorry.
抱歉。 

209
00:12:23,748 --> 00:12:24,949
AUDIENCE: The insertion is constant.
听众：插入是恒定的。 

210
00:12:25,149 --> 00:12:26,524
PROFESSOR: Insertion is constant?
教授：插入是恒定的吗？ 

211
00:12:26,524 --> 00:12:27,330
Is that right?
那正确吗？ 

212
00:12:27,330 --> 00:12:31,123
Do you people agree with him, that insertion is constant?
你们是否同意他的观点，即插入是永恒的？ 

213
00:12:31,323 --> 00:12:33,728
AUDIENCE: You've got a maximum size up there, right?
听众：那里有最大尺寸，对吗？ 

214
00:12:33,729 --> 00:12:35,172
There must be a maximum.
必须有一个最大值。 

215
00:12:35,172 --> 00:12:37,100
[INAUDIBLE]
 [听不清] 

216
00:12:37,100 --> 00:12:39,899
PROFESSOR: No, the indices-- so right now the array
教授：不，索引-现在是数组

217
00:12:39,899 --> 00:12:41,679
has indices i.
有索引i。 

218
00:12:41,679 --> 00:12:47,829
And if you start with 1, it's 1, 2, 3, 4, 5, et cetera.
如果从1开始，则为1、2、3、4、5等。 

219
00:12:47,830 --> 00:12:49,709
So what do you mean by insertion?
那么，插入意味着什么？ 

220
00:12:49,909 --> 00:12:52,749
Someone explain to me what-- yeah, go ahead.
有人向我解释-是的，继续。 

221
00:12:52,749 --> 00:12:54,374
AUDIENCE: When you put something in you
听众：当你在里面放东西时

222
00:12:54,374 --> 00:12:56,042
have to shift every element over.
必须转移所有要素。 

223
00:12:56,042 --> 00:12:57,375
PROFESSOR: That's exactly right.
教授：完全正确。 

224
00:12:57,375 --> 00:12:58,308
That's exactly right.
没错

225
00:12:58,308 --> 00:13:00,891
Ok, good, that's great.
好的，很好。 

226
00:13:00,892 --> 00:13:02,600
I guess I should give you half a cushion.
我想我应该给你半垫子。 

227
00:13:02,600 --> 00:13:05,000
But I'll do the full one, right?
但是我会做完整的，对吧？ 

228
00:13:05,000 --> 00:13:05,940
And you get one, too.
你也得到一个。 

229
00:13:05,940 --> 00:13:08,809



230
00:13:09,009 --> 00:13:11,419
So the point here is this is pretty close.
因此，这里的重点是非常接近的。 

231
00:13:11,419 --> 00:13:13,529
It's almost what we want.
这几乎是我们想要的。 

232
00:13:13,529 --> 00:13:15,610
It's almost what we want.
这几乎是我们想要的。 

233
00:13:15,610 --> 00:13:18,320
There's a little bit of a glitch here.
这里有一些小故障。 

234
00:13:18,320 --> 00:13:20,210
We know about binary search.
我们知道二进制搜索。 

235
00:13:20,210 --> 00:13:22,360
The binary search is going to allow us,
二进制搜索将允许我们， 

236
00:13:22,360 --> 00:13:25,950
if there's n elements here, to find the place--
如果这里有n个元素，要找到位置- 

237
00:13:25,950 --> 00:13:29,719
it's going to be able to find-- and I'm
它将会能够找到-我

238
00:13:29,919 --> 00:13:39,969
going to precise here-- the smallest i such that R of i
这里要精确-最小的i使得i的R 

239
00:13:39,970 --> 00:13:44,709
is greater than or equal to t in order log n time.
大于或等于t的顺序登录n次。 

240
00:13:44,909 --> 00:13:47,519



241
00:13:47,519 --> 00:13:49,970
It's going to be able to do that.
它将能够做到这一点。 

242
00:13:49,970 --> 00:14:00,209
You're going to be able to compare R of i and R of i
您将能够比较i的R和i的R 

243
00:14:00,409 --> 00:14:06,529
minus 1-- so the left and the right-- against t
减1-左右-对t 

244
00:14:06,529 --> 00:14:10,000
in order 1 time.
以1次。 

245
00:14:10,000 --> 00:14:24,105
But sadly, the actual insertion is going to require shifting.
但可悲的是，实际插入将需要移位。 

246
00:14:24,105 --> 00:14:29,599



247
00:14:29,799 --> 00:14:33,889
And that could take order n time, because it's an array.
这可能需要n倍的时间，因为它是一个数组。 

248
00:14:33,889 --> 00:14:38,159



249
00:14:38,159 --> 00:14:40,469
So that's the problem.
这就是问题所在。 

250
00:14:40,470 --> 00:14:47,240
Now you could imagine that you had a sorted list.
现在您可以想象您有一个排序列表。 

251
00:14:47,240 --> 00:14:50,610
And you could say, hey if I have a sorted list,
你可能会说，嘿，如果我有一个排序列表， 

252
00:14:50,610 --> 00:14:57,229
then the list looks like this, and it's
然后列表看起来像这样， 

253
00:14:57,429 --> 00:14:59,649
got a bunch of pointers in it.
里面有一堆指针。 

254
00:14:59,649 --> 00:15:05,689
And if I've found the insertion point,
如果我找到了插入点， 

255
00:15:05,690 --> 00:15:13,370
then-- the list is nice, because you can insert something
然后-该列表很好，因为您可以插入一些内容

256
00:15:13,370 --> 00:15:16,659
by moving pointers in constant time
通过在恒定时间内移动指针

257
00:15:16,659 --> 00:15:18,839
once you've found the insertion point.
找到插入点后。 

258
00:15:18,840 --> 00:15:21,620
But what's the problem with the list?
但是列表有什么问题？ 

259
00:15:21,620 --> 00:15:22,120
Yeah.
是的

260
00:15:22,120 --> 00:15:24,580
AUDIENCE: You can't do binary search [INAUDIBLE].
听众：您无法执行二进制搜索[听不清]。 

261
00:15:24,580 --> 00:15:26,729
PROFESSOR: Well you can't do binary search on a list.
教授：嗯，您不能对列表进行二进制搜索。 

262
00:15:26,929 --> 00:15:30,799
There's no notion of going to the n by 2 index
没有想法去n by 2索引

263
00:15:30,799 --> 00:15:36,479
and doing random access on a conventional list, right?
并在常规列表上进行随机访问，对吗？ 

264
00:15:36,480 --> 00:15:39,610
So the list does one thing right,
所以这个清单做对了一件事情， 

265
00:15:39,610 --> 00:15:41,440
but doesn't do the other thing right.
但没有做正确的另一件事。 

266
00:15:41,440 --> 00:15:43,600
The array does a couple things right,
数组可以正确完成几件事， 

267
00:15:43,600 --> 00:15:45,440
but doesn't do the shifting right.
但不做右移。 

268
00:15:45,440 --> 00:15:49,229
And so you see why we've constructed this toy problem.
因此，您会看到我们为什么构造了这个玩具问题。 

269
00:15:49,429 --> 00:15:52,669
It's to motivate the binary search tree data
是为了激发二叉搜索树数据

270
00:15:52,669 --> 00:15:53,849
structure, obviously.
结构，显然。 

271
00:15:53,850 --> 00:15:58,839
But you're close, but not quite there.
但是您很亲近，但还不完全到那里。 

272
00:15:59,039 --> 00:15:59,829
What about heaps?
那堆呢？ 

273
00:15:59,830 --> 00:16:03,190



274
00:16:03,190 --> 00:16:06,309
We talked about heaps last time.
我们上次谈到堆。 

275
00:16:06,509 --> 00:16:12,350
What's the basic problem with the heap for this problem?
堆的基本问题是什么？ 

276
00:16:12,350 --> 00:16:14,509
The heaps are data arrays, but you
堆是数据数组，但是你

277
00:16:14,509 --> 00:16:15,970
can visualize them as trees.
可以将它们可视化为树木。 

278
00:16:15,970 --> 00:16:19,070
And obviously if we're talking about min heaps and max heaps.
而且很显然，如果我们在谈论最小堆和最大堆。 

279
00:16:19,070 --> 00:16:23,229
So in particular, what goes wrong with a min heap or a max
因此，特别是最小堆或最大堆出了什么问题

280
00:16:23,429 --> 00:16:26,939
heap for this problem?
堆这个问题？ 

281
00:16:26,940 --> 00:16:28,314
What takes a long time?
需要很长时间？ 

282
00:16:28,514 --> 00:16:29,014
Yeah.
是的

283
00:16:29,014 --> 00:16:31,659



284
00:16:31,659 --> 00:16:36,371
AUDIENCE: You have to scan every element, which [INAUDIBLE].
听众：您必须扫描[听不清]的每个元素。 

285
00:16:36,371 --> 00:16:37,371
PROFESSOR: That's right.
教授：是的。 

286
00:16:37,371 --> 00:16:39,990
I mean, sadly, you know when we talk about min heaps or max
我的意思是，可悲的是，您知道当我们谈论最小堆或最大堆时

287
00:16:39,990 --> 00:16:46,460
heaps, they actually have a fairly weak invariant.
实际上，它们实际上具有相当弱的不变性。 

288
00:16:46,460 --> 00:16:49,509
It turns out that-- I'm previewing a bit here--
事实证明-我在这里预览了一下- 

289
00:16:49,509 --> 00:16:51,039
binary search trees are obviously
二进制搜索树显然是

290
00:16:51,039 --> 00:16:53,919
similar to heaps in the sense that you visualize
从视觉上讲类似于堆

291
00:16:53,919 --> 00:16:56,279
an array as a tree, in the case of a heap.
如果是堆，则数组作为树。 

292
00:16:56,279 --> 00:16:58,360
And binary search trees are trees.
二进制搜索树就是树。 

293
00:16:58,360 --> 00:17:02,169
But the invariant in a min heap or a max heap,
但是最小堆或最大堆中的不变量

294
00:17:02,169 --> 00:17:04,068
is this kind of a week invariant.
这种一周不变。 

295
00:17:04,068 --> 00:17:12,740
It essentially says, look at the min element.
本质上说，看一下min元素。 

296
00:17:12,740 --> 00:17:15,670
And the min element has to be the root,
 min元素必须是根， 

297
00:17:15,670 --> 00:17:18,190
so you can do that one operation pretty quickly.
因此您可以相当快地完成一项操作。 

298
00:17:18,190 --> 00:17:21,769
But if you want to look for a k minute check,
但是，如果您想查看ak分钟检查， 

299
00:17:21,769 --> 00:17:30,759
you want to see if there's an element in the heap that
你想看看堆中是否有一个元素

300
00:17:30,759 --> 00:17:36,819
is less than or equal to k, or greater than or equal to k
小于或等于k，或大于或等于k 

301
00:17:36,819 --> 00:17:41,519
from t, this is going to take order n time.
从t开始，这将需要n次命令。 

302
00:17:41,519 --> 00:17:43,250
OK?
好？ 

303
00:17:43,250 --> 00:17:43,750
Good.
好。 

304
00:17:43,750 --> 00:17:46,390



305
00:17:46,390 --> 00:17:49,250
And finally, we haven't talked about dictionaries,
最后，我们没有谈论字典， 

306
00:17:49,250 --> 00:17:52,039
but we will next week.
但是我们下周。 

307
00:17:52,039 --> 00:17:54,529
Eric will talk about hash tables and dictionaries.
 Eric将讨论哈希表和字典。 

308
00:17:54,529 --> 00:17:56,799
And they have the same problem.
他们有同样的问题。 

309
00:17:56,799 --> 00:17:59,690
So it's not like dictionaries are going to solve the problem,
所以这不像字典要解决这个问题， 

310
00:17:59,690 --> 00:18:02,289
for those of you who know about hash tables and dictionaries.
对于那些了解哈希表和字典的人。 

311
00:18:02,289 --> 00:18:04,039
But you'll hear about them in some detail.
但是您会详细了解它们。 

312
00:18:04,039 --> 00:18:06,379
They're very good at other things.
他们在其他方面很擅长。 

313
00:18:06,380 --> 00:18:10,159
So I don't want to say much more about that, because you're not
所以我不想多说，因为你不是

314
00:18:10,359 --> 00:18:12,339
supposed to know about dictionaries.
应该知道字典。 

315
00:18:12,339 --> 00:18:13,798
Or at least we don't want to assume
或者至少我们不想假设

316
00:18:13,798 --> 00:18:16,130
you do, though we have talked about them
你知道，尽管我们已经谈论过

317
00:18:16,130 --> 00:18:19,190
and alluded to dictionaries earlier.
并早些提到字典。 

318
00:18:19,190 --> 00:18:21,404
And so that's a story here.
这就是一个故事。 

319
00:18:21,404 --> 00:18:22,529
Yeah, back there, question.
是的，回到那里，问。 

320
00:18:22,529 --> 00:18:25,450
AUDIENCE: Yeah, can you explain why it's [INAUDIBLE] time?
听众：是的，你能解释为什么现在[听不清]吗？ 

321
00:18:25,450 --> 00:18:27,529
PROFESSOR: So what is a heap, right?
教授：那是堆，对吗？ 

322
00:18:27,529 --> 00:18:30,220
A heap essentially-- a min heap, for example,
本质上是一个堆-例如最小堆

323
00:18:30,220 --> 00:18:34,279
or we talked about max heaps last time,
或者我们上次谈到最大堆

324
00:18:34,279 --> 00:18:39,440
has the property that you have an element k,
具有您拥有元素k的属性， 

325
00:18:39,440 --> 00:18:47,420
and you're going to look at, let's say it's 21.
您将要看的是21岁。 

326
00:18:47,420 --> 00:18:51,849
Let's do min heaps, so this has to be less than what's
让我们做最小堆，所以这必须小于

327
00:18:52,049 --> 00:18:55,440
here, 23, and what there, maybe it's
在这里23岁那边，也许是

328
00:18:55,440 --> 00:18:57,545
30, and so on and so forth.
 30，依此类推。 

329
00:18:57,545 --> 00:18:59,045
And you have a recursive definition.
并且您有一个递归定义。 

330
00:18:59,045 --> 00:19:04,220



331
00:19:04,220 --> 00:19:07,490
And when you insert into a min heap, typically what happens
当您插入最小堆时，通常会发生什么

332
00:19:07,490 --> 00:19:11,589
is suppose you wanted to insert, for argument's sake,
假设您是为了论证而插入

333
00:19:11,589 --> 00:19:16,279
I want to insert 25.
我想插入25。 

334
00:19:16,279 --> 00:19:19,170
I want to insert 25 into this.
我想在其中插入25。 

335
00:19:19,170 --> 00:19:23,009
The insertion algorithm for a min heap
最小堆的插入算法

336
00:19:23,009 --> 00:19:25,779
typically adds to the end of the min heap.
通常添加到最小堆的末尾。 

337
00:19:25,779 --> 00:19:29,279
So what you do is you would add 25 to this.
因此，您要做的是将这加25。 

338
00:19:29,279 --> 00:19:33,500
And let's say that you had something out here.
假设您在这里有东西。 

339
00:19:33,500 --> 00:19:34,630
So you'd add to it.
所以您要添加它。 

340
00:19:34,630 --> 00:19:38,169
And you'd start flipping things.
并且您将开始翻转事物。 

341
00:19:38,369 --> 00:19:43,079
And you could work with just this part of the array
您可以只处理阵列的这一部分

342
00:19:43,079 --> 00:19:45,139
to insert 25 in here.
在此处插入25。 

343
00:19:45,140 --> 00:19:48,660
And you'd be able to satisfy the invariant of the min heap.
并且您将能够满足最小堆的不变性。 

344
00:19:48,660 --> 00:19:51,750
And you'd get a legitimate min heap.
而且您会得到合法的最小堆。 

345
00:19:51,750 --> 00:19:56,109
But you'd never check the left part of it, which is 23.
但是您永远都不会检查它的左侧部分，即23。 

346
00:19:56,109 --> 00:20:00,359
So it's quite possible-- and this is a good example--
所以这很有可能-这是一个很好的例子- 

347
00:20:00,359 --> 00:20:04,419
that your basic insertion algorithm, which is essentially
您的基本插入算法，本质上是

348
00:20:04,420 --> 00:20:07,640
a version of max heap of i, or min heap of i,
 i的最大堆或i的最小堆的版本， 

349
00:20:07,640 --> 00:20:09,639
would simply insert at the end, and keep
只需在末尾插入，并保持

350
00:20:09,839 --> 00:20:12,000
flipping until you get the min heap property,
翻转直到获得最小堆属性， 

351
00:20:12,000 --> 00:20:15,109
would be unable to check for the k minute check
将无法检查k分钟检查

352
00:20:15,109 --> 00:20:16,429
during the insertion.
在插入过程中。 

353
00:20:16,430 --> 00:20:18,659
But what you'd have to do is to go look elsewhere.
但是您要做的就是去别处。 

354
00:20:18,859 --> 00:20:20,826
That min heap of i we'd never look at--
我永远不会看的那最小的堆- 

355
00:20:20,826 --> 00:20:23,035
or the insert algorithm we'd never look at-- and that
或我们永远不会看的插入算法- 

356
00:20:23,035 --> 00:20:24,900
would require order n time.
将需要订购n次。 

357
00:20:24,900 --> 00:20:25,460
All right?
好吧？ 

358
00:20:25,460 --> 00:20:26,092
AUDIENCE: Thank you.
听众：谢谢。 

359
00:20:26,292 --> 00:20:28,889



360
00:20:28,890 --> 00:20:31,500
PROFESSOR: So that's the story for the min heap.
教授：这就是最小堆的故事。 

361
00:20:31,500 --> 00:20:32,730
Thanks for the question.
谢谢你的问题。 

362
00:20:32,730 --> 00:20:35,159
And it's similar for dictionaries, as I said.
正如我所说，字典也是如此。 

363
00:20:35,359 --> 00:20:37,149
And so we're stuck.
因此，我们陷入困境。 

364
00:20:37,150 --> 00:20:42,960
We have no data structure yet that can do all of the things
我们还没有可以做所有事情的数据结构

365
00:20:42,960 --> 00:20:48,910
that I put up on the board to the left, in order log n time.
我把它放在左边的板上，以n次登录。 

366
00:20:48,910 --> 00:20:52,769
And as you can see, the sorted array got pretty close.
如您所见，排序后的数组非常接近。 

367
00:20:52,769 --> 00:20:58,349
And so if you could just solve this problem,
因此，如果您可以解决这个问题， 

368
00:20:58,349 --> 00:21:04,099
if you could do fast insertion-- and by fast I mean order log n
如果您可以进行快速插入-我指的是快速登录log n 

369
00:21:04,099 --> 00:21:14,480
time-- into a sorted array, we'd be in business.
时间-按分类排列，我们会做生意。 

370
00:21:14,480 --> 00:21:18,200
So that's what we'd like to do with binary search trees.
这就是我们想要对二叉搜索树进行的操作。 

371
00:21:18,200 --> 00:21:20,139
Binary search trees are, as you can imagine,
您可以想象，二叉搜索树是

372
00:21:20,339 --> 00:21:22,079
enable binary search.
启用二进制搜索。 

373
00:21:22,079 --> 00:21:27,319
But the sorted arrays don't allow fast insertion,
但是排序后的数组不允许快速插入， 

374
00:21:27,319 --> 00:21:28,419
but BSTs do.
但是BST可以。 

375
00:21:28,420 --> 00:21:30,919



376
00:21:30,919 --> 00:21:31,960
So let me introduce BSTs.
因此，让我介绍一下BST。 

377
00:21:31,960 --> 00:21:38,500



378
00:21:38,500 --> 00:21:40,130
As with any data structure, there's
与任何数据结构一样， 

379
00:21:40,130 --> 00:21:43,619
a nice invariant associated with BSTs.
与BST相关的一个很好的不变式。 

380
00:21:43,819 --> 00:21:49,079
The invariant is stronger than the heap invariant.
不变性比堆不变性强。 

381
00:21:49,079 --> 00:21:52,569
And actually, that makes them a different data structure, not
实际上，这使它们成为不同的数据结构，而不是

382
00:21:52,569 --> 00:21:54,519
necessarily a better data structure.
必然是更好的数据结构。 

383
00:21:54,519 --> 00:21:57,956
And I'll say why, but different.
我会说为什么，但是有所不同。 

384
00:21:57,957 --> 00:21:59,089
For this problem they're better.
对于这个问题，他们会更好。 

385
00:21:59,289 --> 00:22:02,129



386
00:22:02,130 --> 00:22:04,419
So one example of a binary search tree looks like this.
因此，二叉搜索树的一个示例如下所示。 

387
00:22:04,619 --> 00:22:14,000



388
00:22:14,000 --> 00:22:19,599
And as a binary tree you have a node, and we call it x.
作为二叉树，您有一个节点，我们称其为x。 

389
00:22:19,599 --> 00:22:22,879
Each of the nodes has a key of x.
每个节点的密钥为x。 

390
00:22:22,880 --> 00:22:27,089
So 30 is the key for this node, 17 for that one, et cetera.
因此，该节点的密钥为30，而那个节点的密钥为17等。 

391
00:22:27,289 --> 00:22:29,575
Unlike in a heap, your data structure
与堆不同，您的数据结构

392
00:22:29,575 --> 00:22:31,690
is a little more complicated.
有点复杂。 

393
00:22:31,690 --> 00:22:33,669
The heap is simply an array, and you
堆只是一个数组，而你

394
00:22:33,869 --> 00:22:36,523
happen to visualize it as a tree.
碰巧把它想象成一棵树。 

395
00:22:36,523 --> 00:22:37,939
The binary search tree is actually
二进制搜索树实际上是

396
00:22:37,940 --> 00:22:44,039
a tree that has pointers, unlike a heap.
与堆不同的具有指针的树。 

397
00:22:44,039 --> 00:22:46,809
So it's a more complicated data structure.
因此，这是一个更复杂的数据结构。 

398
00:22:46,809 --> 00:22:50,240
You need a few more bytes for every node of the binary search
二进制搜索的每个节点还需要几个字节

399
00:22:50,240 --> 00:22:52,170
tree, as opposed to the heap, which
树，而不是堆， 

400
00:22:52,170 --> 00:22:55,440
is simply an array element.
只是一个数组元素。 

401
00:22:55,440 --> 00:22:59,670
And the pointers are parent of x.
指针是x的父级。 

402
00:22:59,670 --> 00:23:03,659
I haven't bothered showing the arrows here,
我没有打扰在这里显示箭头， 

403
00:23:03,859 --> 00:23:07,149
because you could be going upwards or backwards.
因为您可能会向上或向后移动。 

404
00:23:07,150 --> 00:23:08,879
And you could imagine that you actually
你可以想象你实际上

405
00:23:09,079 --> 00:23:11,929
have a parent pointer that goes up this way,
有一个向上移动的父指针， 

406
00:23:11,930 --> 00:23:14,399
and you have a child pointer that goes this way.
并且您有一个这样的子指针。 

407
00:23:14,599 --> 00:23:17,789
So there's really, potentially, three pointers
因此，实际上可能存在三个指针

408
00:23:17,789 --> 00:23:22,220
for each node, the parent, the left child,
对于每个节点，父节点，左子节点， 

409
00:23:22,220 --> 00:23:24,019
and the right child.
和合适的孩子

410
00:23:24,019 --> 00:23:26,579
So pretty straightforward.
非常简单。 

411
00:23:26,579 --> 00:23:28,639
That's the data structure in terms
这就是数据结构

412
00:23:28,640 --> 00:23:33,420
of what it needs to have so you can operate on it.
它需要什么，以便您可以对其进行操作。 

413
00:23:33,420 --> 00:23:41,440
And there's an invariant for a BST.
 BST有一个不变性。 

414
00:23:41,440 --> 00:23:48,420
What makes a BST is that you have
产生BST的原因是您拥有

415
00:23:48,420 --> 00:23:53,700
an ordering of the key values that
键值的顺序

416
00:23:53,700 --> 00:24:05,419
satisfy the invariant that for all nodes x if y is
满足对于所有节点x的不变量，如果y为

417
00:24:05,619 --> 00:24:18,779
in the left subtree of x, we have--
在x的左子树中，我们有- 

418
00:24:18,779 --> 00:24:23,129
if it's in the left subtree then key of y
如果它在左子树中，则y的键

419
00:24:23,130 --> 00:24:27,950
is less than or equal to key of x.
小于或等于x的键。 

420
00:24:27,950 --> 00:24:35,669
And if y is in the right subtree we
如果y在正确的子树中，我们

421
00:24:35,869 --> 00:24:42,069
have key of y is greater than or equal to key of x.
 y的键大于或等于x的键。 

422
00:24:42,069 --> 00:24:44,539
So if we're talking about trees here,
所以，如果我们在这里谈论树木， 

423
00:24:44,539 --> 00:24:47,109
subtrees here, everything underneath--
这里的子树，下面的一切- 

424
00:24:47,109 --> 00:24:51,169
and that's the stronger part of the invariant in the BST,
这是BST中不变式的更重要部分， 

425
00:24:51,170 --> 00:24:54,700
versus in the heap we were just talking about the children.
而不是堆里，我们只是在谈论孩子们。 

426
00:24:54,700 --> 00:24:57,889
And so you look at this BST, it is a BST
所以你看这个BST，它是一个BST 

427
00:24:58,089 --> 00:25:01,429
because if I look to the right, from the root
因为如果我从根部向右看

428
00:25:01,430 --> 00:25:04,470
I only see values that are greater than 30.
我只看到大于30的值。 

429
00:25:04,470 --> 00:25:08,150
And if I look to the left, in the entire subtree,
如果我向左看，在整个子树中， 

430
00:25:08,150 --> 00:25:13,890
all the way down I only see values that are less than 30.
一路下跌，我只会看到小于30的值。 

431
00:25:13,890 --> 00:25:19,909
And that has to be true for any intermediate node in the tree.
这对于树中的任何中间节点都必须成立。 

432
00:25:20,109 --> 00:25:23,939
And the only other nontrivial node here is 17.
而这里唯一的其他重要节点是17。 

433
00:25:23,940 --> 00:25:28,629
And you see that 14 is less than 17, and 20 is greater than 17.
您会看到14小于17，而20大于17。 

434
00:25:28,829 --> 00:25:30,000
OK?
好？ 

435
00:25:30,000 --> 00:25:32,317
So that's the BST.
这就是BST。 

436
00:25:32,317 --> 00:25:33,400
That's the data structure.
那就是数据结构。 

437
00:25:33,400 --> 00:25:34,910
This is the invariant.
这是不变的。 

438
00:25:34,910 --> 00:25:40,890
So let's look at why BSTs are a possibility for solving
因此，让我们看一下为什么BST可以解决

439
00:25:40,890 --> 00:25:44,669
our runway reservation problem.
我们的跑道保留问题。 

440
00:25:44,869 --> 00:25:50,189
And what I'll do is I'll do the insert.
我要做的就是插入。 

441
00:25:50,190 --> 00:25:54,789



442
00:25:54,789 --> 00:25:58,970
So let's start with the nil set of elements,
因此，让我们从零个元素开始， 

443
00:25:58,970 --> 00:26:04,059
or null set of elements, R. And let's start inserting.
或空元素集R。让我们开始插入。 

444
00:26:04,059 --> 00:26:08,369



445
00:26:08,369 --> 00:26:13,569
So I insert 49.
所以我插入49。 

446
00:26:13,569 --> 00:26:19,839
And all I do is make a node that has a key value of 49.
我要做的就是制作一个键值为49的节点。 

447
00:26:19,839 --> 00:26:22,109
This one is easy.
这很容易。 

448
00:26:22,109 --> 00:26:23,594
Next insert, 79.
接下来插入79。 

449
00:26:23,595 --> 00:26:27,089



450
00:26:27,089 --> 00:26:32,599
And what happens here is I have to look at 49,
我要看的是49， 

451
00:26:32,599 --> 00:26:34,164
and I compare 79 to 49.
我将79与49进行比较。 

452
00:26:34,164 --> 00:26:37,779
And because 79 is greater than 49 I go to the right
因为79比49大，所以我向右移动

453
00:26:37,779 --> 00:26:45,180
and I attach 79 to the right child of 49.
然后我将79附加到49的右子上。 

454
00:26:45,180 --> 00:26:46,674
Then I want to insert 46.
然后我要插入46。 

455
00:26:46,674 --> 00:26:49,500



456
00:26:49,500 --> 00:26:52,190
And when I want to insert 46 I look at this,
当我想插入46时，我会看这个

457
00:26:52,190 --> 00:26:53,869
I compare 49 and 46.
我比较49和46。 

458
00:26:54,069 --> 00:26:59,389
46 is less, so I go to the left side and I put 46 in there.
 46较小，所以我转到左侧，然后在其中放46。 

459
00:26:59,390 --> 00:27:04,359
Next, let's say I want to insert 41.
接下来，假设我要插入41。 

460
00:27:04,559 --> 00:27:09,480
So far I haven't really talked about the k minute checks.
到目前为止，我还没有真正谈论过k分钟检查。 

461
00:27:09,480 --> 00:27:11,700
And you could imagine that they're being done.
您可以想象他们正在完成。 

462
00:27:11,700 --> 00:27:13,879
I'll show you exactly, or talk about exactly how they're
我会确切地告诉你，或者确切地讲它们的状态

463
00:27:14,079 --> 00:27:15,539
done in a second.
在一秒钟内完成。 

464
00:27:15,539 --> 00:27:17,409
It's not that hard.
没那么难。 

465
00:27:17,410 --> 00:27:21,160
But let me go ahead and do one more.
但是，让我继续做一遍。 

466
00:27:21,160 --> 00:27:25,940
For 41, 41 is less than 49, so I go left.
对于41，41小于49，所以我走了。 

467
00:27:25,940 --> 00:27:30,210
41 is less than 46, so I go left and attach it
 41小于46，所以我左转到并附加它

468
00:27:30,210 --> 00:27:31,154
to the left child.
给左孩子

469
00:27:31,154 --> 00:27:31,789
All right?
好吧？ 

470
00:27:31,789 --> 00:27:33,649
So that's what I have right now.
这就是我现在所拥有的。 

471
00:27:33,650 --> 00:27:36,509
Now let's talk about the k minute check.
现在让我们谈谈k分钟检查。 

472
00:27:36,509 --> 00:27:39,099
It's good to talk about the K minute check
谈论K分钟检查很好

473
00:27:39,099 --> 00:27:41,750
when there's actually a violation.
当实际上有违规行为时。 

474
00:27:41,750 --> 00:27:45,220
And let's assume the k equals 3 here.
并假设k等于3。 

475
00:27:45,220 --> 00:27:46,909
And so, same thing here.
因此，这里也是一样。 

476
00:27:47,109 --> 00:27:49,779
You're essentially doing binary search here.
您实际上是在这里进行二进制搜索。 

477
00:27:49,779 --> 00:27:52,501
And you're doing the checks as you're doing the binary search.
就像执行二进制搜索一样，您也在进行检查。 

478
00:27:52,501 --> 00:27:53,960
So what you're going to be doing is
所以你要做的是

479
00:27:53,960 --> 00:27:58,579
you're going to check that-- you're going to compare 42
您将要检查-比较42 

480
00:27:58,579 --> 00:28:01,929
with 49, with the k minute check.
与49，与K分钟检查。 

481
00:28:01,930 --> 00:28:03,779
And you realize they're 7 apart.
您会发现它们相距7。 

482
00:28:03,779 --> 00:28:04,960
So that's OK.
这样就可以了

483
00:28:04,960 --> 00:28:09,009
And 42 is less than 49, so you go left.
 42小于49，所以您向左走。 

484
00:28:09,009 --> 00:28:12,369
And then you compare 42 with 46.
然后将42与46进行比较。 

485
00:28:12,369 --> 00:28:16,769
And again, it's less than 46, but it's k away, more than 3
再说一次，它小于46，但是距离k，大于3 

486
00:28:16,769 --> 00:28:18,029
away from 46.
远离46。 

487
00:28:18,029 --> 00:28:18,950
So that's cool.
太酷了。 

488
00:28:18,950 --> 00:28:20,379
And you go left.
然后你走了。 

489
00:28:20,579 --> 00:28:22,349
And then you get to 41.
然后达到41。 

490
00:28:22,349 --> 00:28:25,179
And you compare 42 with 41.
然后将42与41进行比较。 

491
00:28:25,180 --> 00:28:26,409
In this case is greater.
在这种情况下更大。 

492
00:28:26,609 --> 00:28:30,579
But it's not k more than it.
但这不比k多。 

493
00:28:30,579 --> 00:28:34,509
And so that means that if you didn't have the check,
因此，这意味着如果您没有支票， 

494
00:28:34,509 --> 00:28:37,930
you would be putting 42 in here.
您将在此处放入42。 

495
00:28:37,930 --> 00:28:40,750
But because you have the check, you fail.
但是因为有支票，所以失败了。 

496
00:28:40,750 --> 00:28:43,579
And you say, look, I mean this violates
你说，看，我的意思是这违反了

497
00:28:43,579 --> 00:28:46,484
the safety property, violates the check I need to do.
安全性，违反了我需要做的检查。 

498
00:28:46,484 --> 00:28:48,109
And therefore I'm not going to insert--
因此，我不会插入- 

499
00:28:48,109 --> 00:28:50,750
I'm not going to reserve a request for you.
我不会为您保留请求。 

500
00:28:50,750 --> 00:28:51,519
All right?
好吧？ 

501
00:28:51,519 --> 00:28:55,339
So what's happened here is it's basically a sorted array,
所以这里发生的基本上是一个排序数组

502
00:28:55,339 --> 00:28:57,849
except that you added a bunch of pointers
除了您添加了一堆指针

503
00:28:57,849 --> 00:28:59,299
associated with the tree.
与树关联。 

504
00:28:59,299 --> 00:29:03,519
And so it's somewhere between a sorted list and a sorted array.
因此，它位于排序列表和排序数组之间。 

505
00:29:03,519 --> 00:29:05,500
And it does exactly the right thing
它确实做对了

506
00:29:05,500 --> 00:29:09,309
with respect to being able to insert.
关于能够插入。 

507
00:29:09,309 --> 00:29:11,359
Once you've found the place to insert,
找到插入位置后， 

508
00:29:11,359 --> 00:29:14,369
it's merely attaching this particular new node
它只是附加这个特定的新节点

509
00:29:14,369 --> 00:29:17,149
with it's appropriate key to the pointer.
它是指向指针的适当键。 

510
00:29:17,150 --> 00:29:19,200
All right?
好吧？ 

511
00:29:19,200 --> 00:29:28,390
So what's happened here is that if h
所以这里发生的是

512
00:29:28,390 --> 00:29:37,970
is the height of the tree then insertion
是树的高度然后插入

513
00:29:37,970 --> 00:29:44,509
with or without the check is done in order h time.
有无检查均按h时间进行。 

514
00:29:44,509 --> 00:29:48,329



515
00:29:48,329 --> 00:29:52,043
And that's what BSTs are good for.
这就是BST的优点。 

516
00:29:52,044 --> 00:29:52,710
People buy that?
人们买那个？ 

517
00:29:52,710 --> 00:29:55,700
Any questions about how they k minute check proceeded?
关于如何进行分钟检查有任何疑问吗？ 

518
00:29:55,700 --> 00:29:56,441
Yeah, question.
是的，问题。 

519
00:29:56,441 --> 00:29:57,731
AUDIENCE: So, what's it called?
听众：那叫什么？ 

520
00:29:57,731 --> 00:29:58,460
The what check?
什么检查？ 

521
00:29:58,460 --> 00:30:00,021
PROFESSOR: The k minute check.
教授：k分钟检查。 

522
00:30:00,021 --> 00:30:04,409
Sorry, the k was 3 minutes k.
抱歉，k是3分钟k。 

523
00:30:04,410 --> 00:30:07,589
I had this thing over here, add t to the set R
我在这里有东西，将t添加到集合R 

524
00:30:07,789 --> 00:30:12,109
if no other landings are scheduled within k minutes.
如果未在k分钟内安排其他降落。 

525
00:30:12,109 --> 00:30:13,459
So k was just a number.
所以k只是一个数字。 

526
00:30:13,460 --> 00:30:17,150
I want it to be a parameter because it
我希望它是一个参数，因为它

527
00:30:17,150 --> 00:30:19,130
doesn't matter what k is.
不管k是多少。 

528
00:30:19,130 --> 00:30:22,669
As long as you know what it is when you do the binary search,
只要您知道二进制搜索的含义， 

529
00:30:22,869 --> 00:30:26,069
you can add that in to an argument to your insert,
您可以将其添加到插入的参数中， 

530
00:30:26,069 --> 00:30:27,091
and do the check.
并进行检查。 

531
00:30:27,092 --> 00:30:28,700
AUDIENCE: OK.
听众：好的。 

532
00:30:28,700 --> 00:30:32,879
PROFESSOR: So in this case, I set k to be 3 out here.
教授：因此，在这种情况下，我将k设置为3。 

533
00:30:33,079 --> 00:30:35,909
And I was doing a check to see that the invariant,
我正在检查以确保不变量， 

534
00:30:35,910 --> 00:30:40,629
any elements in the BST already, on any nodes that
 BST中任何已经存在的任何节点上的元素

535
00:30:40,829 --> 00:30:45,919
had keys that were within 3 minutes--
钥匙在3分钟内- 

536
00:30:45,920 --> 00:30:48,900
because I fixed k to be 3-- to the actual time
因为我将k固定为实际时间的3- 

537
00:30:48,900 --> 00:30:50,389
that I was trying to insert.
我试图插入的内容。 

538
00:30:50,589 --> 00:30:51,089
All right?
好吧？ 

539
00:30:51,089 --> 00:30:53,253
AUDIENCE: So there's no way [INAUDIBLE].
听众：所以不可能[听不清]。 

540
00:30:53,253 --> 00:30:54,794
PROFESSOR: I'm sorry, there's no way?
教授：对不起，没有办法吗？ 

541
00:30:54,795 --> 00:30:55,341
AUDIENCE: There's no way you could
听众：您不可能

542
00:30:55,541 --> 00:30:57,159
insert the 42 into the tree then?
然后将42插入树中？ 

543
00:30:57,160 --> 00:31:00,480
PROFESSOR: Well, if the basic insertion
教授：好吧，如果基本的插入

544
00:31:00,480 --> 00:31:03,535
method into a binary search tree doesn't have any constraints.
二进制搜索树中的方法没有任何约束。 

545
00:31:03,535 --> 00:31:05,839



546
00:31:06,039 --> 00:31:10,649
But you can certainly augment the insertion method
但是您当然可以增加插入方法

547
00:31:10,650 --> 00:31:14,720
without changing the efficiency of the insertion method.
而不改变插入方法的效率。 

548
00:31:14,720 --> 00:31:16,710
So let's say that all you wanted to do
假设您想做的所有事情

549
00:31:16,710 --> 00:31:19,779
was insert into a binary search tree,
被插入到二进制搜索树中， 

550
00:31:19,779 --> 00:31:22,710
and it had nothing to do with the runway reservation.
它与跑道保留无关。 

551
00:31:22,710 --> 00:31:25,400
Then you would just insert the way I described to you.
然后，您只需插入我向您描述的方式即可。 

552
00:31:25,400 --> 00:31:26,879
The beauty of the binary search tree
二进制搜索树的美

553
00:31:27,079 --> 00:31:31,149
is that while you're finding the place to insert,
是，当您找到插入位置时， 

554
00:31:31,150 --> 00:31:33,487
you can do these checks-- the k minute checks.
您可以进行这些检查-k分钟检查。 

555
00:31:33,487 --> 00:31:34,369
Yeah, question back there.
是的，再问那里。 

556
00:31:34,569 --> 00:31:36,729
AUDIENCE: What about 45?
听众：45岁呢？ 

557
00:31:36,729 --> 00:31:37,769
PROFESSOR: What about 45?
教授：45岁呢？ 

558
00:31:37,769 --> 00:31:43,190
So this is after-- we haven't inserted 42
所以这是在之后-我们还没有插入42 

559
00:31:43,190 --> 00:31:45,630
because it violated the check.
因为它违反了支票。 

560
00:31:45,630 --> 00:31:47,319
So when you do 45, then what happens
所以当你做45时，会发生什么

561
00:31:47,519 --> 00:31:51,099
is you see that 45 is less than 49
你看到45小于49 

562
00:31:51,099 --> 00:31:55,509
and you pass, because you're more than 3 minutes away.
然后您通过，因为您距离酒店有3分钟多的路程。 

563
00:31:55,509 --> 00:31:57,230
We'll stick with that example.
我们将坚持那个例子。 

564
00:31:57,230 --> 00:31:58,930
And then you get here and then you
然后你来到这里，然后你

565
00:31:58,930 --> 00:32:04,779
see that 45 is less than 46, and you'd fail right here.
看到45小于46，您将在这里失败。 

566
00:32:04,779 --> 00:32:07,389
You would fail right here if you were doing the check,
如果您进行检查，您将在这里失败， 

567
00:32:07,390 --> 00:32:11,220
because 45 is not 3 away from 46.
因为45与46之间不是3。 

568
00:32:11,220 --> 00:32:13,390
All right?
好吧？ 

569
00:32:13,390 --> 00:32:16,379
So that's the story.
这就是故事。 

570
00:32:16,579 --> 00:32:19,129
And so if you have h being the height of the tree,
因此，如果您将h作为树的高度， 

571
00:32:19,130 --> 00:32:21,670
as you can see you're just following a path.
如您所见，您只是在走一条路。 

572
00:32:21,670 --> 00:32:24,150
And depending on what the height is
并取决于高度

573
00:32:24,150 --> 00:32:26,450
you're going to do that many operations,
您将要做很多操作， 

574
00:32:26,450 --> 00:32:28,319
times some constant factor.
乘以某个恒定因子。 

575
00:32:28,319 --> 00:32:31,009
And so you can say that this is order h time.
因此，您可以说这是命令h时间。 

576
00:32:31,009 --> 00:32:32,089
All right?
好吧？ 

577
00:32:32,089 --> 00:32:35,209
Any other questions?
还有其他问题吗？ 

578
00:32:35,210 --> 00:32:36,351
Yeah, question back there.
是的，再问那里。 

579
00:32:36,551 --> 00:32:38,217
AUDIENCE: In a normal array [INAUDIBLE].
听众：在常规数组中[听不清]。 

580
00:32:38,218 --> 00:32:44,349



581
00:32:44,549 --> 00:32:46,409
PROFESSOR: Well, it's up to you.
教授：嗯，这取决于您。 

582
00:32:46,410 --> 00:32:50,680
In a conventional binary search tree, or the vanilla binary
在常规的二进制搜索树中，或者在原始二进制中

583
00:32:50,680 --> 00:32:52,359
search tree, typically what you're doing
搜索树，通常是您在做什么

584
00:32:52,559 --> 00:32:55,099
is you're doing either find or insert.
您正在查找还是插入。 

585
00:32:55,099 --> 00:32:57,049
And so what that means is that you would just
所以这意味着你会

586
00:32:57,049 --> 00:33:00,869
return the pointer associated with that element.
返回与该元素关联的指针。 

587
00:33:00,869 --> 00:33:04,709
So if you're looking for find 46, for example, on the tree
因此，如果您要在树上查找46 

588
00:33:04,710 --> 00:33:08,655
that I have out there, typically 46 is just the key value.
我在那里，通常46只是关键值。 

589
00:33:08,655 --> 00:33:10,529
And there may be a record associated with it.
并且可能有与之相关的记录。 

590
00:33:10,529 --> 00:33:12,278
And you would get a pointer to that record
您将获得指向该记录的指针

591
00:33:12,278 --> 00:33:14,200
because it's already in there.
因为它已经在里面了

592
00:33:14,200 --> 00:33:17,890
At that point you can say I want to override.
那时您可以说我要覆盖。 

593
00:33:17,890 --> 00:33:21,420
Or if you want, you could have duplicate values.
或者，如果需要，可以有重复的值。 

594
00:33:21,420 --> 00:33:23,890
You could have this, what's called a multiset.
您可能有这个，称为多集。 

595
00:33:23,890 --> 00:33:26,569
A multiset is a set that has duplicate elements.
多重集是具有重复元素的集合。 

596
00:33:26,769 --> 00:33:29,400
In that case, you would need a little more sophistication
在这种情况下，您将需要更多的技巧

597
00:33:29,400 --> 00:33:33,470
to differentiate between two elements that
区分两个元素

598
00:33:33,470 --> 00:33:35,669
have the same key values.
具有相同的键值。 

599
00:33:35,869 --> 00:33:38,169
So you'd have to call it 46a and 46b.
因此，您必须将其称为46a和46b。 

600
00:33:38,170 --> 00:33:41,880
And you'd have to have some way of differentiating.
而且，您必须采用某种区分方式。 

601
00:33:41,880 --> 00:33:43,420
Any other questions?
还有其他问题吗？ 

602
00:33:43,420 --> 00:33:44,258
Yeah.
是的

603
00:33:44,258 --> 00:33:45,692
AUDIENCE: Wouldn't it be a problem
听众：不是问题吗

604
00:33:45,692 --> 00:33:47,604
if the tree's not balanced?
如果树不平衡？ 

605
00:33:47,604 --> 00:33:50,769
PROFESSOR: Ah, great question.
教授：啊，很好的问题。 

606
00:33:50,769 --> 00:33:55,930
Yes, stay tuned.
是的，请继续关注。 

607
00:33:55,930 --> 00:33:57,990
So I was careful, right?
所以我很小心，对吗？ 

608
00:33:57,990 --> 00:34:00,368



609
00:34:00,368 --> 00:34:01,909
I guess I kind of alluded to the fact
我想我暗示了这个事实

610
00:34:01,910 --> 00:34:03,669
that we'd solved the runway reservation system.
我们已经解决了跑道预定系统。 

611
00:34:03,869 --> 00:34:06,539
Did I actually say that we'd solved the problem?
我是否真的说过我们已经解决了问题？ 

612
00:34:06,539 --> 00:34:08,079
Did I say we had solved the problem?
我是说我们已经解决了问题吗？ 

613
00:34:08,079 --> 00:34:10,610
OK, so I did not lie.
好，所以我没有说谎。 

614
00:34:10,610 --> 00:34:12,150
I did not lie.
我没撒谎。 

615
00:34:12,150 --> 00:34:15,730
I said that the height of the tree was h.
我说树的高度是h。 

616
00:34:15,730 --> 00:34:18,960
And I said that this was accomplished in order h time,
我说这是在h时间内完成的， 

617
00:34:18,960 --> 00:34:19,760
right?
对？ 

618
00:34:19,760 --> 00:34:23,730
Which is not quite what I want, which is really your question.
这不是我想要的，这实际上是您的问题。 

619
00:34:23,730 --> 00:34:25,300
So we'll get to that.
这样我们就可以解决。 

620
00:34:25,300 --> 00:34:27,880
So we're not quite done yet.
所以我们还没有完成。 

621
00:34:28,079 --> 00:34:30,719
But before we do that, it turns out
但是在我们这样做之前，事实证明

622
00:34:30,719 --> 00:34:34,909
that today's lecture is really part one of two.
今天的演讲确实是其中两个的一部分。 

623
00:34:34,909 --> 00:34:40,079
You'll get a really good sense of BST operations
您会非常了解BST的操作

624
00:34:40,079 --> 00:34:41,699
in today's lecture.
在今天的演讲中。 

625
00:34:41,699 --> 00:34:44,519
But there's going to be a few things that-- we can't cover
但是会有几件事-我们无法涵盖

626
00:34:44,519 --> 00:34:47,090
all of double 6 in the lecture, right?
讲座中双6的全部，对吗？ 

627
00:34:47,090 --> 00:34:50,730
We'd like to, and let you off for the entire fall,
我们很乐意，让您在整个秋天都放松身心， 

628
00:34:50,730 --> 00:34:52,940
but that's not the way it works, all right?
但这不是它的工作方式，好吗？ 

629
00:34:52,940 --> 00:34:54,360
So it's a great question.
因此，这是一个很好的问题。 

630
00:34:54,360 --> 00:34:56,759
I'll answer it towards the end.
我会在最后回答。 

631
00:34:56,958 --> 00:34:58,500
I just wanted you to say a little bit
我只是想让你说一点

632
00:34:58,500 --> 00:35:01,400
about other operations.
关于其他操作。 

633
00:35:01,400 --> 00:35:05,110
There's many operations that you can do on a binary search
二进制搜索可以执行许多操作

634
00:35:05,110 --> 00:35:10,329
tree, that can be done in order h time,
树，可以按时间顺序完成

635
00:35:10,329 --> 00:35:13,039
and some even in constant time.
甚至在恒定的时间内。 

636
00:35:13,039 --> 00:35:14,940
And I'll put these in the notes.
我将其放在便笺中。 

637
00:35:14,940 --> 00:35:16,769
Some of these are fairly straightforward.
其中一些非常简单。 

638
00:35:16,969 --> 00:35:22,750
Find min can be done in heap, in a min heap.
查找min可以在min堆中的堆中完成。 

639
00:35:22,750 --> 00:35:25,449
If you want to find the minimum value, it's constant time.
如果要查找最小值，则为恒定时间。 

640
00:35:25,449 --> 00:35:27,730
You just return the root.
您只需返回根。 

641
00:35:27,730 --> 00:35:32,039
In the case of a binary search tree, how do you find the min?
在二叉搜索树的情况下，如何找到最小值？ 

642
00:35:32,039 --> 00:35:34,134
Someone?
有人吗

643
00:35:34,134 --> 00:35:34,800
Worth a cushion.
值得坐垫。 

644
00:35:34,800 --> 00:35:35,335
Yep.
是的

645
00:35:35,335 --> 00:35:36,710
AUDIENCE: Keep going to the left?
听众：继续向左走？ 

646
00:35:36,710 --> 00:35:37,710
PROFESSOR: Keep going to the left.
教授：继续向左走。 

647
00:35:37,710 --> 00:35:38,659
And how do you find the max?
以及如何找到最大值？ 

648
00:35:38,659 --> 00:35:39,444
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

649
00:35:39,445 --> 00:35:40,702
PROFESSOR: Keep going to the right.
教授：请继续向右走。 

650
00:35:40,902 --> 00:35:42,639
All right great, thank you.
好的，谢谢。 

651
00:35:42,639 --> 00:35:44,645
And finally, what complexity is that?
最后，那是什么复杂性？ 

652
00:35:44,646 --> 00:35:46,612
I sort gave it away, but I want to hear it from you.
我已经把它送走了，但是我想听听你的声音。 

653
00:35:46,811 --> 00:35:47,996
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

654
00:35:47,996 --> 00:35:48,579
PROFESSOR: Hm?
教授：嗯？ 

655
00:35:48,579 --> 00:35:49,469
AUDIENCE: It's the height
听众：是高度

656
00:35:49,469 --> 00:35:50,969
PROFESSOR: It's the height, order h.
教授：这是高度，为h。 

657
00:35:50,969 --> 00:35:52,759
All right, it's order h complexity.
好吧，这是复杂性的顺序。 

658
00:35:52,760 --> 00:35:57,610
Go to the left until you hit a leaf,
向左走直到碰到叶子， 

659
00:35:57,610 --> 00:36:04,269
and until leaf order h complexity.
直到叶序h复杂。 

660
00:36:04,469 --> 00:36:05,916
Same thing for max.
最大值也一样

661
00:36:05,916 --> 00:36:07,500
And then you can do a bunch of things.
然后您可以做一堆事情。 

662
00:36:07,500 --> 00:36:10,030
I'll put these in the notes.
我将这些放在笔记中。 

663
00:36:10,030 --> 00:36:12,980
You can find things like next larger
你可以找到下一个更大的东西

664
00:36:13,179 --> 00:36:18,940
x, which is the next largest value beyond x.
 x，这是x之外的第二个最大值。 

665
00:36:18,940 --> 00:36:22,530
And you look at the key for x and you say, for example,
然后，您查看x的键，然后说， 

666
00:36:22,530 --> 00:36:25,840
if you put 46 in there, what's the next thing that's larger
如果您在其中放46，那么下一个更大的东西是什么

667
00:36:25,840 --> 00:36:28,019
and that?
然后？ 

668
00:36:28,219 --> 00:36:31,929
In this tree here, it's 49.
在这棵树上，它是49。 

669
00:36:31,929 --> 00:36:36,269
But that's something which was trivially done in this example.
但这是在此示例中微不足道的。 

670
00:36:36,269 --> 00:36:40,550
But in general you can do this in order h time as well.
但一般来说，您也可以按h时间执行此操作。 

671
00:36:40,550 --> 00:36:42,280
And you can see the pseudocode.
您会看到伪代码。 

672
00:36:42,280 --> 00:36:46,130
And we'll probably cover that in section tomorrow.
我们明天可能会在本节中介绍。 

673
00:36:46,130 --> 00:36:49,130
What I want to do today, for the rest of the time I have left,
我今天想做的，剩下的时间， 

674
00:36:49,130 --> 00:36:53,519
is actually talk about augmented binary search trees, which
实际上是在谈论增强型二叉搜索树， 

675
00:36:53,719 --> 00:36:58,869
are things that can do more and have more data in them
是可以做更多事并拥有更多数据的东西

676
00:36:58,869 --> 00:37:01,679
than just these pointers.
不仅仅是这些指针。 

677
00:37:01,679 --> 00:37:03,911
And that's actually something which
这实际上是

678
00:37:03,911 --> 00:37:06,409
should give you a sense of the richness of the binary search
应该让您了解二分查找的丰富性

679
00:37:06,409 --> 00:37:09,516
tree structure, this notion of augmentation.
树状结构，即增强的概念。 

680
00:37:09,516 --> 00:37:11,599
And those of you, again, who have taken double 05,
同样，你们中那些拿了双05的人， 

681
00:37:11,599 --> 00:37:13,759
you know about design amendments.
您了解设计修正案。 

682
00:37:13,760 --> 00:37:16,340
And so specifications never stay the same.
因此规格永远不会保持不变。 

683
00:37:16,539 --> 00:37:18,329
I mean, you're working for someone,
我的意思是，您正在为某人工作， 

684
00:37:18,329 --> 00:37:21,029
and they never really tell you what they want.
他们从来没有真正告诉你他们想要什么。 

685
00:37:21,030 --> 00:37:24,250
They might, but they change their mind.
他们可能会，但是他们改变主意。 

686
00:37:24,250 --> 00:37:26,699
So in this case, we're going to change our mind.
因此，在这种情况下，我们将改变主意。 

687
00:37:26,699 --> 00:37:28,969
And so we've done this to the extent
因此，我们已经做到这一点

688
00:37:28,969 --> 00:37:32,329
that we can cover all of these in order h time.
我们可以按h时间覆盖所有这些。 

689
00:37:32,329 --> 00:37:35,110
And let's say that now the problem specification
假设现在问题规范

690
00:37:35,110 --> 00:37:36,809
changed on us.
改变了我们。 

691
00:37:36,809 --> 00:37:38,570
There's an additional requirement
还有一个额外的要求

692
00:37:38,570 --> 00:37:42,250
that we're asked to solve.
我们被要求解决。 

693
00:37:42,250 --> 00:37:47,059
And so you sort of committed to BST structures.
因此，您有点致力于BST结构。 

694
00:37:47,059 --> 00:37:50,150
But now we have an additional requirement.
但是现在我们还有一个附加要求。 

695
00:37:50,150 --> 00:38:00,099
And the new requirement is that we be able to compute rank t.
并且新的要求是我们能够计算等级t。 

696
00:38:00,099 --> 00:38:08,429
And rank t is how many planes are
等级t是多少架飞机

697
00:38:08,429 --> 00:38:22,469
scheduled to land at times less than or equal to t.
计划在小于或等于t的时间降落。 

698
00:38:22,469 --> 00:38:24,039
So perfectly reasonable question.
那么完全合理的问题。 

699
00:38:24,039 --> 00:38:26,739
It wasn't part of the original spec.
它不是原始规范的一部分。 

700
00:38:26,739 --> 00:38:29,809
You now have built your BST data structure,
现在，您已经建立了BST数据结构， 

701
00:38:29,809 --> 00:38:31,480
you thought you were done.
你以为你完成了。 

702
00:38:31,480 --> 00:38:33,340
Sorry, you aren't.
抱歉，您不是。 

703
00:38:33,340 --> 00:38:35,730
You've got to do this extra stuff.
您必须要做这些额外的事情。 

704
00:38:35,730 --> 00:38:39,539
So that's the notion of augmentation,
这就是增强的概念

705
00:38:39,539 --> 00:38:42,744
which we're going to use this is an example of how we're
我们将要使用的这是我们如何

706
00:38:42,744 --> 00:38:45,000
going to augment the BST structure.
将增强BST结构。 

707
00:38:45,199 --> 00:38:46,949
And oh, by the way, I don't want you
哦，顺便说一句，我不要你

708
00:38:46,949 --> 00:38:50,139
to change the complexity from order h.
从订单h更改复杂度。 

709
00:38:50,139 --> 00:38:52,079
And we eventually will get to order log n,
我们最终将订购log n， 

710
00:38:52,079 --> 00:38:56,630
but don't go change something that was logarithmic to linear.
但不要将对数转换为线性。 

711
00:38:56,630 --> 00:38:57,380
That would be bad.
那将是不好的。 

712
00:38:57,380 --> 00:38:59,769



713
00:38:59,969 --> 00:39:01,689
So let's talk about how you do this.
因此，让我们谈谈您如何做到这一点。 

714
00:39:01,690 --> 00:39:03,315
And I don't think we need this anymore.
而且我认为我们不再需要这个了。 

715
00:39:03,315 --> 00:39:07,829



716
00:39:07,829 --> 00:39:11,000
So the first thing we need to do is add a little bit more
所以我们要做的第一件事是增加一些

717
00:39:11,000 --> 00:39:15,789
information to the node structure.
信息到节点结构。 

718
00:39:15,789 --> 00:39:20,250



719
00:39:20,250 --> 00:39:29,282
And what we're going to do is augment the BST structure.
我们要做的是增强BST结构。 

720
00:39:29,282 --> 00:39:34,130



721
00:39:34,130 --> 00:39:38,980
And we're going to add one little number associated
我们将添加一个关联的小数字

722
00:39:38,980 --> 00:39:45,670
with each node, that looks at the number of nodes below it.
与每个节点一起，查看其下方的节点数。 

723
00:39:45,670 --> 00:39:49,000
So in particular, let's say that I
尤其是说

724
00:39:49,000 --> 00:39:59,500
have 49, 46, let's just say 49, 46 for now.
有49、46，现在就说49、46。 

725
00:39:59,500 --> 00:40:06,699
And over here I have 79, 64, and 83.
在这里，我有79、64和83。 

726
00:40:06,699 --> 00:40:09,639



727
00:40:09,639 --> 00:40:11,489
I'm going to modify-- I'm going to have
我要修改-我要

728
00:40:11,489 --> 00:40:16,434
an extra number associated with each of these nodes.
与这些节点中的每个节点关联的额外数字。 

729
00:40:16,434 --> 00:40:18,059
And I'm just going to write that number
我要写那个号码

730
00:40:18,059 --> 00:40:20,829
on the outside of the node.
在节点外部。 

731
00:40:20,829 --> 00:40:23,639
And you can just imagine that now the key value has
您可以想象现在关键的价值已经

732
00:40:23,639 --> 00:40:25,879
two numbers associated with it-- the thing
与之相关的两个数字

733
00:40:25,880 --> 00:40:30,250
that I write inside the node, and what I write outside of it.
我在节点内写的内容以及在节点外写的内容。 

734
00:40:30,449 --> 00:40:35,958
So in particular, when I do insert or delete
所以特别是当我插入或删除时

735
00:40:35,958 --> 00:40:37,625
I'm going to be modifying these numbers.
我将修改这些数字。 

736
00:40:37,625 --> 00:40:40,480



737
00:40:40,480 --> 00:40:44,469
And these are size numbers.
这些是尺寸数字。 

738
00:40:44,469 --> 00:40:46,209
And what do I mean by that?
我的意思是什么？ 

739
00:40:46,210 --> 00:40:51,840
Well these numbers correspond to subtree sizes.
这些数字与子树大小相对应。 

740
00:40:51,840 --> 00:40:57,269



741
00:40:57,469 --> 00:41:01,179
So the subtree size here is 1, 1, 1.
所以这里的子树大小是1、1、1 

742
00:41:01,179 --> 00:41:04,099
So as I'm building this tree up I'm
所以当我建立这棵树时

743
00:41:04,099 --> 00:41:06,449
going to create an augmented BST structure,
要创建增强的BST结构， 

744
00:41:06,449 --> 00:41:08,399
and I've modified insert and delete
并且我已经修改了插入和删除

745
00:41:08,400 --> 00:41:10,364
so they do some extra work.
所以他们做了一些额外的工作。 

746
00:41:10,364 --> 00:41:11,780
So let's say, for argument's sake,
所以说，为了争辩， 

747
00:41:11,780 --> 00:41:18,090
that I've added this in sort of a bottom up fashion.
我以一种自下而上的方式添加了它。 

748
00:41:18,090 --> 00:41:21,190
And what I have are these particular subtree sizes.
我拥有的是这些特定的子树大小。 

749
00:41:21,389 --> 00:41:23,109
All of these should make sense.
所有这些都应该是有道理的。 

750
00:41:23,110 --> 00:41:27,039
This has just a single node, same thing here.
它只有一个节点，此处相同。 

751
00:41:27,239 --> 00:41:31,179
So this subtree sizes associated with these nodes are all 1.
因此，与这些节点关联的子树大小均为1。 

752
00:41:31,179 --> 00:41:33,739
The subtree size associated with 79
与79相关的子树大小

753
00:41:33,739 --> 00:41:39,059
is 3, because you're counting 79 and 64 and 83.
是3，因为您要计算的是79、64和83。 

754
00:41:39,059 --> 00:41:41,199
And the subtree size associated with 49
并且子树的大小与49相关

755
00:41:41,199 --> 00:41:44,929
is 5, because you're counting everything underneath it.
是5，因为您要计算其下的所有内容。 

756
00:41:44,929 --> 00:41:46,395
How did we get these numbers?
我们如何获得这些数字？ 

757
00:41:46,396 --> 00:41:47,769
Well you want to think about this
好吧，你想想一下

758
00:41:47,769 --> 00:41:50,119
as you started with an empty set,
当您从一个空集开始时， 

759
00:41:50,119 --> 00:41:51,529
and you kept inserting into it.
并且您一直插入其中。 

760
00:41:51,530 --> 00:41:54,650
And you were doing a sequence of insert and delete operations.
您正在执行一系列插入和删除操作。 

761
00:41:54,650 --> 00:41:59,090
And if I explain to you how an insert operation modifies
如果我向您解释插入操作的修改方式

762
00:41:59,090 --> 00:42:02,380
these numbers, that is pretty much all you need.
这些数字，这几乎是您所需要的。 

763
00:42:02,380 --> 00:42:05,769
And of course, analogously, for a delete operation.
当然，类似地，用于删除操作。 

764
00:42:05,969 --> 00:42:11,179
So what would happen for, let's say you wanted to insert 43?
那么，假设您要插入43会发生什么？ 

765
00:42:11,179 --> 00:42:15,159
You would insert 43 at this point.
此时您将插入43。 

766
00:42:15,159 --> 00:42:19,449
And what you'd do is you follow the insertion path
而您要做的就是遵循插入路径

767
00:42:19,449 --> 00:42:21,159
just like you did before.
就像以前一样

768
00:42:21,159 --> 00:42:23,429
But when you're following that path
但是当你沿着那条路走

769
00:42:23,429 --> 00:42:28,569
you're going to increment the nodes that you're seeing by 1.
您将使看到的节点增加1。 

770
00:42:28,570 --> 00:42:32,340
So you're going to add 43 to this.
因此，您将为此添加43。 

771
00:42:32,340 --> 00:42:40,519
And you'd add 5 plus 1, because you see 49.
您将加上5加1，因为您看到49。 

772
00:42:40,519 --> 00:42:45,139
And then you would go down and you'd see 46.
然后您会下去，看到46。 

773
00:42:45,139 --> 00:42:47,170
And so you'd add 1 to that.
因此，您将为此加1。 

774
00:42:47,170 --> 00:42:49,610
And then finally, you add 43 and you
最后，您加上43，然后

775
00:42:49,610 --> 00:42:51,440
assign-- since it's a leaf-- you'd
分配-因为它是一片叶子-您会

776
00:42:51,639 --> 00:42:54,379
assign to value corresponding to the subtree size
分配给与子树大小相对应的值

777
00:42:54,380 --> 00:42:58,369
of this new node that you put in there, to be 1.
您放入的这个新节点的值为1。 

778
00:42:58,369 --> 00:43:01,199
It guess a little, teensy bit more complicated
猜测有点复杂

779
00:43:01,199 --> 00:43:04,109
when you want to do the k minute check.
当您想进行k分钟检查时。 

780
00:43:04,110 --> 00:43:06,500
But from a complexity standpoint,
但是从复杂性的角度来看， 

781
00:43:06,699 --> 00:43:08,859
if you're not worried about constant factors,
如果您不担心恒定因素， 

782
00:43:08,860 --> 00:43:10,500
you can just say, you know what?
你可以说，你知道吗？ 

783
00:43:10,699 --> 00:43:14,319
I'm going to first run the regular insert,
我将首先运行常规插入， 

784
00:43:14,320 --> 00:43:16,480
ignoring the subtree sizes.
忽略子树大小。 

785
00:43:16,679 --> 00:43:19,500
And if it fails, I'm done.
如果失败，我就完成了。 

786
00:43:19,500 --> 00:43:22,869
Because I'm not going to modify the BST, and I'm done.
因为我不会修改BST，所以我已经完成了。 

787
00:43:22,869 --> 00:43:25,269
I'm not going to have to modify the subtree sizes.
我将不必修改子树的大小。 

788
00:43:25,269 --> 00:43:27,929
If it succeeds, then I'm going to go in,
如果成功的话，我要进去， 

789
00:43:27,929 --> 00:43:31,379
and I know now that I can increment each of these nodes,
现在我知道我可以增加每个节点， 

790
00:43:31,380 --> 00:43:33,789
because I know I'm going to be successful.
因为我知道我会成功的。 

791
00:43:33,989 --> 00:43:36,349
So that's sort of a trivial way of solving this problem,
因此，这是解决此问题的一种简单方法， 

792
00:43:36,349 --> 00:43:38,849
that from an asymptotic complexity standpoint
从渐进复杂性的角度来看

793
00:43:38,849 --> 00:43:42,299
gives you your order h augmented insert.
给您您的订单h扩大插入。 

794
00:43:42,300 --> 00:43:43,987
That make sense?
有道理？ 

795
00:43:44,186 --> 00:43:46,019
Now you could do something better than that.
现在您可以做得更好。 

796
00:43:46,019 --> 00:43:49,550
I mean, I would urge you, if you had wrote something
我的意思是，如果您写了些东西，我会敦促您

797
00:43:49,550 --> 00:43:52,130
that-- we asked you to write something like this,
那-我们要你写这样的东西， 

798
00:43:52,130 --> 00:43:55,769
to create a single procedure that essentially uses
创建一个基本上使用

799
00:43:55,769 --> 00:44:00,500
a recursion appropriately to do the right thing in one pass
一次递归以一次完成正确的事情

800
00:44:00,500 --> 00:44:01,590
through the BST.
通过BST。 

801
00:44:01,590 --> 00:44:03,230
And we'll talk about things like that
我们将谈论类似的事情

802
00:44:03,429 --> 00:44:08,210
as we go along in sections, and possibly in lectures.
我们会分节进行，甚至可能会在讲座中进行。 

803
00:44:08,210 --> 00:44:11,516
So that's the subtree insert delete.
这就是子树插入删除。 

804
00:44:11,516 --> 00:44:12,264
Everyone buy that?
每个人都买吗？ 

805
00:44:12,264 --> 00:44:13,692
Yeah, question back there.
是的，再问那里。 

806
00:44:13,693 --> 00:44:16,034
AUDIENCE: If I wanted to delete a number, like let's say 79--
听众：如果我想删除一个数字，比如说79-- 

807
00:44:16,233 --> 00:44:16,858
PROFESSOR: Yep?
教授：是吗？ 

808
00:44:16,858 --> 00:44:18,703
AUDIENCE: --would we have to take it out
观众：-我们必须把它拿出来

809
00:44:18,704 --> 00:44:21,010
and then rewrite the entire BST?
然后重写整个BST？ 

810
00:44:21,010 --> 00:44:24,030
PROFESSOR: What you'd have to do is a bubble up pointers.
教授：您需要做的是使指针冒泡。 

811
00:44:24,030 --> 00:44:30,130
So you'd have to actually have 64 connected to-- what
所以您实际上必须连接64个-什么

812
00:44:30,130 --> 00:44:33,960
will happen is 83 would actually come up,
将会发生，实际上是83 

813
00:44:33,960 --> 00:44:36,409
and you would essentially have some thing-- this
而且您本质上会有一些东西-这

814
00:44:36,409 --> 00:44:38,779
is not quite how it works-- but 83 would move up
不太正常-但83会上升

815
00:44:38,780 --> 00:44:40,210
and you'd have 64 to the left.
左边有64个

816
00:44:40,409 --> 00:44:43,309
That's what would happened for delete in this case.
这就是在这种情况下要删除的内容。 

817
00:44:43,309 --> 00:44:47,360
So you would have to move pointers in the case of delete.
因此，在删除的情况下，您将必须移动指针。 

818
00:44:47,360 --> 00:44:50,670
And we're not done with binary search tree operations
而且我们还没有完成二进制搜索树操作

819
00:44:50,670 --> 00:44:53,436
from a standpoint of teaching you about them.
从教给您有关它们的角度来看。 

820
00:44:53,436 --> 00:44:55,519
We'll talk about them not just in today's lecture,
我们不仅在今天的演讲中讨论它们， 

821
00:44:55,519 --> 00:44:58,670
but later as well.
但后来也一样。 

822
00:44:58,670 --> 00:45:00,380
So there's one thing missing here,
所以这里缺少一件事， 

823
00:45:00,380 --> 00:45:03,039
though, which is I haven't quite figured out--
不过，我还没有弄清楚- 

824
00:45:03,239 --> 00:45:05,689
I've told you how these subtree sizes work.
我已经告诉您这些子树大小如何工作。 

825
00:45:05,690 --> 00:45:08,650
But it's not completely clear, this
但这还不是很清楚

826
00:45:08,650 --> 00:45:11,340
is the last thing we have to do, is how are you
是我们要做的最后一件事，你好吗

827
00:45:11,340 --> 00:45:17,460
going to compute rank t from the subtree sizes?
要从子树大小计算等级t？ 

828
00:45:17,460 --> 00:45:21,449
So everyone understand subtree sizes?
这样每个人都了解子树的大小吗？ 

829
00:45:21,449 --> 00:45:23,779
It's just the number of nodes that are underneath you.
它只是您下面的节点数。 

830
00:45:23,780 --> 00:45:27,360
And you remember to count yourself, all right?
而且您还记得要数一数，好吗？ 

831
00:45:27,360 --> 00:45:28,599
Now what is rank t?
现在什么是等级t？ 

832
00:45:28,599 --> 00:45:30,860
Rank t is how many planes are scheduled
等级t是计划的飞机数量

833
00:45:30,860 --> 00:45:33,670
to land at times less than or equal to t.
有时小于或等于t降落。 

834
00:45:33,670 --> 00:45:37,460
So now I have a BST structure that looks like the one
所以现在我有了一个BST结构，看起来像一个

835
00:45:37,460 --> 00:45:40,929
and I just ended up with.
我刚结束。 

836
00:45:40,929 --> 00:45:42,940
So I've added this 43.
所以我添加了这个43。 

837
00:45:42,940 --> 00:45:44,500
And so let me draw that out here,
所以让我在这里画出来

838
00:45:44,500 --> 00:45:48,159
and see if we can answer this question.
看看我们是否可以回答这个问题。 

839
00:45:48,159 --> 00:45:51,369
This is a subtle question.
这是一个微妙的问题。 

840
00:45:51,369 --> 00:45:55,829
So I got 49, and that subtree size is 6.
所以我得到了49，而子树的大小是6。 

841
00:45:55,829 --> 00:45:59,170
I got 46, subtree size is 2.
我得到46，子树大小为2。 

842
00:45:59,170 --> 00:46:07,010
43, 79, 64.
 43、79、64。 

843
00:46:07,010 --> 00:46:08,130
and 83.
和83。 

844
00:46:08,329 --> 00:46:11,000



845
00:46:11,000 --> 00:46:21,639
So what I want is what lands before t?
所以我想要的是t之前的降落？ 

846
00:46:21,639 --> 00:46:24,359



847
00:46:24,360 --> 00:46:27,420
And how do I do that?
我该怎么做？ 

848
00:46:27,420 --> 00:46:30,659
Give me an algorithm that would allow
给我一个可以允许的算法

849
00:46:30,659 --> 00:46:35,699
me to compute in order h time.
我按顺序计算h时间。 

850
00:46:35,699 --> 00:46:38,129
I want to do this in order h time.
我想按小时顺序执行此操作。 

851
00:46:38,130 --> 00:46:40,039
What lands before t?
 t之前落在什么地方？ 

852
00:46:40,039 --> 00:46:42,759
Someone?
有人吗

853
00:46:42,759 --> 00:46:43,257
Yeah.
是的

854
00:46:43,257 --> 00:46:44,661
AUDIENCE: So first you would have
听众：所以首先你会

855
00:46:44,661 --> 00:46:47,285
to find where to insert it, like we did before.
像以前一样找到要插入的位置。 

856
00:46:47,286 --> 00:46:48,284
PROFESSOR: Right, right.
教授：对，对。 

857
00:46:48,284 --> 00:46:53,070
AUDIENCE: And then because we have the order of whatever it
听众：然后因为我们有顺序

858
00:46:53,070 --> 00:46:54,875
was before-- not the order, the--
以前-不是命令- 

859
00:46:54,875 --> 00:46:55,750
PROFESSOR: The sizes?
教授：大小？ 

860
00:46:55,750 --> 00:46:56,280
The sizes?
大小？ 

861
00:46:56,280 --> 00:46:56,780
Yeah.
是的

862
00:46:56,780 --> 00:46:59,445
AUDIENCE: And then we can look what's more than it
听众：然后我们可以看到的不仅仅是它

863
00:46:59,445 --> 00:47:02,485
on the right, we can subtract it and we get--
在右边，我们可以减去它，我们得到- 

864
00:47:02,485 --> 00:47:04,360
PROFESSOR: What is more than it on the right.
教授：不仅是右边。 

865
00:47:04,360 --> 00:47:04,750
Do you want to say--
你想说- 

866
00:47:04,750 --> 00:47:05,791
AUDIENCE: Because, like--
听众：因为，- 

867
00:47:05,791 --> 00:47:06,190
PROFESSOR: OK.
教授：好的。 

868
00:47:06,389 --> 00:47:07,059
AUDIENCE: --on the right--
听众：-在右边- 

869
00:47:07,059 --> 00:47:07,768
PROFESSOR: Right.
教授：对。 

870
00:47:07,768 --> 00:47:09,769
AUDIENCE: --and then we can take this minus this
听众：-然后我们可以减去这个

871
00:47:09,969 --> 00:47:11,859
and we get what's left.
我们得到了剩下的。 

872
00:47:11,860 --> 00:47:13,610
PROFESSOR: That's great, that's excellent.
教授：太好了，太好了。 

873
00:47:13,610 --> 00:47:15,547
Excellent.
优秀的。 

874
00:47:15,746 --> 00:47:18,079
So I'm going to do it a little bit differently from what
所以我要做的与做的有点不同

875
00:47:18,079 --> 00:47:19,009
you described.
你描述的。 

876
00:47:19,010 --> 00:47:20,269
I'm going to actually do it in a,
我实际上要在一个

877
00:47:20,469 --> 00:47:23,553
sort of, a more positive way, no offense intended.
一种更积极的方式，无意冒犯。 

878
00:47:23,554 --> 00:47:24,894
What we're going to do is we're going
我们要做的是

879
00:47:25,094 --> 00:47:28,169
to add up the things that we want to add up.
添加我们要添加的东西。 

880
00:47:28,170 --> 00:47:30,519
And what you have to do is walk--
而您要做的就是步行- 

881
00:47:30,519 --> 00:47:33,210
your first step was right on.
您的第一步是正确的。 

882
00:47:33,210 --> 00:47:35,260
I mean, your answer is correct.
我的意思是，您的答案是正确的。 

883
00:47:35,260 --> 00:47:38,400
I'm just going to do it a little bit differently.
我将做一些不同的事情。 

884
00:47:38,400 --> 00:47:41,980
You walk down the tree to find the desired time.
您沿着树走下来以找到所需的时间。 

885
00:47:42,179 --> 00:47:43,809
This is just your search.
这只是您的搜索。 

886
00:47:43,809 --> 00:47:46,299
We know how to do that.
我们知道该怎么做。 

887
00:47:46,300 --> 00:47:53,840
As you walk down you add in the nodes that
当您走下时，添加以下节点

888
00:47:53,840 --> 00:47:58,141
is the subtree sizes-- you're just adding in the notes here.
是子树的大小-您只需在此处添加注释。 

889
00:47:58,141 --> 00:48:00,139
So if you see-- depending on the number of nodes
因此，如果您看到-取决于节点数

890
00:48:00,139 --> 00:48:01,879
that you see as you're going deeper in,
当您深入时会看到

891
00:48:01,880 --> 00:48:03,289
you want to add in the nodes.
您要添加节点。 

892
00:48:03,489 --> 00:48:05,619
And you're going to add one to that, corresponding
然后您将添加一个对应的

893
00:48:05,619 --> 00:48:07,409
to the nodes that are smaller.
到较小的节点。 

894
00:48:07,409 --> 00:48:12,166
And we're going to add in the subtree sizes to the left,
我们将在左侧添加子树大小， 

895
00:48:12,166 --> 00:48:13,250
as opposed to subtracting.
而不是减去。 

896
00:48:13,250 --> 00:48:19,135



897
00:48:19,135 --> 00:48:20,509
That may not make a lot of sense.
那可能没有多大意义。 

898
00:48:20,510 --> 00:48:23,519
But I guarantee you it will once we do an example.
但是，我保证你一旦做一个例子就可以。 

899
00:48:23,719 --> 00:48:34,269



900
00:48:34,269 --> 00:48:36,179
So what's going on here?
那么这是怎么回事？ 

901
00:48:36,179 --> 00:48:38,429
I want to find a place to insert.
我想找到一个插入的地方。 

902
00:48:38,429 --> 00:48:40,489
I'm not actually going to do the insert.
我实际上不会去做插入。 

903
00:48:40,489 --> 00:48:42,279
Think of it is doing a lookup.
想到它正在执行查找。 

904
00:48:42,280 --> 00:48:45,670
And along the way, I need to figure out
在此过程中，我需要弄清楚

905
00:48:45,869 --> 00:48:47,509
the less than operator.
小于运算符。 

906
00:48:47,510 --> 00:48:49,110
I want to find all of the things that
我想找到所有的东西

907
00:48:49,110 --> 00:48:51,530
are less than this value I'm searching for.
小于我要搜索的值。 

908
00:48:51,530 --> 00:48:54,440
And so I have to do a bit of arithmetic.
因此，我必须做一些算术运算。 

909
00:48:54,639 --> 00:49:00,379
So let's say that I'm looking for what's
假设我在寻找什么

910
00:49:00,380 --> 00:49:03,019
less than or equal to 79.
小于或等于79。 

911
00:49:03,019 --> 00:49:07,719
So t equals 79.
所以t等于79 

912
00:49:07,719 --> 00:49:09,889
So I'm going to look at 49.
所以我来看看49。 

913
00:49:09,889 --> 00:49:13,309
I'm going to walk down, I'm going to look at 49.
我要走下去，我要看49。 

914
00:49:13,309 --> 00:49:22,670
And because I say I'm looking at 49-- and 49
因为我说我在看49和49 

915
00:49:22,670 --> 00:49:24,809
is clearly less than 79.
显然小于79。 

916
00:49:24,809 --> 00:49:27,960
So I'm going to add 1.
所以我要加1。 

917
00:49:27,960 --> 00:49:30,369
And that's this check over here.
这就是这里的检查。 

918
00:49:30,369 --> 00:49:41,829
I move on and what I need to do now is move to the right,
我继续前进，现在我需要做的是向右移动， 

919
00:49:41,829 --> 00:49:45,509
because 79 is greater than 49.
因为79大于49。 

920
00:49:45,510 --> 00:49:47,400
That's how my search would work.
这就是我的搜索工作的方式。 

921
00:49:47,400 --> 00:49:50,500
But because I've moved to the right,
但是因为我已经移到右边， 

922
00:49:50,500 --> 00:49:55,570
I'm going to add the subtree sizes that were to the left.
我将添加左侧的子树大小。 

923
00:49:55,570 --> 00:49:58,039
Because I know that all of the things to the left
因为我知道左边所有的东西

924
00:49:58,239 --> 00:50:01,639
are clearly less than 79.
明显小于79。 

925
00:50:01,639 --> 00:50:10,019
So I'm going to add 2, corresponding to a subtree 46.
因此，我将添加2，对应于子树46。 

926
00:50:10,019 --> 00:50:12,119
So I'm not actually looking there.
所以我实际上不在那儿。 

927
00:50:12,119 --> 00:50:14,420
But I'm going to add all of that stuff in.
但我要添加所有这些内容。 

928
00:50:14,420 --> 00:50:18,250
I'm going to move to the right, and now I'm going to see 79.
我将向右移动，现在将看到79。 

929
00:50:18,250 --> 00:50:26,889
At this point 79 is less than or equal to 79.
在这一点上，79小于或等于79。 

930
00:50:26,889 --> 00:50:33,289
So I'm going to see 79 and I'm going to add 1.
所以我将看到79并添加1。 

931
00:50:33,289 --> 00:50:37,300
And because I've added 79, just like I did with 49,
而且因为我添加了79，就像我添加49一样， 

932
00:50:37,300 --> 00:50:42,090
I have to add the subtree size to the left of 79.
我必须将子树大小添加到79的左侧。 

933
00:50:42,090 --> 00:50:45,960
So the final addition is I add 1 corresponding
所以最后的加法是我加1对应

934
00:50:46,159 --> 00:50:50,759
to the subtree 64.
到子树64。 

935
00:50:50,760 --> 00:50:52,190
And at this point I've discovered
至此，我发现

936
00:50:52,389 --> 00:50:56,039
where I have to insert, I've essentially found the location,
我必须在其中插入的位置基本上已经找到了位置， 

937
00:50:56,039 --> 00:50:57,900
it matches 79.
它匹配79。 

938
00:50:57,900 --> 00:51:00,980
And there was no modification required in this algorithm.
而且该算法不需要修改。 

939
00:51:01,179 --> 00:51:05,989
So if that was 78 you'd essentially do the same things.
因此，如果那是78岁，您基本上会做同样的事情。 

940
00:51:05,989 --> 00:51:10,669
But you're done because you found the value, or the place
但是您完成了，因为您找到了价值或地点

941
00:51:10,670 --> 00:51:11,769
that you want to insert.
您要插入的内容。 

942
00:51:11,769 --> 00:51:13,500
And you've done a bunch of additions.
您已经做了很多补充。 

943
00:51:13,500 --> 00:51:20,159
And you go look at add 1, add 2, add 1, add 1, and you have 5.
然后看一下添加1，添加2，添加1，添加1，然后得到5。 

944
00:51:20,159 --> 00:51:23,538



945
00:51:23,539 --> 00:51:24,880
And that's the correct answer, as you
那是正确的答案，就像你

946
00:51:25,079 --> 00:51:28,440
can see from this example.
从这个例子可以看出。 

947
00:51:28,440 --> 00:51:31,030
So what's the bad news?
那么什么是坏消息呢？ 

948
00:51:31,030 --> 00:51:33,820
The bad news was what this lady said up
坏消息是这位女士说的

949
00:51:33,820 --> 00:51:37,190
front, which was we haven't quite solved the problem.
前面，那是我们还没有完全解决问题。 

950
00:51:37,389 --> 00:51:40,589
Because sadly, I could easily set things
因为可悲的是，我可以轻松地设置东西

951
00:51:40,590 --> 00:51:49,750
up such that the height h is order n, h could be order n.
使得高度h为n阶，h可以为n阶。 

952
00:51:49,949 --> 00:51:54,409
And if, for example, I gave you a sorted list,
例如，如果我给您一个排序列表， 

953
00:51:54,409 --> 00:51:56,649
and I said insert into binary search tree
我说插入二进制搜索树

954
00:51:56,650 --> 00:52:00,210
that's originally null 43, and you put 43 in there.
那原来是零值43，然后您在其中放了43。 

955
00:52:00,409 --> 00:52:02,349
Then I say insert 46.
然后我说插入46。 

956
00:52:02,349 --> 00:52:04,089
And then I say instead of 48.
然后我说而不是48。 

957
00:52:04,090 --> 00:52:06,670
And then I say insert 49, et cetera.
然后我说插入49，等等。 

958
00:52:06,869 --> 00:52:09,199
And, you know, these could be any numbers.
而且，您知道，这些可以是任何数字。 

959
00:52:09,199 --> 00:52:12,029
Then you see that what does this look like?
然后您会看到这是什么样子？ 

960
00:52:12,030 --> 00:52:13,860
Does it look like a tree?
它看起来像一棵树吗？ 

961
00:52:14,059 --> 00:52:16,299
It looks like a list.
它看起来像一个列表。 

962
00:52:16,300 --> 00:52:18,420
That's the bad news.
那是坏消息。 

963
00:52:18,420 --> 00:52:23,000
And I'll let Eric give you good news next week.
下周，我会让埃里克给您个好消息。 

964
00:52:23,199 --> 00:52:25,929
We need to have this notion of balanced binary search trees.
我们需要具有平衡二进制搜索树的概念。 

965
00:52:25,929 --> 00:52:28,949
So everything I've said is true.
所以我说的都是真的。 

966
00:52:28,949 --> 00:52:30,129
I did not lie.
我没撒谎。 

967
00:52:30,130 --> 00:52:32,119
But the one extra thing is we need
但还有一件事是我们需要

968
00:52:32,119 --> 00:52:35,769
to make sure these trees are balanced so h is order log n.
确保这些树是平衡的，因此h是命令log n。 

969
00:52:35,769 --> 00:52:37,581
And then everything I said works.
然后我所说的一切都奏效。 

970
00:52:37,581 --> 00:52:38,079
All right?
好吧？ 

971
00:52:38,079 --> 00:52:43,079
See you next time.
下次见。 

