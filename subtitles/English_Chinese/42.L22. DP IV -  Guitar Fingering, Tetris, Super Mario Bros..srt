1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:27,121



10
00:00:27,321 --> 00:00:28,779
PROFESSOR: Today's our last lecture
教授：今天是我们的最后一次演讲

11
00:00:28,780 --> 00:00:31,070
on dynamic programming, the grand finale.
动态编程方面的盛大结局。 

12
00:00:31,269 --> 00:00:35,549
And we have a bunch of fun examples today on piano,
今天我们在钢琴上有很多有趣的例子， 

13
00:00:35,549 --> 00:00:39,439
guitar, Tetris and Super Mario Brothers.
吉他，俄罗斯方块和超级马里奥兄弟。 

14
00:00:39,439 --> 00:00:42,089
What could be better?
有什么更好的办法吗？ 

15
00:00:42,090 --> 00:00:44,629
We are, again, going to follow this five-step plan
我们将再次遵循这一五步计划

16
00:00:44,829 --> 00:00:48,259
to dynamic programming, define sub-problems, guess something
动态编程，定义子问题，猜测

17
00:00:48,259 --> 00:00:51,109
in order to solve a sub-problem, write a recurrence that
为了解决一个子问题，写一个递归

18
00:00:51,109 --> 00:00:53,920
uses that guessing to relate different sub-problems,
使用该猜测来关联不同的子问题， 

19
00:00:53,920 --> 00:00:56,219
then build your dynamic programming either
然后构建您的动态编程

20
00:00:56,219 --> 00:00:58,129
by just implementing as a recursive algorithm
通过仅实现为递归算法

21
00:00:58,130 --> 00:01:01,739
and memorizing or building it bottom up.
并自下而上地记忆或建立。 

22
00:01:01,939 --> 00:01:05,359
For the first, you need to check with the recurrence is acyclic.
首先，您需要检查循环是否非周期性。 

23
00:01:05,359 --> 00:01:08,019
For the second, you need an actual topological order.
第二，您需要一个实际的拓扑顺序。 

24
00:01:08,019 --> 00:01:10,879
These are, of course, equivalent constraints.
这些当然是等效的约束。 

25
00:01:10,879 --> 00:01:13,219
Personally, I like to write down on topological order
就个人而言，我喜欢写下拓扑顺序

26
00:01:13,219 --> 00:01:15,310
because that proves to me that it is acyclic,
因为这向我证明了它是非循环的， 

27
00:01:15,310 --> 00:01:17,400
if I think about it.
如果我考虑一下。 

28
00:01:17,400 --> 00:01:19,754
But either way is fine.
但是任何一种方式都可以。 

29
00:01:19,954 --> 00:01:21,579
Then we get that the total running time
然后我们得出总运行时间

30
00:01:21,579 --> 00:01:24,292
is number of sub-problems times time per sub-problems,
是子问题数乘以每个子问题的时间， 

31
00:01:24,292 --> 00:01:26,250
and then we need to solve our original problem.
然后我们需要解决我们原来的问题。 

32
00:01:26,250 --> 00:01:27,998
Usually it's just one of the sub-problems,
通常这只是子问题之一， 

33
00:01:27,998 --> 00:01:31,055
but sometimes we have to look at a few of them.
但有时我们必须看看其中一些。 

34
00:01:31,055 --> 00:01:32,429
So that's what we're going to do.
这就是我们要做的。 

35
00:01:32,430 --> 00:01:34,119
And we have one new concept today
今天我们有了一个新概念

36
00:01:34,319 --> 00:01:38,199
that all these examples will illustrate,
所有这些例子都将说明

37
00:01:38,200 --> 00:01:41,369
which is a kind of second kind of guessing.
这是第二种猜测。 

38
00:01:41,569 --> 00:01:44,269
We've talked about guessing in part two
我们已经在第二部分讨论过猜测

39
00:01:44,269 --> 00:01:46,619
here in which we saw the obvious thing.
在这里，我们看到了明显的东西。 

40
00:01:46,620 --> 00:01:48,400
In the recurrence, we usually take the min
在复发中，我们通常会服用

41
00:01:48,400 --> 00:01:51,629
of a bunch of options or the max of a bunch of options.
一堆选项或一堆选项的最大值。 

42
00:01:51,829 --> 00:01:54,743
And those options correspond to a guessed feature.
这些选项对应于一个猜测的功能。 

43
00:01:54,743 --> 00:01:56,659
We don't know whether the go left or go right,
我们不知道向左走还是向右走

44
00:01:56,659 --> 00:01:57,492
so we try them both.
所以我们都尝试

45
00:01:57,492 --> 00:01:59,000
That's guessing.
那是猜测。 

46
00:01:59,000 --> 00:02:02,109
But there's another way to guess.
但是还有另一种猜测的方式。 

47
00:02:02,109 --> 00:02:11,639
So two kinds of guessing.
因此有两种猜测。 

48
00:02:11,639 --> 00:02:17,589



49
00:02:17,590 --> 00:02:21,377
So you can do it in step two.
因此，您可以在第二步中进行操作。 

50
00:02:21,377 --> 00:02:23,085
Let's see what I have to say about these.
让我们看看我要说些什么。 

51
00:02:23,085 --> 00:02:26,120



52
00:02:26,319 --> 00:02:36,269
In step two and three, you are guessing usually
在第二和第三步中，您通常会猜测

53
00:02:36,270 --> 00:02:38,250
which sub-problems to use in order
按顺序使用哪些子问题

54
00:02:38,250 --> 00:02:44,139
to solve your bigger sub-problem.
解决更大的子问题。 

55
00:02:44,139 --> 00:02:50,469



56
00:02:50,469 --> 00:02:52,719
So that's what we've seen many, many times by now.
因此，这就是我们到目前为止已经看到很多次了。 

57
00:02:52,719 --> 00:02:55,939
Every DP that we've covered except for Fibonacci numbers
除斐波那契数外，我们涵盖的所有DP 

58
00:02:55,939 --> 00:02:58,020
has used this kind of guessing.
使用了这种猜测。 

59
00:02:58,020 --> 00:03:00,780
And it's sort of the most common, I guess you might say.
我想您可能会说这是最常见的。 

60
00:03:00,979 --> 00:03:03,159
But there's a higher level of guessing
但是猜测的水平更高

61
00:03:03,159 --> 00:03:05,750
that you can use, which we've sort of seen
您可以使用的，我们已经看到了

62
00:03:05,750 --> 00:03:09,199
in the knapsack dynamic programming, dynamic program,
在背包动态编程，动态程序中， 

63
00:03:09,199 --> 00:03:13,679
which is when you define your sub-problems, you can add more.
在定义子问题时，可以添加更多问题。 

64
00:03:13,680 --> 00:03:20,939



65
00:03:21,139 --> 00:03:26,349
Add more sub-problems to guess or you can think of it
添加更多子问题进行猜测，或者您可以考虑一下

66
00:03:26,349 --> 00:03:31,314
as remembering more features of the solution.
记住该解决方案的更多功能。 

67
00:03:31,314 --> 00:03:38,819



68
00:03:38,819 --> 00:03:40,299
And we just leave it at that.
而我们只剩下它了。 

69
00:03:40,300 --> 00:03:43,240



70
00:03:43,240 --> 00:03:49,400
Essentially what this does-- so remember with knapsack,
本质上是这样做的-请记住背包， 

71
00:03:49,400 --> 00:03:50,750
we had a sequence of items.
我们有一系列物品。 

72
00:03:50,949 --> 00:03:54,459
They had values and sizes.
他们具有价值和规模。 

73
00:03:54,460 --> 00:03:57,115
And we had some target knapsack, some capacity.
我们有一些目标背包，一些容量。 

74
00:03:57,115 --> 00:03:59,340
We wanted to pack those items into that knapsack.
我们想将那些物品装进那个背包。 

75
00:03:59,340 --> 00:04:02,370
And the obvious sub-problems were suffixes of the items.
并且明显的子问题是项目的后缀。 

76
00:04:02,370 --> 00:04:04,620
Because we always know suffixes, prefixes, substrings,
因为我们一直都知道后缀，前缀，子字符串， 

77
00:04:04,620 --> 00:04:06,370
those are the obvious things to try.
这些都是显而易见的尝试。 

78
00:04:06,370 --> 00:04:07,969
But suffixes wasn't quite enough.
但是后缀还不够。 

79
00:04:07,969 --> 00:04:09,629
Because if we looked at a suffix,
因为如果我们看一下后缀， 

80
00:04:09,629 --> 00:04:12,289
we didn't know of the prefix that we've
我们不知道我们拥有的前缀

81
00:04:12,289 --> 00:04:14,251
skipped over how many of those items
跳过了其中的几项

82
00:04:14,251 --> 00:04:16,459
were in-- and in particular, how much of the capacity
尤其是多少容量

83
00:04:16,459 --> 00:04:17,721
we'd used up.
我们用光了。 

84
00:04:17,721 --> 00:04:19,430
And so we needed to add more sub-problems
因此，我们需要添加更多子问题

85
00:04:19,430 --> 00:04:23,439
to remember how much capacity had we used up in the prefix.
记住前缀中已经用完了多少容量。 

86
00:04:23,439 --> 00:04:25,610
We did that by multiplying every sub-problem
我们通过乘以每个子问题来做到这一点

87
00:04:25,610 --> 00:04:32,189
by s different choices, which is how many units of the knapsack
通过不同的选择，即背包的单位数

88
00:04:32,189 --> 00:04:34,233
still remain.
仍然保持。 

89
00:04:34,233 --> 00:04:35,899
So in some sense, we're remembering more
所以从某种意义上讲，我们还记得更多

90
00:04:35,899 --> 00:04:37,459
about the prefix.
关于前缀。 

91
00:04:37,459 --> 00:04:41,109
You can also think of it as-- in the more forward direction,
您也可以将其视为-在更向前的方向上， 

92
00:04:41,110 --> 00:04:42,480
we have the suffix problem.
我们有后缀问题。 

93
00:04:42,480 --> 00:04:44,420
I'm going to solve it s different times,
我要解决不同的时间， 

94
00:04:44,420 --> 00:04:45,463
or s plus 1 different times.
或s加1个不同的时间。 

95
00:04:45,663 --> 00:04:46,579
I'm going to solve it.
我要解决它。 

96
00:04:46,579 --> 00:04:47,815
What if I had a big knapsack?
如果我有一个大背包该怎么办？ 

97
00:04:47,815 --> 00:04:49,189
What if I had a smaller knapsack?
如果我有一个较小的背包怎么办？ 

98
00:04:49,189 --> 00:04:50,779
What if I had a zero-size knapsack?
如果我的背包尺寸为零，该怎么办？ 

99
00:04:50,779 --> 00:04:53,129
All of those different versions of the problem.
所有这些问题的不同版本。 

100
00:04:53,129 --> 00:04:57,269
In some sense, you were solving more sub-problems.
从某种意义上说，您正在解决更多子问题。 

101
00:04:57,269 --> 00:04:59,329
You're, in some, sense finding more solutions
在某种意义上，您是在寻找更多解决方案

102
00:04:59,329 --> 00:05:00,286
to that sub-problem.
这个子问题。 

103
00:05:00,286 --> 00:05:01,410
You're looking at a suffix.
您正在查看一个后缀。 

104
00:05:01,410 --> 00:05:04,750
And I want to know all these different solutions that
我想知道所有这些不同的解决方案

105
00:05:04,750 --> 00:05:07,619
use different amounts of the knapsack.
使用不同数量的背包。 

106
00:05:07,619 --> 00:05:09,910
So in that sense, you're just adding more sub-problems.
因此，从这个意义上讲，您只是添加了更多子问题。 

107
00:05:09,910 --> 00:05:11,334
But from a guessing perspective, you're
但从猜测的角度来看， 

108
00:05:11,533 --> 00:05:12,980
remembering more about the past.
记得更多关于过去的事情。 

109
00:05:12,980 --> 00:05:16,220
We're going to see a bunch of examples of this type today.
今天，我们将看到大量此类示例。 

110
00:05:16,220 --> 00:05:18,579
We'll always use this type, but we'll
我们将始终使用此类型，但我们将

111
00:05:18,779 --> 00:05:23,229
see more of this where the obvious sub-problems don't work
在明显的子问题不起作用的地方看到更多

112
00:05:23,230 --> 00:05:25,939
and we need to add more.
并且我们需要添加更多。 

113
00:05:25,939 --> 00:05:33,079
So the first example is piano and guitar fingering.
所以第一个例子是钢琴和吉他指法。 

114
00:05:33,079 --> 00:05:38,029



115
00:05:38,029 --> 00:05:42,939
This is a practical problem for any musicians in the audience.
对于听众中的任何音乐家来说，这都是一个实际问题。 

116
00:05:42,939 --> 00:05:45,769
How many people here play piano, or have played piano?
这里有多少人弹钢琴，或者曾经弹钢琴？ 

117
00:05:45,769 --> 00:05:46,740
OK, about a quarter.
好，大约四分之一。 

118
00:05:46,740 --> 00:05:49,740
How many people have played guitar?
有多少人弹吉他？ 

119
00:05:49,740 --> 00:05:51,560
A few, all right.
几个，好吧。 

120
00:05:51,560 --> 00:05:52,480
I brought my guitar.
我带了吉他。 

121
00:05:52,480 --> 00:05:53,855
I've been learning this semester.
这个学期我一直在学习。 

122
00:05:53,855 --> 00:05:56,319
I'm not very good yet, but we'll fool around
我还不是很好，但我们会鬼混

123
00:05:56,319 --> 00:05:58,009
with it a little bit.
一点点。 

124
00:05:58,009 --> 00:06:03,552
So the general idea is you're given some musical piece
所以一般的想法是给你一些音乐作品

125
00:06:03,552 --> 00:06:05,810
that you want to play.
你想玩的。 

126
00:06:05,810 --> 00:06:07,870
And on a piano, there's a bunch of keys.
在钢琴上，有一堆琴键。 

127
00:06:07,870 --> 00:06:09,480
You have all these keyboards, so you
您拥有所有这些键盘，所以您

128
00:06:09,480 --> 00:06:11,045
know what a piano looks like, more or less.
或多或少知道钢琴是什么样子。 

129
00:06:11,045 --> 00:06:12,711
It's just like a keyboard, but only row.
它就像一个键盘，但只有一行。 

130
00:06:12,711 --> 00:06:13,470
It's crazy.
这很疯狂。 

131
00:06:13,470 --> 00:06:16,910



132
00:06:16,910 --> 00:06:18,930
Each key that you press makes a note,
您按的每个键都会做一个音符， 

133
00:06:18,930 --> 00:06:20,800
and every key has a different note.
每个键都有不同的音符。 

134
00:06:20,800 --> 00:06:23,699
So it's very simple from a computer scientist's
因此，从计算机科学家的

135
00:06:23,899 --> 00:06:24,479
perspective.
透视。 

136
00:06:24,480 --> 00:06:26,028
You want to play a note, you push the key.
要弹奏音符，请按该键。 

137
00:06:26,228 --> 00:06:29,629
But you could push it with any one of these fingers.
但是您可以用这些手指中的任何一根推动它。 

138
00:06:29,629 --> 00:06:30,839
Humans have 10 fingers.
人类有十根手指。 

139
00:06:30,839 --> 00:06:31,939
Most humans.
大多数人。 

140
00:06:31,939 --> 00:06:33,560
I guess a few have more.
我想还有更多。 

141
00:06:33,560 --> 00:06:37,800
But you want to know, which finger should I
但是你想知道，我应该用哪根手指

142
00:06:37,800 --> 00:06:39,139
use to play each note?
用来演奏每个音符？ 

143
00:06:39,339 --> 00:06:40,679
It may not seem like a big deal.
似乎没什么大不了的。 

144
00:06:40,680 --> 00:06:43,139
And if you're only playing one note, it's not a big deal.
而且，如果您只演奏一个音符，那没什么大不了的。 

145
00:06:43,139 --> 00:06:46,250
But if you're going to play a long sequence of notes,
但是，如果您要演奏很长的音符， 

146
00:06:46,250 --> 00:06:48,759
some transitions are easier than others.
有些过渡比其他过渡容易。 

147
00:06:48,759 --> 00:06:55,620
So let's say we're given a sequence of n notes
假设我们给了n个音符序列

148
00:06:55,620 --> 00:06:58,470
we want to play.
我们想玩。 

149
00:06:58,470 --> 00:07:07,060
And we want to find a fingering for each note.
我们希望找到每个音符的指法。 

150
00:07:07,060 --> 00:07:12,100



151
00:07:12,100 --> 00:07:15,579
So fingering, so let's say there are-- I'm
所以指法，可以说-我是

152
00:07:15,779 --> 00:07:21,539
going to label the fingers on your hand, 1 up to f.
将要标记您手上的手指，直到1。 

153
00:07:21,540 --> 00:07:24,819
For humans, f is 5 or 10, depending
对于人类来说，f是5或10，具体取决于

154
00:07:24,819 --> 00:07:27,480
on if you're doing one hand or two hand stuff.
如果您正在做一只手或两只手的东西。 

155
00:07:27,480 --> 00:07:33,040
I think to keep it simple, let's think about piano, right hand
我想保持简单，让我们考虑一下钢琴，右手

156
00:07:33,040 --> 00:07:36,319
only, and just you're playing one note at the time, OK?
只是，而您当时正在演奏一个音符，好吗？ 

157
00:07:36,319 --> 00:07:38,319
We're going to make it more complicated later.
稍后我们将使其变得更加复杂。 

158
00:07:38,319 --> 00:07:41,469
But let's just think of a note as being a single note.
但是，让我们仅将注释视为单个注释。 

159
00:07:41,470 --> 00:07:44,615



160
00:07:44,815 --> 00:07:48,709
OK, or you can think of guitar, single note, left hand
好，或者您可以想到吉他，单音符，左手

161
00:07:48,709 --> 00:07:50,589
is playing things.
在玩东西。 

162
00:07:50,589 --> 00:07:54,159
You want to assign one of these fingers to each node.
您想要将这些分支之一分配给每个节点。 

163
00:07:54,160 --> 00:08:04,870
And then you have a difficulty measure, d.
然后，您便有了一个困难度量，d。 

164
00:08:04,870 --> 00:08:06,850
And this you need to think about for awhile
这需要您考虑一会儿

165
00:08:06,850 --> 00:08:12,620
musically, or anatomically, how to define.
在音乐上或解剖学上如何定义。 

166
00:08:12,620 --> 00:08:16,379
If we have some note p and we're on finger f
如果我们有一些音符p并且在手指f上

167
00:08:16,379 --> 00:08:20,980
and we want to transition to note q using figure g,
我们想使用图g转换为音符q， 

168
00:08:20,980 --> 00:08:23,410
how hard is that?
那有多难？ 

169
00:08:23,410 --> 00:08:28,079
So this is-- the p and q are notes to play.
这就是-p和q是要演奏的音符。 

170
00:08:28,279 --> 00:08:30,729
I guess p stands for pitch.
我想p代表音高。 

171
00:08:30,730 --> 00:08:34,399
And f and g are fingers.
 f和g是手指。 

172
00:08:34,399 --> 00:08:39,340
So this is how hard is it to transition from f on p
所以这就是从f到p过渡的难度。 

173
00:08:39,340 --> 00:08:40,470
to g on q.
到q上的g。 

174
00:08:40,470 --> 00:08:43,580



175
00:08:43,580 --> 00:08:47,960
There's a huge literature on for piano.
钢琴方面有大量文献。 

176
00:08:47,960 --> 00:08:51,350
There are a lot of rules like, well,
有很多规则，例如， 

177
00:08:51,350 --> 00:08:55,219
if p is much smaller than q, unless they're stretched,
如果p比q小得多，除非它们被拉伸， 

178
00:08:55,419 --> 00:08:58,370
then that becomes hard.
然后就很难了。 

179
00:08:58,370 --> 00:09:00,519
And if you want to stretch, you probably
如果你想伸展，你可能

180
00:09:00,519 --> 00:09:04,230
need to use fingers that are far away from each other.
需要使用彼此远离的手指。 

181
00:09:04,230 --> 00:09:07,460
If your playing legato-- so you have to smoothly go from one
如果您演奏连奏-那么您必须平稳地从一个开始

182
00:09:07,460 --> 00:09:09,949
note the other-- you can't use the same finger on both keys.
请注意另一个-您不能在两个键上使用相同的手指。 

183
00:09:10,149 --> 00:09:13,949
So if f equals g and you're playing legato,
因此，如果f等于g并且您正在演奏连奏， 

184
00:09:13,950 --> 00:09:17,479
then p better be the same as q sort of thing.
那么p最好和q一样。 

185
00:09:17,679 --> 00:09:20,165



186
00:09:20,166 --> 00:09:21,089
There's a weak finger rule.
手指法则很弱。 

187
00:09:21,289 --> 00:09:25,730
You tend to avoid fingers four and five, these two.
您倾向于避免手指四和五，这两个。 

188
00:09:25,730 --> 00:09:29,120
Apparently going from-- I'm not much of a pianist-- so
显然是因为-我不是钢琴家-所以

189
00:09:29,120 --> 00:09:31,547
going from between three and four,
从三到四之间

190
00:09:31,547 --> 00:09:33,879
which I can barely hold them up, it's kind of difficult,
我几乎不能忍受它们，这有点困难， 

191
00:09:33,879 --> 00:09:34,975
is "annoying."
是“烦人的”。 

192
00:09:34,975 --> 00:09:36,879
That's what I wrote down.
那就是我写下来的。 

193
00:09:36,879 --> 00:09:40,169
So between three and four transitions you try and avoid.
因此，请在三到四个过渡之间尝试避免。 

194
00:09:40,169 --> 00:09:42,209
And so you can encode into this function.
因此，您可以将其编码为该函数。 

195
00:09:42,210 --> 00:09:43,190
It's a giant table.
这是一张巨大的桌子。 

196
00:09:43,190 --> 00:09:44,720
You can just put in whatever values
您可以输入任何值

197
00:09:44,720 --> 00:09:46,690
you want that you're most comfortable with.
您希望自己最满意。 

198
00:09:46,690 --> 00:09:48,940
And music theorists work a lot on trying
音乐理论家在尝试

199
00:09:48,940 --> 00:09:51,735
to define these function so.
这样定义这些功能。 

200
00:09:51,735 --> 00:09:53,879
So you can do that.
这样就可以做到。 

201
00:09:53,879 --> 00:09:58,735
And for guitar, maybe I should do a little example.
对于吉他，也许我应该举个例子。 

202
00:09:58,735 --> 00:10:01,769
Get this out.
拿出来

203
00:10:01,769 --> 00:10:04,605
I can't play much, so bear with me.
我不能玩太多，所以请忍受我。 

204
00:10:04,605 --> 00:10:07,984



205
00:10:07,984 --> 00:10:09,699
Bet you didn't think this would happen in 006.
赌你没想到这会在006年发生。 

206
00:10:09,899 --> 00:10:12,220
[LAUGHTER]
 [笑声] 

207
00:10:12,220 --> 00:10:15,100
So let's see.
让我们来看看。 

208
00:10:15,100 --> 00:10:17,469
So let's say you're trying to play your favorite song.
假设您要播放自己喜欢的歌曲。 

209
00:10:17,669 --> 00:10:20,483
[STRUMS "SUPER MARIO BROTHERS"  THEME]
 [STRONGS“ SUPER MARIO BROTHERS”主题] 

210
00:10:20,484 --> 00:10:22,360
[LAUGHTER]
 [笑声] 

211
00:10:22,360 --> 00:10:23,099
OK.
好。 

212
00:10:23,299 --> 00:10:26,529
So when I'm playing that, I have to think about the fingering.
因此，当我演奏时，我必须考虑指法。 

213
00:10:26,529 --> 00:10:29,059
Which finger is going to go where to play each note?
哪个手指会去弹每个音符？ 

214
00:10:29,059 --> 00:10:31,919
OK, so the first notes are actually open,
好，所以第一个音符实际上是打开的， 

215
00:10:31,919 --> 00:10:33,229
so it's really easy.
所以真的很容易

216
00:10:33,230 --> 00:10:40,730
And then I go up to holding the first fret on the fifth string.
然后我将第五根弦上的第一个品格固定住。 

217
00:10:40,730 --> 00:10:43,840
OK, and I'm using my index finger because everyone
好，我正在使用食指，因为每个人

218
00:10:43,840 --> 00:10:45,230
loves to use their index finger.
喜欢用食指。 

219
00:10:45,230 --> 00:10:48,009
And in particular because the very next note
特别是因为下一个音符

220
00:10:48,009 --> 00:10:50,720
I'm going to play-- well, actually it's down here.
我要去玩-好吧，实际上它就在这里。 

221
00:10:50,720 --> 00:10:53,639
Then the next note is going to be this one.
那么下一个音符就是这个。 

222
00:10:53,639 --> 00:10:57,860
So I'm holding on the third fret of the bottom string.
所以我握住底部弦的第三个音格。 

223
00:10:57,860 --> 00:10:59,769
And then I've got to transition over here.
然后我必须在这里过渡。 

224
00:10:59,769 --> 00:11:02,370
And actually, usually I do it with my middle finger.
实际上，通常我用中指来做。 

225
00:11:02,370 --> 00:11:05,552
I don't know quite why I find that easier, but I do.
我不知道为什么我会发现这更容易，但是我知道。 

226
00:11:05,552 --> 00:11:09,730
OK, and so I've actually played that opening a zillion
好的，所以我实际上已经玩过

227
00:11:09,730 --> 00:11:11,230
times with lots of different things.
时代有很多不同的东西。 

228
00:11:11,230 --> 00:11:13,355
This is the one I found to be the most comfortable.
这是我发现最舒适的一种。 

229
00:11:13,355 --> 00:11:14,604
And there's this issue, right?
还有这个问题，对不对？ 

230
00:11:14,604 --> 00:11:16,949
If your pinky is here, where can I reach with this finger?
如果您的小指在这里，我可以用这个手指到达哪里？ 

231
00:11:17,149 --> 00:11:19,689
Where can I reach with this finger?
用手指可以到达哪里？ 

232
00:11:19,690 --> 00:11:20,243
It gets difficult.
很难。 

233
00:11:20,443 --> 00:11:22,110
And in particular, it's very hard for me
特别是对我来说很难

234
00:11:22,110 --> 00:11:25,440
to reach down here when my pink is there.
当我的粉红色在那里时到达这里。 

235
00:11:25,440 --> 00:11:28,440
And so you can encode that in this d function
因此，您可以在此d函数中对其进行编码

236
00:11:28,440 --> 00:11:30,209
however you want.
随你怎么便。 

237
00:11:30,409 --> 00:11:33,038
You get the idea.
你明白了。 

238
00:11:33,038 --> 00:11:35,729
[APPLAUSE]
 [掌声] 

239
00:11:35,929 --> 00:11:37,498
Thanks.
谢谢。 

240
00:11:37,499 --> 00:11:39,339
I'll skip to our lessons. [? We're ?] [? worth ?]
我将跳过我们的课程。 [？我们是？] [？值得吗？] 

241
00:11:39,539 --> 00:11:46,349
[? it. ?] So let's solve this with dynamic programming, OK?
 [？它。 ？]那么让我们通过动态编程解决这个问题，好吗？ 

242
00:11:46,350 --> 00:11:47,219
That's the cool thing.
那是很酷的事情。 

243
00:11:47,419 --> 00:11:49,709
So we can do it.
这样我们就可以做到。 

244
00:11:49,710 --> 00:11:54,450
And we follow our five step procedure.
并且我们遵循我们的五步过程。 

245
00:11:54,450 --> 00:11:56,340
So the first thing is to define sub-problems.
因此，第一件事就是定义子问题。 

246
00:11:56,340 --> 00:11:59,329
What are the sub-problems for a set-up like this?
这样的设置有哪些子问题？ 

247
00:11:59,529 --> 00:12:04,709



248
00:12:04,710 --> 00:12:06,370
What are the three obvious candidates?
三个明显的候选人是什么？ 

249
00:12:06,370 --> 00:12:20,990



250
00:12:20,990 --> 00:12:22,399
Do you remember last lecture?
你还记得上一次讲座吗？ 

251
00:12:22,399 --> 00:12:27,366



252
00:12:27,366 --> 00:12:28,699
How many people know the answer?
有多少人知道答案？ 

253
00:12:28,700 --> 00:12:29,283
Just checking.
只是检查。 

254
00:12:29,283 --> 00:12:32,543



255
00:12:32,543 --> 00:12:34,432
One person.
一个人。 

256
00:12:34,432 --> 00:12:35,375
Go for it.
去吧。 

257
00:12:35,375 --> 00:12:37,261
AUDIENCE: Prefixes, suffixes, and substrings.
听众：前缀，后缀和子字符串。 

258
00:12:37,261 --> 00:12:37,969
PROFESSOR: Right.
教授：对。 

259
00:12:37,970 --> 00:12:39,427
Prefixes, suffixes, and substrings.
前缀，后缀和子字符串。 

260
00:12:39,427 --> 00:12:40,595
We have a sequence of notes.
我们有一系列注释。 

261
00:12:40,595 --> 00:12:42,685
We're not going to worry about the sequence of fingers.
我们不会担心手指的顺序。 

262
00:12:42,885 --> 00:12:44,529
I don't think that's too big a deal.
我认为这没什么大不了的。 

263
00:12:44,529 --> 00:12:45,799
That's what we're finding.
这就是我们所发现的。 

264
00:12:45,799 --> 00:12:48,029
What we're given is a sequence of notes,
我们得到的是一系列注释， 

265
00:12:48,029 --> 00:12:50,529
so we should try suffixes, prefixes, or substrings.
因此，我们应该尝试后缀，前缀或子字符串。 

266
00:12:50,529 --> 00:12:54,317
I'll just tell you, suffixes are fine.
我只告诉你，后缀很好。 

267
00:12:54,317 --> 00:12:55,689
Kind of.
的种类。 

268
00:12:55,690 --> 00:13:01,500
So a sub-problem will be suffixes,
因此，子问题将是后缀， 

269
00:13:01,500 --> 00:13:10,440
so how to play notes from i onwards.
那么如何从i开始演奏音符。 

270
00:13:10,440 --> 00:13:12,120
Intuitively, we want to figure out,
凭直觉，我们想弄清楚， 

271
00:13:12,120 --> 00:13:13,782
how should we play the first note?
我们应该如何演奏第一音符？ 

272
00:13:13,782 --> 00:13:15,740
And then we go on to the second note and so on.
然后，我们继续第二个音符，依此类推。 

273
00:13:15,740 --> 00:13:17,769
So we're applying them one by one
所以我们一一应用

274
00:13:17,769 --> 00:13:19,929
from left to right from the prefix side.
从前缀一侧从左到右。 

275
00:13:19,929 --> 00:13:22,039
And so we'll always be left with a suffix.
因此，我们总是会留下一个后缀。 

276
00:13:22,039 --> 00:13:24,939



277
00:13:24,940 --> 00:13:28,340
OK, then we need to guess something.
好的，那么我们需要猜测一下。 

278
00:13:28,340 --> 00:13:30,509
What's the obvious thing to guess,
有什么显而易见的猜测， 

279
00:13:30,509 --> 00:13:32,389
given I need to play notes i onward?
鉴于我需要继续弹奏笔记？ 

280
00:13:32,389 --> 00:13:36,314



281
00:13:36,315 --> 00:13:38,738
Think little harder.
多想一点。 

282
00:13:38,938 --> 00:13:40,480
This one you shouldn't have to think.
您不必思考这一点。 

283
00:13:40,480 --> 00:13:43,080
That's what I tell you.
我就是这么告诉你的

284
00:13:43,080 --> 00:13:45,195
Try suffixes, try prefixes, try substrings.
尝试后缀，尝试前缀，尝试子字符串。 

285
00:13:45,195 --> 00:13:54,920



286
00:13:55,120 --> 00:13:55,620
Yeah?
是啊

287
00:13:55,620 --> 00:13:58,049
AUDIENCE: Maybe which finger to just put around i?
听众：也许我要戴哪根手指？ 

288
00:13:58,049 --> 00:14:00,329
PROFESSOR: Yeah, which we're going to use for note i.
教授：是的，我们将在笔记i中使用它。 

289
00:14:00,330 --> 00:14:02,354
Our whole point is to assign fingering.
我们的重点是分配指法。 

290
00:14:02,554 --> 00:14:03,849
The first note here is i.
这里的第一个音符是i。 

291
00:14:03,850 --> 00:14:06,090
So let's think about i, what could you do for i?
那么，让我们考虑一下我，您能为我做什么？ 

292
00:14:06,090 --> 00:14:07,960
We'll try all the possibilities.
我们将尝试所有可能性。 

293
00:14:07,960 --> 00:14:14,459
Which finger to use for note i?
我要用哪个手指做笔记？ 

294
00:14:14,659 --> 00:14:19,459



295
00:14:19,460 --> 00:14:22,479
OK, now the really hard part-- because it's impossible--
好吧，现在真正困难的部分-因为这是不可能的- 

296
00:14:22,679 --> 00:14:23,959
is to write a recurrence.
是写一个循环。 

297
00:14:23,960 --> 00:14:28,936
This is wrong, by the way, but it's the first thing to try.
顺便说一句，这是错误的，但这是尝试的第一件事。 

298
00:14:28,936 --> 00:14:30,109
So this is what I want to ask you
所以这就是我想问你的

299
00:14:30,309 --> 00:14:31,979
to do because it's not possible.
之所以这样做，是因为不可能。 

300
00:14:31,980 --> 00:14:33,859
But intuitively, what we might try to do
但直觉上，我们可能会尝试做的

301
00:14:34,059 --> 00:14:37,929
is we're trying to solve DP for i.
是我们正在尝试为我解决DP。 

302
00:14:37,929 --> 00:14:40,109
And we want to find-- this is difficulty,
我们想发现-这很困难， 

303
00:14:40,110 --> 00:14:42,450
so you want to minimize difficulty.
所以你想尽量减少难度。 

304
00:14:42,450 --> 00:14:45,349
So we'll take a min over all of our guesses
因此，我们将花一点时间讨论所有猜测

305
00:14:45,549 --> 00:14:50,729
of what it would take to solve the rest of the notes,
解决其余笔记所需的时间， 

306
00:14:50,730 --> 00:14:53,720
to play the rest of the notes, plus somehow the cost
演奏其余的音符，再加上费用

307
00:14:53,720 --> 00:14:56,639
of playing the first note.
演奏第一个音符。 

308
00:14:56,639 --> 00:14:59,750
So what's the cost of playing the first note?
那么演奏第一音符的费用是多少？ 

309
00:14:59,750 --> 00:15:01,769
And then is going to be a for loop over fingers.
然后将成为手指之间的for循环。 

310
00:15:01,769 --> 00:15:05,649



311
00:15:05,649 --> 00:15:06,940
OK, that's going to be the min.
好，那将是最小的。 

312
00:15:06,940 --> 00:15:11,700
We want to try all possible fingers for note i.
我们想尝试所有可能的手指作为注释i。 

313
00:15:11,700 --> 00:15:13,700
Then we have to play all the remaining notes.
然后，我们必须演奏所有剩余的音符。 

314
00:15:13,700 --> 00:15:15,040
And then there's this transition cost
然后有这个过渡成本

315
00:15:15,240 --> 00:15:17,299
where you're going from note i to i plus 1.
从注释i到i加1的位置。 

316
00:15:17,299 --> 00:15:19,469
So it's going to be something like d
所以它将像d 

317
00:15:19,470 --> 00:15:23,009
of if-- we know that we use finger f to play i-- then
如果-我们知道我们用手指f演奏我- 

318
00:15:23,009 --> 00:15:25,720
we have to go to note i plus 1.
我们必须注意我加1。 

319
00:15:25,720 --> 00:15:28,514
But then the problem is we have no idea what to write here,
但是问题是我们不知道在这里写什么

320
00:15:28,514 --> 00:15:30,139
because we don't know what finger we're
因为我们不知道我们是哪根手指

321
00:15:30,139 --> 00:15:34,199
going to guess for note i plus 1.
我猜猜我加1。 

322
00:15:34,200 --> 00:15:38,334
So this cannot be known.
因此，这是未知的。 

323
00:15:38,534 --> 00:15:41,469
OK, but it's the first thing you should
好，但这是您应该做的第一件事

324
00:15:41,470 --> 00:15:43,940
try, because often this works.
尝试一下，因为这经常有效。 

325
00:15:43,940 --> 00:15:47,320
For simple DPs, that's enough for sub-problems.
对于简单的DP，这足以解决子问题。 

326
00:15:47,320 --> 00:15:49,439
But we need to know more information
但是我们需要了解更多信息

327
00:15:49,639 --> 00:15:52,149
about what we're going to do next.
关于我们接下来要做什么。 

328
00:15:52,149 --> 00:15:54,120
And this seems very worrisome, maybe
这似乎很令人担忧，也许

329
00:15:54,120 --> 00:15:55,715
now we have to guess two things.
现在我们不得不猜测两件事。 

330
00:15:55,715 --> 00:15:57,899
Do we have to guess more than two things?
我们是否必须猜测两件事以上？ 

331
00:15:57,899 --> 00:15:59,209
Turns out two things is enough.
事实证明，两件事就足够了。 

332
00:15:59,210 --> 00:16:00,959
But we cannot use this type of guessing.
但是我们不能使用这种猜测。 

333
00:16:01,159 --> 00:16:05,000
We need to use-- we need to add more sub-problems.
我们需要使用-我们需要添加更多子问题。 

334
00:16:05,000 --> 00:16:08,559
More sub-problem, more power.
更多子问题，更多功能。 

335
00:16:08,559 --> 00:16:12,849
So any guesses what we could do for sub-problem?
那么有什么猜想我们可以为子问题做什么？ 

336
00:16:12,850 --> 00:16:15,479



337
00:16:15,679 --> 00:16:17,179
A couple of right answers here.
这里有几个正确的答案。 

338
00:16:17,179 --> 00:16:23,484



339
00:16:23,485 --> 00:16:24,940
Yeah?
是啊

340
00:16:24,940 --> 00:16:28,820
AUDIENCE: Maybe like all the suffixes [INAUDIBLE]
听众：可能像所有后缀一样[听不清] 

341
00:16:28,820 --> 00:16:32,439
like the i, for all written i's, like all the possible fingers
就像我，对于所有书面我来说，就像所有可能的手指

342
00:16:32,639 --> 00:16:33,552
for i?
为我？ 

343
00:16:33,552 --> 00:16:35,009
PROFESSOR: All the possible fingers
教授：所有可能的手指

344
00:16:35,009 --> 00:16:36,051
for i in the sub-problem.
对于我在子问题。 

345
00:16:36,051 --> 00:16:37,980
Yeah, good.
耶，好样的。 

346
00:16:37,980 --> 00:16:43,580
How to play-- it's still about the suffixes.
怎么玩-仍然是关于后缀的。 

347
00:16:43,780 --> 00:16:45,029
We're still going to use that.
我们仍将使用它。 

348
00:16:45,029 --> 00:16:52,708



349
00:16:52,708 --> 00:16:54,250
But we're going to suppose we already
但是我们要假设我们已经

350
00:16:54,250 --> 00:17:02,230
know what finger to use for the first note, note i.
知道第一个音符使用哪个手指，请注意i。 

351
00:17:02,230 --> 00:17:04,700
OK, this is a little weird, because we were guessing that
好吧，这有点奇怪，因为我们猜测

352
00:17:04,700 --> 00:17:05,970
before.
之前。 

353
00:17:05,970 --> 00:17:07,588
Now we're just supposing someone tells
现在我们只是假设有人告诉

354
00:17:07,588 --> 00:17:11,759
us, use finger f for that note.
我们，用手指f表示该音符。 

355
00:17:11,759 --> 00:17:12,868
This will work.
这将起作用。 

356
00:17:12,868 --> 00:17:15,041
That's the one I had in mind.
那就是我想到的那个。 

357
00:17:15,041 --> 00:17:17,000
But the question becomes, what should we guess?
但是问题变成了，我们应该猜什么？ 

358
00:17:17,000 --> 00:17:21,328



359
00:17:21,328 --> 00:17:22,730
Anyone else?
还有谁？ 

360
00:17:22,730 --> 00:17:24,105
You clearly get [? a pillow. ?] I
你清楚得到[？一个枕头。 ？] 一世

361
00:17:24,105 --> 00:17:25,784
don't know how many you have by now.
不知道你现在有多少。 

362
00:17:25,984 --> 00:17:28,169
Have another one.
再来一个

363
00:17:28,170 --> 00:17:28,950
That's tough.
太难了

364
00:17:28,950 --> 00:17:30,559
This is not easy to figure out.
这不容易弄清楚。 

365
00:17:30,559 --> 00:17:33,376



366
00:17:33,376 --> 00:17:35,210
Now, given that that's our sub-problem, what
现在，考虑到这是我们的子问题， 

367
00:17:35,210 --> 00:17:36,470
is the next thing to guess?
接下来要猜测的是什么？ 

368
00:17:36,470 --> 00:17:46,844



369
00:17:46,844 --> 00:17:47,572
Do you have an idea?
你有想法吗？ 

370
00:17:47,772 --> 00:17:49,313
AUDIENCE: I got an idea to define it.
听众：我有一个定义的想法。 

371
00:17:49,314 --> 00:17:51,244
Like either the next or previous finger for the--
就像食指的下一个或上一个

372
00:17:51,444 --> 00:17:53,069
PROFESSOR: The next or previous finger.
教授：下一个或上一个手指。 

373
00:17:53,069 --> 00:17:54,359
Well, I'm looking at suffixes.
好吧，我在看后缀。 

374
00:17:54,359 --> 00:17:56,430
So I only care about the next one.
所以我只关心下一个。 

375
00:17:56,431 --> 00:17:56,930
Yeah.
是的

376
00:17:56,930 --> 00:17:59,303



377
00:17:59,503 --> 00:18:01,169
I see what you mean by next or previous.
我明白您的意思是下一个或上一个。 

378
00:18:01,170 --> 00:18:03,119
But what we mean is note i plus 1,
但是我们的意思是注意我加1 

379
00:18:03,319 --> 00:18:05,259
that's the next thing we don't know about.
那是我们不知道的下一件事。 

380
00:18:05,259 --> 00:18:08,539
So we're going to guess finger-- we'll
因此，我们将猜测手指- 

381
00:18:08,539 --> 00:18:12,599
call it g-- for note i plus 1.
称它为g--表示我加1。 

382
00:18:12,599 --> 00:18:17,459



383
00:18:17,460 --> 00:18:19,750
And now magically, this recurrence
现在神奇的是，这种复发

384
00:18:19,750 --> 00:18:22,029
becomes easy to write.
变得容易写。 

385
00:18:22,029 --> 00:18:23,539
So it's almost the same thing.
因此，几乎是同一回事。 

386
00:18:23,539 --> 00:18:28,089



387
00:18:28,089 --> 00:18:31,849
I wish I could just copy and paste this over, but I can't.
我希望我可以将其复制并粘贴到上面，但不能。 

388
00:18:31,849 --> 00:18:35,579
It's not a digital blackboard.
它不是数字黑板。 

389
00:18:35,579 --> 00:18:36,829
Are there digital blackboards?
有数字黑板吗？ 

390
00:18:36,829 --> 00:18:39,079
That would be cool.
那肯定很棒。 

391
00:18:39,079 --> 00:18:41,139
Someone should make that.
有人应该做到这一点。 

392
00:18:41,140 --> 00:18:43,795
I don't know why switched from open parens to square brackets,
我不知道为什么从开放括号改为方括号， 

393
00:18:43,795 --> 00:18:45,440
but I did.
但是我做到了

394
00:18:45,440 --> 00:18:51,601
Then we have-- I think it's just the obvious thing, if i plus 1
然后我们有-如果我加1，我认为这只是显而易见的事情

395
00:18:51,601 --> 00:18:51,899
g.
 G。 

396
00:18:52,099 --> 00:18:55,009
Ahh, this is a slightly wrong, though.
嗯，不过这有点不对。 

397
00:18:55,009 --> 00:18:57,049
It's a copy paste error.
这是复制粘贴错误。 

398
00:18:57,049 --> 00:19:00,419
This should really be DP of i comma
这应该是我逗号的DP 

399
00:19:00,420 --> 00:19:03,019
f, because now sub-problem consists of two things-- which
 f，因为现在子问题由两件事组成- 

400
00:19:03,019 --> 00:19:07,259
suffix am I in, and what's my finger for note I?
我在后缀中，请注意，我的手指是什么？ 

401
00:19:07,259 --> 00:19:11,289
And so when I call DP, I also have to provide two arguments.
因此，当我调用DP时，我还必须提供两个参数。 

402
00:19:11,289 --> 00:19:16,250
It's going to be DP of i plus 1 comma g.
这将是DP的i加1逗号g。 

403
00:19:16,250 --> 00:19:17,630
And then I'm looping over g.
然后我遍历g。 

404
00:19:17,630 --> 00:19:20,589
I'm trying all possibilities for g.
我正在尝试g的所有可能性。 

405
00:19:20,789 --> 00:19:24,920



406
00:19:24,920 --> 00:19:27,399
That's the recurrence.
这就是复发。 

407
00:19:27,599 --> 00:19:30,869
So if I want starting with finger f on note i,
因此，如果我想从音符i的手指f开始， 

408
00:19:30,869 --> 00:19:32,869
how do I solve the suffix from i?
我如何解决我的后缀？ 

409
00:19:32,869 --> 00:19:36,109
Well, I guess what finger am I going
好吧，我猜我要去哪根手指

410
00:19:36,109 --> 00:19:39,119
to use for the very next note.
用于下一个音符。 

411
00:19:39,119 --> 00:19:42,649
Then I have to pay this transition cost for f on i
然后我必须为我的f支付过渡费用

412
00:19:42,650 --> 00:19:44,369
to g on i plus 1.
给我加1。 

413
00:19:44,569 --> 00:19:48,745



414
00:19:48,746 --> 00:19:50,670
Yeah, OK.
是的，好的

415
00:19:50,670 --> 00:19:53,430
So slightly, I'm cheating the notation here.
稍微说一下，我在这里欺骗这个符号。 

416
00:19:53,430 --> 00:19:58,730
This probably should be the note, what is note i,
这可能应该是注释，注释i是什么， 

417
00:19:58,730 --> 00:20:01,180
and this thing should be what is note i plus 1.
这个东西应该是我加1的注解

418
00:20:01,180 --> 00:20:04,119



419
00:20:04,319 --> 00:20:07,099
If you think of this d function just being given
如果你想到这个d函数

420
00:20:07,099 --> 00:20:09,179
notes, pitches that you need to play,
音符，需要演奏的音调， 

421
00:20:09,180 --> 00:20:11,034
instead of indices into the array.
而不是索引到数组中。 

422
00:20:11,234 --> 00:20:14,789
It doesn't really matter, but that's how I defined it before.
其实并不重要，但这就是我之前定义的方式。 

423
00:20:14,789 --> 00:20:16,539
OK, so I have to pay this transition cost.
好的，因此我必须支付此过渡费用。 

424
00:20:16,539 --> 00:20:19,909
What does it take to make that transition from i to i plus 1?
从i过渡到i加1需要什么？ 

425
00:20:19,910 --> 00:20:24,480
And then what does it take to do the rest of the notes, given
然后，给出给定的其余注释需要做什么

426
00:20:24,480 --> 00:20:29,319
that now my finger is-- or now finger g is playing the note
现在我的手指是-或现在手指g正在演奏音符

427
00:20:29,319 --> 00:20:30,309
i plus 1?
我加1？ 

428
00:20:30,309 --> 00:20:32,909
So we transition from f to g, and that's now
所以我们从f过渡到g，现在

429
00:20:32,910 --> 00:20:35,109
kept track of in the sub-problem.
跟踪子问题。 

430
00:20:35,309 --> 00:20:37,639
This is the magic of defining more sub-problem.
这是定义更多子问题的魔力。 

431
00:20:37,640 --> 00:20:39,629
We needed to know where our finger used to be.
我们需要知道我们的手指曾经在哪里。 

432
00:20:39,829 --> 00:20:42,279
And now we're telling it, oh, your finger right now
现在我们正在告诉它，哦，你的手指现在

433
00:20:42,279 --> 00:20:44,119
is finger f.
是手指f。 

434
00:20:44,119 --> 00:20:46,371
Finger f is the one that's currently playing the note.
手指f是当前正在播放音符的手指。 

435
00:20:46,372 --> 00:20:48,379
And then afterwards, g is the finger that's currently
然后，g是当前的手指

436
00:20:48,579 --> 00:20:50,960
playing the note, and we can keep track of that.
播放音符，我们可以对其进行跟踪。 

437
00:20:50,960 --> 00:20:52,809
You could also define this to say, oh,
您也可以将其定义为，哦， 

438
00:20:52,809 --> 00:20:55,859
f was the finger that was used for the previous note,
 f是用于上一个音符的手指， 

439
00:20:55,859 --> 00:20:56,939
note i minus 1.
注意我减1。 

440
00:20:56,940 --> 00:21:00,799
But it's just a shifting of the indices here.
但这只是索引的变化。 

441
00:21:00,799 --> 00:21:04,730
You can do i minus 1 to i instead of i to i plus 1.
您可以对我减去1，而不对我加1。 

442
00:21:04,730 --> 00:21:06,930
But this is, I think, slightly cleaner.
但是，我认为这稍微清洁一些。 

443
00:21:06,930 --> 00:21:09,549



444
00:21:09,549 --> 00:21:11,309
OK, and then we have a DP, right?
好，然后我们有DP，对吗？ 

445
00:21:11,309 --> 00:21:13,759
We've just memoized that recurrence.
我们刚刚记下了这种复发。 

446
00:21:13,759 --> 00:21:16,324
We get a recursive DP, or you could build it bottom up.
我们获得了递归DP，或者您可以自底向上构建它。 

447
00:21:16,324 --> 00:21:17,740
If you were building it bottom up,
如果您是自底向上构建它， 

448
00:21:17,740 --> 00:21:19,680
you'd want to know a topological order.
您想知道拓扑顺序。 

449
00:21:19,680 --> 00:21:22,650



450
00:21:22,650 --> 00:21:24,919
And this requires a little bit of care
这需要一点点的照顾

451
00:21:25,119 --> 00:21:26,859
because there's two parameters.
因为有两个参数。 

452
00:21:26,859 --> 00:21:28,289
And so it's going to be a for loop
所以这将是一个for循环

453
00:21:28,289 --> 00:21:30,480
over those two parameters in some order.
以某种顺序覆盖这两个参数。 

454
00:21:30,480 --> 00:21:33,980
And I believe the right order is for i
我相信正确的顺序适合我

455
00:21:33,980 --> 00:21:37,230
has to go from right to left because this is suffixes.
必须从右向左移动，因为这是后缀。 

456
00:21:37,230 --> 00:21:46,259
So I would write reversed range n python if there are n notes.
因此，如果有n个注释，我会写反向范围n python。 

457
00:21:46,259 --> 00:21:49,259
And then within that loop, I would do a for loop over f.
然后在该循​​环中，我将对f进行for循环。 

458
00:21:49,259 --> 00:21:52,557



459
00:21:52,557 --> 00:21:54,390
If you reverse the order of these for loops,
如果您颠倒这些for循环的顺序， 

460
00:21:54,390 --> 00:21:57,450
it would not be in the right order, I'm pretty sure.
我敢肯定，它的顺序不正确。 

461
00:21:57,450 --> 00:21:58,740
But this one will work.
但这将起作用。 

462
00:21:58,740 --> 00:21:59,970
You can check it.
您可以检查一下。 

463
00:21:59,970 --> 00:22:07,130
And then to solve our original problem, here
然后解决我们原来的问题

464
00:22:07,130 --> 00:22:13,480
we require a little more work because none
我们需要做更多的工作，因为没有

465
00:22:13,480 --> 00:22:14,880
of these sub-problems are what we
这些子问题是我们

466
00:22:14,880 --> 00:22:19,698
want to solve because we don't know what the first finger is.
想要解决，因为我们不知道第一指是什么。 

467
00:22:19,898 --> 00:22:21,189
We know what the first note is.
我们知道第一个音符是什么。 

468
00:22:21,190 --> 00:22:22,369
That's note 0.
注释为0。 

469
00:22:22,569 --> 00:22:24,349
But what finger goes there?
但是什么手指去了？ 

470
00:22:24,349 --> 00:22:24,980
I don't know.
我不知道。 

471
00:22:24,980 --> 00:22:30,779
And DP of 0 requires us to give it a finger.
 DP为0要求我们给它一个手指。 

472
00:22:30,779 --> 00:22:32,649
Give it the finger, ha.
给它手指，哈。 

473
00:22:32,650 --> 00:22:36,990
Give it the finger for whatever is the first note.
用手指指任何第一音符。 

474
00:22:36,990 --> 00:22:38,250
So this is pretty easy though.
因此，这很容易。 

475
00:22:38,250 --> 00:22:40,505
We just take a min over those choices.
我们只花一分钟的时间就这些选择。 

476
00:22:40,505 --> 00:22:43,390



477
00:22:43,390 --> 00:22:44,794
Which finger should we give it?
我们应该给哪根手指？ 

478
00:22:44,994 --> 00:22:53,099



479
00:22:53,099 --> 00:22:54,199
That should do it.
那应该做。 

480
00:22:54,200 --> 00:22:56,069
So we don't know what finger to start with.
因此，我们不知道从哪个手指开始。 

481
00:22:56,069 --> 00:22:58,139
Just try them all, take the min.
只要尝试全部，花点时间。 

482
00:22:58,140 --> 00:23:00,710
This is just like the guessing that we did here,
就像我们在这里所做的猜测一样， 

483
00:23:00,710 --> 00:23:02,639
just a slightly simpler version.
只是稍微简单一点的版本。 

484
00:23:02,839 --> 00:23:05,244
There's no transition cost because there's no transition.
没有过渡成本，因为没有过渡。 

485
00:23:05,244 --> 00:23:06,881
We weren't anywhere before.
我们以前没去过。 

486
00:23:06,882 --> 00:23:08,139
Just what finger do you start with?
您从哪一根手指开始？ 

487
00:23:08,339 --> 00:23:09,923
I don't care what finger I start with.
我不在乎我用什么手指开始。 

488
00:23:09,923 --> 00:23:13,730
It's how I transition from one note to the next that's hard.
这就是我很难从一个音符过渡到另一个音符的方法。 

489
00:23:13,730 --> 00:23:17,029
OK, done.
 OK完成。 

490
00:23:17,029 --> 00:23:17,815
That's the DP.
那就是DP。 

491
00:23:17,815 --> 00:23:21,129
Now, if this is not obvious or not clear,
现在，如果这不明显或不清楚， 

492
00:23:21,329 --> 00:23:26,470
I think it's easier to think about it in the DAG form.
我认为以DAG形式考虑它更容易。 

493
00:23:26,470 --> 00:23:28,390
So let's draw all the sub problems.
因此，让我们画出所有子问题。 

494
00:23:28,390 --> 00:23:31,909
We have here a two dimensional matrix of sub-problems.
这里我们有一个子问题的二维矩阵。 

495
00:23:32,109 --> 00:23:35,259
We have the different suffixes on the one hand.
一方面，我们有不同的后缀。 

496
00:23:35,259 --> 00:23:41,230
So this is it, it stats a 9, goes to n minus 1.
就是这样，它统计为9，等于n减1。 

497
00:23:41,230 --> 00:23:42,909
And then in the other dimension, we
然后在另一个方面，我们

498
00:23:43,109 --> 00:23:49,019
have what finger to use from 1 to f.
从1到f使用什么手指。 

499
00:23:49,019 --> 00:23:51,653
And so in each of these positions, there a note.
因此，在每个位置中都有一个注释。 

500
00:23:51,653 --> 00:23:52,569
There's a sub-problem.
有一个子问题。 

501
00:23:52,569 --> 00:23:59,525



502
00:23:59,526 --> 00:24:00,025
Race.
种族。 

503
00:24:00,025 --> 00:24:04,639



504
00:24:04,839 --> 00:24:07,730
I wanted to get five rows because there are five fingers.
我想得到五行，因为有五个手指。 

505
00:24:07,730 --> 00:24:09,940
And then our transitions basically
然后我们的过渡基本上

506
00:24:09,940 --> 00:24:13,159
look-- if we're at finger one on this note,
看-如果我们在此音符上用手指指一指， 

507
00:24:13,359 --> 00:24:16,039
we can go to finger one on the next note.
我们可以在下一个音符上动动手指。 

508
00:24:16,039 --> 00:24:17,940
Or we can go, if we're not legato,
或者我们可以走了，如果我们没有连音， 

509
00:24:17,940 --> 00:24:19,910
or we can go to finger two on the next note,
或者我们可以在下一个音符上移至第二根手指， 

510
00:24:19,910 --> 00:24:22,669
or finger three or finger four or finger five.
或三指或四指或五指。 

511
00:24:22,869 --> 00:24:25,366
And then if we're starting with finger two,
然后，如果我们从第二根手指开始， 

512
00:24:25,366 --> 00:24:26,700
we could go to any one of these.
我们可以去任何一个。 

513
00:24:26,700 --> 00:24:30,269
So you get a complete bipartite graph,
这样就得到了一个完整的二部图， 

514
00:24:30,269 --> 00:24:33,670
which you usually draw like this.
你通常这样画

515
00:24:33,670 --> 00:24:38,197
That is how graph theorists draw complete bipartite graphs.
图论家就是这样绘制完整的二部图的。 

516
00:24:38,397 --> 00:24:40,750
OK, but I tried to draw a little more explicitly here.
好的，但是我试图在这里画得更明确一些。 

517
00:24:40,750 --> 00:24:42,220
It's just any possible transition.
这是任何可能的过渡。 

518
00:24:42,220 --> 00:24:43,669
And for each of these, the point is
对于每个这些，关键是

519
00:24:43,869 --> 00:24:45,816
you can compute the D cost, because you
您可以计算D成本，因为您

520
00:24:45,817 --> 00:24:47,210
know what figure you were at.
知道你在做什么。 

521
00:24:47,210 --> 00:24:49,673
You know what finger you are going to
你知道你要用什么手指

522
00:24:49,673 --> 00:24:51,089
and what note you're starting from
以及你从哪开始

523
00:24:51,089 --> 00:24:52,779
and what note you're going to.
以及您要注意的事项。 

524
00:24:52,779 --> 00:24:55,579
Those are the four arguments you need for D.
这些是D所需的四个参数。 

525
00:24:55,579 --> 00:24:57,369
So you put those weights on, and then
所以你把那些重物放在上面，然后

526
00:24:57,369 --> 00:25:00,479
you solve shortest paths on this DAG.
您可以在此DAG上解决最短路径。 

527
00:25:00,480 --> 00:25:06,349
And that is exactly what this DP is doing, OK?
这正是DP所做的，好吗？ 

528
00:25:06,349 --> 00:25:08,589
Except there's no single source here,
除非这里没有单一来源， 

529
00:25:08,589 --> 00:25:09,949
which is kind of annoying.
这有点烦人。 

530
00:25:09,950 --> 00:25:12,691
And so you need to take this min over what's
因此，您需要花几分钟时间了解

531
00:25:12,691 --> 00:25:14,690
the shortest path from here, what's the shortest
从这里最短的路径，最短的是什么

532
00:25:14,690 --> 00:25:16,553
path from here, from here, from here, from here.
从这里开始，从这里开始，从这里开始，从这里开始。 

533
00:25:16,753 --> 00:25:18,169
Of course, you don't actually need
当然，您实际上并不需要

534
00:25:18,170 --> 00:25:23,629
to do that by running single source shortest paths f times.
为此，请运行单个源最短路径f次。 

535
00:25:23,829 --> 00:25:26,659
If you're a clever shortest paths person,
如果您是聪明的最短路径人， 

536
00:25:26,660 --> 00:25:29,190
you would add an extra source note, connect
您将添加一个额外的原始注释，然后连接

537
00:25:29,190 --> 00:25:35,460
that with 0 weight to all of these sources.
所有这些来源的权重均为0。 

538
00:25:35,460 --> 00:25:37,889
So put 0s on there.
因此，将0放在那。 

539
00:25:38,089 --> 00:25:40,649
And then do single shortest paths from here.
然后从这里开始最短的路径。 

540
00:25:40,650 --> 00:25:41,839
And you will find the best way.
您将找到最好的方法。 

541
00:25:42,039 --> 00:25:43,705
You don't really care where you started,
你真的不在乎你从哪里开始

542
00:25:43,705 --> 00:25:45,659
so this is trying all the options.
所以这正在尝试所有选项。 

543
00:25:45,660 --> 00:25:47,553
That's exactly what we're doing here.
这正是我们在这里所做的。 

544
00:25:47,753 --> 00:25:49,919
But here I'm doing it with the shortest paths trick,
但是在这里我用最短的路径把戏

545
00:25:49,920 --> 00:25:56,029
here I'm doing it with guessing and taking a min like DP style.
在这里，我通过猜测并像DP风格一样花了一点时间。 

546
00:25:56,029 --> 00:26:01,559
OK, so that's how to do piano figuring and guitar
好，这就是做钢琴造型和吉他的方法

547
00:26:01,559 --> 00:26:04,659
fingering for single hand, one note at time.
一只手的指法，一次注一次。 

548
00:26:04,660 --> 00:26:05,798
Questions?
有什么问题吗

549
00:26:05,798 --> 00:26:07,339
And this even worse for aliens if you
对于外星人来说，甚至更糟

550
00:26:07,339 --> 00:26:09,569
have arbitrarily many fingers on your hand.
手上有很多手指。 

551
00:26:09,569 --> 00:26:13,129
I guess we should figure out what's the running time.
我想我们应该弄清楚几点了。 

552
00:26:13,130 --> 00:26:15,670
So we have sub-problems.
因此，我们有子问题。 

553
00:26:15,670 --> 00:26:17,920
We see how many sub-problems there are here.
我们看到这里有多少个子问题。 

554
00:26:17,920 --> 00:26:22,000
There's n times f sub-problems.
有n次f个子问题。 

555
00:26:22,000 --> 00:26:24,809
How much time, or how many choices are there
多少时间，或有多少选择

556
00:26:24,809 --> 00:26:26,159
for our guess?
为我们的猜测？ 

557
00:26:26,160 --> 00:26:31,599
Well there's f different choices for what finger we use.
那么，我们使用哪种手指有f个不同的选择。 

558
00:26:31,799 --> 00:26:35,639
And when we do this min, we spend theta F time.
而当我们做这个分钟时，我们会花费theF时间。 

559
00:26:35,640 --> 00:26:40,710



560
00:26:40,710 --> 00:26:42,220
Because there's a for loop over F,
因为在F上有一个for循环， 

561
00:26:42,220 --> 00:26:43,635
we're doing constant work assuming
我们一直在假设

562
00:26:43,635 --> 00:26:45,759
D lookups take constant time.
 D查找需要固定的时间。 

563
00:26:45,759 --> 00:26:46,799
This is theta F time.
这是θF时间。 

564
00:26:46,799 --> 00:26:49,519
So we multiply those two things together,
因此，我们将这两件事相乘， 

565
00:26:49,519 --> 00:26:53,569
and we get the total time, the number of sub-problems which
然后我们得到总时间，子问题的数量

566
00:26:53,569 --> 00:26:56,319
is n times F, and we multiply them
是F的n倍，我们将它们相乘

567
00:26:56,319 --> 00:26:58,839
by theta F for each sub-problem.
对于每个子问题，用θF表示。 

568
00:26:58,839 --> 00:27:02,509
So this is nF squared.
因此，这是nF平方。 

569
00:27:02,509 --> 00:27:09,099
And given F is usually pretty small, it's almost linear time.
鉴于F通常很小，几乎是线性时间。 

570
00:27:09,099 --> 00:27:10,529
So that's a pretty good algorithm.
因此，这是一个非常好的算法。 

571
00:27:10,529 --> 00:27:18,460



572
00:27:18,460 --> 00:27:22,201
But in reality, you tend to play multiple notes
但实际上，您倾向于演奏多个音符

573
00:27:22,201 --> 00:27:22,910
at the same time.
与此同时。 

574
00:27:22,910 --> 00:27:26,035



575
00:27:26,035 --> 00:27:29,269
In music, typically you're playing a chord.
在音乐中，通常您正在演奏和弦。 

576
00:27:29,269 --> 00:27:33,549
With piano, you're playing several notes
使用钢琴，您会演奏几个音符

577
00:27:33,549 --> 00:27:36,839
with one hand, maybe several notes with another hand.
一只手，也许另一只手有几个音符。 

578
00:27:36,839 --> 00:27:38,359
Two handed piano, it's crazy.
两只手的钢琴，这太疯狂了。 

579
00:27:38,359 --> 00:27:41,000
You could do four handed piano, make it a little more exciting.
您可以做四手钢琴，使它更加令人兴奋。 

580
00:27:41,000 --> 00:27:44,393
With the guitar, play-- I don't know very many chords,
用吉他弹奏，我不知道很多和弦， 

581
00:27:44,393 --> 00:27:47,289
but I know at least one.
但我至少知道一个

582
00:27:47,289 --> 00:27:49,000
You play, I don't know.
你玩，我不知道。 

583
00:27:49,000 --> 00:27:52,115
This looks like something.
这看起来像东西。 

584
00:27:52,115 --> 00:27:53,701
That's a G chord.
那是G弦。 

585
00:27:53,701 --> 00:27:56,700
Do I know any others?
我认识其他人吗？ 

586
00:27:56,700 --> 00:27:59,499
And that's an E chord.
那是E和弦。 

587
00:27:59,499 --> 00:28:03,585
All right, you get the idea.
好吧，您知道了。 

588
00:28:03,585 --> 00:28:04,960
I mean, for each of these chords,
我的意思是，对于每个和弦， 

589
00:28:04,960 --> 00:28:06,259
different people use different fingers,
不同的人用不同的手指， 

590
00:28:06,259 --> 00:28:07,259
even for a single cord.
即使是单根电线。 

591
00:28:07,259 --> 00:28:09,009
So it's sort of a personal taste how
所以有点个人品味

592
00:28:09,009 --> 00:28:11,490
you're going to define your difficulty measure.
您将定义难度指标。 

593
00:28:11,490 --> 00:28:15,150
But I could play an E like this, or I could-- I don't know,
但是我可以像这样演奏E，或者我可以-我不知道， 

594
00:28:15,150 --> 00:28:16,839
play it like this.
像这样玩。 

595
00:28:17,039 --> 00:28:21,180
Or I could play like this.
或者我可以这样玩。 

596
00:28:21,180 --> 00:28:23,899
And there's lots of crazy ways to put your finger here
还有很多疯狂的方法可以将手指放在这里

597
00:28:24,099 --> 00:28:26,119
and your finger here and your finger here.
和你的手指在这里，你的手指在这里。 

598
00:28:26,119 --> 00:28:28,479
And for each of them, you could define some difficulty.
而对于每个人，您都可以定义一些难度。 

599
00:28:28,480 --> 00:28:29,979
And then, of course, is a transition
然后，当然是过渡

600
00:28:29,979 --> 00:28:31,529
from one chord to another.
从一个和弦到另一个。 

601
00:28:31,529 --> 00:28:33,289
And because there's different ways to play different chords,
而且由于演奏和弦的方式不同， 

602
00:28:33,289 --> 00:28:35,289
that wasn't a very good example because they all
那不是一个很好的例子，因为它们都

603
00:28:35,289 --> 00:28:37,730
look pretty bad.
看起来很糟糕。 

604
00:28:37,730 --> 00:28:41,319
Well, this one for example, this is the G again.
好，例如，这是G。 

605
00:28:41,319 --> 00:28:45,629
I could use my-- one, two, three, four-- fourth finger
我可以用我的-，1、2、3、4-第四根手指

606
00:28:45,630 --> 00:28:48,444
here, or I could use my fifth finger.
在这里，或者我可以用无名指。 

607
00:28:48,644 --> 00:28:51,019
My instructor says we should use our pinky because people
我的老师说我们应该使用小指，因为人们

608
00:28:51,019 --> 00:28:52,185
tend not to use their pinky.
往往不使用其小指。 

609
00:28:52,185 --> 00:28:53,833
But it makes a difference what I'm
但这改变了我

610
00:28:53,834 --> 00:28:55,000
going to transition to next.
过渡到下一个。 

611
00:28:55,000 --> 00:28:56,999
Maybe my pinky really needs to go over here next
也许我的小指下一步真的需要去这里

612
00:28:56,999 --> 00:28:58,480
and I should free it up for later,
我应该释放它以便以后使用

613
00:28:58,480 --> 00:29:01,059
or maybe it's better if this one's freed because then I
也许这是更好的，因为那我

614
00:29:01,059 --> 00:29:02,619
can move it somewhere else.
可以将其移动到其他地方。 

615
00:29:02,619 --> 00:29:04,639
So that's what we'd like to capture
这就是我们想要捕捉的

616
00:29:04,640 --> 00:29:07,009
in a generalized form or this dynamic program,
以一般形式或此动态程序， 

617
00:29:07,009 --> 00:29:08,980
and we can do it.
我们可以做到。 

618
00:29:08,980 --> 00:29:12,159
So I'll try to do it quickly so we
所以我会尽快做的，所以我们

619
00:29:12,359 --> 00:29:14,319
can get on to the other examples.
可以继续看其他例子。 

620
00:29:14,319 --> 00:29:16,141
All right, other fun stuff.
好吧，其他有趣的东西。 

621
00:29:16,142 --> 00:29:17,399
Actually, there's another fun thing
其实还有一件有趣的事

622
00:29:17,599 --> 00:29:20,309
with guitar, which is that there's
用吉他，那是

623
00:29:20,309 --> 00:29:22,740
more than one way to play each note.
演奏每个音符的方法不止一种。 

624
00:29:22,740 --> 00:29:24,329
There are six strings here.
这里有六个琴弦。 

625
00:29:24,329 --> 00:29:29,529
And you could play like this note for the Super Mario
您可以像这样为超级马里奥演奏

626
00:29:29,529 --> 00:29:30,460
Brothers.
兄弟。 

627
00:29:30,460 --> 00:29:34,720
I could also play that doing the fifth thing here.
我也可以在这里做第五件事。 

628
00:29:34,720 --> 00:29:39,970
It's slightly out of tune, but those sound almost the same.
有点不合时宜，但听起来几乎一样。 

629
00:29:39,970 --> 00:29:44,649
Or I could play on the 10th fret on the third string.
或者，我可以在第三弦的第十个品格上演奏。 

630
00:29:44,849 --> 00:29:46,299
That's the same as bottom one.
这与下一个相同。 

631
00:29:46,299 --> 00:29:50,710
So a lot of options, so you also like to capture that.
有很多选择，所以您也喜欢捕获它。 

632
00:29:50,710 --> 00:29:52,259
This is actually not too hard.
这实际上并不难。 

633
00:29:52,259 --> 00:30:02,000
You just need to generalize the notion of finger
您只需要概括一下手指的概念

634
00:30:02,000 --> 00:30:07,569
to what finger you're using and what string you're using.
您正在使用的手指以及正在使用的字符串。 

635
00:30:07,569 --> 00:30:10,743
So there are f different choices for what finger you're using.
因此，您使用的手指有f个不同的选择。 

636
00:30:10,743 --> 00:30:12,409
If you use a generalized guitar, there's
如果您使用通用吉他， 

637
00:30:12,410 --> 00:30:14,144
s choices for what string you're playing.
选择要播放的字符串。 

638
00:30:14,144 --> 00:30:16,435
There's a lot of different guitars with various numbers
有很多不同数量的吉他

639
00:30:16,435 --> 00:30:18,451
of strings, so we can just generalize that.
字符串，所以我们可以将其概括化。 

640
00:30:18,451 --> 00:30:20,700
And now it's not only, which finger am I going to use,
现在不仅是我要使用哪根手指， 

641
00:30:20,700 --> 00:30:22,220
but what sting will I play it on?
但是我会继续弹什么呢？ 

642
00:30:22,220 --> 00:30:26,390
And then you can still define a difficulty measure
然后您仍然可以定义难度衡量

643
00:30:26,390 --> 00:30:29,503
like this for this set up, depending
这样的设置，取决于

644
00:30:29,703 --> 00:30:31,119
both on the finger and the string.
手指和弦上都有

645
00:30:31,119 --> 00:30:34,889
And then the running time grows slightly.
然后运行时间会稍微增加。 

646
00:30:34,890 --> 00:30:39,119
It's now n times F squared S squared,
现在是F平方S平方的n倍， 

647
00:30:39,319 --> 00:30:41,759
because now I have to take the product of F and S. OK,
因为现在我必须取F和S的乘积。 

648
00:30:41,759 --> 00:30:42,950
so that's first thing.
所以这是第一件事。 

649
00:30:42,950 --> 00:30:50,990
But then if I wanted to do multiple notes,
但是如果我想做多个笔记， 

650
00:30:50,990 --> 00:30:54,390
well, you can imagine it's a similar type of deal.
好吧，您可以想象这是一种类似的交易。 

651
00:30:54,390 --> 00:30:56,791
It's going to get harder though.
但是，它将变得越来越困难。 

652
00:30:56,991 --> 00:30:58,950
First thing we need to generalize is the input.
我们需要概括的第一件事是输入。 

653
00:30:58,950 --> 00:31:02,190
Before the input was a sequence of notes.
在输入之前是一系列注释。 

654
00:31:02,190 --> 00:31:05,779
Now it's going to be a sequence of multi-notes.
现在将是一系列多音符。 

655
00:31:05,779 --> 00:31:11,109
So notes of i is now going to be, let's say,
所以我现在要成为一个音符， 

656
00:31:11,109 --> 00:31:16,399
a list of notes that all need to be played at once.
所有音符都需要同时演奏的音符列表。 

657
00:31:16,400 --> 00:31:19,129
And conveniently, it's probably going to be, at most, F notes,
而且方便起见，最多可能是F个音符， 

658
00:31:19,329 --> 00:31:23,259
because you really can only play one note with each finger
因为每个手指只能弹一个音符

659
00:31:23,259 --> 00:31:24,109
pretty much.
差不多

660
00:31:24,109 --> 00:31:26,219
I guess you could try to play two notes at once
我想您可以尝试同时演奏两个音符

661
00:31:26,220 --> 00:31:28,477
on a piano with a finger, but eh.
用手指在钢琴上，但是

662
00:31:28,477 --> 00:31:29,109
It sounds difficult.
听起来很难。 

663
00:31:29,309 --> 00:31:33,980
For a guitar, it's at most s notes.
对于吉他来说，最多是笔记。 

664
00:31:33,980 --> 00:31:38,329
You can only play one note per string, more or less.
每个字符串最多只能播放一个音符。 

665
00:31:38,329 --> 00:31:42,659
So that's our input.
这就是我们的投入。 

666
00:31:42,660 --> 00:31:45,349
And now we need to adjust the dynamic program.
现在我们需要调整动态程序。 

667
00:31:45,549 --> 00:31:49,909



668
00:31:49,910 --> 00:31:52,240
And I think I'll tell you how to do this.
我想我会告诉你如何做到的。 

669
00:31:52,240 --> 00:32:24,410



670
00:32:24,410 --> 00:32:26,669
Basically, now you need to know where all your fingers are.
基本上，现在您需要知道所有手指的位置。 

671
00:32:26,869 --> 00:32:31,139
So you go from one pose to another pose,
所以你从一个姿势转到另一个姿势， 

672
00:32:31,140 --> 00:32:32,759
from one chord to another.
从一个和弦到另一个。 

673
00:32:32,759 --> 00:32:34,061
Different ways to finger that.
用不同的方式来说明这一点。 

674
00:32:34,061 --> 00:32:35,519
Which fingers are and which strings
哪根手指是哪根弦

675
00:32:35,519 --> 00:32:39,039
and which frets on the guitar, which fingers
吉他上有哪些烦恼，手指

676
00:32:39,039 --> 00:32:41,220
are on which keys on the keyboard.
是键盘上的哪个键。 

677
00:32:41,220 --> 00:32:43,140
But you just need to know all that.
但是您只需要知道所有这些。 

678
00:32:43,140 --> 00:32:46,339
And all your fingers might be doing something,
而且你所有的手指可能正在做某事， 

679
00:32:46,539 --> 00:32:49,079
and you've got to know for each finger what note is it on,
而且您必须知道每个手指上都有什么音符， 

680
00:32:49,079 --> 00:32:51,289
or is it not being used at all.
还是根本不使用它。 

681
00:32:51,289 --> 00:32:54,369
So how many different ways to do such a mapping are there?
那么，有多少种不同的方法可以进行这种映射？ 

682
00:32:54,369 --> 00:32:56,239
I mean, this is just a function.
我的意思是，这只是一个功能。 

683
00:32:56,240 --> 00:32:59,250
So it's the number of targets of the function.
这就是函数的目标数量。 

684
00:32:59,250 --> 00:33:03,109
So how many of these are there.
那么有多少个。 

685
00:33:03,109 --> 00:33:06,879
Gosh, well, I guess we said there are, at most, f notes.
天哪，嗯，我想我们说的最多是f个音符。 

686
00:33:06,880 --> 00:33:12,329
So f plus 1 is the maximum number of possible things
所以f加1是最大可能数

687
00:33:12,529 --> 00:33:13,660
each finger can do.
每个手指都能做到。 

688
00:33:13,660 --> 00:33:16,519
And we raise that to the power of the number of fingers.
我们将其提高到手指数量的力量。 

689
00:33:16,519 --> 00:33:19,470
That's the possible mappings of what all of my fingers
那是我所有手指可能的映射

690
00:33:19,470 --> 00:33:20,375
could be doing.
可能正在做。 

691
00:33:20,375 --> 00:33:22,299
It's exponential in f, not so great.
它在f中是指数的，不是很大。 

692
00:33:22,299 --> 00:33:25,139
But if f is 5, it's all right.
但是如果f为5，就可以了。 

693
00:33:25,140 --> 00:33:27,849
And then-- well, then you just generalize the rest.
然后-好吧，然后您就可以将其余的内容进行概括。 

694
00:33:28,049 --> 00:33:30,889
I don't think I'll write it down in detail.
我认为我不会详细记录下来。 

695
00:33:30,890 --> 00:33:32,829
But our sub-problems now are going
但是我们现在的子问题正在发展

696
00:33:33,029 --> 00:33:37,000
to be-- let me switch boards here.
是的-让我在这里切换板子。 

697
00:33:37,000 --> 00:33:40,700



698
00:33:40,700 --> 00:33:46,130
How do we play these multi-notes from i onwards,
我们如何从i开始播放这些多音符， 

699
00:33:46,130 --> 00:33:48,930
given that we're going to use that pose-- or I called
鉴于我们将使用该姿势-或者我打电话给

700
00:33:48,930 --> 00:33:54,539
it the state of all my fingers-- for the first notes of i
这是我所有手指的状态-对于我的第一个音符

701
00:33:54,539 --> 00:33:56,159
is now a whole bunch of notes.
现在是一堆笔记。 

702
00:33:56,160 --> 00:33:57,909
So given I'm now going to play those notes
因此，鉴于我现在要演奏这些音符

703
00:33:57,909 --> 00:34:01,910
with this particular finger assignment,
通过这种特殊的手指分配， 

704
00:34:01,910 --> 00:34:04,279
how do I play the rest?
我怎么玩剩下的？ 

705
00:34:04,279 --> 00:34:07,559
And then what we'll guess is the entire finger assignment
然后我们将猜测整个手指分配

706
00:34:07,559 --> 00:34:09,630
for the next set of notes, i plus 1--
对于下一组音符，我加1-- 

707
00:34:09,630 --> 00:34:11,929
the next chord, if you will.
下一个和弦（如果可以）。 

708
00:34:11,929 --> 00:34:17,070
And that guessing involves now F plus 1 to the F time.
现在猜测涉及F加F的时间1。 

709
00:34:17,070 --> 00:34:19,319
And then we just write the recurrence in the same way.
然后，我们以相同的方式编写重复记录。 

710
00:34:19,320 --> 00:34:22,480
So we're basically generalizing here we call the finger,
所以我们基本上在这里概括为手指， 

711
00:34:22,480 --> 00:34:25,760
now it's an entire pose for your hand.
现在这是您的整个姿势。 

712
00:34:25,760 --> 00:34:28,949
Instead of F, you might write H for hand or something.
您可以用H代替手写，而不是F。 

713
00:34:28,949 --> 00:34:31,969
And so the running time in this situation
因此在这种情况下的运行时间

714
00:34:31,969 --> 00:34:36,630
is going to go up to something like n times F of plus
会上升到F的n倍

715
00:34:36,630 --> 00:34:42,382
1 to the F. Did I miss anything?
 1到F。我错过了什么吗？ 

716
00:34:42,382 --> 00:34:43,590
Probably have to square that.
可能不得不平方。 

717
00:34:43,590 --> 00:34:46,269



718
00:34:46,269 --> 00:34:47,766
2F.
 2楼

719
00:34:47,766 --> 00:34:49,139
Before it was F squared, now it's
在F平方之前，现在是

720
00:34:49,139 --> 00:34:51,359
just F plus 1 to the F squared.
只是F加1到F的平方。 

721
00:34:51,360 --> 00:34:52,860
So if F is small, this is all right.
因此，如果F小，那么就可以了。 

722
00:34:52,860 --> 00:34:53,900
Otherwise, not so great.
否则，不会那么好。 

723
00:34:53,900 --> 00:34:57,980
This is the best algorithm I know for chord fingering.
这是我所知的和弦指法的最佳算法。 

724
00:34:58,179 --> 00:34:59,675
Questions?
有什么问题吗

725
00:34:59,675 --> 00:35:02,364
Just trying to make it practical,
只是想使其实用， 

726
00:35:02,364 --> 00:35:03,530
solve the real life problem.
解决现实生活中的问题。 

727
00:35:03,530 --> 00:35:05,000
I would love, I think-- I don't know
我想，我想-我不知道

728
00:35:05,000 --> 00:35:06,708
if this has been implemented, but someone
如果已经实施，但是有人

729
00:35:06,708 --> 00:35:12,019
should implement this in some-- I don't know,
应该以某种方式实现这一点-我不知道， 

730
00:35:12,219 --> 00:35:15,919
score program, musical score program.
乐谱程序，乐谱程序。 

731
00:35:15,920 --> 00:35:17,864
I would love as learning guitar, it'd
我很想学习吉他， 

732
00:35:17,864 --> 00:35:20,280
be great for someone to just tell me how to finger things.
对某人来说很棒，只是告诉我如何去指责。 

733
00:35:20,280 --> 00:35:21,538
Then I can retroactively figure out
然后我可以追溯出

734
00:35:21,737 --> 00:35:23,811
why using the dynamic program.
为什么使用动态程序。 

735
00:35:23,811 --> 00:35:25,269
All right, let's move on to Tetris.
好吧，让我们继续俄罗斯方块。 

736
00:35:25,269 --> 00:35:33,661



737
00:35:33,661 --> 00:35:35,869
All these problems are going to have the same flavor.
所有这些问题将具有相同的味道。 

738
00:35:35,869 --> 00:35:37,130
You can solve them with basically
您基本上可以解决它们

739
00:35:37,130 --> 00:35:37,971
the same dynamic program.
相同的动态程序。 

740
00:35:38,170 --> 00:35:41,899
It's all about figuring out what should the sub-problems be.
都是要弄清楚子问题应该是什么。 

741
00:35:41,900 --> 00:35:45,311
So let me-- does anyone here not know Tetris?
所以让我-这里有人不认识俄罗斯方块吗？ 

742
00:35:45,311 --> 00:35:45,980
OK, good.
好好

743
00:35:45,980 --> 00:35:47,594
No one's willing to admit it.
没有人愿意承认这一点。 

744
00:35:47,594 --> 00:35:49,169
So you've got these blocks falling.
因此，您已经跌落了这些障碍。 

745
00:35:49,170 --> 00:35:53,639
But I'm going to make several artificial constraints.
但是我要做出一些人为的约束。 

746
00:35:53,639 --> 00:35:56,425
First of all, I tell you the entire sequence
首先，我告诉你整个过程

747
00:35:56,425 --> 00:35:57,799
of pieces that are going to come.
将要出现的碎片。 

748
00:35:57,800 --> 00:35:59,019
This is more like a Tetris puzzle.
这更像是俄罗斯方块难题。 

749
00:35:59,219 --> 00:36:02,319



750
00:36:02,320 --> 00:36:08,510
OK, we're given sequence of n pieces that will fall.
好吧，我们得到了n个碎片的序列。 

751
00:36:08,510 --> 00:36:12,090
For each of them, we must drop the piece from the top.
对于每个人，我们都必须从顶部放下。 

752
00:36:12,090 --> 00:36:15,460



753
00:36:15,659 --> 00:36:18,899
OK, and if you're a fancy Tetris player,
好的，如果您是俄罗斯方块玩家， 

754
00:36:18,900 --> 00:36:21,500
you can let a piece fall and then rotate it at very end
您可以放下一块然后在最后旋转

755
00:36:21,500 --> 00:36:23,610
to do some clever, clever thing.
做一些聪明的事情

756
00:36:23,610 --> 00:36:24,463
I disallow that.
我不允许。 

757
00:36:24,463 --> 00:36:26,130
You always have to push the drop button.
您始终必须按下下拉按钮。 

758
00:36:26,130 --> 00:36:29,329
So the piece starts here, it goes instantly to the ground.
因此，这部分从这里开始，立即到了地面。 

759
00:36:29,329 --> 00:36:30,400
This will be necessary.
这将是必要的。 

760
00:36:30,400 --> 00:36:31,740
I don't know how to solve the problem
我不知道该怎么解决

761
00:36:31,940 --> 00:36:33,739
without this constraint.
没有这个限制。 

762
00:36:33,739 --> 00:36:37,409
OK, and then the other weird thing--
好吧，然后是另一件事

763
00:36:37,409 --> 00:36:41,710
this is very weird for Tetris-- full rows normally clear,
对于俄罗斯方块来说这很奇怪-通常整行都很清晰， 

764
00:36:41,710 --> 00:36:44,880
but now they don't clear.
但是现在他们还不清楚。 

765
00:36:44,880 --> 00:36:46,500
This is like hardcore Tetris.
这就像铁杆俄罗斯方块。 

766
00:36:46,699 --> 00:36:48,639
You're guaranteed to die eventually.
你一定会死的。 

767
00:36:48,639 --> 00:36:53,286
The question is, can you survive these n pieces?
问题是，您可以在这n个零件中生存吗？ 

768
00:36:53,286 --> 00:36:54,119
That's the question.
这就是问题所在。 

769
00:36:54,119 --> 00:36:54,786
Can you survive?
你能生存吗？ 

770
00:36:54,786 --> 00:36:57,461



771
00:36:57,461 --> 00:36:59,309
Oh, I've got one other constraint.
哦，我还有另一个约束。 

772
00:36:59,309 --> 00:37:02,239
This is actually kind of natural.
这实际上是自然的。 

773
00:37:02,239 --> 00:37:07,199
The width of the board is small, relatively small,
木板的宽度很小，比较小， 

774
00:37:07,199 --> 00:37:09,409
because we're going to be exponential in w.
因为我们将在w中取指数。 

775
00:37:09,409 --> 00:37:12,136
In real life it's 12, I think?
我认为现实生活中是12岁吗？ 

776
00:37:12,137 --> 00:37:12,519
AUDIENCE: Ten.
听众：十。 

777
00:37:12,719 --> 00:37:13,864
PROFESSOR: Ten, sorry.
教授：十，对不起。 

778
00:37:13,864 --> 00:37:17,029
It's been a while since I wrote my Tetris paper.
自从我写《俄罗斯方块》论文以来已经有一段时间了。 

779
00:37:17,030 --> 00:37:20,070
So all right, these are all kind of weird constraints.
因此，这些都是怪异的约束。 

780
00:37:20,070 --> 00:37:22,730
If you don't make all of these constraints-- oh,
如果您不做所有这些限制-哦， 

781
00:37:22,730 --> 00:37:25,110
also the board is initially empty.
板子最初也是空的。 

782
00:37:25,110 --> 00:37:26,769
That's like level one of Tetris.
这就像俄罗斯方块的一级。 

783
00:37:26,769 --> 00:37:34,170



784
00:37:34,170 --> 00:37:36,460
If all of these things are not the case, which
如果不是所有这些情况，那

785
00:37:36,460 --> 00:37:39,313
is regular Tetris, if you just have the first thing
是普通的俄罗斯方块，如果您只有第一件事

786
00:37:39,313 --> 00:37:40,980
then this problem is called NP-complete.
那么这个问题就叫做NP完全

787
00:37:40,980 --> 00:37:42,730
We'll be defining that next class.
我们将定义下一个类。 

788
00:37:42,730 --> 00:37:45,561
So it's computationally intractable.
因此它在计算上很棘手。 

789
00:37:45,561 --> 00:37:47,269
But if you make all of these assumptions,
但是，如果您做出所有这些假设， 

790
00:37:47,269 --> 00:37:49,940
the problem becomes easy, and you
问题变得容易，而你

791
00:37:49,940 --> 00:37:53,260
can do it by dynamic programming.
可以通过动态编程做到这一点。 

792
00:37:53,260 --> 00:37:57,039
So how do we do it?
那么我们该怎么做呢？ 

793
00:37:57,239 --> 00:38:00,489
We define sub-problems just like before.
我们像以前一样定义子问题。 

794
00:38:00,489 --> 00:38:02,079
The obvious thing to try is suffixes.
显而易见的事情是后缀。 

795
00:38:02,079 --> 00:38:07,230



796
00:38:07,230 --> 00:38:13,900
How do we play a suffix of pieces i onwards?
我该如何播放我以后的作品后缀？ 

797
00:38:13,900 --> 00:38:18,329
How to play those guys.
怎么打那些家伙。 

798
00:38:18,329 --> 00:38:23,599
And just like fingering, this is not enough information, right?
就像指法一样，这还不够，对吗？ 

799
00:38:23,599 --> 00:38:26,130
Because if we're going to play from pieces i onward, what
因为如果我要从头开始演奏，那

800
00:38:26,130 --> 00:38:28,210
we need to now is what the board currently looks like.
我们现在需要的是董事会当前的样子。 

801
00:38:28,409 --> 00:38:30,311
I said here the board is initially empty.
我在这里说董事会最初是空的。 

802
00:38:30,311 --> 00:38:32,019
That's not going to be the case after you
在您之后情况将不再如此

803
00:38:32,019 --> 00:38:33,672
place the very first piece.
放置第一块。 

804
00:38:33,672 --> 00:38:35,880
So in general, after we've placed the first i pieces,
所以总的来说，在我们放置了第一个i件之后， 

805
00:38:35,880 --> 00:38:38,972
we need to know what the board looks like.
我们需要知道董事会的样子。 

806
00:38:38,972 --> 00:38:41,230
And here's where I'm going to use all of these assumptions.
这就是我要使用所有这些假设的地方。 

807
00:38:41,429 --> 00:38:46,379
If you always drop things from the top and rows don't clear,
如果您总是从顶部放东西而行却不清除， 

808
00:38:46,380 --> 00:38:51,454
then all you really care about is how high each column is.
那么您真正关心的就是每列的高度。 

809
00:38:51,454 --> 00:38:54,980
This is what you might call the skyline of the board.
这就是您所说的董事会的天际线。 

810
00:38:54,980 --> 00:38:58,139



811
00:38:58,139 --> 00:39:02,219
OK, now in reality, there might be holes here
好吧，现在实际上，这里可能会有漏洞

812
00:39:02,219 --> 00:39:03,884
because you drop things in silly ways.
因为你以愚蠢的方式丢东西。 

813
00:39:03,885 --> 00:39:07,030
Maybe you drop a piece like this.
也许您放这样的一块。 

814
00:39:07,030 --> 00:39:09,090
And then I claim, because I'm dropping things
然后我声称，因为我要丢东西

815
00:39:09,090 --> 00:39:12,338
from infinity from the sky, I really
从无边无际的天空，我真的

816
00:39:12,338 --> 00:39:14,130
don't care about that there's a whole here.
不在乎这里有个整体。 

817
00:39:14,130 --> 00:39:17,150
I can just fill that in and say, OK, that's my new skyline.
我可以填写一下，然后说，好，那是我的新天际线。 

818
00:39:17,150 --> 00:39:19,300
Because if you can't do these last minute twists
因为如果你不能做这些最后的转折

819
00:39:19,300 --> 00:39:22,380
and if lines never clear, that's going to be gone.
如果线条不清晰，那将消失。 

820
00:39:22,579 --> 00:39:25,380
That material is wasted.
那材料被浪费了。 

821
00:39:25,380 --> 00:39:30,630
OK, so all I need to remember is how high is each column.
好的，所以我需要记住的是每列的高度。 

822
00:39:30,630 --> 00:39:38,882
So I should say given the board skyline.
所以我应该说鉴于董事会的天际线。 

823
00:39:38,882 --> 00:39:40,590
Now, how many choices are there for that?
现在，有多少选择呢？ 

824
00:39:40,590 --> 00:39:45,019
It's quite similar to this function, the fingering.
它非常类似于此功能，指法。 

825
00:39:45,219 --> 00:39:45,719
Let's see.
让我们来看看。 

826
00:39:45,719 --> 00:39:48,969
There's the height of the board, different choices.
有板子的高度，有不同的选择。 

827
00:39:48,969 --> 00:39:50,891
It's going to be h.
将会是h。 

828
00:39:50,891 --> 00:39:53,099
For each column it could be anywhere between 0 and h,
对于每一列，它可以在0到h之间的任意位置， 

829
00:39:53,099 --> 00:39:56,089
so I guess h plus 1 if you want to get technical.
因此，如果您想获取技术知识，我想h加1。 

830
00:39:56,090 --> 00:39:57,840
And then we raise it to the power w,
然后我们将其提高到幂w 

831
00:39:57,840 --> 00:40:00,860
because there's w different columns and each of them
因为有w个不同的列，每个列

832
00:40:00,860 --> 00:40:03,697
is independent choice.
是独立的选择。 

833
00:40:03,697 --> 00:40:06,030
So this is going to n times that different sub-problems.
因此，这将是不同子问题的n倍。 

834
00:40:06,030 --> 00:40:10,670



835
00:40:10,869 --> 00:40:12,849
And here's what I need the is small
这就是我所需要的

836
00:40:12,849 --> 00:40:14,329
because this is exponential in w.
因为这是w的指数

837
00:40:14,329 --> 00:40:18,779
So it's reasonable in h, but exponential in w.
因此，它在h中是合理的，但在w中是指数的。 

838
00:40:18,780 --> 00:40:21,880
OK, then what do I guess?
好，那我猜怎么着？ 

839
00:40:21,880 --> 00:40:23,065
Any suggestions what to guess?
有什么建议要猜吗？ 

840
00:40:23,264 --> 00:40:38,379



841
00:40:38,380 --> 00:40:43,184
AUDIENCE: So where the new piece falls, as in [INAUDIBLE]?
听众：那么新作品落在哪里，如[听不清]？ 

842
00:40:43,184 --> 00:40:43,650
PROFESSOR: Yeah.
教授：是的。 

843
00:40:43,849 --> 00:40:46,529
What should I do with piece i?
我该怎么办？ 

844
00:40:46,530 --> 00:40:47,980
There's not that many choices.
没有太多选择。 

845
00:40:47,980 --> 00:40:51,639
I can rotate it zero, one, two, or three times.
我可以将其旋转零，一，二或三次。 

846
00:40:51,639 --> 00:40:53,170
I can choose someplace to drop it,
我可以选择放一个地方

847
00:40:53,170 --> 00:40:55,456
but those are my only choices.
但这是我唯一的选择。 

848
00:40:55,456 --> 00:41:01,059
So it's just how to play piece i.
因此，这就是如何演奏我的作品。 

849
00:41:01,059 --> 00:41:02,869
And given that guess, you can figure out
鉴于这种猜测，您可以找出

850
00:41:02,869 --> 00:41:05,900
how the skyline updates, like I did here.
天际如何更新，就像我在这里所做的那样。 

851
00:41:05,900 --> 00:41:08,730
If I drop that piece like that, then I fill in this part
如果我那样掉那块，那么我要填写这部分

852
00:41:08,730 --> 00:41:09,965
and recompute my new skyline.
并重新计算我的新天际线。 

853
00:41:09,965 --> 00:41:12,590



854
00:41:12,590 --> 00:41:13,920
So it's going to be something like 4
所以大概是4 

855
00:41:14,119 --> 00:41:19,704
times w different choices, roughly-- 4 for the rotation,
 w有不同的选择，大约-4表示旋转， 

856
00:41:19,704 --> 00:41:20,663
w for the x-coordinate.
 w为x坐标。 

857
00:41:20,663 --> 00:41:23,170



858
00:41:23,170 --> 00:41:24,840
And so the running time is just going
因此，运行时间即将过去

859
00:41:24,840 --> 00:41:26,010
to be the product of these.
成为这些产品。 

860
00:41:26,010 --> 00:41:42,019



861
00:41:42,219 --> 00:41:49,029
n times w times h plus 1 to the w.
 n乘以w乘以h。 

862
00:41:49,030 --> 00:41:53,610
Open problem, if I drop any one of these assumptions,
公开的问题，如果我放弃这些假设中的任何一个， 

863
00:41:53,809 --> 00:41:56,400
can you get a dynamic program that's reasonable?
您可以获得合理的动态程序吗？ 

864
00:41:56,400 --> 00:41:58,039
Could you do it if w is large?
如果w大，你能做到吗？ 

865
00:41:58,039 --> 00:41:58,954
I don't know.
我不知道。 

866
00:41:58,954 --> 00:42:02,219
Could you do if rows do clear?
如果行清除，您能做吗？ 

867
00:42:02,219 --> 00:42:04,778
That's the least natural constraint here.
这是最不自然的约束。 

868
00:42:04,778 --> 00:42:05,320
I don't know.
我不知道。 

869
00:42:05,320 --> 00:42:07,650



870
00:42:07,849 --> 00:42:09,329
Puzzle for you to think about.
拼图让您思考。 

871
00:42:09,329 --> 00:42:10,496
I'd love to know the answer.
我很想知道答案。 

872
00:42:10,496 --> 00:42:16,780



873
00:42:16,780 --> 00:42:18,804
You can obviously do the rest of the steps, right?
您显然可以完成其余步骤，对吗？ 

874
00:42:19,003 --> 00:42:20,420
You can write down the recurrence.
您可以记下重复发生率。 

875
00:42:20,420 --> 00:42:21,253
It's the same thing.
这是同一件事。 

876
00:42:21,253 --> 00:42:23,650
You take the min over all guesses.
您将所有猜测都放在心上。 

877
00:42:23,849 --> 00:42:25,079
What are we minimizing?
我们要最小化什么？ 

878
00:42:25,079 --> 00:42:25,710
Hmm.
嗯

879
00:42:25,710 --> 00:42:29,699
I guess here the question is survival.
我想这里的问题是生存。 

880
00:42:29,699 --> 00:42:31,579
Can you survive?
你能生存吗？ 

881
00:42:31,579 --> 00:42:34,269
So this is one of the first examples where the answer is
所以这是第一个例子，答案是

882
00:42:34,269 --> 00:42:37,469
a Boolean value, true or false.
一个布尔值，真或假。 

883
00:42:37,469 --> 00:42:40,049
But if you think of true or false as 0 and 1,
但是，如果您认为true或false为0和1， 

884
00:42:40,050 --> 00:42:42,885
then it's still a maximization problem.
那仍然是一个最大化的问题。 

885
00:42:43,085 --> 00:42:43,959
You want to maximize.
您想最大化。 

886
00:42:43,960 --> 00:42:45,119
You want 1 if possible.
如果可能，您需要1。 

887
00:42:45,119 --> 00:42:47,630
Otherwise, you'll get 0 when you maximize.
否则，最大化时将获得0。 

888
00:42:47,630 --> 00:42:50,320
So you can write the recurrence using max.
因此，您可以使用max编写重复记录。 

889
00:42:50,320 --> 00:42:53,880
And in the base case, you have truth values, true or false.
在基本情况下，您将拥有真值（真或假）。 

890
00:42:53,880 --> 00:42:55,530
And you'll see, did I survive?
而且您会看到，我生存了吗？ 

891
00:42:55,530 --> 00:42:56,980
Did I die?
我死了吗

892
00:42:56,980 --> 00:42:58,860
That sort of thing.
之类的东西。 

893
00:42:58,860 --> 00:43:00,507
I want to go on to Super Mario Brothers,
我想去超级马里奥兄弟

894
00:43:00,706 --> 00:43:02,539
because everyone loves Super Mario Brothers.
因为每个人都喜欢超级马里奥兄弟。 

895
00:43:02,539 --> 00:43:10,090



896
00:43:10,090 --> 00:43:10,589
has?
拥有？ 

897
00:43:10,590 --> 00:43:14,010
Anyone not played NES Super Mario Brothers 1?
没有人玩过NES Super Mario Brothers 1吗？ 

898
00:43:14,010 --> 00:43:17,315
Aww, you got to play it, man.
噢，你一定要玩，伙计。 

899
00:43:17,315 --> 00:43:19,079
You're the only one.
你是唯一的一个。 

900
00:43:19,079 --> 00:43:20,980
You can play it on an emulator.
您可以在模拟器上播放它。 

901
00:43:20,980 --> 00:43:23,699
Maybe not legally, but you can play it on an emulator
也许不合法，但是您可以在模拟器上播放

902
00:43:23,699 --> 00:43:27,429
and just see how it is.
看看情况如何。 

903
00:43:27,429 --> 00:43:29,519
So what I'm going to talk about next,
所以我接下来要谈的是

904
00:43:29,519 --> 00:43:31,900
in theory, works for many different platform games,
从理论上讲，适用于许多不同的平台游戏， 

905
00:43:31,900 --> 00:43:34,320
side-scrolling platform games.
侧滚动平台游戏。 

906
00:43:34,320 --> 00:43:38,940
But Super Mario Brothers 1 has some nice features.
但是超级马里奥兄弟1具有一些不错的功能。 

907
00:43:39,139 --> 00:43:41,839
In particular, a nice feature is that whenever anything
特别是一个不错的功能是

908
00:43:41,840 --> 00:43:46,460
moves off of the screen, it disappears from the world.
移动离开屏幕，它从世界上消失了。 

909
00:43:46,460 --> 00:43:48,190
So the monster moves off, it's gone.
所以怪物移开了，它消失了。 

910
00:43:48,190 --> 00:43:51,409



911
00:43:51,409 --> 00:43:53,559
You can think of there's a static level there.
您可以想到那里有一个静态水平。 

912
00:43:53,559 --> 00:43:56,139
When the level comes into screen, when a monster comes
当关卡进入屏幕时，当怪物来时

913
00:43:56,139 --> 00:43:58,388
on screen, then it starts acting.
在屏幕上，然后它开始起作用。 

914
00:43:58,389 --> 00:44:00,480
But as soon as you move the screen-- you can't actually
但是，只要您移动屏幕，您实际上就无法

915
00:44:00,679 --> 00:44:02,512
move backwards in Super Mario 1, but as soon
在Super Mario 1中向后移动，但尽快

916
00:44:02,512 --> 00:44:05,569
as you move forwards and that character is offscreen,
当您向前移动并且该角色不在屏幕上时， 

917
00:44:05,570 --> 00:44:06,630
it's gone.
它消失了。 

918
00:44:06,630 --> 00:44:07,971
So in a sense, that part of the level
所以从某种意义上说

919
00:44:08,170 --> 00:44:09,559
reset to its initial state.
重置为其初始状态。 

920
00:44:09,559 --> 00:44:12,960
Now, as long as your screen is not too big-- and thankfully,
现在，只要您的屏幕不是太大-幸运的是， 

921
00:44:12,960 --> 00:44:14,699
on NES screens were not very big.
在NES屏幕上不是很大。 

922
00:44:14,699 --> 00:44:18,029
It's 320p, or whatever.
它是320p，或其他任何值。 

923
00:44:18,030 --> 00:44:21,269
This will work.
这将起作用。 

924
00:44:21,269 --> 00:44:27,429
If you are given the entire level--
如果您获得了整个级别的信息， 

925
00:44:27,429 --> 00:44:30,899
so let's say there's n bits of information there--
假设那里有n条信息

926
00:44:30,900 --> 00:44:38,000
and you have a small screen, w by h screen, w and h
并且您有一个小屏幕，w和h屏幕，w和h 

927
00:44:38,000 --> 00:44:39,579
are not too big.
不太大。 

928
00:44:39,579 --> 00:44:42,099
Then I claim we can solve Super Mario
然后我声称我们可以解决超级马里奥

929
00:44:42,099 --> 00:44:43,440
Brothers by dynamic programming.
兄弟们通过动态编程。 

930
00:44:43,440 --> 00:44:46,101
So let's say we want to maximize our score.
假设我们要最大化得分。 

931
00:44:46,101 --> 00:44:48,349
Want to run through the level and maximize your score,
想跑遍关卡并最大化您的分数， 

932
00:44:48,349 --> 00:44:50,159
or you want to minimize the amount of time you use.
或者您想减少使用时间。 

933
00:44:50,159 --> 00:44:51,230
You're doing level runs.
您正在执行关卡运行。 

934
00:44:51,230 --> 00:44:54,514
Pick your favorite measure, all of those can be solved.
选择您最喜欢的措施，所有这些都可以解决。 

935
00:44:54,514 --> 00:44:56,639
And the way to do it, this sort of general approach
以及这种方法，这种通用方法

936
00:44:56,639 --> 00:44:58,839
to all these DPs is we need to write down
对于所有这些DP，我们需要写下来

937
00:44:58,840 --> 00:45:01,125
what do I need to know about the game state.
我需要了解什么游戏状态。 

938
00:45:01,324 --> 00:45:02,615
I'll call that a configuration.
我将其称为配置。 

939
00:45:02,615 --> 00:45:05,780



940
00:45:05,780 --> 00:45:07,780
What can we care about for Super Mario Brothers?
超级马里奥兄弟能为我们做什么？ 

941
00:45:07,780 --> 00:45:13,190
Well, I guess everything on screen.
好吧，我猜屏幕上的所有内容。 

942
00:45:13,190 --> 00:45:17,280



943
00:45:17,280 --> 00:45:20,429
This is a bit tricky, but there's stuff on screen.
这有点棘手，但是屏幕上有东西。 

944
00:45:20,628 --> 00:45:21,920
There are monsters and objects.
有怪物和物体。 

945
00:45:21,920 --> 00:45:24,253
For the monsters, I need to know their current position.
对于怪物，我需要知道它们的当前位置。 

946
00:45:24,253 --> 00:45:26,092
For the objects, I need to know-- like,
对于物体，我需要知道- 

947
00:45:26,291 --> 00:45:27,500
is there a question mark box?
有问号框吗？ 

948
00:45:27,500 --> 00:45:28,909
Did I hit it already?
我已经打了吗？ 

949
00:45:28,909 --> 00:45:31,879
Did I already get the coin or did I already get the mushroom?
我已经拿硬币还是蘑菇了？ 

950
00:45:31,880 --> 00:45:33,710
So for each of those things, there's
因此，对于每件事， 

951
00:45:33,909 --> 00:45:35,940
some amount of information you need to store.
您需要存储一些信息。 

952
00:45:35,940 --> 00:45:38,980
How much information?
多少信息？ 

953
00:45:38,980 --> 00:45:45,000
I think something like constant to the w times h should do.
我认为应该对w乘以常数。 

954
00:45:45,000 --> 00:45:47,083
That's saying for every pixel on the screen
也就是说屏幕上的每个像素

955
00:45:47,083 --> 00:45:48,500
or for every square on the screen,
或屏幕上的每个方块， 

956
00:45:48,500 --> 00:45:50,789
however you-- whatever you define the resolution here
但是您-无论您在此处定义分辨率

957
00:45:50,789 --> 00:45:51,289
to be.
成为。 

958
00:45:51,289 --> 00:45:54,800
Let's say for every little unit square in Mario land,
假设在马里奥（Mario）土地上的每个小单位广场， 

959
00:45:54,800 --> 00:45:56,750
is it a brick?
是砖头吗？ 

960
00:45:56,750 --> 00:46:01,639
Is it a hard brick, or has it been a destroyed brick?
它是坚硬的砖块，还是被破坏的砖块？ 

961
00:46:01,639 --> 00:46:03,489
Is a monster there right now?
现在有怪物吗？ 

962
00:46:03,489 --> 00:46:04,849
Is Mario there right now?
马里奥现在在吗？ 

963
00:46:04,849 --> 00:46:07,299
All these kinds of information.
所有这些信息。 

964
00:46:07,300 --> 00:46:10,380
OK, so there's a cost number of choices for each pixel.
好的，因此每个像素都有一个成本选择。 

965
00:46:10,579 --> 00:46:12,340
You can write them all down.
您可以将它们全部写下来。 

966
00:46:12,340 --> 00:46:16,880
You might also want Mario's velocity.
您可能还需要Mario的速度。 

967
00:46:16,880 --> 00:46:18,860
I had to play it again just to check
我只好再次检查一下

968
00:46:18,860 --> 00:46:20,400
that there is indeed velocity.
确实有速度。 

969
00:46:20,400 --> 00:46:23,260
Turning around is slower than going forward.
转身比前进慢。 

970
00:46:23,260 --> 00:46:24,500
You do accelerate a little bit.
您确实会加速一点。 

971
00:46:24,699 --> 00:46:25,789
So you've got to remember that.
因此，您必须记住这一点。 

972
00:46:25,789 --> 00:46:27,414
There's probably only a constant number
可能只有一个常数

973
00:46:27,414 --> 00:46:30,840
of choices for what your velocity is.
速度的选择。 

974
00:46:30,840 --> 00:46:33,208
What else?
还有什么？ 

975
00:46:33,407 --> 00:46:36,710
Ah, I want to remember the score.
啊，我想记住分数。 

976
00:46:36,710 --> 00:46:38,119
You want to maximize score.
您想最大化分数。 

977
00:46:38,119 --> 00:46:40,576
And let's say you also-- how much time is left.
再说一遍，您还剩下多少时间。 

978
00:46:40,577 --> 00:46:41,335
There's a time counter.
有一个计时器。 

979
00:46:41,534 --> 00:46:43,509
If it hits zero, you die.
如果达到零，则死亡。 

980
00:46:43,510 --> 00:46:46,460
Now, these are kind of annoying, because they're integers.
现在，这些有点烦人，因为它们是整数。 

981
00:46:46,460 --> 00:46:48,300
They could be kind of large.
它们可能很大。 

982
00:46:48,300 --> 00:46:51,010
So I'm going to say the score could be capital S big,
所以我要说分数可能是大写S， 

983
00:46:51,010 --> 00:46:53,510
and time could be capital T big.
时间可能是大资本。 

984
00:46:53,510 --> 00:46:56,519
So this'll be a pseudopolynomial algorithm.
因此，这将是一个伪多项式算法。 

985
00:46:56,719 --> 00:46:58,519
The number of configurations in total
总计配置数

986
00:46:58,519 --> 00:47:00,320
here is the product of these things.
这是这些东西的产物。 

987
00:47:00,320 --> 00:47:03,980
It's exponential in w and h.
它在w和h中是指数的。 

988
00:47:03,980 --> 00:47:09,420
And then multiply by S and T. So that's
然后乘以S和T。 

989
00:47:09,420 --> 00:47:11,389
the number of configurations.
配置数量。 

990
00:47:11,389 --> 00:47:13,500
And that's also going to be our sub-problem.
这也将是我们的子问题。 

991
00:47:13,500 --> 00:47:15,909
I guess we should also write down
我想我们也应该写下来

992
00:47:15,909 --> 00:47:21,309
where is the screen relative to the level.
屏幕相对于级别的位置在哪里。 

993
00:47:21,309 --> 00:47:24,269
OK, how far to the right have you gone?
好，你走到右边多远了？ 

994
00:47:24,269 --> 00:47:25,420
That's another w.
那是另一个w。 

995
00:47:25,420 --> 00:47:28,710



996
00:47:28,710 --> 00:47:30,030
That's not a big deal.
没什么大不了的。 

997
00:47:30,030 --> 00:47:32,269
OK, given this information, you know everything
好，有了这些信息，您就知道了一切

998
00:47:32,269 --> 00:47:35,579
you need to know about playing from here on.
您需要从这里开始玩。 

999
00:47:35,579 --> 00:47:38,139
And the time counter's always going to keep ticking.
而且时间计数器总是在滴答作响。 

1000
00:47:38,139 --> 00:47:41,190
So you can draw a graph of all configurations,
因此，您可以绘制所有配置的图表， 

1001
00:47:41,190 --> 00:47:42,800
just enumerate all of these things.
只是列举所有这些事情。 

1002
00:47:42,800 --> 00:47:44,550
It's this many of them.
就是这么多。 

1003
00:47:44,550 --> 00:47:47,039
And then draw, for every configuration,
然后针对每种配置绘制

1004
00:47:47,239 --> 00:47:48,959
what are the possible things I can do?
我可以做些什么？ 

1005
00:47:48,960 --> 00:47:50,039
I could push this button.
我可以按一下此按钮。 

1006
00:47:50,039 --> 00:47:52,079
I can push the A button, I can release the A button.
我可以按A按钮，也可以释放A按钮。 

1007
00:47:52,079 --> 00:47:54,246
I can push the B button, I can release the B button.
我可以按B按钮，也可以释放B按钮。 

1008
00:47:54,246 --> 00:47:55,487
I can push the up arrow.
我可以按向上箭头。 

1009
00:47:55,487 --> 00:47:57,070
Those are all the things you could do.
这些就是您可以做的所有事情。 

1010
00:47:57,070 --> 00:47:58,820
It's a constant number of choices.
这是一个不变的选择。 

1011
00:47:58,820 --> 00:48:01,500
So each vertex will have constant out degree.
因此，每个顶点将具有恒定的出度。 

1012
00:48:01,500 --> 00:48:04,335
If you did this, what configuration would I reach?
如果这样做，我将达到什么配置？ 

1013
00:48:04,335 --> 00:48:05,619
Just draw that whole graph.
只需绘制整个图形即可。 

1014
00:48:05,619 --> 00:48:07,839
Do shortest paths.
做最短的路径。 

1015
00:48:07,840 --> 00:48:11,626
Or dynamic programming, these are your sub-problems.
或动态编程，这些是您的子问题。 

1016
00:48:11,626 --> 00:48:12,750
There are no suffixes here.
这里没有后缀。 

1017
00:48:12,750 --> 00:48:14,760
These are your sub-problem.
这些是您的子问题。 

1018
00:48:14,760 --> 00:48:18,210
And then you take a max, if you're
然后，如果您是

1019
00:48:18,409 --> 00:48:20,909
trying to maximize score or max if you're trying to maximize
尝试最大化分数或最大，如果您尝试最大化

1020
00:48:20,909 --> 00:48:23,440
time, minimize the time you use.
时间，尽量减少使用时间。 

1021
00:48:23,440 --> 00:48:25,579
This is time remaining.
这是剩余时间。 

1022
00:48:25,579 --> 00:48:27,228
And you can relate each sub-problem
您可以关联每个子问题

1023
00:48:27,228 --> 00:48:29,019
to a constant number of other sub-problems.
恒定数量的其他子问题。 

1024
00:48:29,019 --> 00:48:30,436
So your running time will be this,
所以您的跑步时间将是这样， 

1025
00:48:30,436 --> 00:48:33,269
because you only pay constant time per sub-problem.
因为您只为每个子问题支付固定时间。 

1026
00:48:33,269 --> 00:48:35,539
And now you can solve Super Mario Brothers optimally,
现在您可以最佳解决超级马里奥兄弟了， 

1027
00:48:35,539 --> 00:48:37,956
as long as your screen is not too big and as long
只要您的屏幕不太大且不长

1028
00:48:37,956 --> 00:48:40,039
as your scores and times don't get too big either,
因为你的分数和时间也不会太大

1029
00:48:40,039 --> 00:48:42,039
because we're only pseudopolynomial with respect
因为我们只是尊重的伪多项式

1030
00:48:42,039 --> 00:48:43,989
to S and T.
到S和T。 

1031
00:48:43,989 --> 00:48:46,699
Questions?
有什么问题吗

1032
00:48:46,699 --> 00:48:47,199
All right.
好吧。 

1033
00:48:47,199 --> 00:48:48,139
That's-- yeah?
是的-是吗？ 

1034
00:48:48,139 --> 00:48:51,592
AUDIENCE: So are we going to be trying
听众：那么我们将要尝试吗

1035
00:48:51,592 --> 00:48:56,058
to memoize all of these possible configurations?
记住所有这些可能的配置？ 

1036
00:48:56,059 --> 00:48:57,650
PROFESSOR: If you do the recursive version,
教授：如果您执行的是递归版本， 

1037
00:48:57,849 --> 00:49:00,819
you will end up memoizing all of these configuration values.
您最终将记住所有这些配置值。 

1038
00:49:00,820 --> 00:49:04,009
Well, anyone that's reachable from the initial state.
好吧，从初始状态可以到达的任何人。 

1039
00:49:04,009 --> 00:49:05,800
Some configurations might not be reachable,
某些配置可能无法访问， 

1040
00:49:05,800 --> 00:49:08,090
but the ones that are reachable you're
但是那些可及的你

1041
00:49:08,090 --> 00:49:09,380
going to start doing them.
要开始做他们。 

1042
00:49:09,380 --> 00:49:13,530
When you finish doing them, you will memoize the result.
完成这些操作后，您将记住结果。 

1043
00:49:13,530 --> 00:49:18,530



