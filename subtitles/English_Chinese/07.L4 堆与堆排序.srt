1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:22,210



10
00:00:22,210 --> 00:00:24,789
PROFESSOR: One of the cutest little data structures
教授：最可爱的小数据结构之一

11
00:00:24,989 --> 00:00:27,889
that was ever invented is called the heap.
曾经被发明的被称为堆。 

12
00:00:27,890 --> 00:00:31,289
And we're going to use the heap as an example
我们将以堆为例

13
00:00:31,489 --> 00:00:35,390
implementation of a priority queue.
执行优先级队列。 

14
00:00:35,390 --> 00:00:40,850
And we'll also use heaps to build a sorting algorithm,
而且我们还将使用堆来构建排序算法， 

15
00:00:40,850 --> 00:00:43,840
called heap sort, that is very, very
叫做堆排序

16
00:00:43,840 --> 00:00:48,589
different from either insertion sort or merge sort.
与插入排序或合并排序不同。 

17
00:00:48,789 --> 00:00:52,460
And it has some nice properties that neither insertions sort
而且它具有一些不错的属性，两个插入都不排序

18
00:00:52,460 --> 00:00:54,520
nor merge sort have.
也没有合并排序。 

19
00:00:54,520 --> 00:00:57,339
But what I want to do is get started
但是我要开始做

20
00:00:57,539 --> 00:01:02,869
with motivating the heap data structure,
通过激励堆数据结构， 

21
00:01:02,869 --> 00:01:06,670
regardless of whether you're interested in sorting or not.
无论您是否对排序感兴趣。 

22
00:01:06,670 --> 00:01:08,790
So the notion of a priority queue, I think,
因此，我认为优先队列的概念

23
00:01:08,790 --> 00:01:11,640
makes intuitive sense to all of you.
对所有人都很直观。 

24
00:01:11,640 --> 00:01:14,750
It's essentially a structure that
本质上是一个结构

25
00:01:14,750 --> 00:01:21,784
implements a set S of elements.
实现元素S的集合。 

26
00:01:21,784 --> 00:01:28,340



27
00:01:28,340 --> 00:01:34,180
And each of these elements is associated with the key.
这些元素中的每一个都与密钥相关联。 

28
00:01:34,180 --> 00:01:43,689



29
00:01:43,890 --> 00:01:46,299
And as you can imagine, a priority queue is something
可以想象，优先级队列是

30
00:01:46,299 --> 00:01:49,250
where you queue up for something,
在哪里排队

31
00:01:49,250 --> 00:01:52,140
you want to buy something, you want to sell something.
你想买东西，你想卖东西。 

32
00:01:52,140 --> 00:01:55,579
You have certain priorities assigned to you,
您分配了某些优先级， 

33
00:01:55,579 --> 00:01:59,969
and you want to pick the maximum priority or the min priority.
并且您要选择最大优先级或最小优先级。 

34
00:01:59,969 --> 00:02:02,010
You want to be able to delete it from the queue.
您希望能够将其从队列中删除。 

35
00:02:02,010 --> 00:02:04,650
You want to be able to insert things into this queue.
您希望能够将东西插入此队列。 

36
00:02:04,650 --> 00:02:07,430
You want to be able to change priorities in the queue.
您希望能够更改队列中的优先级。 

37
00:02:07,430 --> 00:02:12,620
So all of these operations are interesting operations
所以所有这些操作都是有趣的操作

38
00:02:12,620 --> 00:02:17,197
that should run fast, and for some definition of fast.
应该可以快速运行，并且可以快速定义。 

39
00:02:17,197 --> 00:02:19,530
Obviously we are interested in the asymptotic complexity
显然，我们对渐进复杂性感兴趣

40
00:02:19,530 --> 00:02:20,729
definition of fast.
快速的定义。 

41
00:02:20,729 --> 00:02:23,379
In that case, we'll be saying does this operation run
在这种情况下，我们将说此操作是否运行

42
00:02:23,379 --> 00:02:27,400
an order n time, order log n time, et cetera.
 n次订单，n次订单日志等。 

43
00:02:27,400 --> 00:02:30,810
So in general, I think for the next few lectures,
所以总的来说，我认为在接下来的几讲中

44
00:02:30,810 --> 00:02:36,599
you're going to see a specification of data structure
您将看到数据结构的规范

45
00:02:36,599 --> 00:02:39,419
in terms of the operations that the data structure should
就数据结构应执行的操作而言

46
00:02:39,419 --> 00:02:40,489
perform.
表演。 

47
00:02:40,490 --> 00:02:42,659
And those of you who have taken six double O five,
你们那些拿了六双O 5的人， 

48
00:02:42,659 --> 00:02:45,560
you'll see that it's basically an abstract data type that's
您会发现它基本上是一种抽象的数据类型

49
00:02:45,560 --> 00:02:48,689
associated with these operations.
与这些操作相关联。 

50
00:02:48,689 --> 00:02:51,539
So it's a spec for the abstract data type.
因此，它是抽象数据类型的规范。 

51
00:02:51,539 --> 00:02:54,199
In six double O five, you had really
在六双O五中， 

52
00:02:54,199 --> 00:02:56,939
spent a lot of time on asymptotic complexity,
在渐进复杂度上花了很多时间， 

53
00:02:56,939 --> 00:03:00,400
or the efficiency of operations on the abstract data type.
或对抽象数据类型进行操作的效率。 

54
00:03:00,400 --> 00:03:04,504
Here, in double O six, you'll specify this ADT,
在此，请在双O六中指定此ADT， 

55
00:03:04,504 --> 00:03:07,319
and specify the set of operations or methods
并指定一组操作或方法

56
00:03:07,319 --> 00:03:08,449
in the ADT.
在ADT中。 

57
00:03:08,449 --> 00:03:12,609
And we'll talk about whether these are order end complexity
我们将讨论这些是否是订单结束的复杂性

58
00:03:12,610 --> 00:03:17,250
log end complexity, and compare and contrast different ADTs.
记录最终复杂性，并比较和对比不同的ADT。 

59
00:03:17,250 --> 00:03:20,740
So today's ADT is a heap.
因此，今天的ADT是一大堆。 

60
00:03:20,740 --> 00:03:24,629
And what is the set of operations
什么是操作集

61
00:03:24,629 --> 00:03:28,030
that we'd like to perform on a priority queue?
我们想在优先级队列上执行？ 

62
00:03:28,030 --> 00:03:31,580
So we can use that to motivate the development of the heap.
因此，我们可以使用它来激发堆的开发。 

63
00:03:31,580 --> 00:03:35,080
And those are, insert s x.
然后插入s x。 

64
00:03:35,080 --> 00:03:37,270
So you have a set of elements s, and you
所以你有一组元素s 

65
00:03:37,270 --> 00:03:47,219
want to be able to insert element x into set s.
希望能够将元素x插入set。 

66
00:03:47,419 --> 00:03:51,739
You want to be able to do max of s, which
您希望能够做最大s，这

67
00:03:51,740 --> 00:04:03,129
is return the element of s with the largest key.
返回具有最大键的s的元素。 

68
00:04:03,129 --> 00:04:06,740



69
00:04:06,740 --> 00:04:11,900
And different from max of s is extract
与s的最大值不同的是提取

70
00:04:11,900 --> 00:04:18,579
max of x, which not only returns the element with the largest
 x的最大值，不仅返回最大的元素

71
00:04:18,579 --> 00:04:27,639
key, but also removes it from s.
键，但也将其从中删除。 

72
00:04:27,839 --> 00:04:31,149
So you have a queue, and the person in the queue
所以你有一个队列，队列中的人

73
00:04:31,149 --> 00:04:33,439
was serviced, or the element in the queue was serviced,
已被服务，或队列中的元素已被服务， 

74
00:04:33,439 --> 00:04:36,319
and then removed from the queue.
然后从队列中删除。 

75
00:04:36,319 --> 00:04:41,949
And finally you can imagine changing
最后你可以想象改变

76
00:04:41,949 --> 00:04:46,610
the priority of a particular element x in the set s.
集合s中特定元素x的优先级。 

77
00:04:46,610 --> 00:04:50,740
And this priority, there's an associated key
而这个优先级，有一个关联的密钥

78
00:04:50,740 --> 00:04:54,240
as we have up there with each element.
因为我们每个元素都在那里。 

79
00:04:54,240 --> 00:04:56,699
And that key is called a k.
该键称为k。 

80
00:04:56,899 --> 00:05:13,979
And increase key s x k would increase the value of x's key
并且增加密钥sxk会增加x的密钥的值

81
00:05:13,980 --> 00:05:15,160
to the new value k.
到新值k。 

82
00:05:15,160 --> 00:05:21,699



83
00:05:21,899 --> 00:05:27,989
And k could correspond to, it's just called increase.
 k可以对应，这就是所谓的增加。 

84
00:05:27,990 --> 00:05:31,079
Most of the time, you're increasing the value
大多数时候，您在增加价值

85
00:05:31,279 --> 00:05:32,779
in maybe a particular application.
在特定的应用中

86
00:05:32,779 --> 00:05:34,969
You could have suddenly a decrease key,
您可能突然有一个减小键， 

87
00:05:34,970 --> 00:05:37,379
and you would have to know what the previous value was.
并且您将必须知道以前的值是什么。 

88
00:05:37,579 --> 00:05:39,560
And is just a matter of exactly what
而仅仅是什么问题

89
00:05:39,560 --> 00:05:40,810
operation you want to perform.
您要执行的操作。 

90
00:05:40,810 --> 00:05:46,430
You could call it update, or increment, whatever you like.
您可以根据需要将其称为更新或增量。 

91
00:05:46,430 --> 00:05:50,079
I'm going to spend most of the time here talking
我会花大部分时间在这里聊天

92
00:05:50,079 --> 00:05:55,259
about how you maintain a rep invariant of this data
关于如何维护此数据的表示不变式

93
00:05:55,259 --> 00:05:59,899
structure called the heap, that allows you to do
称为堆的结构，使您可以

94
00:05:59,899 --> 00:06:02,939
these operations in an efficient way.
这些操作都是有效的方式。 

95
00:06:02,939 --> 00:06:05,709
And we'll talk about what the efficiency is,
我们将讨论效率是什么， 

96
00:06:05,709 --> 00:06:08,329
and we'll try to analyze the efficiency of these algorithms
我们将尝试分析这些算法的效率

97
00:06:08,329 --> 00:06:09,029
that we put up.
我们提出来的

98
00:06:09,029 --> 00:06:11,609



99
00:06:11,610 --> 00:06:13,009
So let's talk about a heap.
因此，让我们谈谈一个堆。 

100
00:06:13,209 --> 00:06:17,109
A heap is an implementation of a priority queue.
堆是优先级队列的实现。 

101
00:06:17,110 --> 00:06:21,790
It's amazingly and array structure,
数组结构令人惊讶

102
00:06:21,790 --> 00:06:30,290
except that you're visualizing this array
除了您正在可视化此数组

103
00:06:30,290 --> 00:06:32,939
as a nearly complete binary tree.
作为几乎完整的二叉树。 

104
00:06:32,939 --> 00:06:41,129



105
00:06:41,129 --> 00:06:43,620
And what does that mean exactly?
那到底是什么意思？ 

106
00:06:43,620 --> 00:06:46,290
Well, the best way to understand that
好吧，了解这一点的最好方法

107
00:06:46,290 --> 00:06:48,675
is by looking at an example.
是通过看一个例子。 

108
00:06:48,675 --> 00:06:51,379



109
00:06:51,379 --> 00:06:52,629
We got 10 here, so.
我们这里有10个。 

110
00:06:52,629 --> 00:06:59,338



111
00:06:59,338 --> 00:07:00,588
1, 2, 3, 4, 5, 6, 7, 8, 9, 10.
 1、2、3、4、5、6、7、8、9、10 

112
00:07:00,588 --> 00:07:04,189



113
00:07:04,389 --> 00:07:07,560
So here's my array of 10 elements.
这是我的10个元素的数组。 

114
00:07:07,560 --> 00:07:15,689
And the elements are 16, 14, 10, 8, 7.
元素是16、14、10、8、7。 

115
00:07:15,689 --> 00:07:20,469



116
00:07:20,470 --> 00:07:22,449
So some set of elements that are in random order,
因此，某些元素以随机顺序排列， 

117
00:07:22,649 --> 00:07:26,250
clearly not sorted, and I'm looking at the indices,
显然没有排序，我正在查看索引， 

118
00:07:26,250 --> 00:07:27,720
and I'm looking at the elements.
我正在看元素。 

119
00:07:27,720 --> 00:07:32,000
I'm going to visualize this as a nearly complete binary tree.
我将其可视化为几乎完整的二叉树。 

120
00:07:32,199 --> 00:07:33,939
Is not a full binary tree, because I only
不是完整的二叉树，因为我只

121
00:07:33,939 --> 00:07:36,449
have 10 elements in it, and it would
里面有10个元素， 

122
00:07:36,449 --> 00:07:41,430
have to have 15 elements to be a complete binary tree.
必须具有15个元素才能成为完整的二叉树。 

123
00:07:41,430 --> 00:07:45,389
And we want to be able to do the general case of an arbitrary
我们希望能够做一个任意的一般情况

124
00:07:45,389 --> 00:07:50,399
size array, and so that's why we have nearly complete here.
大小数组，这就是我们在这里几乎完成的原因。 

125
00:07:50,399 --> 00:07:53,639
So what does it mean to visualize this as a tree?
那么将其可视化为树意味着什么？ 

126
00:07:53,639 --> 00:07:59,659
Well, index one is the root of the tree,
好吧，索引一是树的根， 

127
00:07:59,660 --> 00:08:04,370
and that item is the value is 16.
该项目的值为16。 

128
00:08:04,370 --> 00:08:15,399
And what I have are indices 2 and 3 are the children,
我的索引是2和3是孩子， 

129
00:08:15,399 --> 00:08:26,560
and 4, 5, 6, and 7 are the children of 2 and 3.
和4、5、6和7是2和3的孩子。 

130
00:08:26,560 --> 00:08:39,830
And 8, 9, and 10 are the children of 4 and 5,
 8、9和10是4和5的孩子

131
00:08:39,830 --> 00:08:41,100
in this case.
在这种情况下。 

132
00:08:41,100 --> 00:08:42,710
And so that's the picture you want
这就是你想要的照片

133
00:08:42,710 --> 00:08:45,089
to keep in your head for the rest of this lecture.
在本讲座的其余部分中保持头脑清醒。 

134
00:08:45,289 --> 00:08:46,871
Any time you see an array, and you
每当你看到一个数组，你

135
00:08:46,871 --> 00:08:48,579
say we're going to be looking at the heap
说我们要看堆

136
00:08:48,580 --> 00:08:51,479
representation of the array, the picture on the right
数组的表示形式，右侧的图片

137
00:08:51,679 --> 00:08:53,949
tells you what the heap looks like.
告诉您堆的外观。 

138
00:08:53,950 --> 00:08:56,349
And so that I'm not going to fill in all of these.
因此，我将不填写所有这些内容。 

139
00:08:56,549 --> 00:08:58,969
You can, but I'll do a couple.
您可以，但我会做几个。 

140
00:08:58,970 --> 00:09:07,639
So you have 10 here, and 8, 7, et cetera.
所以这里有10个，还有8个，7个等等。 

141
00:09:07,639 --> 00:09:10,389
So that's a heap structure.
这就是一个堆结构。 

142
00:09:10,389 --> 00:09:12,919
So what's nice about this heap structure,
那么这个堆结构有什么好处， 

143
00:09:12,919 --> 00:09:19,549
is that you'll have tree representation of an array,
是您将拥有数组的树表示形式， 

144
00:09:19,549 --> 00:09:23,009
and that lets you do a bunch of interesting things.
这样您就可以做很多有趣的事情。 

145
00:09:23,009 --> 00:09:27,629
What do you get out of this visualization?
您从这种可视化中得到什么？ 

146
00:09:27,629 --> 00:09:40,059
Well, the root of the tree is the first element
好吧，树的根是第一个元素

147
00:09:40,059 --> 00:09:43,609
corresponding to i equals 1.
对应于i等于1。 

148
00:09:43,610 --> 00:09:52,409
The parent of i is i over 2.
我的父母是我2岁以上。 

149
00:09:52,409 --> 00:09:57,179
The left child of i is 2i.
 i的左孩子是2i。 

150
00:09:57,179 --> 00:10:03,000
And the right child of i is 2i plus 1.
我的右子是2i加1。 

151
00:10:03,000 --> 00:10:06,059



152
00:10:06,059 --> 00:10:09,809
So that's essentially what this mapping corresponds to.
因此，这基本上就是该映射所对应的。 

153
00:10:09,809 --> 00:10:15,229
Now on top of that, this is just what a heap corresponds to.
现在最重要的是，这就是堆所对应的。 

154
00:10:15,230 --> 00:10:18,480
We're going to have particular types of heaps
我们将要使用特定类型的堆

155
00:10:18,480 --> 00:10:22,849
that we'll call max-heaps and min-heaps.
我们将其称为max-heaps和min-heaps。 

156
00:10:23,049 --> 00:10:25,269
And as you can imagine, max-heaps and min-heaps
可以想象，最大堆和最小堆

157
00:10:25,269 --> 00:10:28,379
have additional properties on top of the basic
在基本功能之上还有其他属性

158
00:10:28,379 --> 00:10:29,230
keep structures.
保持结构。 

159
00:10:29,230 --> 00:10:31,769
So this is essentially a definition of a heap.
因此，这本质上是堆的定义。 

160
00:10:31,769 --> 00:10:35,019
Now I'm going to define what the max-heap property is.
现在，我将定义什么是max-heap属性。 

161
00:10:35,019 --> 00:10:41,509



162
00:10:41,509 --> 00:10:52,269
And the max-heap property says that the key of a node
而max-heap属性表示节点的密钥

163
00:10:52,269 --> 00:11:00,384
is greater than or equal to the keys of its children.
大于或等于其子项的键。 

164
00:11:00,384 --> 00:11:06,120



165
00:11:06,120 --> 00:11:08,200
OK, that's it.
好，就是这样。 

166
00:11:08,200 --> 00:11:10,960
It's obviously recursive, in the sense
从某种意义上说，这显然是递归的

167
00:11:10,960 --> 00:11:19,220
that you have to have this true for every node in the tree.
您必须对树中的每个节点都具有此true。 

168
00:11:19,220 --> 00:11:23,000
And when you get down to the leaves of the tree,
当你下到树上的叶子时， 

169
00:11:23,000 --> 00:11:25,659
they're not children corresponding to the leaves,
他们不是叶子的孩子

170
00:11:25,659 --> 00:11:27,389
So that's a trivial property.
这是一个琐碎的属性。 

171
00:11:27,389 --> 00:11:31,439
But at higher levels, you're going to have children,
但更高层次上，您将要有孩子， 

172
00:11:31,440 --> 00:11:32,949
and you have to check that.
而你必须检查一下。 

173
00:11:33,149 --> 00:11:36,629
So if you look at this example here,
因此，如果您在此处查看此示例， 

174
00:11:36,629 --> 00:11:38,730
maybe I should fill this whole thing out.
也许我应该把这件事填满。 

175
00:11:38,730 --> 00:11:43,600
A have eight and seven here, and six would be nine.
一个在这里有八个和七个，六个将是九个。 

176
00:11:43,600 --> 00:11:51,509
And I have three over here, and then two, four, one.
我这里有三个，然后是两个，四个，一个。 

177
00:11:51,509 --> 00:11:54,629
So we can look at this and check whether it
所以我们可以看一下并检查是否

178
00:11:54,629 --> 00:11:57,720
has the max-heap property or not.
是否具有max-heap属性。 

179
00:11:57,720 --> 00:11:59,609
Does it have the max-heap property?
它具有max-heap属性吗？ 

180
00:11:59,809 --> 00:12:01,099
This heap?
这个堆吗

181
00:12:01,100 --> 00:12:01,600
Yeah.
是的

182
00:12:01,600 --> 00:12:05,110
All you have to do is look at these nodes.
您要做的就是查看这些节点。 

183
00:12:05,110 --> 00:12:10,210
one, two, three indices, index four, five, six, but you
一，二，三索引，四，五，六索引，但是你

184
00:12:10,210 --> 00:12:11,940
don't have to look at six and seven,
不必看六点和七点

185
00:12:11,940 --> 00:12:14,110
because they don't have any children.
因为他们没有孩子。 

186
00:12:14,110 --> 00:12:16,979
But you could shop with five here,
但是你可以在这里买五个

187
00:12:17,179 --> 00:12:21,599
and you look at the children, and there you go.
然后你看着孩子们，然后你就去了。 

188
00:12:21,600 --> 00:12:25,509
To the parent is greater than or equal to either
给父母大于或等于

189
00:12:25,509 --> 00:12:29,189
of its children, or its only child, in the case of node
如果是节点，则其子节点或唯一子节点的

190
00:12:29,190 --> 00:12:29,929
five.
五。 

191
00:12:30,129 --> 00:12:32,649
And so you have the max-heap property.
因此，您具有max-heap属性。 

192
00:12:32,649 --> 00:12:36,100
So fairly straightforward property.
如此简单明了的属性。 

193
00:12:36,100 --> 00:12:41,940
And you can imagine defining the min-heap property
您可以想象定义min-heap属性

194
00:12:41,940 --> 00:12:43,699
in an equivalent way.
以等效的方式。 

195
00:12:43,899 --> 00:12:45,980
Just replace the greater than or equal to,
只需替换大于或等于， 

196
00:12:45,980 --> 00:12:47,849
with less than or equal to.
小于或等于。 

197
00:12:48,049 --> 00:12:54,029
So right off the bat, what operation
所以马上开始，什么操作

198
00:12:54,029 --> 00:12:59,629
is going to be trivially performed on a max-heap?
将在最大堆上轻松执行？ 

199
00:12:59,629 --> 00:13:03,080
This is kind of trivial question.
这是一个琐碎的问题。 

200
00:13:03,080 --> 00:13:04,715
Yep.
是的

201
00:13:04,715 --> 00:13:06,090
Just finding the biggest element.
只是找到最大的要素。 

202
00:13:06,090 --> 00:13:08,349
Exactly right.
非常正确。 

203
00:13:08,549 --> 00:13:10,329
The max operation.
最大操作。 

204
00:13:10,330 --> 00:13:14,610
Now, what about extract max?
现在，最大提取量呢？ 

205
00:13:14,610 --> 00:13:19,056
Is that trivially performed on a max-heap?
这是在最大堆上完成的吗？ 

206
00:13:19,056 --> 00:13:19,354
No.
没有。 

207
00:13:19,554 --> 00:13:22,109



208
00:13:22,110 --> 00:13:24,220
What do I mean by that?
那是什么意思

209
00:13:24,220 --> 00:13:27,769
When you say, max is trivially performed,
当您说时，max是微不足道的， 

210
00:13:27,769 --> 00:13:30,480
what it means is that you can return the max,
这意味着您可以返回最大值， 

211
00:13:30,480 --> 00:13:33,730
you can find the maximum element, or a maximum element,
您可以找到最大元素或最大元素， 

212
00:13:33,730 --> 00:13:36,849
and you obviously don't modify the heap.
而且您显然不修改堆。 

213
00:13:37,049 --> 00:13:40,689
And the heap stays the same, so it stays a max-heap.
并且堆保持不变，因此保持最大堆。 

214
00:13:40,690 --> 00:13:43,000
In general, when we talk about data structures,
一般来说，当我们谈论数据结构时， 

215
00:13:43,000 --> 00:13:45,049
and this goes back to rep invariance, which
这可以追溯到代表不变性

216
00:13:45,049 --> 00:13:46,990
I've mentioned already, you typically
我已经提到过，你通常

217
00:13:46,990 --> 00:13:49,440
want to maintain this rep invariant.
想要保持这个代表不变。 

218
00:13:49,440 --> 00:13:53,819
And so the rep invariant of our data structure, in this case,
因此，在这种情况下，我们数据结构的rep不变量

219
00:13:54,019 --> 00:13:55,649
is a max-heap property.
是最大堆属性。 

220
00:13:55,649 --> 00:13:56,149
OK.
好。 

221
00:13:56,149 --> 00:13:58,509
So we want to maintain the max-heap property
所以我们要保持max-heap属性

222
00:13:58,509 --> 00:14:00,500
as we modify the heat.
当我们修改热量。 

223
00:14:00,500 --> 00:14:02,610
So if you go from one heap to another,
因此，如果您从一个堆移到另一个堆， 

224
00:14:02,610 --> 00:14:06,229
you start at the max-heap, you want to end with the max-heap.
您从最大堆开始，想要以最大堆结束。 

225
00:14:06,429 --> 00:14:10,109
It makes perfect sense, because in one of the simplest
这是完全合理的，因为在最简单的方法之一中

226
00:14:10,110 --> 00:14:12,190
things that you want to do in a priority queue,
您要在优先级队列中要做的事情， 

227
00:14:12,190 --> 00:14:15,069
is you want to be able to create a priority queue,
您是否希望能够创建优先级队列， 

228
00:14:15,269 --> 00:14:18,480
and you want to be able to run extract max on the priority
并且您希望能够在优先级上运行extract max 

229
00:14:18,480 --> 00:14:20,503
queue, over and over.
排队，一遍又一遍。 

230
00:14:20,703 --> 00:14:23,120
And what that means, is that you take the max element, you
这意味着，您采用max元素， 

231
00:14:23,120 --> 00:14:25,820
delete it, take the next max element, delete it,
删除它，取下一个max元素，删除它， 

232
00:14:25,820 --> 00:14:27,110
and so on and so forth.
等等等等。 

233
00:14:27,110 --> 00:14:30,159
And there you go.
然后你去。 

234
00:14:30,159 --> 00:14:32,490
It's a bit of a preview here, but you
这里有点预览，但是你

235
00:14:32,490 --> 00:14:35,000
could imagine that if you did that, you would
可以想象，如果您这样做，您会

236
00:14:35,000 --> 00:14:40,460
get a sorted list of elements in decreasing order.
以降序获得元素的排序列表。 

237
00:14:40,460 --> 00:14:42,642
So you see the connection to sorting,
这样您就可以看到排序的关联， 

238
00:14:42,642 --> 00:14:44,850
because you could imagine that once we have this heap
因为你可以想象一旦我们有了这个堆

239
00:14:44,850 --> 00:14:47,609
structure, and we can maintain the max-heap property,
结构，我们可以保持max-heap属性， 

240
00:14:47,809 --> 00:14:51,009
that we could continually run extract max on it.
这样我们就可以继续对其运行extract max。 

241
00:14:51,009 --> 00:14:53,789
And if you could build extract max in an efficient way,
而且，如果您可以高效地构建Extract Max， 

242
00:14:53,789 --> 00:14:56,649
you might have a fantastic sorting algorithm.
您可能有一个很棒的排序算法。 

243
00:14:56,649 --> 00:14:59,569



244
00:14:59,570 --> 00:15:04,079
So, the big question that really remains,
因此，真正的大问题仍然存在， 

245
00:15:04,279 --> 00:15:07,519
is how do we maintain the max-heap property
是如何维护max-heap属性

246
00:15:07,519 --> 00:15:10,370
as we modify the heap?
当我们修改堆？ 

247
00:15:10,370 --> 00:15:15,029
And the other question, which I haven't answered
还有另一个问题，我没有回答

248
00:15:15,029 --> 00:15:28,759
is-- this array that turns out it was a max-heap,
是-这个数组证明是最大堆， 

249
00:15:28,759 --> 00:15:31,409
but it's quite possible that I have
但是我很有可能

250
00:15:31,409 --> 00:15:33,884
a trivial example of an array.
一个简单的数组示例。 

251
00:15:33,884 --> 00:15:40,960



252
00:15:40,960 --> 00:15:42,210
In fact, let me make this one.
实际上，让我做这个。 

253
00:15:42,210 --> 00:15:44,830



254
00:15:44,830 --> 00:15:46,870
That is not a max-heap.
那不是最大的堆。 

255
00:15:46,870 --> 00:15:49,720
It's not a max-heap, it's not a min-heap, it's neither.
这不是最大堆，也不是最小堆，也不是。 

256
00:15:49,720 --> 00:15:51,729
Right? it's just a heap.
对？这只是一堆。 

257
00:15:51,929 --> 00:15:56,739
So if I just transform, or visualize
因此，如果我只是变换或可视化

258
00:15:56,740 --> 00:16:01,200
I should say, this array as a heap, I don't have a max-heap,
我应该说，这个数组是堆，我没有最大堆， 

259
00:16:01,200 --> 00:16:02,690
I don't have a min-heap.
我没有最小的堆。 

260
00:16:02,690 --> 00:16:07,076
So if I'm very interested in sorting, and I am,
因此，如果我对排序非常感兴趣，而我

261
00:16:07,076 --> 00:16:08,450
there's this another thing that's
还有另一件事是

262
00:16:08,450 --> 00:16:10,710
sort of missing here that we have to work on,
我们必须努力解决的问题， 

263
00:16:10,710 --> 00:16:14,469
which is how are we going to build a max-heap out
我们将如何建立最大堆

264
00:16:14,669 --> 00:16:18,269
of an initially unsorted array.
最初未排序的数组。 

265
00:16:18,269 --> 00:16:21,210
Which may or may not turn into a max-heap.
可能会或可能不会变成最大堆。 

266
00:16:21,210 --> 00:16:23,860
This trivially happened to be exactly the right thing,
这琐碎恰好是正确的事情， 

267
00:16:23,860 --> 00:16:26,609
because I picked it, and it turned into a max-heap
因为我选了它，然后变成了最大堆

268
00:16:26,809 --> 00:16:28,719
just by visualizing it.
只是通过可视化它。 

269
00:16:28,720 --> 00:16:30,229
But it's quite possible that you have
但是你很有可能

270
00:16:30,429 --> 00:16:33,019
arrays that are input to your sorting algorithm that
输入到您的排序算法的数组

271
00:16:33,019 --> 00:16:33,819
look like that.
看起来像那样。 

272
00:16:33,820 --> 00:16:37,500



273
00:16:37,500 --> 00:16:41,059
OK, so let's dive into heap operations.
好的，让我们深入研究堆操作。 

274
00:16:41,059 --> 00:16:46,909
I'm going to have spend some time describing to you
我将花一些时间向您描述

275
00:16:46,909 --> 00:16:50,919
a bunch of different methods that you would call on a heap.
一堆您将在堆上调用的不同方法。 

276
00:16:50,919 --> 00:16:53,779
And all of these methods are going
所有这些方法都在

277
00:16:53,779 --> 00:16:56,439
to have to maintain our representation
必须保持我们的代表性

278
00:16:56,440 --> 00:16:59,840
invariant of the max-heap property.
 max-heap属性的不变量。 

279
00:16:59,840 --> 00:17:02,450
So what are the heap operations that we
那么我们要做的堆操作是什么

280
00:17:02,450 --> 00:17:08,910
have to implement and analyze the complexity for?
必须实施和分析复杂性？ 

281
00:17:08,910 --> 00:17:13,368
Well, we're going to have build-max-heap
好吧，我们将要建立build-max-heap 

282
00:17:13,568 --> 00:17:24,129
which produces a max-heap from an arbitrary or unordered
从任意或无序产生最大堆

283
00:17:24,130 --> 00:17:24,630
array.
数组。 

284
00:17:24,630 --> 00:17:28,190



285
00:17:28,190 --> 00:17:33,420
So somehow I got to turn this into, for example,
因此，我必须以某种方式将其转化为

286
00:17:33,420 --> 00:17:37,509
four, two, one.
四，二，一

287
00:17:37,509 --> 00:17:40,509
Which is in effect, sorting this array.
实际上，对这个数组进行排序。 

288
00:17:40,509 --> 00:17:41,569
Or changing the order.
或更改顺序。 

289
00:17:41,569 --> 00:17:44,490
Maybe not fully sorting it, but changing the order.
可能没有完全排序，而是更改了顺序。 

290
00:17:44,490 --> 00:17:47,240
So that's what I have to do, and build-max-heap
这就是我要做的，并且建立最大堆

291
00:17:47,240 --> 00:17:51,380
is going to have to do that.
将必须这样做。 

292
00:17:51,380 --> 00:17:59,660
In order to do build-max-heap, the first procedure
为了做build-max-heap，第一步

293
00:17:59,660 --> 00:18:05,119
that I'm going to describe to you, is called max-heapify.
我要向您描述的称为max-heapify。 

294
00:18:05,319 --> 00:18:06,659
Heapify.
堆肥。 

295
00:18:06,660 --> 00:18:11,440
Sounds a little strange, but I guess
听起来有些奇怪，但我猜

296
00:18:11,440 --> 00:18:13,970
you can -ify pretty much anything.
您几乎可以使任何东西变身。 

297
00:18:13,970 --> 00:18:24,259
So you correct a single violation
因此，您可以纠正一个违规情况

298
00:18:24,259 --> 00:18:41,440
of the heap property in a subtree, a subtree's root.
子树（子树的根）中的heap属性。 

299
00:18:41,440 --> 00:18:44,160



300
00:18:44,160 --> 00:18:48,250
And I'll explain what I mean by that in just a minute.
我将在一分钟内解释我的意思。 

301
00:18:48,250 --> 00:18:51,279
So max-heapify is the fundamental operation
所以最大堆是最基本的操作

302
00:18:51,279 --> 00:18:52,889
that we have to understand here.
我们必须在这里理解。 

303
00:18:52,890 --> 00:18:56,150
And we're going to use it over and over.
我们将一遍又一遍地使用它。 

304
00:18:56,150 --> 00:18:59,589
What it does, is take something that
它所做的就是拿一些东西

305
00:18:59,789 --> 00:19:02,259
is not a heap, not a max-heap.
不是堆，也不是最大堆。 

306
00:19:02,259 --> 00:19:05,155
When I say not a heap from now on,
当我说从现在开始不再是一堆东西时， 

307
00:19:05,155 --> 00:19:06,779
pretend that I'm saying not a max-heap.
假装我不是在说最大堆。 

308
00:19:06,779 --> 00:19:08,579
We're only going to be talking about max-heaps
我们只会谈论最大堆

309
00:19:08,579 --> 00:19:09,788
for the rest of this lecture.
在本讲座的其余部分。 

310
00:19:09,788 --> 00:19:13,319



311
00:19:13,319 --> 00:19:17,500
What max-heapify does, is take something
 max-heapify要做的是采取一些措施

312
00:19:17,500 --> 00:19:20,250
that is not quite a max-heap.
那不是最大的堆。 

313
00:19:20,250 --> 00:19:21,769
It can't take anything arbitrary.
它不能随心所欲。 

314
00:19:21,769 --> 00:19:23,519
It's going to take something where there's
需要采取一些措施

315
00:19:23,519 --> 00:19:26,869
a single violation of the max-heap property
一次违反了max-heap属性

316
00:19:26,869 --> 00:19:32,439
at some subtree of this heap that is given to you,
在给你的这个堆的某个子树上， 

317
00:19:32,440 --> 00:19:34,490
and there's a single violation of that.
而且有一个违规行为。 

318
00:19:34,490 --> 00:19:36,419
And it's going to fix that.
它将解决此问题。 

319
00:19:36,619 --> 00:19:40,479
And we need to be able to do this recursively
我们需要能够递归地执行此操作

320
00:19:40,480 --> 00:19:42,890
at different levels to go build a max-heap
在不同的级别去建立最大堆

321
00:19:42,890 --> 00:19:45,622
from an unordered array.
来自无序数组。 

322
00:19:45,622 --> 00:19:46,879
Then once you have that, you can do
然后，一旦有了，就可以做

323
00:19:47,079 --> 00:19:50,429
all sorts of things like insert and extract max, and heap sort,
各种各样的事情，例如插入和提取最大值，以及堆排序， 

324
00:19:50,430 --> 00:19:52,220
and so on and so forth.
等等等等。 

325
00:19:52,220 --> 00:19:55,880
So let's take a look at max-heapify using an example.
因此，让我们使用一个示例来看看max-heapify。 

326
00:19:55,880 --> 00:20:00,890
I'm not going to write pseudocode for max-heapify.
我不会为max-heapify编写伪代码。 

327
00:20:00,890 --> 00:20:05,659
I'll run through an example, and the pseudocode is in the notes.
我将通过一个示例进行演示，并且伪代码在注释中。 

328
00:20:05,859 --> 00:20:07,659
The big assumption, and you think
大的假设，你认为

329
00:20:07,660 --> 00:20:13,480
of this as a precondition, for running max-heapify,
这是运行max-heapify的前提， 

330
00:20:13,480 --> 00:20:30,640
is the trees rooted at left i and right i are max-heaps.
是根植于左侧i和右侧i的树是最大堆。 

331
00:20:30,640 --> 00:20:35,420



332
00:20:35,420 --> 00:20:40,740
So max-heapify is going to look like a comma i.
因此，max-heapify看起来像一个逗号。 

333
00:20:40,740 --> 00:20:45,589
a is simply the array, and i is the index.
 a只是数组，而i是索引。 

334
00:20:45,589 --> 00:20:48,639
Max-heapify is willing to, you're
 Max-heapify愿意，您

335
00:20:48,640 --> 00:20:53,639
allowed to crash and not do anything useful
允许崩溃而没有做任何有用的事情

336
00:20:53,839 --> 00:20:57,289
if this precondition is violated in max-heapify.
如果在max-heapify中违反了此前提条件。 

337
00:20:57,289 --> 00:21:00,720
But if the precondition is true, then what you have to do
但是如果前提是正确的，那么您必须要做的是

338
00:21:00,720 --> 00:21:03,569
is, you have to return a max-heap correcting
是，您必须返回最大堆校正

339
00:21:03,569 --> 00:21:05,336
this violation.
这种侵犯。 

340
00:21:05,336 --> 00:21:06,170
That's the contract.
那是合同。 

341
00:21:06,170 --> 00:21:11,160



342
00:21:11,160 --> 00:21:13,359
So let's take a look at an example.
因此，让我们看一个例子。 

343
00:21:13,559 --> 00:21:16,809
I think what I want to do is start over here.
我想我想做的就是从这里开始。 

344
00:21:16,809 --> 00:21:20,669



345
00:21:20,670 --> 00:21:22,351
I want you to see all of the steps here.
我希望您在这里看到所有步骤。 

346
00:21:22,551 --> 00:21:24,259
So we'll take a simple example, and we'll
因此，我们将举一个简单的例子， 

347
00:21:24,259 --> 00:21:25,410
run through max-heapify.
通过最大堆运行。 

348
00:21:25,410 --> 00:21:33,349



349
00:21:33,549 --> 00:22:05,720
And let's take a look at 16, four--
让我们来看看16 

350
00:22:05,720 --> 00:22:09,490
I'm just going to draw the indices for this first example,
我将为第一个示例绘制索引， 

351
00:22:09,490 --> 00:22:10,490
and then I won't bother.
然后我就不会打扰

352
00:22:10,490 --> 00:22:13,230



353
00:22:13,230 --> 00:22:15,339
So there you go.
所以你去了。 

354
00:22:15,339 --> 00:22:18,059
Is this a max-heap?
这是最大堆吗？ 

355
00:22:18,059 --> 00:22:18,710
No.
没有。 

356
00:22:18,710 --> 00:22:21,440
Because right here, I've got a problem.
因为在这里，我遇到了问题。 

357
00:22:21,440 --> 00:22:27,170
4 is less than 14, therefore I have a violation.
 4小于14，因此我违反了。 

358
00:22:27,170 --> 00:22:38,519
And so, if you look at the call max-heapify A comma 2,
因此，如果您查看呼叫max-heapify A逗号2， 

359
00:22:38,519 --> 00:22:41,329
this is an index 2, and all you have to do
这是索引2，您需要做的所有事情

360
00:22:41,329 --> 00:22:43,449
is to look at this subtree.
是看这个子树。 

361
00:22:43,450 --> 00:22:47,630
And what you need to be satisfied in order
而您需要满足的条件

362
00:22:47,630 --> 00:22:54,400
to run max-heapify, is that the subtrees of nodes index two,
要运行max-heapify，是节点的子树索引为2， 

363
00:22:54,400 --> 00:22:57,630
which is this four node, are max-heaps.
这是这四个节点，是最大堆。 

364
00:22:57,630 --> 00:23:00,380
And if you go look below, you see that this is a max-heap
如果您去下面看，您会发现这是一个最大堆

365
00:23:00,380 --> 00:23:02,524
and that's a max-heap.
那是最大的堆。 

366
00:23:02,724 --> 00:23:04,099
Most of the time, by the way, you
顺便说一句，大多数时候

367
00:23:04,099 --> 00:23:06,139
will be sort of working bottom up,
将自下而上地工作， 

368
00:23:06,140 --> 00:23:08,880
and that's why this is going to make sense.
这就是为什么这很有意义。 

369
00:23:08,880 --> 00:23:10,579
This will all work out, because leaves
一切都会解决，因为离开

370
00:23:10,779 --> 00:23:13,329
are by definition max-heaps.
根据定义是最大堆。 

371
00:23:13,329 --> 00:23:15,289
Because you don't have to check anything.
因为您不必检查任何东西。 

372
00:23:15,289 --> 00:23:17,099
When you put two leaves together,
当你把两片叶子放在一起时

373
00:23:17,099 --> 00:23:22,209
and you want to create a tree like that, or a heap like that,
而您想要创建像这样的树或像这样的堆， 

374
00:23:22,210 --> 00:23:24,990
then you run max-heapify.
然后运行max-heapify。 

375
00:23:24,990 --> 00:23:27,759
And then when you have a couple different max-heaps,
然后，当您有几个不同的最大堆时， 

376
00:23:27,759 --> 00:23:29,349
and you want to put them together
你想把它们放在一起

377
00:23:29,349 --> 00:23:34,288
to make it a bigger max-heap, you'd have run max-heapify.
为了使其更大，可以运行max-heapify。 

378
00:23:34,288 --> 00:23:35,829
So that's the way it's going to work.
这就是它的工作方式。 

379
00:23:35,829 --> 00:23:39,471
So you want to do a max-heapify A comma 2.
所以你想做一个最大堆的逗号2。 

380
00:23:39,471 --> 00:23:41,430
One of the things that's going to be important,
一件很重要的事情， 

381
00:23:41,430 --> 00:23:45,039
not in this example, but when we get to sorting,
不是在此示例中，而是在进行排序时， 

382
00:23:45,039 --> 00:23:48,720
is that we want to know what the size of the heap is.
是我们想知道堆的大小。 

383
00:23:48,720 --> 00:23:51,819
And in this case, the heap size is 10.
在这种情况下，堆大小为10。 

384
00:23:51,819 --> 00:23:55,169
So, what does max-heapify do?
那么，max-heapify有什么作用？ 

385
00:23:55,170 --> 00:24:00,259
Well, all max-heapify does is exchanges elements.
好吧，max-heapify所做的只是交换元素。 

386
00:24:00,259 --> 00:24:03,410
And so, if you looked at the code for max-heapify,
因此，如果您查看max-heapify的代码， 

387
00:24:03,410 --> 00:24:06,700
and you walked through it, this is what it would do.
然后您浏览了它，这就是它的作用。 

388
00:24:06,700 --> 00:24:09,160
You're going to look at 4 and 14,
您将要看4和14 

389
00:24:09,160 --> 00:24:10,629
and it's going to say, OK, I'm going
会说，好的，我要

390
00:24:10,829 --> 00:24:12,309
to look at both my children.
看我两个孩子

391
00:24:12,309 --> 00:24:16,289
And I'm going to go ahead and exchange with the bigger child.
我将继续与大孩子交流。 

392
00:24:16,289 --> 00:24:21,659
So I'm going to exchange AA[2] with AA[4].
因此，我要与AA [4]交换AA [2]。 

393
00:24:21,660 --> 00:24:24,720



394
00:24:24,720 --> 00:24:35,450
And what that would do is, take this, make this 4,
然后要做的就是把这个变成4 

395
00:24:35,450 --> 00:24:37,740
and make this 14.
并制作这个14。 

396
00:24:37,740 --> 00:24:40,630
And that would be step one.
那将是第一步。 

397
00:24:40,630 --> 00:24:43,569
And then when you get to this point,
然后到了这一点， 

398
00:24:43,769 --> 00:24:48,700
recursively, you'd realize that the max-heap property
递归地，您将意识到max-heap属性

399
00:24:48,700 --> 00:24:51,460
at this level is violated.
在这个级别被违反。 

400
00:24:51,460 --> 00:25:06,269
And so you would go ahead and call max-heapify A comma 4.
因此，您将继续调用max-heapify A逗号4。 

401
00:25:06,269 --> 00:25:12,379
And when that happens, that call happens,
当那件事发生的时候，那个电话就发生了， 

402
00:25:12,380 --> 00:25:16,129
you're going to look at the two children corresponding
您将要查看对应的两个孩子

403
00:25:16,329 --> 00:25:19,679
to this little subtree there, and you're
到那里的这个小子树，你

404
00:25:19,680 --> 00:25:21,609
going to do the exchange.
去做交流。 

405
00:25:21,809 --> 00:25:24,899
You're going to have 8 here and 4 here.
您将在这里有8个，在这里有4个。 

406
00:25:24,900 --> 00:25:36,419
So you would exchange AA[4] with AA[8].
因此，您可以将AA [4]与AA [8]交换。 

407
00:25:36,619 --> 00:25:44,769
And now you're done, so there's no more calls.
现在您已经完成了，因此不再有通话。 

408
00:25:44,769 --> 00:25:46,869
So, fairly straightforward.
因此，相当简单。 

409
00:25:46,869 --> 00:25:49,509
It's actually not any more complicated than this.
实际上，没有比这更复杂的了。 

410
00:25:49,509 --> 00:25:51,839
There may be many steps.
可能有很多步骤。 

411
00:25:51,839 --> 00:25:54,439
What might happen is that you'd have to go all the way down
可能会发生的是，您必须一直走下去

412
00:25:54,440 --> 00:25:55,379
to the leaves.
到树叶。 

413
00:25:55,579 --> 00:25:58,689
And in this case, you went a couple of steps,
在这种情况下，您走了几步， 

414
00:25:58,690 --> 00:26:00,578
and then you got to stop.
然后你必须停下来。 

415
00:26:00,578 --> 00:26:02,369
But obviously, you could have a large heap,
但显然，您可能会有一大堆， 

416
00:26:02,369 --> 00:26:04,629
and it could take a bunch of time.
这可能会花费很多时间。 

417
00:26:04,630 --> 00:26:10,480
So, what is the complexity of max-heapify?
那么，max-heapify的复杂性是什么？ 

418
00:26:10,480 --> 00:26:10,980
Anybody?
有人吗

419
00:26:10,980 --> 00:26:13,854



420
00:26:13,854 --> 00:26:14,354
Yeah.
是的

421
00:26:14,354 --> 00:26:15,347
Back there.
回到那里。 

422
00:26:15,347 --> 00:26:16,763
AUDIENCE: Ultimately, potentially,
听众：最终，潜在地， 

423
00:26:16,763 --> 00:26:18,692
if the tree is totally upside down,
如果树完全倒挂， 

424
00:26:18,692 --> 00:26:23,900
you could potentially switch every node to make it order in.
您可能会切换每个节点来订购它。 

425
00:26:23,900 --> 00:26:28,108
PROFESSOR: Every node to make it order in.
教授：将其排序的每个节点。 

426
00:26:28,308 --> 00:26:29,099
Everybody, anybody.
每个人，任何人。 

427
00:26:29,099 --> 00:26:31,529
Do you have a different answer?
您有其他答案吗？ 

428
00:26:31,529 --> 00:26:32,480
AUDIENCE: Log n.
听众：登录n。 

429
00:26:32,480 --> 00:26:33,105
PROFESSOR: Why?
教授：为什么？ 

430
00:26:33,105 --> 00:26:34,086
Why is it log n.
为什么登录n。 

431
00:26:34,086 --> 00:26:36,170
AUDIENCE: Because I think the worst case scenario,
听众：因为我认为最坏的情况是， 

432
00:26:36,170 --> 00:26:39,845
all of your-- the worst case scenario you
您所有-最坏的情况

433
00:26:39,845 --> 00:26:42,539
would have [INAUDIBLE] on the left-hand side,
在左侧会显示[音频不清晰]， 

434
00:26:42,539 --> 00:26:44,500
[INAUDIBLE] right-hand side.
 [听不清]右侧。 

435
00:26:44,500 --> 00:26:48,145
And it would be skewed.
而且它会歪斜。 

436
00:26:48,145 --> 00:26:48,645
[INAUDIBLE]
 [听不清] 

437
00:26:48,645 --> 00:27:08,864



438
00:27:08,864 --> 00:27:10,779
PROFESSOR: So you're arguing that the solution
教授：所以您在争论解决方案

439
00:27:10,779 --> 00:27:14,190
to the recurrence gives you a logarithmic complexity.
复发给您带来了对数复杂性。 

440
00:27:14,190 --> 00:27:14,690
Alright.
好的。 

441
00:27:14,690 --> 00:27:16,139
Not quite.
不完全的。 

442
00:27:16,339 --> 00:27:18,099
There's an easier way of arguing this.
有一种更简单的方法可以解决这个问题。 

443
00:27:18,099 --> 00:27:18,599
this Yeah.
是的

444
00:27:18,599 --> 00:27:20,029
Back there.
回到那里。 

445
00:27:20,029 --> 00:27:20,990
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

446
00:27:20,990 --> 00:27:24,829



447
00:27:24,829 --> 00:27:25,839
PROFESSOR: That's right.
教授：是的。 

448
00:27:25,839 --> 00:27:26,791
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

449
00:27:26,791 --> 00:27:30,679



450
00:27:30,680 --> 00:27:31,680
PROFESSOR: That's right.
教授：是的。 

451
00:27:31,680 --> 00:27:32,630
So what is the complexity?
那么复杂度是多少？ 

452
00:27:32,630 --> 00:27:33,170
AUDIENCE: Log n.
听众：登录n。 

453
00:27:33,170 --> 00:27:33,677
PROFESSOR: Log n.
教授：登录n。 

454
00:27:33,877 --> 00:27:34,710
Great.
大。 

455
00:27:34,710 --> 00:27:36,355
Excellent.
优秀的。 

456
00:27:36,355 --> 00:27:37,480
Definitely worth a cushion.
绝对值得一坐。 

457
00:27:37,480 --> 00:27:40,059



458
00:27:40,059 --> 00:27:41,649
Missed you by that much.
非常想念你。 

459
00:27:41,650 --> 00:27:42,349
AUDIENCE: Thank you.
听众：谢谢。 

460
00:27:42,549 --> 00:27:44,259
PROFESSOR: It's pretty soft, by the way.
教授：顺便说一句，它很柔软。 

461
00:27:44,259 --> 00:27:44,759
Right.
对。 

462
00:27:44,759 --> 00:27:45,740
OK.
好。 

463
00:27:45,740 --> 00:27:48,530
So, if I hit somebody, they get a cushion.
因此，如果我撞到某人，他们会得到缓冲。 

464
00:27:48,530 --> 00:27:49,029
OK.
好。 

465
00:27:49,029 --> 00:27:54,129



466
00:27:54,130 --> 00:27:55,169
That's exactly right.
没错

467
00:27:55,369 --> 00:27:58,279
Thanks for that description.
感谢您的描述。 

468
00:27:58,279 --> 00:28:01,769
So, first off, there's two important aspects
因此，首先，有两个重要方面

469
00:28:01,769 --> 00:28:03,430
to this argument.
这个论点。 

470
00:28:03,430 --> 00:28:05,180
The first thing is, that we're visualizing
首先是，我们正在可视化

471
00:28:05,180 --> 00:28:08,505
this is a nearly complete binary tree.
这是几乎完整的二叉树。 

472
00:28:08,505 --> 00:28:10,310
It is not an unbalanced tree.
它不是一棵不平衡的树。 

473
00:28:10,510 --> 00:28:11,009
Alright?
好的？ 

474
00:28:11,009 --> 00:28:13,400
We'll talk about unbalanced trees and balanced trees
我们将讨论不平衡树和平衡树

475
00:28:13,400 --> 00:28:14,930
in the next couple of lectures.
在接下来的两节课中。 

476
00:28:14,930 --> 00:28:18,380
But the visualization of a heap is a nearly complete binary
但是堆的可视化几乎是完整的二进制文件

477
00:28:18,380 --> 00:28:18,880
tree.
树。 

478
00:28:18,880 --> 00:28:20,730
And, in fact, if you had 15 elements,
而且，实际上，如果您有15个元素， 

479
00:28:20,730 --> 00:28:23,009
it would be a perfect binary tree.
这将是一个完美的二叉树。 

480
00:28:23,009 --> 00:28:28,220
So the good news is, that the height of this visualization
好消息是，这种可视化的高度

481
00:28:28,220 --> 00:28:31,779
tree is bounded by log n.
树以log n为边界。 

482
00:28:31,779 --> 00:28:33,460
That's the good news.
那是个好消息。 

483
00:28:33,460 --> 00:28:35,509
And you want to exploit that good news
而你想利用这个好消息

484
00:28:35,509 --> 00:28:39,750
by creating algorithms that go level by level.
通过创建逐级执行的算法。 

485
00:28:39,750 --> 00:28:42,549
If you can do that, you're going to have logarithmic complexity
如果能做到，那将有对数复杂性

486
00:28:42,549 --> 00:28:44,569
algorithms.
算法。 

487
00:28:44,569 --> 00:28:45,809
So that was one aspect of it.
这就是它的一方面。 

488
00:28:45,809 --> 00:28:48,419
The other aspect of it, is the key assumption
另一个方面是关键假设

489
00:28:48,420 --> 00:28:50,990
that we're making, with respect to build-max-heap,
关于build-max-heap，我们正在做的

490
00:28:50,990 --> 00:28:53,289
that there was a single violation.
只有一次违规。 

491
00:28:53,289 --> 00:28:57,730
It is true that the answer that was given that was order n,
确实，给出的答案是n阶， 

492
00:28:57,730 --> 00:28:59,220
would be a problem.
会是个问题。 

493
00:28:59,220 --> 00:29:01,930
I could set it up so that's actually the right answer,
我可以进行设置，这样实际上是正确的答案， 

494
00:29:01,930 --> 00:29:05,029
if I did not have this assumption-- where
如果我没有这个假设-哪里

495
00:29:05,029 --> 00:29:08,470
do I have that here-- assume that the trees rooted at left i
我在这里有那个吗-假设树根在我的左边

496
00:29:08,470 --> 00:29:10,095
and right i are max-heaps.
对，我是最大堆。 

497
00:29:10,095 --> 00:29:11,720
So maybe that's what you were thinking.
所以也许这就是您的想法。 

498
00:29:11,720 --> 00:29:13,569
But this is a key assumption.
但这是一个关键的假设。 

499
00:29:13,569 --> 00:29:16,069
This is going back and like making
这回去就像

500
00:29:16,069 --> 00:29:18,019
connections between classes.
类之间的连接。 

501
00:29:18,019 --> 00:29:20,759
This is a precondition that makes
这是使

502
00:29:20,759 --> 00:29:22,500
the algorithm more efficient.
该算法更加有效。 

503
00:29:22,500 --> 00:29:25,339
Makes the implementation easier.
使实施更容易。 

504
00:29:25,339 --> 00:29:28,589
And this precondition essentially
前提是

505
00:29:28,589 --> 00:29:31,601
says that you have to just go down and do a number of steps,
说你必须走下去并做一些步骤， 

506
00:29:31,602 --> 00:29:33,984
that's the number of levels in the tree, which is logarithmic.
那是树中的级别数，它是对数的。 

507
00:29:34,184 --> 00:29:36,799



508
00:29:36,799 --> 00:29:40,389
So that's the story here with the max-heapify.
这就是max-heapify的故事。 

509
00:29:40,390 --> 00:29:44,730
It's order log n, in terms of complexity.
就复杂性而言，它是订单日志n。 

510
00:29:44,730 --> 00:29:46,640
That's the number of steps that you have.
那就是您要执行的步骤数。 

511
00:29:46,640 --> 00:29:53,740
And it's a basic building block for all of the other algorithms
这是所有其他算法的基本构建块

512
00:29:53,740 --> 00:29:57,490
that we look at for the rest of this lecture, and in section
我们将在本讲座的其余部分以及本节中

513
00:29:57,490 --> 00:30:00,059
tomorrow.
明天。 

514
00:30:00,059 --> 00:30:05,609
Let's talk about how you would take max-heapify and use
让我们谈谈如何使用max-heapify和使用

515
00:30:05,609 --> 00:30:08,299
it to do build-max-heap.
做build-max-heap。 

516
00:30:08,299 --> 00:30:11,049
So the first step now, let's say that we
所以现在第一步，我们说

517
00:30:11,049 --> 00:30:14,509
want to go and get a nice sorting algorithm.
想去获得一个不错的排序算法。 

518
00:30:14,509 --> 00:30:17,710
We don't like insertion sort, we don't like merge sort.
我们不喜欢插入排序，我们不喜欢合并排序。 

519
00:30:17,710 --> 00:30:20,970
We'd like to get a heap-based sorting algorithm.
我们想要一个基于堆的排序算法。 

520
00:30:20,970 --> 00:30:24,059
One of the things that we need to do, as I said,
正如我所说，我们要做的一件事是， 

521
00:30:24,059 --> 00:30:27,049
is to take an unordered array, and turn it
是取一个无序数组，然后将其旋转

522
00:30:27,049 --> 00:30:31,250
into a max-heap, which is a non-trivial thing to do.
变成最大堆，这是不平凡的事情。 

523
00:30:31,250 --> 00:30:35,279
And once we do that, we can do this extract-max deal
一旦完成，我们就可以进行extract-max处理

524
00:30:35,279 --> 00:30:37,399
to sort the array.
对数组进行排序。 

525
00:30:37,400 --> 00:30:45,599
So the first step is, we want to convert an array A 1
所以第一步是，我们要转换数组A 1 

526
00:30:45,799 --> 00:30:51,940
through n into a max-heap.
通过n到最大堆。 

527
00:30:51,940 --> 00:30:53,720
And the key word here is max-heap,
这里的关键词是最大堆

528
00:30:53,720 --> 00:30:57,839
because every array can be visualized as a heap.
因为每个数组都可以可视化为一个堆。 

529
00:30:57,839 --> 00:31:02,750
And I am going write the pseudocode for build-max-heap,
我将为build-max-heap编写伪代码， 

530
00:31:02,750 --> 00:31:06,190
because it's just two lines of code.
因为只有两行代码。 

531
00:31:06,190 --> 00:31:11,369
And that's about the limit of a size of a program
那就是程序大小的限制

532
00:31:11,569 --> 00:31:15,339
I can really understand, or explain, I should say.
我应该说，我真的可以理解或解释。 

533
00:31:15,339 --> 00:31:19,698



534
00:31:19,699 --> 00:31:20,990
And this is what it looks like.
这就是它的样子。 

535
00:31:20,990 --> 00:31:30,960



536
00:31:30,960 --> 00:31:31,460
Alright.
好的。 

537
00:31:31,460 --> 00:31:32,569
that's it.
而已。 

538
00:31:32,569 --> 00:31:40,419
Build-max-heap says go from i equals n, by 2, down to 1.
 Build-max-heap说从i等于n乘以2，下降到1。 

539
00:31:40,420 --> 00:31:44,139
Max-heapify A of i.
 i的最大堆A。 

540
00:31:44,339 --> 00:31:51,939
So someone explain to me why I can start with n over 2,
所以有人向我解释了为什么我可以从2开始

541
00:31:51,940 --> 00:31:55,019
and why I'm going down to 1.
以及为什么我下降到1。 

542
00:31:55,019 --> 00:31:55,519
Yep.
是的

543
00:31:55,519 --> 00:31:56,948
I saw you first.
我第一次见到你

544
00:31:56,948 --> 00:31:57,900
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

545
00:31:57,900 --> 00:32:00,583



546
00:32:00,583 --> 00:32:01,708
PROFESSOR: Leaves are good.
教授：叶子很好。 

547
00:32:01,708 --> 00:32:02,649
Leaves are good.
叶子很好。 

548
00:32:02,849 --> 00:32:05,449
I'll let you go on in a second.
我让你继续。 

549
00:32:05,450 --> 00:32:14,519
Leaves are good, because if you look at elements A of n over 2,
叶子是好的，因为如果您看n的元素A超过2， 

550
00:32:14,519 --> 00:32:21,451
plus 1 through n, are all leaves.
加1到n，都是叶子。 

551
00:32:21,451 --> 00:32:22,535
That's a good observation.
这是一个很好的观察。 

552
00:32:22,535 --> 00:32:25,509



553
00:32:25,509 --> 00:32:28,089
And this is true for any array.
这对于任何数组都是如此。 

554
00:32:28,089 --> 00:32:29,629
It doesn't matter what n is.
 n是什么都没关系。 

555
00:32:29,630 --> 00:32:31,880
Doesn't have the power of 2, or 2 [INAUDIBLE] minus 1,
没有2的幂或2 [听不清]减1， 

556
00:32:31,880 --> 00:32:33,170
or anything like that.
或类似的东西。 

557
00:32:33,170 --> 00:32:34,879
And leaves a good, because they automatically
并留下一个好的，因为它们会自动

558
00:32:35,079 --> 00:32:38,389
satisfy the backseat property.
满足后座属性。 

559
00:32:38,390 --> 00:32:39,218
Continue.
继续。 

560
00:32:39,218 --> 00:32:40,100
AUDIENCE: OK. [INAUDIBLE].
听众：好的。 [听不清]。 

561
00:32:40,300 --> 00:32:54,910



562
00:32:54,911 --> 00:32:56,721
PROFESSOR: That's exactly right.
教授：完全正确。 

563
00:32:56,721 --> 00:32:57,220
Beautiful.
美丽。 

564
00:32:57,220 --> 00:33:00,009



565
00:33:00,009 --> 00:33:03,259
I won't hit anybody here.
我不会在这里打任何人。 

566
00:33:03,259 --> 00:33:04,730
So that's it.
就是这样了。 

567
00:33:04,730 --> 00:33:08,000
The reason this works, is because you're
之所以有效，是因为你

568
00:33:08,000 --> 00:33:10,630
calling max-heapify multiple times,
多次调用max-heapify， 

569
00:33:10,630 --> 00:33:15,579
but every time you call it, you satisfy the precondition.
但每次调用它，您都满足前提。 

570
00:33:15,779 --> 00:33:20,089
And the leaves are automatically max-heaps.
并且叶子自动是最大堆。 

571
00:33:20,089 --> 00:33:23,490
Then you start with n over 2.
然后，从n开始于2。 

572
00:33:23,490 --> 00:33:26,920
You are going to see two leaves as your children
您将看到两片叶子作为您的孩子

573
00:33:26,920 --> 00:33:28,250
for the n over 2 node, right?
对于n over 2节点，对吗？ 

574
00:33:28,250 --> 00:33:31,039
I mean, just pick an example here.
我的意思是，在这里仅举一个例子。 

575
00:33:31,039 --> 00:33:35,159
Our 2 is an A of 5, right?
我们的2是5的A，对吧？ 

576
00:33:35,160 --> 00:33:36,710
You're out here.
你在这里

577
00:33:36,710 --> 00:33:38,720
In this case, depending on the value of n,
在这种情况下，取决于n的值， 

578
00:33:38,720 --> 00:33:41,172
you may have either two children, or just one child.
您可能有两个孩子，或只有一个孩子。 

579
00:33:41,172 --> 00:33:42,130
And you have one child.
你有一个孩子。 

580
00:33:42,130 --> 00:33:43,910
But regardless of that, that's going
但是不管怎样， 

581
00:33:43,910 --> 00:33:46,279
to be a max-heap, because it's a leaf.
成为最大堆，因为它是一片叶子。 

582
00:33:46,279 --> 00:33:48,490
And so you'll have two leaves, and you
这样你就会有两片叶子，而你

583
00:33:48,490 --> 00:33:49,839
need to put them together.
需要将它们放在一起。 

584
00:33:49,839 --> 00:33:52,829
And that's a fairly straightforward process
这是一个相当简单的过程

585
00:33:52,829 --> 00:33:55,809
of attaching the leaves together.
将叶子粘在一起的过程。 

586
00:33:55,809 --> 00:33:59,129
You might have to do a swap, based on what the element is.
您可能必须根据元素是什么进行交换。 

587
00:33:59,130 --> 00:34:03,430
One operation and you get a little small tree,
一次手术，您会得到一棵小树， 

588
00:34:03,430 --> 00:34:05,139
that's a max-heap.
那是最大的堆。 

589
00:34:05,339 --> 00:34:07,449
And then you do a bunch of other things
然后你做一堆其他的事情

590
00:34:07,450 --> 00:34:12,300
that all work on leaves, because n over 2 minus 1
都在叶子上工作，因为n超过2减1 

591
00:34:12,300 --> 00:34:14,190
is probably also going to have leaves
可能还会有叶子

592
00:34:14,190 --> 00:34:17,427
as it's children, given the large value of n.
因为它是孩子，所以n大。 

593
00:34:17,427 --> 00:34:18,969
There will be a bunch of things where
会有很多东西

594
00:34:18,969 --> 00:34:23,110
you work on these level one nodes, if you will,
您将在这些一级节点上工作，如果愿意， 

595
00:34:23,110 --> 00:34:25,789
that all have leaves as children.
小时候都有叶子。 

596
00:34:25,789 --> 00:34:27,519
And then you work on the level two nodes,
然后您在第二层节点上工作， 

597
00:34:27,519 --> 00:34:28,719
and so on and so forth.
等等等等。 

598
00:34:28,719 --> 00:34:31,420
And as I said before, you're working your way up,
正如我之前说的，您正在努力， 

599
00:34:31,420 --> 00:34:33,489
and you're only working with max-heaps
而且你只用最大堆

600
00:34:33,489 --> 00:34:37,032
as your left child and your right child.
作为你的左孩子和右孩子。 

601
00:34:37,032 --> 00:34:37,699
That make sense?
有道理？ 

602
00:34:37,699 --> 00:34:42,630



603
00:34:42,630 --> 00:34:45,960
If you do that, and this is a fairly straightforward
如果您这样做的话，这是相当简单的

604
00:34:45,960 --> 00:34:48,070
question, if you do a straightforward
问题，如果你做一个简单的

605
00:34:48,070 --> 00:34:51,659
analysis of this, what is the complexity of build-max-heap?
对此进行分析，build-max-heap的复杂性是什么？ 

606
00:34:51,659 --> 00:34:54,670



607
00:34:54,670 --> 00:34:55,637
Yep.
是的

608
00:34:55,637 --> 00:34:58,592
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

609
00:34:58,592 --> 00:34:59,300
PROFESSOR: Right.
教授：对。 

610
00:34:59,300 --> 00:35:00,460
So that's order.
这就是命令。 

611
00:35:00,460 --> 00:35:03,099



612
00:35:03,099 --> 00:35:04,969
Order n log n.
顺序n日志n。 

613
00:35:04,969 --> 00:35:08,219
Now, this is through a simple analysis.
现在，这是通过简单的分析。 

614
00:35:08,219 --> 00:35:10,596
Now I'm going to give you a chance
现在我要给你机会

615
00:35:10,596 --> 00:35:15,070
to tell me if you can do better than that.
告诉我是否可以做得更好。 

616
00:35:15,070 --> 00:35:15,750
Or not.
或不。 

617
00:35:15,750 --> 00:35:16,889
In terms of analysis.
在分析方面。 

618
00:35:16,889 --> 00:35:19,429



619
00:35:19,429 --> 00:35:22,480
It's a subtle question.
这是一个微妙的问题。 

620
00:35:22,480 --> 00:35:25,159
It's a subtle question, that I'm asking.
我要问的是一个微妙的问题。 

621
00:35:25,159 --> 00:35:29,159
I'm saying, this is the algorithm, alright?
我是说，这是算法，好吗？ 

622
00:35:29,159 --> 00:35:31,509
I don't want you to change the algorithm,
我不要你改变算法

623
00:35:31,510 --> 00:35:34,340
but I want you to change your analysis.
但我希望您更改分析。 

624
00:35:34,340 --> 00:35:37,440
The analysis that you just did was,
您刚才所做的分析是

625
00:35:37,639 --> 00:35:42,259
you said, I got [INAUDIBLE] n steps here,
你说过，我在这里[听不清] n步， 

626
00:35:42,260 --> 00:35:45,280
because it's n by 2 steps.
因为它是n分2步。 

627
00:35:45,280 --> 00:35:49,800
Looks like each of the steps is taking log n time.
看来每个步骤都需要花费n倍的时间。 

628
00:35:49,800 --> 00:35:51,190
So that's n log n.
这就是n log n。 

629
00:35:51,389 --> 00:35:54,079
And I was careful.
而且我很小心。 

630
00:35:54,079 --> 00:35:55,949
I put big O here.
我把大O放在这里。 

631
00:35:55,949 --> 00:35:56,581
OK?
好？ 

632
00:35:56,581 --> 00:35:57,789
Because that's an upper bond.
因为那是一个较高的纽带。 

633
00:35:57,789 --> 00:36:00,139
So that's a valid answer.
所以这是一个有效的答案。 

634
00:36:00,139 --> 00:36:01,650
Can you do better?
你能做得更好吗？ 

635
00:36:01,650 --> 00:36:03,309
Can you do a better analysis-- and I'll
您能做一个更好的分析吗，我会

636
00:36:03,309 --> 00:36:08,909
let you go first-- can you do a better analysis that somehow
让您先走-您能以某种方式进行更好的分析吗

637
00:36:08,909 --> 00:36:10,955
gives me better complexity?
给我更好的复杂性？ 

638
00:36:10,956 --> 00:36:14,253
AUDIENCE: I think you bring it to [INAUDIBLE].
听众：我想你把它带到[听不清]。 

639
00:36:14,253 --> 00:36:14,635
PROFESSOR: OK.
教授：好的。 

640
00:36:14,835 --> 00:36:15,335
How?
怎么样？ 

641
00:36:15,335 --> 00:36:19,671
AUDIENCE: So each node get a maximum of two [INAUDIBLE].
听众：因此，每个节点最多获得两个[听不清]。 

642
00:36:19,672 --> 00:36:24,153



643
00:36:24,153 --> 00:36:33,615
So, for some n, there will be a constant number of comparisons
因此，对于某些n，将有恒定数量的比较

644
00:36:33,615 --> 00:36:37,422
to max-heapify that [INAUDIBLE].
以最大程度地堆砌[音频不清晰]。 

645
00:36:37,422 --> 00:36:43,723



646
00:36:43,724 --> 00:36:44,190
PROFESSOR: Yeah.
教授：是的。 

647
00:36:44,389 --> 00:36:46,766
It's hard to explain.
很难解释。 

648
00:36:46,766 --> 00:36:47,849
You're on the right track.
您走在正确的轨道上。 

649
00:36:47,849 --> 00:36:50,556
Absolutely on the right track.
绝对正确。 

650
00:36:50,556 --> 00:36:52,179
So it turns out that, and I'll do this,
事实证明，我会这样做， 

651
00:36:52,179 --> 00:36:53,799
it's going to take a few minutes here,
这里要花几分钟， 

652
00:36:53,800 --> 00:36:55,780
because I write some things out.
因为我写了一些东西。 

653
00:36:55,780 --> 00:36:58,980
You have to sum up a bunch of arithmetic series, and so on.
您必须总结一堆算术级数，依此类推。 

654
00:36:59,179 --> 00:37:03,940
So it's a bit unfair to have to speak out the answer,
因此，必须大声说出答案有点不公平， 

655
00:37:03,940 --> 00:37:07,340
but the correct answer, in fact, is
但事实上，正确的答案是

656
00:37:07,340 --> 00:37:10,820
that this is order n complexity.
这就是n阶复杂度。 

657
00:37:10,820 --> 00:37:12,800
This algorithm that I put up here,
我在这里提出的算法

658
00:37:12,800 --> 00:37:14,690
if you do a careful analysis of it,
如果您仔细分析一下

659
00:37:14,889 --> 00:37:16,980
you can get order n out of it.
您可以从中得到订单n。 

660
00:37:16,980 --> 00:37:18,769
And we'll do this careful analysis.
我们将进行仔细的分析。 

661
00:37:18,769 --> 00:37:21,369
And I'll tell you why it's order n,
我会告诉你为什么要订购n 

662
00:37:21,369 --> 00:37:24,880
in terms of a hand wavy argument.
波浪形的争论。 

663
00:37:24,880 --> 00:37:29,826
A hand wavy argument is that you're doing basically,
一个波浪形的争论是，你基本上在做， 

664
00:37:30,025 --> 00:37:31,399
obviously no work for the leaves.
显然，叶无用。 

665
00:37:31,400 --> 00:37:32,615
But you're not even counting that,
但是你甚至都没有数过

666
00:37:32,815 --> 00:37:34,619
because you're starting with n over 2.
因为您要从2以上的n开始。 

667
00:37:34,619 --> 00:37:38,089
But when you look at the n over 2 node,
但是当您查看n over 2节点时， 

668
00:37:38,090 --> 00:37:40,900
it's essentially one operation, or two operations,
本质上是一个操作或两个操作， 

669
00:37:41,099 --> 00:37:45,779
in whichever way you count, to build max-heap.
以您认为的任何一种方式来建立最大堆。 

670
00:37:45,780 --> 00:37:48,460
And so for that first level of nodes,
因此，对于第一级节点， 

671
00:37:48,460 --> 00:37:51,280
it's exactly one operation.
这只是一项操作。 

672
00:37:51,280 --> 00:37:53,400
The first level that are above the leaves.
叶子上方的第一层。 

673
00:37:53,400 --> 00:37:56,980
For the next level, you may be doing two operations.
对于下一个级别，您可能要执行两个操作。 

674
00:37:57,179 --> 00:38:00,319
And so there is an increase in operations
因此，运营增加了

675
00:38:00,320 --> 00:38:02,570
as you get higher and higher up.
随着你越来越高。 

676
00:38:02,570 --> 00:38:04,940
But there are fewer and fewer nodes as you
但是随着您的节点越来越少

677
00:38:04,940 --> 00:38:06,539
at higher and higher up, right?
在越来越高的地方吧？ 

678
00:38:06,739 --> 00:38:12,189
Because there's only one node that is the highest level node.
因为只有一个节点是最高级别的节点。 

679
00:38:12,190 --> 00:38:13,440
The root node.
根节点。 

680
00:38:13,440 --> 00:38:16,269
That node has logarithmic number of operations,
该节点具有对数个运算， 

681
00:38:16,469 --> 00:38:19,980
but it's only one node.
但这只是一个节点。 

682
00:38:19,980 --> 00:38:22,289
The ones down on the bottom have a constant number
底部的数字恒定

683
00:38:22,289 --> 00:38:24,110
of operations.
操作。 

684
00:38:24,110 --> 00:38:26,829
So I'll put all of this down, and hopefully you'll
所以我会把所有这些都放下来，希望你会

685
00:38:26,829 --> 00:38:30,049
be convinced by the time we've done some math here,
相信我们在这里做一些数学的时间， 

686
00:38:30,050 --> 00:38:35,170
or some arithmetic here, but you can quantify what I just
或一些算术运算，但您可以量化我的

687
00:38:35,369 --> 00:38:40,429
said fairly easily, as long as you're
说的很轻松，只要你

688
00:38:40,429 --> 00:38:43,049
careful about the counting that we have to do.
注意我们必须做的计数。 

689
00:38:43,050 --> 00:38:45,210
So this is really, truly counting.
因此，这确实非常重要。 

690
00:38:45,210 --> 00:38:47,889
Analysis has a lot to do with counting.
分析与计数有很大关系。 

691
00:38:47,889 --> 00:38:50,759
And we're just being more careful with the counting,
而且我们在计数方面更加谨慎， 

692
00:38:50,760 --> 00:38:53,340
as opposed to this straightforward argument that
与此简单的论点相反

693
00:38:53,340 --> 00:38:57,250
wasn't particularly careful with the counting.
对计数不是特别小心。 

694
00:38:57,250 --> 00:39:00,280
So let's take a look at exactly this algorithm.
因此，让我们来看看这个算法。 

695
00:39:00,280 --> 00:39:02,760
And I want to make an observation.
我想观察一下。 

696
00:39:02,760 --> 00:39:05,110
Which is what I just did, but I'd like to write it out.
这就是我刚刚做的，但是我想写出来。 

697
00:39:05,110 --> 00:39:18,530
Where we say, max-heapify takes constant time
我们说的最大堆花时间是恒定的

698
00:39:18,530 --> 00:39:29,380
for nodes that are one level above leaves.
对于叶子上方一级的节点。 

699
00:39:29,380 --> 00:39:34,590



700
00:39:34,590 --> 00:39:51,019
And, in general, order L time for nodes
而且，通常，节点的L时间为

701
00:39:51,019 --> 00:40:00,614
that are L levels above the leaves.
在叶子上方L个水平。 

702
00:40:00,614 --> 00:40:05,479



703
00:40:05,480 --> 00:40:09,079
That's observation number one.
这是第一观察结果。 

704
00:40:09,079 --> 00:40:10,569
Observation number two is that we
第二个观察是我们

705
00:40:10,570 --> 00:40:17,090
have n over 4 nodes that, give or take one,
在4个以上的节点中有n个，给予或接受一个， 

706
00:40:17,090 --> 00:40:18,670
depending on the value of n.
取决于n的值。 

707
00:40:18,869 --> 00:40:22,326
I don't want to get hung up on floors and ceilings.
我不想挂在地板和天花板上。 

708
00:40:22,326 --> 00:40:23,699
And in any case, we're eventually
无论如何，我们最终

709
00:40:23,699 --> 00:40:25,478
going to get an asymptotic result,
得到渐近结果， 

710
00:40:25,478 --> 00:40:27,019
so we don't have to worry about that.
因此我们不必为此担心。 

711
00:40:27,019 --> 00:40:32,070
But we have n over four nodes with level one, n over 8
但是我们有n个超过1个节点的四个节点，n个超过8个节点

712
00:40:32,070 --> 00:40:33,030
with level two.
第二级。 

713
00:40:33,030 --> 00:40:36,760



714
00:40:36,760 --> 00:40:45,860
And 1 node with log n, sort of the log n
和1个具有日志n的节点，排序为日志n 

715
00:40:45,860 --> 00:40:49,190
level, which is the root.
级别，这是根本。 

716
00:40:49,389 --> 00:40:54,500
So this is decrease in terms of nodes as the work
所以这是节点工作量的减少

717
00:40:54,500 --> 00:40:57,230
that you're doing increases.
你正在做的事情增加。 

718
00:40:57,230 --> 00:40:59,530
And that's the careful accounting that we have to do.
这就是我们必须要做的仔细核算。 

719
00:40:59,530 --> 00:41:03,710
And so all I have to do now to prove to you that this
因此，我现在要做的就是向您证明

720
00:41:03,909 --> 00:41:06,529
is actually an order and algorithm,
实际上是一个命令和算法， 

721
00:41:06,530 --> 00:41:10,289
is to write a little summation that sums up
是写一些总结

722
00:41:10,489 --> 00:41:13,339
all of the work across these different levels.
这些不同层次上的所有工作。 

723
00:41:13,340 --> 00:41:20,670



724
00:41:20,670 --> 00:41:34,769
And so the total amount of work in the 4 loop
这样4个循环中的总工作量

725
00:41:34,969 --> 00:41:40,179
can be summed as n divided by 4, times 1, times c.
可以求和为n除以4乘以1乘以c。 

726
00:41:40,179 --> 00:41:44,190
So this sum, I have one level here,
所以这个总和，我在这里有一个层次， 

727
00:41:44,190 --> 00:41:46,340
and I'm going to do some constant amount of work
我要做一些固定的工作

728
00:41:46,340 --> 00:41:47,509
for that one level.
对于那个水平。 

729
00:41:47,509 --> 00:41:49,050
So I'm just going to put c out there,
所以我要把c放在那里

730
00:41:49,050 --> 00:41:51,050
because eventually I can take away the c, right?
因为最终我可以拿走c，对吧？ 

731
00:41:51,050 --> 00:41:53,190
That's the beauty of asymptotics.
那就是无症状的美。 

732
00:41:53,190 --> 00:41:56,570
So we don't need to argue about how much work
所以我们不需要争论多少工作

733
00:41:56,570 --> 00:41:58,539
is done at that one level, how many swaps,
在那个级别完成了多少次交换

734
00:41:58,739 --> 00:42:00,069
et cetera, et cetera.
等，等等。 

735
00:42:00,070 --> 00:42:02,039
But the fact is that these n over four nodes
但是事实是，这n个超过四个节点

736
00:42:02,039 --> 00:42:03,829
are one level above the leaves.
在叶子上方一层。 

737
00:42:03,829 --> 00:42:04,969
That's what's key.
那才是关键。 

738
00:42:04,969 --> 00:42:14,469
And then I have n over 8 times 2c, plus n over 16 times 3c,
然后我得到n超过8倍2c，再加上n超过16倍3c， 

739
00:42:14,469 --> 00:42:23,169
plus 1 times log of n c.
加n乘以1的对数。 

740
00:42:23,170 --> 00:42:26,710
I've essentially written in an arithmetic expression
我基本上是用算术表达式写的

741
00:42:26,710 --> 00:42:31,840
exactly what I have observed on the board above.
正是我在上面的板上观察到的。 

742
00:42:31,840 --> 00:42:34,150
Stop me if you have questions.
如有疑问，请阻止我。 

743
00:42:34,150 --> 00:42:37,550
Now I'm going to set-- just to try and make
现在我要开始设置-只是尝试使

744
00:42:37,550 --> 00:42:41,000
this a little easier to look at, and easy to reason
这看起来更容易理解，而且容易推理

745
00:42:41,000 --> 00:42:48,900
about-- I'm going to set n over 4 to 2 raised to k,
关于-我将把4的n设置为2，将n设置为k， 

746
00:42:48,900 --> 00:42:50,451
and I'm going to simplify.
我将简化。 

747
00:42:50,451 --> 00:42:51,949
I'm just pulling out certain things,
我只是拿出某些东西

748
00:42:51,949 --> 00:42:54,829
and this thing is going to translate to c times 2
这个东西将转换为c乘以2 

749
00:42:54,829 --> 00:43:04,969
raised to k, times 1, divided by 2 raised to 0,
提高到k，乘以1，除以2，得到0， 

750
00:43:04,969 --> 00:43:09,969
2 divided by 2 raised to 1, 3 divided by 2 raised to 2,
 2除以2升为1，3除以2升为2， 

751
00:43:09,969 --> 00:43:14,349
et cetera, k plus 1 divided by 2 raised to k.
等，将k加1除以2得出k。 

752
00:43:14,349 --> 00:43:17,339



753
00:43:17,340 --> 00:43:20,920
Now, if that was confusing, raise your hand,
现在，如果这令人困惑，请举手， 

754
00:43:20,920 --> 00:43:25,690
but it's essentially identical given the substitution and sort
但是考虑到替换和排序，它基本上是相同的

755
00:43:25,690 --> 00:43:28,500
of just applying the distributive law.
仅适用分配法。 

756
00:43:28,699 --> 00:43:30,419
And the reason I did this, is because I
我这样做的原因是因为我

757
00:43:30,420 --> 00:43:37,380
wanted you to see the arithmetic expression that's in here.
希望您看到其中的算术表达式。 

758
00:43:37,380 --> 00:43:43,079
Now we do know that 2 raised to k is n over four, of course.
现在我们确实知道，将2升至k等于4上的n。 

759
00:43:43,079 --> 00:43:48,099
But if you look at this expression that's inside here,
但是，如果您查看此处的表达式， 

760
00:43:48,099 --> 00:43:50,869
what is this expression?
这个表达是什么？ 

761
00:43:50,869 --> 00:43:52,849
Anyone?
任何人？ 

762
00:43:52,849 --> 00:43:56,949
Can you bound this expression?
你能约束这个表达吗？ 

763
00:43:56,949 --> 00:43:59,809
Someone?
有人吗

764
00:43:59,809 --> 00:44:00,489
For the cushion.
为垫子。 

765
00:44:00,489 --> 00:44:04,729



766
00:44:04,730 --> 00:44:10,994
Remember your arithmetic series from wherever it was.
无论身在何处，都请记住您的算术级数。 

767
00:44:10,994 --> 00:44:11,710
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

768
00:44:11,909 --> 00:44:13,809
PROFESSOR: Yeah.
教授：是的。 

769
00:44:13,809 --> 00:44:17,980
You know better than I. I guess you took those courses more
你比我了解得更多。我想你选修了那些课程

770
00:44:17,980 --> 00:44:22,204
recently, but what happens with that?
最近，但是那会发生什么呢？ 

771
00:44:22,204 --> 00:44:23,420
Those of you who have calculators,
那些有计算器的人， 

772
00:44:23,619 --> 00:44:29,199
I mean, you could plug that in, and answer that.
我的意思是，您可以插入并回答。 

773
00:44:29,199 --> 00:44:30,125
No one?
没有人？ 

774
00:44:30,126 --> 00:44:30,626
Go ahead.
前进。 

775
00:44:30,626 --> 00:44:32,891
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

776
00:44:33,090 --> 00:44:35,559
You know that it's going to merge to two.
您知道它将合并为两个。 

777
00:44:35,559 --> 00:44:38,309
PROFESSOR: That's exactly what I was looking for.
教授：那正是我想要的。 

778
00:44:38,309 --> 00:44:40,980
Essentially, well, it's not quite two, because you have a 1
从本质上讲，它不是两个，因为您有一个1 

779
00:44:40,980 --> 00:44:43,230
here, and you have a 1 here, but you're exactly right.
在这里，您这里有1，但您说得很对。 

780
00:44:43,230 --> 00:44:44,469
I mean, two is good.
我的意思是，两个很好。 

781
00:44:44,469 --> 00:44:46,279
It's asymptotic, I mean, come on.
我的意思是说，这是渐近的。 

782
00:44:46,280 --> 00:44:49,480
I'm not going to complain about two versus three, right?
我不会抱怨两个还是三个，对吗？ 

783
00:44:49,480 --> 00:44:52,699
So the point is it's bounded by a constant.
因此，关键是它以一个常数为界。 

784
00:44:52,699 --> 00:44:55,169
It's bounded by a constant.
它以常量为界。 

785
00:44:55,170 --> 00:44:58,980
This is a convergent series and it's bounded by a constant.
这是一个收敛的级数，并且以一个常数为界。 

786
00:44:59,179 --> 00:45:01,739
And we can argue about what the constant is.
我们可以争论什么是常数。 

787
00:45:01,739 --> 00:45:04,599
It's less than three.
不到三个。 

788
00:45:04,599 --> 00:45:07,005
And it doesn't matter of k goes to infinity.
与k到无穷大无关。 

789
00:45:07,005 --> 00:45:08,379
And you want k to go to infinity,
你想让k达到无穷大， 

790
00:45:08,380 --> 00:45:11,440
but it doesn't matter if k is small or k is large,
但是k小还是k都没关系， 

791
00:45:11,440 --> 00:45:12,730
this is bounded by a constant.
这是一个常数。 

792
00:45:12,730 --> 00:45:16,929



793
00:45:16,929 --> 00:45:22,029
And that's the key observation.
这就是关键的观察。 

794
00:45:22,030 --> 00:45:23,375
What do we have left?
我们还剩下什么？ 

795
00:45:23,375 --> 00:45:24,250
What do we have left?
我们还剩下什么？ 

796
00:45:24,250 --> 00:45:26,429
We have a constant there.
我们在那里有一个常数。 

797
00:45:26,429 --> 00:45:28,299
We have a c, which is a constant,
我们有一个交流电，这是一个常数， 

798
00:45:28,300 --> 00:45:32,269
and we have a 2 raised to k, which is really n.
我们将k的值提高了2，实际上是n。 

799
00:45:32,269 --> 00:45:33,559
So there you go.
所以你去了。 

800
00:45:33,559 --> 00:45:35,809
There you have your theta n complexity.
那里有您的理论复杂性。 

801
00:45:35,809 --> 00:45:39,159
Now I can say theta n, because I know it's theta n.
现在我可以说theta n，因为我知道它是theta n。 

802
00:45:39,159 --> 00:45:43,339
But big O of n, theta n, that's what it is.
但是n是theta n的大O就是这样。 

803
00:45:43,340 --> 00:45:46,309
So that's what I'd say is subtle analysis.
所以我要说的是微妙的分析。 

804
00:45:46,309 --> 00:45:49,049
Clearly a little more complicated than anything
显然比任何事情都要复杂

805
00:45:49,050 --> 00:45:52,170
we've done so far, and let me see if there are questions.
到目前为止，我们已经完成了，让我看看是否有问题。 

806
00:45:52,369 --> 00:45:55,029
How many people got this?
有多少人得到这个？ 

807
00:45:55,030 --> 00:45:57,690
I did too.
我也是

808
00:45:57,690 --> 00:46:01,099
Someone who didn't get it, ask a question.
有人不明白，问一个问题。 

809
00:46:01,099 --> 00:46:02,519
What didn't you get?
没得到什么

810
00:46:02,519 --> 00:46:05,889
What step would you like me to repeat here?
您希望我在这里重复什么步骤？ 

811
00:46:05,889 --> 00:46:07,769
Any particular step?
有什么特别的步骤吗？ 

812
00:46:07,769 --> 00:46:08,730
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

813
00:46:08,730 --> 00:46:12,514



814
00:46:12,514 --> 00:46:13,639
PROFESSOR: This thing here?
教授：这东西在这里吗？ 

815
00:46:13,639 --> 00:46:14,609
Right here?
就在这儿？ 

816
00:46:14,610 --> 00:46:17,480
OK, so you're not convinced that this expression
好，所以您不相信这个表达

817
00:46:17,480 --> 00:46:19,829
got translated to this expression.
被翻译成这个表达。 

818
00:46:19,829 --> 00:46:22,179
So let me try and convince you of that, alright?
因此，让我尝试说服您，好吗？ 

819
00:46:22,179 --> 00:46:25,579
So let's take a look at each of the terms.
因此，让我们看一下每个术语。 

820
00:46:25,579 --> 00:46:27,679
n by 4 is 2 raised to k.
 n乘4是2升至k。 

821
00:46:27,679 --> 00:46:30,469
I'm just looking at this term and this term.
我只是在看这个学期和这个学期。 

822
00:46:30,469 --> 00:46:33,509
n by 4 is 2 raised to k.
 n乘4是2升至k。 

823
00:46:33,510 --> 00:46:35,750
c is c.
 c是c。 

824
00:46:35,949 --> 00:46:44,148
And I just wrote 1 as 1 divided by 2 raised to 0, which is 1.
我只写了1为1除以2升为0（即1）。 

825
00:46:44,148 --> 00:46:45,690
And the reason I want you to do this,
我希望您这样做的原因， 

826
00:46:45,690 --> 00:46:49,059
is because I want to show you an expression where in some sense,
是因为我想向您展示某种意义上的表达， 

827
00:46:49,059 --> 00:46:52,799
this is the term that is the summation for your expression.
这是表达的总和。 

828
00:46:52,800 --> 00:46:55,320
If we just replace this, you can write this out
如果我们只是替换掉它，你可以写出来

829
00:46:55,320 --> 00:47:05,440
as i equals 0 through k, I plus 1 divided by 2 raised to i.
当我等于0到k时，我加1除以2得出i。 

830
00:47:05,440 --> 00:47:09,059
That is the symbolic form of this expression,
那是这个表达的象征形式， 

831
00:47:09,059 --> 00:47:10,750
which came from here.
从这里来的

832
00:47:10,750 --> 00:47:13,250
And then the argument was made that this
然后有人争论说

833
00:47:13,250 --> 00:47:18,489
is a convergent series and is bounded by a constant.
是一个收敛的级数，并以一个常数为界。 

834
00:47:18,489 --> 00:47:20,109
That make sense?
有道理？ 

835
00:47:20,110 --> 00:47:21,539
Good.
好。 

836
00:47:21,739 --> 00:47:23,159
So that's pretty neat, right?
这很整洁吧？ 

837
00:47:23,159 --> 00:47:26,519
I mean, you have the same algorithm and, whala,
我的意思是，您有相同的算法，而且， 

838
00:47:26,519 --> 00:47:28,610
it suddenly got more efficient.
突然变得更有效率。 

839
00:47:28,610 --> 00:47:30,670
Doesn't always happen, but that tells you
并非总是会发生，但这可以告诉您

840
00:47:30,670 --> 00:47:33,159
that you have to have some care in doing
你必须在做的时候多加注意

841
00:47:33,159 --> 00:47:36,119
your analysis, because what really happened here, was you
您的分析，因为这里真正发生的是您

842
00:47:36,119 --> 00:47:37,779
did a rudimentary analysis.
做了初步的分析。 

843
00:47:37,780 --> 00:47:40,420
You said, this was order log n, big O log n,
您说，这是订单日志n，大O日志n， 

844
00:47:40,619 --> 00:47:43,639
and you said this was theta n, and you ended up with this.
然后您说这是theta n，结果就这样了。 

845
00:47:43,639 --> 00:47:47,639
But in reality, it's actually a faster algorithm.
但实际上，它实际上是一种更快的算法。 

846
00:47:47,639 --> 00:47:49,210
So that's the good news.
这是个好消息。 

847
00:47:49,210 --> 00:47:53,300
Build-max-heap can be done in order n time.
 Build-max-heap可以按n次完成。 

848
00:47:53,300 --> 00:47:55,539
Now in the time that I have left, it turns out,
事实证明，在我离开的那一刻， 

849
00:47:55,739 --> 00:48:01,459
we are essentially all the way to heaps sort.
从本质上讲，我们一直在进行堆排序。 

850
00:48:01,460 --> 00:48:05,230
Because all we have to do is use,
因为我们要做的就是使用， 

851
00:48:05,230 --> 00:48:06,849
once we have build-max-heap, I'll
一旦有了build-max-heap，我会

852
00:48:06,849 --> 00:48:10,839
just write out the code for heap sort,
只需写出用于堆排序的代码， 

853
00:48:10,840 --> 00:48:13,210
and you can take a look at examples in the notes.
您可以在注释中查看示例。 

854
00:48:13,409 --> 00:48:16,119



855
00:48:16,119 --> 00:48:18,179
The pseudocode, I should say, for heap sort.
我应该说，用于堆排序的伪代码。 

856
00:48:18,179 --> 00:48:19,949
And it looks like this.
它看起来像这样。 

857
00:48:19,949 --> 00:48:25,039
The first step that you do is you build max-heap
要做的第一步是构建max-heap 

858
00:48:25,039 --> 00:48:27,029
from the unordered array.
来自无序数组。 

859
00:48:27,030 --> 00:48:32,000



860
00:48:32,000 --> 00:48:37,989
Then you find the maximum element AA[1].
然后找到最大元素AA [1]。 

861
00:48:37,989 --> 00:48:41,429
All of this I've said multiple times.
我已经多次说过所有这些。 

862
00:48:41,429 --> 00:48:45,210
Now the key step is, you could do extract max,
现在的关键步骤是，您可以提取最大

863
00:48:45,210 --> 00:48:49,429
but one nice way of handling this,
但是一种很好的处理方式

864
00:48:49,429 --> 00:48:54,059
is to swap the elements AA[n] with AA[1].
将用AA [1]交换元素AA [n]。 

865
00:48:54,059 --> 00:48:56,554



866
00:48:56,554 --> 00:48:57,929
Let me write this out and explain
我写出来解释一下

867
00:48:57,929 --> 00:49:00,739
exactly what that means.
确切的意思。 

868
00:49:00,739 --> 00:49:07,219
Now the maximum element is at the end of the array.
现在，最大元素位于数组的末尾。 

869
00:49:07,219 --> 00:49:11,929



870
00:49:11,929 --> 00:49:13,119
When you do the swap.
进行交换时。 

871
00:49:13,119 --> 00:49:15,109
That's the one step that I will have
那是我要做的一步

872
00:49:15,110 --> 00:49:17,519
to spend another minute on.
再花一点时间。 

873
00:49:17,719 --> 00:49:23,859
Now we discard node n from the heap,
现在我们从堆中丢弃节点n， 

874
00:49:23,860 --> 00:49:30,110
simply by decrementing heap size.
只需通过减少堆大小即可。 

875
00:49:30,110 --> 00:49:34,519
So the heap becomes n minus 1 in size
所以堆的大小变成n减1 

876
00:49:34,519 --> 00:49:37,639
from n in the first iteration.
在第一次迭代中从n开始。 

877
00:49:37,639 --> 00:49:47,609
Now the new root after the swap may violate max-heap,
现在，交换之后的新根目录可能会违反max-heap， 

878
00:49:47,610 --> 00:49:51,440
we'll call it the max-heap property,
我们将其称为max-heap属性， 

879
00:49:51,639 --> 00:49:55,429
but the children are max-heaps.
但是孩子们堆得最多。 

880
00:49:55,429 --> 00:49:58,759



881
00:49:58,760 --> 00:50:01,360
So that's the one node that can possibly violate it.
因此，这是一个可能违反它的节点。 

882
00:50:01,559 --> 00:50:10,860
So what that means, is we can run max-heapify to fix this.
因此，这意味着我们可以运行max-heapify来解决此问题。 

883
00:50:10,860 --> 00:50:11,980
And that's it .
就是这样。 

884
00:50:12,179 --> 00:50:17,529
Once you do that, you go back to that step.
完成此操作后，您将返回到该步骤。 

885
00:50:17,530 --> 00:50:19,230
So what's happened here exactly?
那么这里到底发生了什么？ 

886
00:50:19,429 --> 00:50:22,679
Well this part we spent a bunch of time on.
好吧，这部分我们花了很多时间。 

887
00:50:22,679 --> 00:50:25,579
element is the maximum element, so you grab that.
 element是最大的元素，因此您可以抓住它。 

888
00:50:25,579 --> 00:50:29,779
And you know that's a maximum element.
而且您知道这是最大的要素。 

889
00:50:29,780 --> 00:50:32,460
One way of doing it is to use extract max, but rather
一种方法是使用extract max，而是

890
00:50:32,659 --> 00:50:35,449
than doing extract max, which I haven't explained to you,
而不是我没有向您解释的最大提取量， 

891
00:50:35,449 --> 00:50:37,409
you could imagine that you go off
你可以想象你会离开

892
00:50:37,409 --> 00:50:42,719
and you swap the top element with the bottom element,
然后将顶部元素与底部元素交换， 

893
00:50:42,719 --> 00:50:45,019
and then you discard it.
然后将其丢弃。 

894
00:50:45,019 --> 00:50:47,630
So here's a trivial example, where
所以这是一个简单的例子， 

895
00:50:47,630 --> 00:50:56,920
let's say I had 4, 2, and 1, which is a max-heap.
假设我有4、2和1，这是最大堆。 

896
00:50:56,920 --> 00:50:59,829
What would happen is you'd say, I'm going to take 4
你会说什么，我要拿4 

897
00:50:59,829 --> 00:51:02,480
and I'm going swap it with 1.
我将其与1交换。 

898
00:51:02,480 --> 00:51:07,539
And so you have, 1, 2, and 4.
这样就得到了1、2和4。 

899
00:51:07,539 --> 00:51:12,110
Now four used to be AA[1], and that's the maximum element,
现在四个曾经是AA [1]，这是最大的元素， 

900
00:51:12,110 --> 00:51:14,039
and I'm just going to delete it from the heap,
我将要从堆中删除它， 

901
00:51:14,239 --> 00:51:17,729
which means I'm going to end up with a heap that looks like--
这意味着我将要得到一个看起来像是的堆

902
00:51:17,730 --> 00:51:19,969
a heap, not a max-heap-- that looks like this.
这样的堆，而不是最大堆。 

903
00:51:19,969 --> 00:51:21,569
And I write down 4 here.
我在这里写下4。 

904
00:51:21,570 --> 00:51:23,880
4 is the first element in my sorted array.
 4是我排序数组中的第一个元素。 

905
00:51:24,079 --> 00:51:28,239
Now I look at 1 and 2, and 1 and 2 there's
现在我看1和2，还有1和2 

906
00:51:28,239 --> 00:51:29,689
obviously not a max-heap.
显然不是最大堆。 

907
00:51:29,690 --> 00:51:32,300
But I can run max-- I know the child is a max-heap,
但是我可以最大跑-我知道孩子是最大堆

908
00:51:32,300 --> 00:51:33,920
so I can run max-heapify on this.
所以我可以在此上运行max-heapify。 

909
00:51:34,119 --> 00:51:38,139
And what this turns into is 2 and 1.
变成2和1。 

910
00:51:38,139 --> 00:51:41,239
And at this point, I know that the max is the root,
至此，我知道最大值是根， 

911
00:51:41,239 --> 00:51:44,039
because I've run max-heapify and I take 2 out,
因为我已经跑了max-heapify，我拿了2个， 

912
00:51:44,039 --> 00:51:47,230
and after this, it becomes trivial.
之后，它变得微不足道了。 

913
00:51:47,230 --> 00:51:50,170
But that's the general algorithm.
但这是通用算法。 

914
00:51:50,170 --> 00:51:53,150
So this whole thing takes order n log n time,
因此，这整个过程需要n log n次的时间， 

915
00:51:53,150 --> 00:51:54,920
because even though build-max-heap
因为即使build-max-heap 

916
00:51:54,920 --> 00:52:01,880
is order n and max element is constant time,
是n阶，最大元素是恒定时间， 

917
00:52:01,880 --> 00:52:05,329
swapping the elements is constant time.
交换元素是恒定的时间。 

918
00:52:05,329 --> 00:52:10,730
But running max-heapify is order log n time,
但是，运行max-heapify是订单登录时间n， 

919
00:52:10,730 --> 00:52:13,360
and you have n steps.
并且您有n个步骤。 

920
00:52:13,360 --> 00:52:18,400
So you have an order n log n algorithm.
因此，您有一个阶数为n log n的算法。 

921
00:52:18,400 --> 00:52:21,119
But the first step was order n, which
但是第一步是阶n 

922
00:52:21,119 --> 00:52:22,949
is what we spent a bunch of time on.
我们花了很多时间。 

923
00:52:22,949 --> 00:52:25,589
So I'll show you examples in the notes,
因此，我将在笔记中为您展示示例， 

924
00:52:25,590 --> 00:52:28,769
and that will get covered again in section.
这将在本节中再次讨论。 

925
00:52:28,969 --> 00:52:30,689
I'll stick around for questions.
我会四处询问。 

926
00:52:30,690 --> 00:52:35,690
See you next time.
下次见。 

