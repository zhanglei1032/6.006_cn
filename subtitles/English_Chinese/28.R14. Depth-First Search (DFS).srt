1
00:00:00,000 --> 00:00:00,070



2
00:00:00,070 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:21,800



10
00:00:21,800 --> 00:00:22,500
PROFESSOR: OK.
教授：好的。 

11
00:00:22,500 --> 00:00:25,149
Who's going to lecture?
谁去演讲？ 

12
00:00:25,149 --> 00:00:26,641
Wow.
哇。 

13
00:00:26,641 --> 00:00:27,289
Nice.
真好

14
00:00:27,289 --> 00:00:29,500
Does lecture make sense?
演讲有意义吗？ 

15
00:00:29,500 --> 00:00:31,719
One, two, three-- sort of.
一二三

16
00:00:31,719 --> 00:00:32,759
OK.
好。 

17
00:00:32,759 --> 00:00:35,079
Then I'm going to have an easy job.
然后，我将有一份轻松的工作。 

18
00:00:35,079 --> 00:00:38,019
So any pointed questions?
那么有什么尖锐的问题吗？ 

19
00:00:38,020 --> 00:00:40,309
Any specific pinpoints?
有什么具体的观点吗？ 

20
00:00:40,509 --> 00:00:43,539
We talked about DFS, but DFS and BFS are sort of related,
我们讨论了DFS，但是DFS和BFS有点相关， 

21
00:00:43,539 --> 00:00:45,641
so I'm happy to take both.
所以我很高兴两者兼得。 

22
00:00:45,642 --> 00:00:47,599
AUDIENCE: The classification of edges?
听众：边缘的分类？ 

23
00:00:47,799 --> 00:00:48,473
PROFESSOR: OK.
教授：好的。 

24
00:00:48,473 --> 00:00:50,139
We're going to talk about that for sure.
我们将肯定地谈论它。 

25
00:00:50,140 --> 00:01:02,049



26
00:01:02,049 --> 00:01:04,459
Anything else?
还要别的吗？ 

27
00:01:04,459 --> 00:01:07,509
AUDIENCE: I thought it was funny that in undirected graphs,
听众：我觉得很有趣，在无向图中

28
00:01:07,709 --> 00:01:10,744
you could have a backward-- or something like that.
您可能会有倒退-或类似的东西。 

29
00:01:10,745 --> 00:01:12,620
PROFESSOR: You don't have to give a radiance.
教授：您不必发光。 

30
00:01:12,620 --> 00:01:14,120
I will derive it.
我将得出它。 

31
00:01:14,120 --> 00:01:20,290
OK So what edges do we have in directed versus undirected.
好了，那么我们在定向与非定向方面有哪些优势。 

32
00:01:20,290 --> 00:01:24,429



33
00:01:24,629 --> 00:01:25,129
OK.
好。 

34
00:01:25,129 --> 00:01:25,628
What else?
还有什么？ 

35
00:01:25,629 --> 00:01:30,370



36
00:01:30,370 --> 00:01:30,950
Cool.
凉。 

37
00:01:30,950 --> 00:01:34,260
So I'm going to go through the concepts in DFS really quickly.
因此，我将非常快速地了解DFS中的概念。 

38
00:01:34,260 --> 00:01:35,959
And we're going to focus on this.
我们将专注于此。 

39
00:01:36,159 --> 00:01:38,959
Because it seems like this is where the issues are.
因为看起来这就是问题所在。 

40
00:01:38,959 --> 00:01:41,500



41
00:01:41,500 --> 00:01:42,310
I want this.
我要这个。 

42
00:01:42,310 --> 00:01:43,234
So what's a graph?
那是什么图？ 

43
00:01:43,234 --> 00:01:46,262



44
00:01:46,262 --> 00:01:48,367
AUDIENCE: Interconnected notes.
听众：相互关联的音符。 

45
00:01:48,367 --> 00:01:48,950
PROFESSOR: OK.
教授：好的。 

46
00:01:48,950 --> 00:01:49,620
Fancy names.
花式名字。 

47
00:01:49,620 --> 00:01:49,939
Come on.
来吧。 

48
00:01:49,939 --> 00:01:51,314
We had this in the last workshop.
我们在上一个讲习班中有这个。 

49
00:01:51,314 --> 00:01:54,810
AUDIENCE: A set of edges and vertices.
听众：一组边和顶点。 

50
00:01:54,810 --> 00:01:55,899
PROFESSOR: All right.
教授：好的。 

51
00:01:56,099 --> 00:01:58,425
How do I draw my vertices?
如何绘制顶点？ 

52
00:01:58,426 --> 00:01:59,302
AUDIENCE: Dots.
听众：点。 

53
00:01:59,302 --> 00:02:00,897
Circles.
界。 

54
00:02:01,097 --> 00:02:02,561
PROFESSOR: Dots.
教授：点。 

55
00:02:02,561 --> 00:02:05,977
How do I draw my edges?
如何画边缘？ 

56
00:02:05,977 --> 00:02:06,941
AUDIENCE: Dots.
听众：点。 

57
00:02:06,941 --> 00:02:07,441
Lines.
线。 

58
00:02:07,441 --> 00:02:10,049



59
00:02:10,050 --> 00:02:10,550
Oops.
哎呀。 

60
00:02:10,550 --> 00:02:42,960



61
00:02:42,960 --> 00:02:44,580
PROFESSOR: Looks like a graph?
教授：看起来像图吗？ 

62
00:02:44,580 --> 00:02:47,460
What kind of graph?
什么样的图？ 

63
00:02:47,460 --> 00:02:47,960
Directed.
导演。 

64
00:02:47,960 --> 00:02:50,500
Because there are arrows and not straight up lines.
因为有箭头而不是直线。 

65
00:02:50,500 --> 00:02:51,400
Right?
对？ 

66
00:02:51,400 --> 00:02:53,620
How do we store graphs in Python?
我们如何在Python中存储图形？ 

67
00:02:53,620 --> 00:02:57,300



68
00:02:57,300 --> 00:03:00,250
Fancy name first and then implementation.
花式名称，然后执行。 

69
00:03:00,449 --> 00:03:01,579
AUDIENCE: [INAUDIBLE] list.
听众：[听不清]清单。 

70
00:03:01,580 --> 00:03:02,163
PROFESSOR: OK.
教授：好的。 

71
00:03:02,163 --> 00:03:09,020



72
00:03:09,020 --> 00:03:12,300
What's an adjacency list in Python?
什么是Python中的邻接表？ 

73
00:03:12,300 --> 00:03:14,939
AUDIENCE: It just shows what notes
听众：它只是显示了哪些注意事项

74
00:03:14,939 --> 00:03:16,806
are adjacent to other notes.
与其他音符相邻。 

75
00:03:16,806 --> 00:03:17,389
PROFESSOR: OK.
教授：好的。 

76
00:03:17,389 --> 00:03:19,709
So what data structure do we use?
那么我们使用什么数据结构？ 

77
00:03:19,710 --> 00:03:22,442
What elementary python data structure do we use?
我们使用什么基本的python数据结构？ 

78
00:03:22,442 --> 00:03:23,400
AUDIENCE: A dictionary?
听众：一本字典？ 

79
00:03:23,400 --> 00:03:24,219
PROFESSOR: All right.
教授：好的。 

80
00:03:24,419 --> 00:03:29,298
So an adjacency list is a dictionary that keys our--
因此，邻接表是一本字典，可用来

81
00:03:29,298 --> 00:03:30,759
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

82
00:03:30,759 --> 00:03:32,500
PROFESSOR: OK.
教授：好的。 

83
00:03:32,500 --> 00:03:35,520
So the keys are the vertices.
因此，关键点是顶点。 

84
00:03:35,520 --> 00:03:39,084



85
00:03:39,283 --> 00:03:41,364
So on and so forth.
等等等等。 

86
00:03:41,365 --> 00:03:42,365
And what are the values?
值是多少？ 

87
00:03:42,365 --> 00:03:45,508



88
00:03:45,508 --> 00:03:48,376
AUDIENCE: The nodes?
听众：节点？ 

89
00:03:48,376 --> 00:03:50,097
Adjacent nodes?
相邻节点？ 

90
00:03:50,097 --> 00:03:50,680
PROFESSOR: OK.
教授：好的。 

91
00:03:50,680 --> 00:03:54,159



92
00:03:54,159 --> 00:03:57,840
A list of something.
清单。 

93
00:03:57,840 --> 00:03:59,969
So after our presentation, is the object the one
因此，在我们介绍之后，对象就是一个

94
00:03:59,969 --> 00:04:02,550
that has edges and the simplified
有边缘和简化

95
00:04:02,550 --> 00:04:04,439
one that has vertices.
一个有顶点的

96
00:04:04,639 --> 00:04:07,219
So suppose I want to go for the simple one.
因此，假设我想选择简单的一种。 

97
00:04:07,219 --> 00:04:10,840
Where vertices do I have in A's list?
 A列表中的哪些顶点？ 

98
00:04:10,840 --> 00:04:12,219
AUDIENCE: B and G. Right?
听众：B和G。 

99
00:04:12,419 --> 00:04:15,939



100
00:04:15,939 --> 00:04:17,605
PROFESSOR: B and G. Sounds good.
教授：B和G。听起来不错。 

101
00:04:17,605 --> 00:04:20,151



102
00:04:20,151 --> 00:04:20,651
Right.
对。 

103
00:04:20,651 --> 00:04:24,466
What vertices do I have in B's list?
我在B列表中有哪些顶点？ 

104
00:04:24,466 --> 00:04:28,920
AUDIENCE: C.
听众：C. 

105
00:04:28,920 --> 00:04:32,093
PROFESSOR: Why do I not have A?
教授：为什么我没有A？ 

106
00:04:32,093 --> 00:04:36,713
AUDIENCE: Because it's an arrow, so it can't get to A.
听众：因为是箭头，所以它无法到达A。 

107
00:04:36,713 --> 00:04:37,379
PROFESSOR: Yeah.
教授：是的。 

108
00:04:37,379 --> 00:04:39,625
So the nodes that I have in the list
所以我在列表中的节点

109
00:04:39,625 --> 00:04:42,860
are the nodes that are reachable from that node.
是从该节点可访问的节点。 

110
00:04:42,860 --> 00:04:45,610
I have an edge from B to C, so C is reachable from B.
我从B到C有优势，因此从B可以到达C。 

111
00:04:45,610 --> 00:04:48,509
I do not have an edge from B to A
我没有从B到A的优势

112
00:04:48,509 --> 00:04:49,759
because my edges are directed.
因为我的边缘是定向的。 

113
00:04:49,759 --> 00:04:51,880
So A is not there.
所以A不在那里。 

114
00:04:51,880 --> 00:04:52,379
OK.
好。 

115
00:04:52,379 --> 00:04:56,480
Let's write a bit of pseudo- So although it's Python,
让我们写一些伪的东西-尽管是Python， 

116
00:04:56,480 --> 00:05:01,480
let's say our graph is represented by a class G. Let's
假设我们的图形由G类表示。 

117
00:05:01,480 --> 00:05:05,250
say in this class I have a dictionary called
说这堂课我有一本字典

118
00:05:05,449 --> 00:05:09,420
al, which has what we want.
等，这就是我们想要的。 

119
00:05:09,420 --> 00:05:12,819
If I want to get all the vertices in the graph,
如果我想获得图中的所有顶点， 

120
00:05:12,819 --> 00:05:15,300
I want to write the method that returns all the vertices.
我想编写返回所有顶点的方法。 

121
00:05:15,300 --> 00:05:19,040



122
00:05:19,040 --> 00:05:21,449
What should it look like?
看起来像什么？ 

123
00:05:21,649 --> 00:05:24,783
Just to make sure that we're all getting the data structure.
只是为了确保我们都得到了数据结构。 

124
00:05:24,783 --> 00:05:25,699
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

125
00:05:25,699 --> 00:05:26,283
PROFESSOR: OK.
教授：好的。 

126
00:05:26,283 --> 00:05:28,216



127
00:05:28,416 --> 00:05:29,750
So the keys are in the vertices.
因此，关键点在顶点中。 

128
00:05:29,750 --> 00:05:34,839



129
00:05:34,839 --> 00:05:37,109
Now, given the vertex, I want its neighbors.
现在，给定顶点，我想要它的邻居。 

130
00:05:37,110 --> 00:05:42,240



131
00:05:42,240 --> 00:05:44,278
How do I write that?
我该怎么写？ 

132
00:05:44,278 --> 00:05:47,632
AUDIENCE: You mean only the vertices that it can go to?
听众：您的意思是仅它可以到达的顶点？ 

133
00:05:47,632 --> 00:05:48,298
PROFESSOR: Yeah.
教授：是的。 

134
00:05:48,298 --> 00:05:51,526



135
00:05:51,526 --> 00:05:51,949
AUDIENCE: Yeah.
听众：是的。 

136
00:05:52,149 --> 00:05:54,399
Dictionary and that vertex.
字典和那个顶点。 

137
00:05:54,399 --> 00:05:58,954
PROFESSOR: So return dictionary--
教授：那么请返回字典- 

138
00:05:58,954 --> 00:06:04,243
AUDIENCE: al bracket vertex v.
听众：全括号顶点v。 

139
00:06:04,244 --> 00:06:05,560
PROFESSOR: Cool.
教授：太好了。 

140
00:06:05,759 --> 00:06:06,259
OK.
好。 

141
00:06:06,259 --> 00:06:07,925
So this makes sense for everyone, right?
所以这对每个人都有意义，对吧？ 

142
00:06:07,925 --> 00:06:12,110



143
00:06:12,110 --> 00:06:13,920
Let's start writing DFS because no one
让我们开始编写DFS，因为没有人

144
00:06:13,920 --> 00:06:15,759
said they don't understand DFS.
说他们不了解DFS。 

145
00:06:15,959 --> 00:06:22,319
So let's say we have a DFS procedure.
假设我们有一个DFS过程。 

146
00:06:22,319 --> 00:06:25,930
And it gets a graph.
它得到一个图。 

147
00:06:25,930 --> 00:06:27,040
And it has to do DFS.
并且它必须执行DFS。 

148
00:06:27,040 --> 00:06:29,639



149
00:06:29,839 --> 00:06:31,069
What do you need for DFS?
 DFS需要什么？ 

150
00:06:31,069 --> 00:06:33,680



151
00:06:33,680 --> 00:06:36,240
Starting points would be good.
起点会很好。 

152
00:06:36,240 --> 00:06:39,060
Just like for DFS, right?
就像DFS一样，对不对？ 

153
00:06:39,060 --> 00:06:41,740
So how do we do DFS?
那么我们如何做DFS？ 

154
00:06:41,740 --> 00:06:46,829



155
00:06:47,029 --> 00:06:49,699
AUDIENCE: Start with one node and then we
听众：从一个节点开始，然后我们

156
00:06:49,699 --> 00:06:53,219
keep on following a path down by picking the first vertex.
通过选择第一个顶点继续沿着向下的路径前进。 

157
00:06:53,220 --> 00:06:55,870
So like for A, we'd start with A.
因此，像A一样，我们将从A开始。 

158
00:06:55,870 --> 00:06:58,514
Then we'd pick the first vertex in its list.
然后，我们在列表中选择第一个顶点。 

159
00:06:58,714 --> 00:07:02,599
And then we pick the first vertex in that one's list,
然后我们选择该列表中的第一个顶点， 

160
00:07:02,600 --> 00:07:05,242
first vertex in that one's list, until we run out.
该列表中的第一个顶点，直到我们用完为止。 

161
00:07:05,242 --> 00:07:05,826
PROFESSOR: OK.
教授：好的。 

162
00:07:05,826 --> 00:07:08,689
So basically you start today.
所以基本上你今天开始。 

163
00:07:08,889 --> 00:07:12,219
And for every neighbor, you recursively
对于每个邻居，您递归地

164
00:07:12,220 --> 00:07:14,500
do DFS on that neighbor.
在该邻居上执行DFS。 

165
00:07:14,500 --> 00:07:15,000
Right?
对？ 

166
00:07:15,000 --> 00:07:17,699
So since this is recursive, let's write it
因此，由于这是递归的，所以让我们编写它

167
00:07:17,699 --> 00:07:20,189
in a recursive manner, nice and easy.
以递归的方式，轻松愉快。 

168
00:07:20,189 --> 00:07:29,089
So say DFS calls DFS visit of g and s.
可以说DFS调用g和s进行DFS访问。 

169
00:07:29,089 --> 00:07:37,989
And let's say DFS visit takes the graph,
假设使用DFS进行访问， 

170
00:07:37,990 --> 00:07:40,019
takes the node that we're visiting,
带我们要访问的节点， 

171
00:07:40,019 --> 00:07:43,029
and how are we implementing this?
以及我们如何实施呢？ 

172
00:07:43,029 --> 00:07:46,529



173
00:07:46,529 --> 00:07:50,269
AUDIENCE: Just return [INAUDIBLE].
听众：只需返回[听不清]。 

174
00:07:50,269 --> 00:07:50,769
No.
没有。 

175
00:07:50,769 --> 00:07:53,197
It marks as visited.
它标记为已访问。 

176
00:07:53,197 --> 00:07:53,579
PROFESSOR: OK.
教授：好的。 

177
00:07:53,779 --> 00:07:56,869
Marking something as visited is important to lead this.
将某些内容标记为已访问很重要，可以引导它。 

178
00:07:56,870 --> 00:08:00,910
So what's the main thing that you do in DFS?
那么，在DFS中主要做什么呢？ 

179
00:08:00,910 --> 00:08:02,750
Iterate over the neighbors and recurse.
遍历邻居并递归。 

180
00:08:02,750 --> 00:08:03,379
Right?
对？ 

181
00:08:03,379 --> 00:08:25,949
So for n in g neighbors of v called DFS visit of g and n.
因此，对于v中的n个g的n个邻居（称为DFS），访问g和n。 

182
00:08:25,949 --> 00:08:29,870
So this is the basic idea.
因此，这是基本思想。 

183
00:08:29,870 --> 00:08:33,139
It has some holes that we need to fill because otherwise it
它需要填补一些漏洞，否则

184
00:08:33,139 --> 00:08:34,080
doesn't quite work.
不太有效。 

185
00:08:34,080 --> 00:08:36,330
This is going to recurse forever,
这将永远递归， 

186
00:08:36,330 --> 00:08:38,940
which is not very good if you have a time
如果有时间，那不是很好

187
00:08:38,940 --> 00:08:41,348
limit that your code needs to obey.
限制您的代码需要遵守。 

188
00:08:41,548 --> 00:08:45,528
So how do I make it not recurse forever?
那么如何使它不会永远递归呢？ 

189
00:08:45,528 --> 00:08:48,070
AUDIENCE: Every time you visit, you're about to visit a node,
听众：每次访问时，您都将访问一个节点， 

190
00:08:48,070 --> 00:08:51,215
check if you've already visited it.
检查您是否已经访问过它。 

191
00:08:51,215 --> 00:08:52,090
PROFESSOR: All right.
教授：好的。 

192
00:08:52,090 --> 00:08:53,589
So we should keep track of the nodes
所以我们应该跟踪节点

193
00:08:53,589 --> 00:08:56,690
that we've already visited and not visit them again.
我们已经访问过并且不再访问它们。 

194
00:08:56,690 --> 00:08:57,190
Right.
对。 

195
00:08:57,190 --> 00:09:02,131
So you start with A, go to B, go to C,
因此，您从A开始，转到B，转到C， 

196
00:09:02,331 --> 00:09:04,539
you'd better not go to A again because you've already
您最好不要再去A了，因为您已经

197
00:09:04,539 --> 00:09:06,980
been there.
到过那里。 

198
00:09:06,980 --> 00:09:08,219
So let's implement that this way.
因此，让我们以这种方式实现它。 

199
00:09:08,419 --> 00:09:12,649
Let's make a new object called DFS result that
让我们创建一个称为DFS结果的新对象

200
00:09:12,649 --> 00:09:17,559
is sort of that drawer that you have
是那种你拥有的抽屉

201
00:09:17,559 --> 00:09:19,159
where you stick everything in where
你把所有东西都粘在哪里

202
00:09:19,159 --> 00:09:20,563
you don't have a good place.
你没有一个好地方。 

203
00:09:20,563 --> 00:09:22,230
So everything I do not have a good place
所以我没有一个好地方

204
00:09:22,230 --> 00:09:24,240
to put it, you just stick it in a drawer.
放进去，就把它放在抽屉里。 

205
00:09:24,240 --> 00:09:25,311
And then you can close the drawing that be like,
然后您可以关闭类似的图形， 

206
00:09:25,511 --> 00:09:26,179
it's clean.
很干净

207
00:09:26,179 --> 00:09:27,429
Everything's clean.
一切都干净。 

208
00:09:27,429 --> 00:09:29,776
So let's say DFS result is that drawer.
因此，可以说DFS的结果就是那个抽屉。 

209
00:09:29,777 --> 00:09:31,360
Everything that they need from now on,
从现在开始，他们需要的一切， 

210
00:09:31,360 --> 00:09:33,129
we're just going to stick in there.
我们只是要坚持在那里。 

211
00:09:33,129 --> 00:09:39,100
So I have an object DFS result.
所以我有一个对象DFS结果。 

212
00:09:39,100 --> 00:09:41,100
And we're going to figure out what we put in it.
我们将弄清楚放入其中的内容。 

213
00:09:41,100 --> 00:09:44,995
But at the beginning of DFS, I'm going to create that.
但是在DFS的开始，我将创建它。 

214
00:09:44,995 --> 00:09:48,859



215
00:09:49,059 --> 00:09:50,489
So create the new object.
因此，创建新对象。 

216
00:09:50,490 --> 00:09:54,110
And then I'm going to pass it onto to DFS visit.
然后，我将其传递给DFS访问。 

217
00:09:54,110 --> 00:09:59,740



218
00:09:59,740 --> 00:10:04,789
So now we have a drawer where we can put everything we want.
所以现在我们有了一个抽屉，我们可以在这里放想要的所有东西。 

219
00:10:04,789 --> 00:10:10,610
So let's keep track of the visited information here.
因此，让我们在这里跟踪访问的信息。 

220
00:10:10,610 --> 00:10:14,769
How would I keep track of what nodes I visited?
我将如何跟踪我访问过的节点？ 

221
00:10:14,769 --> 00:10:16,149
AUDIENCE: In a list?
听众：在列表中？ 

222
00:10:16,149 --> 00:10:17,909
PROFESSOR: In a list.
教授：在列表中。 

223
00:10:17,909 --> 00:10:22,529
So if I do a list, it turns out that in DFS,
因此，如果我列出一个列表，事实证明在DFS中， 

224
00:10:22,529 --> 00:10:24,169
and VFS, for that matter, you check
和VFS，为此，您检查

225
00:10:24,169 --> 00:10:25,759
if you visited a node pretty often.
如果您经常访问某个节点。 

226
00:10:25,759 --> 00:10:28,129
So it would be kind of slow.
因此，这有点慢。 

227
00:10:28,129 --> 00:10:29,269
So let's have a dictionary.
因此，我们来字典。 

228
00:10:29,269 --> 00:10:31,102
What are we going to put in that dictionary?
我们要把那本字典放什么？ 

229
00:10:31,102 --> 00:10:33,693



230
00:10:33,693 --> 00:10:37,421
AUDIENCE: The node [INAUDIBLE] and listed [INAUDIBLE].
听众：节点[听不清]，并列出[听不清]。 

231
00:10:37,422 --> 00:10:38,004
PROFESSOR: OK.
教授：好的。 

232
00:10:38,004 --> 00:10:43,710
So we're going to have a visited dictionary.
因此，我们将有一个访问字典。 

233
00:10:43,710 --> 00:10:45,839
And then the keys are going to be nodes.
然后键将成为节点。 

234
00:10:46,039 --> 00:10:49,319
And let's say we're only going to put the nodes that we visit
假设我们只放置访问的节点

235
00:10:49,320 --> 00:10:52,080
in it so we don't have to initialize it.
在其中，因此我们不必初始化它。 

236
00:10:52,080 --> 00:10:53,580
And the values are going to be true.
这些价值观将是正确的。 

237
00:10:53,580 --> 00:10:55,288
Because if the node is in the dictionary,
因为如果节点在字典中， 

238
00:10:55,288 --> 00:10:59,090
it means we visited it.
这意味着我们参观了它。 

239
00:10:59,090 --> 00:11:00,719
So for all the nodes that are in there,
因此，对于其中的所有节点， 

240
00:11:00,919 --> 00:11:02,500
visited is going to be true.
访问将是真实的。 

241
00:11:02,500 --> 00:11:06,024



242
00:11:06,024 --> 00:11:06,523
Sorry.
抱歉。 

243
00:11:06,523 --> 00:11:10,139



244
00:11:10,139 --> 00:11:10,639
OK.
好。 

245
00:11:10,639 --> 00:11:14,490
So where do I fill this in?
那么我应该在哪里填写呢？ 

246
00:11:14,490 --> 00:11:14,859
Let's use it.
让我们使用它。 

247
00:11:15,059 --> 00:11:19,089



248
00:11:19,090 --> 00:11:26,470
AUDIENCE: Four n and g neighbors, set it to true.
听众：四个n和g邻居，将其设置为true。 

249
00:11:26,470 --> 00:11:27,709
But before that--
但在此之前

250
00:11:27,909 --> 00:11:29,919
PROFESSOR: So here?
教授：那么在这里？ 

251
00:11:29,919 --> 00:11:33,279
AUDIENCE: R not.
听众：R不。 

252
00:11:33,279 --> 00:11:36,047
Um.
嗯

253
00:11:36,047 --> 00:11:36,629
PROFESSOR: OK.
教授：好的。 

254
00:11:36,629 --> 00:11:40,529



255
00:11:40,529 --> 00:11:41,429
So let's say this.
这么说吧。 

256
00:11:41,429 --> 00:11:44,089
Let's say these are lines 1, 2, 3.
假设这些是第1、2、3行。 

257
00:11:44,090 --> 00:11:47,719
Line 1.5 or 2.5?
 1.5或2.5行？ 

258
00:11:47,919 --> 00:11:54,839
AUDIENCE: So at n 1.5, check if v is in the dictionary.
听众：所以在n 1.5处，检查v是否在字典中。 

259
00:11:54,840 --> 00:11:55,519
PROFESSOR: Here?
教授：这吗？ 

260
00:11:55,519 --> 00:11:57,110
OK.
好。 

261
00:11:57,110 --> 00:12:06,645
If v in r dot visited, then--
如果访问了v in r点，则- 

262
00:12:06,645 --> 00:12:09,016



263
00:12:09,017 --> 00:12:09,725
AUDIENCE: Return.
听众：回来。 

264
00:12:09,725 --> 00:12:19,360



265
00:12:19,360 --> 00:12:26,750
Then 2.5, set r dot n to true.
然后2.5，将r dot n设置为true。 

266
00:12:26,750 --> 00:12:31,114
You would only do it n times--
你只会做n次

267
00:12:31,114 --> 00:12:31,579
PROFESSOR: Wait.
教授：等等。 

268
00:12:31,779 --> 00:12:35,982
So here you're saying say r dot visited of n equals true?
因此，您在这里说的是n的r点访问是否等于true？ 

269
00:12:35,982 --> 00:12:37,461
AUDIENCE: Oh, no.
听众：哦，不。 

270
00:12:37,461 --> 00:12:40,913
Change the v in v visited return,
更改已访问退货中的v， 

271
00:12:40,913 --> 00:12:42,884
change that into a loop.
改变成一个循环。 

272
00:12:42,884 --> 00:12:44,909
Put that after the loop.
将其放在循环之后。 

273
00:12:44,909 --> 00:12:48,391
Put that into the loop.
将其放入循环中。 

274
00:12:48,392 --> 00:12:52,368
And it's n visited to the [INAUDIBLE].
而且它已经访问过[音频不清晰]。 

275
00:12:52,368 --> 00:12:59,350



276
00:12:59,350 --> 00:13:08,803
PROFESSOR: n in r dot visited-- we probably want not n, right?
教授：n点中有n个访问过-我们可能不想要n个，对吧？ 

277
00:13:08,803 --> 00:13:09,720
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

278
00:13:09,720 --> 00:13:14,147



279
00:13:14,147 --> 00:13:14,730
PROFESSOR: OK.
教授：好的。 

280
00:13:14,730 --> 00:13:19,469



281
00:13:19,669 --> 00:13:28,636
R dot visited is true and then the DFS.
访问的R点为true，然后为DFS。 

282
00:13:28,636 --> 00:13:31,219
So will this achieve the thing that I wanted at the beginning.
因此这将实现我一开始想要的东西。 

283
00:13:31,220 --> 00:13:33,080
You start at A, you go to B, you go to C,
您从A开始，进入B，进入C， 

284
00:13:33,080 --> 00:13:35,079
and then you do not go to A?
然后你不去A？ 

285
00:13:35,279 --> 00:13:37,000
Not quite.
不完全的。 

286
00:13:37,000 --> 00:13:39,019
AUDIENCE: We haven't had our starting yet.
听众：我们还没有开始。 

287
00:13:39,019 --> 00:13:39,519
Yeah.
是的

288
00:13:39,519 --> 00:13:43,413



289
00:13:43,413 --> 00:13:48,528
We could add V at the beginning and check at the end.
我们可以在开头添加V，然后在末尾检查。 

290
00:13:48,528 --> 00:13:52,309
Because that's only the visited, right?
因为那只是参观者，对不对？ 

291
00:13:52,309 --> 00:13:54,859
PROFESSOR: So I think I like Christian's suggestion.
教授：所以我认为我喜欢克里斯蒂安的建议。 

292
00:13:54,860 --> 00:14:02,759
r dot visited of v is true.
 v的r点访问为true。 

293
00:14:02,759 --> 00:14:04,259
And then we can remove it from here.
然后我们可以从这里删除它。 

294
00:14:04,259 --> 00:14:07,703



295
00:14:07,703 --> 00:14:11,639
AUDIENCE: It has to be [INAUDIBLE]
听众：必须是[听不清] 

296
00:14:11,639 --> 00:14:14,840
because the other case is going to cover
因为另一种情况将涵盖

297
00:14:14,840 --> 00:14:16,204
for if you visited again.
如果您再次访问。 

298
00:14:16,404 --> 00:14:21,855
But the first time it's being called, it's not checking--
但是第一次调用它时，它并没有检查- 

299
00:14:21,855 --> 00:14:23,730
PROFESSOR: Well you mean the first time here?
教授：那您是第一次来吗？ 

300
00:14:23,730 --> 00:14:26,000
AUDIENCE: The first call that's being made,
听众：第一次拨打电话， 

301
00:14:26,000 --> 00:14:27,913
and the recursive call, it's going
和递归调用

302
00:14:27,913 --> 00:14:30,433
to be as if it's not into the visited node.
好像它不在访问节点中一样。 

303
00:14:30,433 --> 00:14:31,100
PROFESSOR: Yeah.
教授：是的。 

304
00:14:31,100 --> 00:14:34,090
But this is at the beginning.
但这只是开始。 

305
00:14:34,090 --> 00:14:35,129
Right?
对？ 

306
00:14:35,129 --> 00:14:38,210
So this calls DFS visit to the starting node.
因此，这将调用DFS访问起始节点。 

307
00:14:38,210 --> 00:14:38,609
Do we care?
我们在乎吗？ 

308
00:14:38,809 --> 00:14:42,339



309
00:14:42,340 --> 00:14:43,349
So I think this should work.
所以我认为这应该可行。 

310
00:14:43,549 --> 00:14:46,091
It's not the only way to write it, but it's reasonably clean.
这不是唯一的编写方法，但是它相当干净。 

311
00:14:46,091 --> 00:14:50,370
It's easy to reason about, and it works.
这很容易推理，并且有效。 

312
00:14:50,370 --> 00:14:52,629
Does it make sense to everyone?
这对所有人有意义吗？ 

313
00:14:52,629 --> 00:14:53,129
OK.
好。 

314
00:14:53,129 --> 00:14:54,879
We're going to change things a little bit.
我们将稍作更改。 

315
00:14:54,879 --> 00:14:56,690
So instead of using visited, we're
因此，我们不使用访问，而是

316
00:14:56,690 --> 00:14:59,849
going to keep track for every node of its parent.
跟踪其父节点的每个节点。 

317
00:15:00,049 --> 00:15:03,000
So the node that we visited from.
因此，我们访问的节点。 

318
00:15:03,000 --> 00:15:04,750
So we're not going to use visited anymore.
因此，我们将不再使用访问。 

319
00:15:04,750 --> 00:15:10,220
Instead we're going to use parent of v
相反，我们将使用v的父级

320
00:15:10,220 --> 00:15:13,370
is going to be some other node.
将成为其他节点。 

321
00:15:13,370 --> 00:15:17,929



322
00:15:17,929 --> 00:15:21,129
So what I want is for this graph,
所以我想要这张图

323
00:15:21,129 --> 00:15:24,220
I said I'm going to go from A to B, and then from B to C.
我说过我将从A到B，然后从B到C。 

324
00:15:24,220 --> 00:15:32,340
So I want the parent of B to be A, and the parent of C to be B.
所以我希望B的父母是A，C的父母是B。 

325
00:15:32,340 --> 00:15:34,019
Make sense for everyone?
对每个人都有意义吗？ 

326
00:15:34,019 --> 00:15:36,230
So what's the parent of A?
那么A的父母是谁？ 

327
00:15:36,230 --> 00:15:37,110
AUDIENCE: None.
听众：没有。 

328
00:15:37,110 --> 00:15:38,979
PROFESSOR: None's a good value, right?
教授：没有一个好的价值吧？ 

329
00:15:39,179 --> 00:15:41,099
There's no parent.
没有父母

330
00:15:41,100 --> 00:15:42,090
OK.
好。 

331
00:15:42,090 --> 00:15:44,879
So how would I modify this code to write that?
那么我将如何修改此代码以编写该代码？ 

332
00:15:44,879 --> 00:15:52,730



333
00:15:52,730 --> 00:15:59,940
AUDIENCE: Stick a line in 2.75 and establish 3b
观众：在2.75分界线并建立3b 

334
00:15:59,940 --> 00:16:03,370
as the parent of n.
作为n的父母。 

335
00:16:03,370 --> 00:16:08,299
PROFESSOR: So r dot parent?
教授：那么，父母吗？ 

336
00:16:08,299 --> 00:16:12,699
AUDIENCE: Yeah, of n is v.
听众：是的，n为v。 

337
00:16:12,700 --> 00:16:15,480
PROFESSOR: Of n is v. Good.
教授：n是v。 

338
00:16:15,480 --> 00:16:17,200
And I don't have visited anymore,
而且我不再去了， 

339
00:16:17,200 --> 00:16:18,849
so this line is going to blow up.
所以这条线会炸毁。 

340
00:16:19,049 --> 00:16:20,250
So what do I do instead?
那我该怎么办呢？ 

341
00:16:20,250 --> 00:16:23,080



342
00:16:23,080 --> 00:16:24,509
AUDIENCE: Oh.
听众：哦。 

343
00:16:24,509 --> 00:16:28,029
It doesn't have a parent?
它没有父母吗？ 

344
00:16:28,029 --> 00:16:28,699
PROFESSOR: Yep.
教授：是的。 

345
00:16:28,700 --> 00:16:31,324
So if it doesn't have a parent, we didn't visit it.
因此，如果没有父母，我们就没有拜访它。 

346
00:16:31,524 --> 00:16:33,149
So the parents works just like visited,
父母的工作就像拜访一样

347
00:16:33,149 --> 00:16:35,107
except the values are not going to be all true.
除了这些值不会全部为真。 

348
00:16:35,107 --> 00:16:38,014
They're going to be something a bit more useful.
它们将变得更有用。 

349
00:16:38,014 --> 00:16:41,231
AUDIENCE: We can't test for none because the first one has
观众：我们无法测试，因为第一个有

350
00:16:41,231 --> 00:16:41,899
a value of none.
无值。 

351
00:16:41,899 --> 00:16:43,730
PROFESSOR: But they're not testing for none,
教授：但是他们并没有全力以赴， 

352
00:16:43,730 --> 00:16:45,688
we're saying is it in the dictionary or not?
我们是说在字典里还是没有？ 

353
00:16:45,688 --> 00:16:46,230
AUDIENCE: Oh.
听众：哦。 

354
00:16:46,230 --> 00:16:46,730
OK.
好。 

355
00:16:46,730 --> 00:16:52,359



356
00:16:52,359 --> 00:16:53,449
PROFESSOR: That's a good point.
教授：很好。 

357
00:16:53,649 --> 00:16:54,230
You could be testing for none.
您可能没有测试。 

358
00:16:54,230 --> 00:16:55,639
That wouldn't work.
那是行不通的。 

359
00:16:55,639 --> 00:16:58,370
So you have to write the check like this.
因此，您必须像这样写支票。 

360
00:16:58,370 --> 00:17:00,953
And we're going to erase this because otherwise, it's
我们将删除它，因为否则

361
00:17:00,953 --> 00:17:02,120
going to throw an exception.
将引发异常。 

362
00:17:02,120 --> 00:17:06,210



363
00:17:06,210 --> 00:17:08,954
And what else do we need?
我们还需要什么？ 

364
00:17:08,954 --> 00:17:10,078
There's one missing parent.
有一个失踪的父母。 

365
00:17:10,078 --> 00:17:14,533



366
00:17:14,534 --> 00:17:15,736
AUDIENCE: Inverse form?
听众：逆形式？ 

367
00:17:15,936 --> 00:17:16,519
PROFESSOR: OK.
教授：好的。 

368
00:17:16,519 --> 00:17:18,695
Where do I say that?
我在哪说

369
00:17:18,695 --> 00:17:21,459
AUDIENCE: In DFS.
听众：在DFS中。 

370
00:17:21,460 --> 00:17:23,059
PROFESSOR: OK.
教授：好的。 

371
00:17:23,059 --> 00:17:26,598
One, two, three, which line?
一二三

372
00:17:26,598 --> 00:17:30,379
1.5, 2.5, 3.5?
 1.5、2.5、3.5？ 

373
00:17:30,380 --> 00:17:31,375
AUDIENCE: 2.5.
观众：2.5。 

374
00:17:31,375 --> 00:17:32,000
PROFESSOR: 2.5.
教授：2.5。 

375
00:17:32,000 --> 00:17:34,476
All right, so here.
好的，这里。 

376
00:17:34,476 --> 00:17:35,822
What do I write?
我写什么？ 

377
00:17:36,022 --> 00:17:39,469



378
00:17:39,470 --> 00:17:39,970
Yes?
是？ 

379
00:17:39,970 --> 00:17:42,538



380
00:17:42,538 --> 00:17:44,980
AUDIENCE: Parent of s is none.
听众：的父不是。 

381
00:17:44,980 --> 00:17:46,700
PROFESSOR: OK.
教授：好的。 

382
00:17:46,700 --> 00:17:54,890
So r dot parent s is none.
所以点双亲是无。 

383
00:17:54,890 --> 00:17:57,619
So now this works.
所以现在这可行。 

384
00:17:57,819 --> 00:17:58,509
Right?
对？ 

385
00:17:58,509 --> 00:17:59,650
Any questions so far?
到目前为止有什么问题吗？ 

386
00:17:59,650 --> 00:18:03,470



387
00:18:03,470 --> 00:18:03,970
Nope.
不。 

388
00:18:03,970 --> 00:18:05,159
Basic DFS works.
基本的DFS可以工作。 

389
00:18:05,359 --> 00:18:06,649
Everyone's happy with it?
每个人都满意吗？ 

390
00:18:06,650 --> 00:18:11,460



391
00:18:11,460 --> 00:18:16,970
Let's try to track it for this graph here.
让我们尝试在此处跟踪此图。 

392
00:18:16,970 --> 00:18:19,180
And you're going to be in a better position than me
而且你会比我处于更好的位置

393
00:18:19,180 --> 00:18:21,480
because I'm not sure I can see the graph all
因为我不确定是否可以看到所有图表

394
00:18:21,480 --> 00:18:23,990
the way from here.
从这里走的路。 

395
00:18:23,990 --> 00:18:25,460
Almost.
几乎。 

396
00:18:25,460 --> 00:18:30,750
So let's have the parents or the parent's dictionary here.
因此，让我们这里有父母或父母的字典。 

397
00:18:30,750 --> 00:18:35,559



398
00:18:35,559 --> 00:18:39,829
And here, let's write the call structure as it will happen.
在这里，让我们编写将要发生的调用结构。 

399
00:18:39,829 --> 00:18:43,919
So where do I start?
那我从哪里开始呢？ 

400
00:18:43,920 --> 00:18:46,639
DFS of A, right?
 D的DFS，对不对？ 

401
00:18:46,839 --> 00:18:56,129
DFS of A. And this is going to call DFS visit A.
 DFS的A。这将称为DFS访问A。 

402
00:18:56,130 --> 00:18:57,130
What are A's neighbors?
 A的邻居是什么？ 

403
00:18:57,130 --> 00:18:59,890



404
00:18:59,890 --> 00:19:00,872
AUDIENCE: b and g.
听众：b和g。 

405
00:19:00,872 --> 00:19:03,913



406
00:19:03,913 --> 00:19:04,579
PROFESSOR: Cool.
教授：太好了。 

407
00:19:04,579 --> 00:19:07,480
Is b in parents?
父母有b吗？ 

408
00:19:07,480 --> 00:19:09,801
What's in parents, at this point?
父母现在在做什么？ 

409
00:19:09,801 --> 00:19:12,121
AUDIENCE: Just a.
听众：只是。 

410
00:19:12,122 --> 00:19:14,769
Oh.
哦。 

411
00:19:14,769 --> 00:19:16,019
PROFESSOR: A is none.
教授：A不是。 

412
00:19:16,019 --> 00:19:16,665
Good.
好。 

413
00:19:16,665 --> 00:19:18,289
Excellent.
优秀的。 

414
00:19:18,289 --> 00:19:21,559
So B is not in parents, so what am I going to do?
所以B不在父母中，那我该怎么办？ 

415
00:19:21,559 --> 00:19:23,571
And it's the parents in visited.
这是拜访的父母。 

416
00:19:23,571 --> 00:19:24,529
Right?
对？ 

417
00:19:24,529 --> 00:19:25,767
What's B's parents?
 B的父母是谁？ 

418
00:19:25,767 --> 00:19:28,428



419
00:19:28,628 --> 00:19:31,500
AUDIENCE: A.
听众：A. 

420
00:19:31,500 --> 00:19:32,380
PROFESSOR: OK.
教授：好的。 

421
00:19:32,380 --> 00:19:38,480
I'm going to call DFS visit of B. These children.
我将打电话给B的DFS访问。这些孩子。 

422
00:19:38,480 --> 00:19:43,159



423
00:19:43,359 --> 00:19:45,939
C. Is C parents?
 C.是C父母吗？ 

424
00:19:45,940 --> 00:19:46,440
No?
没有？ 

425
00:19:46,440 --> 00:19:46,821
What happens?
怎么了？ 

426
00:19:47,021 --> 00:19:47,980
Feel free to take over.
随时接管。 

427
00:19:47,980 --> 00:19:49,813
When you get it, feel free to start talking,
掌握之后，请随时开始讲话， 

428
00:19:49,813 --> 00:19:51,062
and I can just write.
我可以写

429
00:19:51,262 --> 00:19:52,346
AUDIENCE: Of C.
听众：来自C。 

430
00:19:52,346 --> 00:19:52,930
PROFESSOR: OK.
教授：好的。 

431
00:19:52,930 --> 00:19:56,660



432
00:19:56,660 --> 00:19:58,737
What else?
还有什么？ 

433
00:19:58,737 --> 00:20:03,659
PROFESSOR: C's parent is B. So I'm
教授：C的父母是B。所以我

434
00:20:03,859 --> 00:20:06,809
in B. The only child is C. C is not in parents.
在B中。唯一的孩子是C。C不在父母中。 

435
00:20:06,809 --> 00:20:07,960
C gets in parent.
 C成为父母。 

436
00:20:07,960 --> 00:20:13,269
C's parent is B. Call DFS visit of C, what are C's children?
 C的父母是B。打电话给C的DFS访问，C的孩子是什么？ 

437
00:20:13,269 --> 00:20:14,769
AUDIENCE: [INAUDIBLE] and d.
听众：[听不清]和d。 

438
00:20:14,769 --> 00:20:17,001



439
00:20:17,001 --> 00:20:19,210
PROFESSOR: So we're wondering about the order, right?
教授：所以我们想知道订单，对吗？ 

440
00:20:19,210 --> 00:20:20,980
Let's assume that in the adjacency list,
假设在邻接列表中， 

441
00:20:20,980 --> 00:20:24,500
all the nodes are in alphabetical order.
所有节点均按字母顺序排列。 

442
00:20:24,500 --> 00:20:34,930
So I'm going to have A, D, and F. OK.
所以我要有A，D和F。好的。 

443
00:20:34,930 --> 00:20:37,669
Is A in parents?
父母有A吗？ 

444
00:20:37,869 --> 00:20:39,959
AUDIENCE: Yes.
听众：是的。 

445
00:20:39,960 --> 00:20:42,729
PROFESSOR: Is D in parents?
教授：父母有D吗？ 

446
00:20:42,729 --> 00:20:43,269
AUDIENCE: No.
听众：不。 

447
00:20:43,269 --> 00:20:45,542
PROFESSOR: So what happens?
教授：那会发生什么？ 

448
00:20:45,542 --> 00:20:54,389
AUDIENCE: Parents visit D. D's parent is C.
听众：父母拜访D。D的父母是C。 

449
00:20:54,390 --> 00:20:56,663
PROFESSOR: D's neighbors?
教授：D的邻居？ 

450
00:20:56,663 --> 00:21:02,400
AUDIENCE: E and F.
观众：E和F。 

451
00:21:02,400 --> 00:21:04,599
PROFESSOR: E is in the-- no.
教授：E在-不。 

452
00:21:04,799 --> 00:21:11,354



453
00:21:11,354 --> 00:21:12,269
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

454
00:21:12,269 --> 00:21:19,139



455
00:21:19,140 --> 00:21:19,980
PROFESSOR: Cool.
教授：太好了。 

456
00:21:19,980 --> 00:21:21,789
Does E have any children?
 E有孩子吗？ 

457
00:21:21,789 --> 00:21:22,609
AUDIENCE: No.
听众：不。 

458
00:21:22,609 --> 00:21:23,759
PROFESSOR: So I'm done.
教授：我完成了。 

459
00:21:23,759 --> 00:21:27,309
I get out of it, right?
我摆脱它，对不对？ 

460
00:21:27,309 --> 00:21:30,111
Is F in parents?
父母有F吗？ 

461
00:21:30,112 --> 00:21:32,887
AUDIENCE: No.
听众：不。 

462
00:21:33,087 --> 00:21:36,460
PROFESSOR: F's parent is?
教授：F的父母是？ 

463
00:21:36,460 --> 00:21:36,960
Cool.
凉。 

464
00:21:36,960 --> 00:21:43,463



465
00:21:43,463 --> 00:21:44,629
F doesn't have any children.
 F没有孩子。 

466
00:21:44,630 --> 00:21:45,220
Right?
对？ 

467
00:21:45,220 --> 00:21:49,210
So I get out of this DFS visit.
因此，我离开了这次DFS访问。 

468
00:21:49,210 --> 00:21:51,799
I'm done with F. So I get out of this visit.
我已经完成了F。所以我离开了这次访问。 

469
00:21:51,799 --> 00:21:53,654
And I get back to this one.
我回到这一点。 

470
00:21:53,654 --> 00:21:58,059
I'm done with D, and I'm at F. Is F in parents?
我完成了D，现在在F。F是父母吗？ 

471
00:21:58,059 --> 00:21:59,240
OK.
好。 

472
00:21:59,240 --> 00:22:05,594
So what kind of edge is C to F?
那么C到F的优势是什么？ 

473
00:22:05,594 --> 00:22:06,344
AUDIENCE: Forward.
听众：转发。 

474
00:22:06,344 --> 00:22:08,611



475
00:22:08,811 --> 00:22:09,394
PROFESSOR: OK.
教授：好的。 

476
00:22:09,394 --> 00:22:12,690



477
00:22:12,690 --> 00:22:14,568
So forward maybe tree.
所以前进也许树。 

478
00:22:14,568 --> 00:22:15,859
Let's start with the easy ones.
让我们从简单的开始。 

479
00:22:15,859 --> 00:22:20,789
So now we've gone forward with AB, BC, CD, DE, and DF.
因此，现在我们开始使用AB，BC，CD，DE和DF。 

480
00:22:20,789 --> 00:22:22,791
What kind of edges are these ones?
这些是什么样的边缘？ 

481
00:22:22,791 --> 00:22:26,519



482
00:22:26,519 --> 00:22:27,019
Tree edges.
树的边缘。 

483
00:22:27,019 --> 00:22:32,539



484
00:22:32,539 --> 00:22:34,519
Does anyone know why they're called tree edges?
有谁知道为什么他们被称为树边缘？ 

485
00:22:34,519 --> 00:22:38,503



486
00:22:38,503 --> 00:22:41,969
So if you look at the parent pointers that they have there,
因此，如果您查看它们在那里的父指针， 

487
00:22:41,970 --> 00:22:46,279
they're going to end up defining a tree.
他们最终将定义一棵树。 

488
00:22:46,279 --> 00:22:48,529
And the tree is, the tree shows the order
树是，树显示顺序

489
00:22:48,529 --> 00:22:51,349
in which DFS looked at the notes.
 DFS在其中查看了注释。 

490
00:22:51,349 --> 00:22:56,329
So let me erase this and draw the tree for DFS
因此，让我删除它并为DFS绘制树

491
00:22:56,329 --> 00:22:57,210
that we had so far.
我们到目前为止。 

492
00:22:57,210 --> 00:23:01,480



493
00:23:01,480 --> 00:23:05,450
So we started at A, then we went to B. Then we went to C, then
所以我们从A开始，然后去了B。然后我们去了C，然后

494
00:23:05,450 --> 00:23:12,200
we went to D, E, F. So this is all part of the DFS tree.You
我们去了D，E，F。所以这都是DFS树的一部分。 

495
00:23:12,200 --> 00:23:13,940
can see that for all these nodes,
可以看到对于所有这些节点， 

496
00:23:13,940 --> 00:23:16,889
their parent pointers point the right way.
它们的父指针指向正确的方向。 

497
00:23:17,089 --> 00:23:19,009
So if you have parent pointers for every node,
因此，如果每个节点都有父指针， 

498
00:23:19,009 --> 00:23:21,940
this is going to give you a tree.
这会给你一棵树。 

499
00:23:21,940 --> 00:23:24,950
So these are tree edges because they're part of this tree.
这些是树的边缘，因为它们是该树的一部分。 

500
00:23:24,950 --> 00:23:30,269
So now we have this edge from C to F.
所以现在我们有了从C到F的优势。 

501
00:23:30,269 --> 00:23:32,779
And this is what kind of edge?
这是什么样的优势？ 

502
00:23:32,779 --> 00:23:36,126



503
00:23:36,126 --> 00:23:36,667
Forward edge.
前缘。 

504
00:23:36,667 --> 00:23:39,751
Why is it a forward edge?
为什么是前缘？ 

505
00:23:39,751 --> 00:23:42,142
AUDIENCE: Somewhere up higher in the tree
听众：在树上更高的某个地方

506
00:23:42,142 --> 00:23:45,009
is trying to get somewhere lower on the tree.
试图降到树下的某个地方。 

507
00:23:45,009 --> 00:23:46,559
It's going forward in time.
这是及时的。 

508
00:23:46,559 --> 00:23:49,740
PROFESSOR: So it's going from a node in the tree
教授：所以它是从树中的一个节点开始的

509
00:23:49,740 --> 00:23:53,142
to a node's child in the tree.
到树中节点的孩子。 

510
00:23:53,142 --> 00:23:53,649
Sorry, not child.
对不起，不是孩子。 

511
00:23:53,849 --> 00:23:54,709
Descendant.
后裔。 

512
00:23:54,710 --> 00:23:59,250
So F is strictly under C. So yeah.
所以F严格在C之下。是的。 

513
00:23:59,250 --> 00:24:00,480
It takes us forward in time.
它使我们及时前进。 

514
00:24:00,480 --> 00:24:02,240
It's a shortcut in the tree.
这是树上的捷径。 

515
00:24:02,240 --> 00:24:05,400
So that's why it's a forward edge.
这就是为什么这是一个前沿。 

516
00:24:05,400 --> 00:24:07,259
So we now have two types of edges so far.
因此，到目前为止，我们有两种类型的边缘。 

517
00:24:07,259 --> 00:24:09,650
Tree edges and forward edges.
树边缘和前边缘。 

518
00:24:09,650 --> 00:24:13,169
AUDIENCE: So tree edges [INAUDIBLE]?
听众：那么树的边缘[听不清]？ 

519
00:24:13,369 --> 00:24:14,150
PROFESSOR: Yep.
教授：是的。 

520
00:24:14,151 --> 00:24:16,150
So the tree edges are the ones that DFS follows.
因此，树边缘就是DFS遵循的边缘。 

521
00:24:16,150 --> 00:24:19,640



522
00:24:19,640 --> 00:24:21,730
All of these are tree edges.
所有这些都是树的边缘。 

523
00:24:21,730 --> 00:24:22,230
Yes.
是。 

524
00:24:22,230 --> 00:24:25,630
AUDIENCE: So like an edge from B to C,
听众：就像从B到C的优势一样， 

525
00:24:25,830 --> 00:24:28,185
why can't that be a forward edge?
为什么不能成为前锋？ 

526
00:24:28,185 --> 00:24:29,127
Because technically it's not a shortcut, right?
因为从技术上讲这不是捷径，对吗？ 

527
00:24:29,127 --> 00:24:31,043
But it's saying it's pointing to the children,
但这是指孩子们

528
00:24:31,044 --> 00:24:32,430
but it only has one child.
但只有一个孩子

529
00:24:32,430 --> 00:24:35,609
PROFESSOR: Because that's the edge that DFS took.
教授：因为那是DFS的优势。 

530
00:24:35,809 --> 00:24:38,179
So the edges that we actually follow in DFS
所以我们在DFS中实际遵循的优势

531
00:24:38,180 --> 00:24:41,980
have a special name, and they're tree edges.
有一个特殊的名字，它们是树的边缘。 

532
00:24:41,980 --> 00:24:43,680
So first off, the most important edges
首先，最重要的优势

533
00:24:43,680 --> 00:24:46,480
are the edges that make up your DFS tree.
是构成DFS树的边缘。 

534
00:24:46,480 --> 00:24:49,866
And that's why those are tree edges.
这就是为什么这些是树的边缘。 

535
00:24:49,866 --> 00:24:51,450
We don't even look at the other types.
我们甚至不看其他类型。 

536
00:24:51,450 --> 00:24:54,309
If you have an edge and DFS followed it, it's a tree edge.
如果您有一条边缘并且DFS紧随其后，则它是树边缘。 

537
00:24:54,309 --> 00:24:56,339
Done.
做完了

538
00:24:56,339 --> 00:24:57,929
So these are all tree edges.
这些都是树的边缘。 

539
00:24:57,930 --> 00:24:59,679
We don't care about the other definitions.
我们不在乎其他定义。 

540
00:24:59,679 --> 00:25:03,609



541
00:25:03,809 --> 00:25:06,139
So don't be ashamed to ask questions about this
所以不要以问这个问题为耻

542
00:25:06,140 --> 00:25:08,220
because this is hard to understand.
因为这很难理解。 

543
00:25:08,220 --> 00:25:10,410
It's an issue we're trying to clarify here.
这是我们要在此处澄清的问题。 

544
00:25:10,410 --> 00:25:12,169
So the point, why we're doing that example,
关键是为什么我们要做这个例子， 

545
00:25:12,369 --> 00:25:15,149
is to figure this out.
是要弄清楚这一点。 

546
00:25:15,150 --> 00:25:16,769
So please do ask your questions.
所以请问您的问题。 

547
00:25:16,769 --> 00:25:17,519
Yes?
是？ 

548
00:25:17,519 --> 00:25:21,036
AUDIENCE: So is it edges that are followed at any point
听众：在任何时候都遵循的边缘

549
00:25:21,036 --> 00:25:23,357
during the search process?
在搜索过程中？ 

550
00:25:23,357 --> 00:25:26,984
I guess they're edges that never get touched.
我想它们是永不动摇的边缘。 

551
00:25:26,984 --> 00:25:27,769
Right?
对？ 

552
00:25:27,769 --> 00:25:28,394
PROFESSOR: Yep.
教授：是的。 

553
00:25:28,394 --> 00:25:31,319
So when I'm at C, and I look at this edge,
因此，当我在C语言时，我会看着这个优势， 

554
00:25:31,319 --> 00:25:32,990
F is already in parents.
 F已经在父母中了。 

555
00:25:32,990 --> 00:25:35,622
So this edge is not going to be followed by DFS.
因此，DFS将不会跟随这一优势。 

556
00:25:35,622 --> 00:25:36,879
There are some other types of edges
还有一些其他类型的边缘

557
00:25:37,079 --> 00:25:38,163
that will not be followed.
那将不会被遵循。 

558
00:25:38,163 --> 00:25:41,811
And we'll get to that by the time DFS completes.
在DFS完成时，我们将解决这个问题。 

559
00:25:41,811 --> 00:25:44,281
Yes.
是。 

560
00:25:44,281 --> 00:25:48,710
AUDIENCE: You mean that like G to C is not--
听众：您的意思是说，从G到C并非- 

561
00:25:48,710 --> 00:25:50,460
PROFESSOR: You're ruining my example, man.
教授：老兄，你毁了我的榜样。 

562
00:25:50,460 --> 00:25:53,670
I'm supposed to ask you that later on.
我应该稍后再问你。 

563
00:25:53,670 --> 00:25:56,159
So let's let go through it and see what kind of edge it is.
因此，让我们看一下它是什么样的优势。 

564
00:25:56,359 --> 00:25:58,789
You're right, but let's pretend we don't know that.
您是对的，但是我们假装不知道这一点。 

565
00:25:58,789 --> 00:26:01,720
And we'll see as we follow the DFS.
然后我们将按照DFS进行查看。 

566
00:26:01,720 --> 00:26:02,220
OK.
好。 

567
00:26:02,220 --> 00:26:04,106
So yep.
是的

568
00:26:04,106 --> 00:26:05,190
That one's a forward edge.
那是一个前沿。 

569
00:26:05,190 --> 00:26:06,900
We'll deal with it later.
我们稍后再处理。 

570
00:26:06,900 --> 00:26:08,380
We're here.
我们在这里

571
00:26:08,380 --> 00:26:12,309
We decided that C to F is a forward edge.
我们认为C到F是一个前沿。 

572
00:26:12,509 --> 00:26:13,629
F is already in parents.
 F已经在父母中了。 

573
00:26:13,630 --> 00:26:15,420
So we're going to return from DFS visit
因此，我们将从DFS访问中返回

574
00:26:15,420 --> 00:26:21,529
C. We're in DFS visit V. We're done with C.
 C.我们在DFS中访问V。C已经完成。 

575
00:26:21,529 --> 00:26:24,829
Do we have anything else to do here?
我们在这里还有其他事情吗？ 

576
00:26:24,829 --> 00:26:31,789
So we go up to A. We're done with B. And we look at G. A
因此，我们转到A。B完成了。我们来看G。 

577
00:26:31,789 --> 00:26:35,490
to G. Is G in parents?
给G。父母中有G吗？ 

578
00:26:35,490 --> 00:26:35,990
No.
没有。 

579
00:26:35,990 --> 00:26:40,059
So we're going to call it.
因此，我们将其称为。 

580
00:26:40,059 --> 00:26:52,954
So A, B. DFS visit G. What are G's neighbors?
因此，A，B。DFS访问G。G的邻居是什么？ 

581
00:26:52,954 --> 00:26:58,409
AUDIENCE: C.
听众：C. 

582
00:26:58,410 --> 00:27:00,129
PROFESSOR: OK.
教授：好的。 

583
00:27:00,329 --> 00:27:05,089
So is C in parents?
父母的C也一样吗？ 

584
00:27:05,089 --> 00:27:07,775



585
00:27:07,776 --> 00:27:08,650
Actually I was wrong.
其实我错了。 

586
00:27:08,650 --> 00:27:09,579
Sorry.
抱歉。 

587
00:27:09,779 --> 00:27:13,274
So C is in parents, so we're not going to visit it.
因为C在父母中，所以我们不会去拜访它。 

588
00:27:13,275 --> 00:27:15,400
So let's see how the tree looks like at this point.
现在，让我们看看树的外观。 

589
00:27:15,400 --> 00:27:20,000



590
00:27:20,000 --> 00:27:23,089
So it looks like this.
所以看起来像这样。 

591
00:27:23,089 --> 00:27:27,994
Is C a child of G?
 C是G的孩子吗？ 

592
00:27:27,994 --> 00:27:31,479



593
00:27:31,480 --> 00:27:35,269
So I'm wondering about this edge that we chose not to follow.
所以我想知道我们选择不遵循的这一优势。 

594
00:27:35,269 --> 00:27:39,400
We followed A to G so we know this is actually the edge.
我们遵循A到G的原则，因此我们知道这实际上是优势。 

595
00:27:39,400 --> 00:27:43,640
So from this edge, G to C, I'm wondering what kind of edge
所以从G到C的这个边缘，我想知道什么样的边缘

596
00:27:43,640 --> 00:27:44,425
it is.
它是。 

597
00:27:44,625 --> 00:27:49,559



598
00:27:49,559 --> 00:27:52,490
So C is not G's child, right?
所以C不是G的孩子，对吗？ 

599
00:27:52,490 --> 00:27:53,769
So another forward edge.
因此，另一个前沿。 

600
00:27:53,769 --> 00:27:54,269
Sorry.
抱歉。 

601
00:27:54,269 --> 00:27:55,728
I got confused earlier because they
我之前很困惑，因为他们

602
00:27:55,728 --> 00:27:58,140
look the same in a drawing.
在图纸上看起来一样。 

603
00:27:58,140 --> 00:28:02,220
So it's not a forward edge, then it's a cross edge.
因此，它不是前边缘，而是交叉边缘。 

604
00:28:02,220 --> 00:28:06,428



605
00:28:06,628 --> 00:28:08,169
There's one more edge that we haven't
还有一个我们没有的优势

606
00:28:08,170 --> 00:28:10,769
talked about because it was too early in the search.
谈论是因为搜索尚为时过早。 

607
00:28:10,769 --> 00:28:18,000
And that edge is from C to A. So if you remember
那边是从C到A。所以如果你还记得

608
00:28:18,000 --> 00:28:23,309
there, we were in DFS visit C. And the first thing we did
在那里，我们在DFS中访问了C。我们做的第一件事

609
00:28:23,309 --> 00:28:26,409
was we looked at A, we said, hey it's already in parents,
是我们看着A，我们说，嘿，它已经在父母那里了， 

610
00:28:26,410 --> 00:28:28,170
so we're not going to visit it.
所以我们不会去参观它。 

611
00:28:28,170 --> 00:28:31,557
So DFS did not follow the edge C to A.
因此，DFS没有跟随C到A的边缘。 

612
00:28:31,557 --> 00:28:32,640
That edge looks like this.
那个边缘看起来像这样。 

613
00:28:32,640 --> 00:28:35,197
What kind of edge is it?
这是什么优势？ 

614
00:28:35,397 --> 00:28:37,749
Back edge.
后边缘。 

615
00:28:37,749 --> 00:28:38,374
AUDIENCE: Wait.
听众：等等。 

616
00:28:38,374 --> 00:28:41,039
So it has to be direct descendant in order
因此它必须是顺序的直接后代

617
00:28:41,039 --> 00:28:42,945
to be a forward edge?
成为前锋？ 

618
00:28:42,945 --> 00:28:47,809
Because they are related through A, right?
因为它们通过A相关，对吗？ 

619
00:28:47,809 --> 00:28:49,356
C and G?
 C和G？ 

620
00:28:49,356 --> 00:28:51,940
PROFESSOR: So you have to look and which direction does it go?
教授：那你必须看一下，往哪个方向走？ 

621
00:28:51,940 --> 00:28:54,900
Does it go down the tree or up the tree?
它是沿着树走还是向上走？ 

622
00:28:54,900 --> 00:29:00,460
AUDIENCE: It's going down if you consider G to C. From G to C,
听众：如果您考虑G到C，它会下降。从G到C， 

623
00:29:00,460 --> 00:29:02,334
so it's a cross edge.
所以这是一个交叉的边缘。 

624
00:29:02,334 --> 00:29:03,000
PROFESSOR: Yeah.
教授：是的。 

625
00:29:03,000 --> 00:29:07,138
But is C G's descendant?
但是C G是后代吗？ 

626
00:29:07,138 --> 00:29:07,679
AUDIENCE: No.
听众：不。 

627
00:29:07,680 --> 00:29:10,789
But they are related.
但是它们是相关的。 

628
00:29:10,789 --> 00:29:13,089
PROFESSOR: They're related, but they're just
教授：它们是相关的，但它们只是

629
00:29:13,089 --> 00:29:15,620
related because they're in the tree.
相关，因为它们在树上。 

630
00:29:15,621 --> 00:29:16,162
AUDIENCE: OK.
听众：好的。 

631
00:29:16,162 --> 00:29:18,819
So it's only directly descendants?
所以这只是直接的后代吗？ 

632
00:29:18,819 --> 00:29:20,139
PROFESSOR: Yep.
教授：是的。 

633
00:29:20,140 --> 00:29:22,900
So DFS puts together a tree.
因此DFS整理了一棵树。 

634
00:29:22,900 --> 00:29:25,910
A forward edge is a shortcut in that tree.
前缘是该树中的快捷方式。 

635
00:29:25,910 --> 00:29:29,160
It lets you go forward in the VFS.
它使您可以在VFS中前进。 

636
00:29:29,160 --> 00:29:32,660
A backward edge points to a parent in the tree,
后缘指向树中的父级， 

637
00:29:32,660 --> 00:29:34,659
so it lets you go back in time.
这样您就可以回到过去。 

638
00:29:34,859 --> 00:29:37,949
A cross edge takes you from one point to another point.
十字边缘将您从一个点带到另一个点。 

639
00:29:37,950 --> 00:29:39,919
And it's not a forward edge, not a backward edge.
它不是前缘，也不是后缘。 

640
00:29:40,119 --> 00:29:44,179
So it takes you in a whole different world.
因此，它带您进入了一个全新的世界。 

641
00:29:44,180 --> 00:29:49,500
So C, A, G, has-- A, G is the sub-tree,
因此C，A，G具有-A，G是子树， 

642
00:29:49,500 --> 00:29:51,880
and then this guy's this other sub-tree,
然后这个家伙是另一个子树， 

643
00:29:51,880 --> 00:29:54,660
and they're different little worlds.
他们是不同的小世界。 

644
00:29:54,660 --> 00:29:57,500
And this edge goes from one to the other.
这个优势从一个延伸到另一个。 

645
00:29:57,500 --> 00:30:00,161



646
00:30:00,161 --> 00:30:02,660
So the algorithm to decide what kind of an edge it is, let's
因此，决定该边缘类型的算法，让我们

647
00:30:02,660 --> 00:30:04,380
put it together.
把它放在一起。 

648
00:30:04,380 --> 00:30:08,599
Which edge do we look at, which type do we think about first?
我们要看哪个边缘，首先要考虑哪种类型？ 

649
00:30:08,799 --> 00:30:09,399
Tree edge.
树边缘。 

650
00:30:09,400 --> 00:30:10,920
So DFS followed the edge.
因此DFS紧随其后。 

651
00:30:10,920 --> 00:30:12,940
It's a tree edge.
这是树的边缘。 

652
00:30:12,940 --> 00:30:15,980
So we have tree edges.
所以我们有树的边缘。 

653
00:30:15,980 --> 00:30:18,730
What do we do next?
接下来我们要做什么？ 

654
00:30:18,730 --> 00:30:25,420
So say we have an edge from u to v. If DFS follows it,
假设我们从u到v都有优势。如果DFS跟随它， 

655
00:30:25,420 --> 00:30:26,419
it's a tree edge.
这是树的边缘。 

656
00:30:26,619 --> 00:30:31,227
If not, then what question do I ask myself?
如果没有，那么我会问自己什么问题？ 

657
00:30:31,228 --> 00:30:33,712
AUDIENCE: It could be one of three edges then,
听众：那可能是三个优势之一

658
00:30:33,712 --> 00:30:34,876
back, forward, or cross.
向后，向前或交叉。 

659
00:30:34,876 --> 00:30:35,460
PROFESSOR: OK.
教授：好的。 

660
00:30:35,460 --> 00:30:37,380
So let's try to write a simple algorithm
因此，让我们尝试编写一个简单的算法

661
00:30:37,380 --> 00:30:38,880
so that if I ask you this on a quiz,
因此，如果我在测验中问您这个问题， 

662
00:30:38,880 --> 00:30:40,846
you can decide which is which.
您可以决定哪个。 

663
00:30:40,846 --> 00:30:44,915
AUDIENCE: So I think that you look forward
听众：所以我认为你很期待

664
00:30:44,915 --> 00:30:47,626
if u is the parent of v.
如果您是v的父母。 

665
00:30:47,626 --> 00:30:48,210
PROFESSOR: OK.
教授：好的。 

666
00:30:48,210 --> 00:30:58,852
So if u is a parent of v-- well, let's say ascendant.
因此，如果u是v的父级，那么，假设上升。 

667
00:30:58,852 --> 00:31:02,659
It's not just the direct parent, but this
不只是直系亲属

668
00:31:02,859 --> 00:31:04,179
is the right intuition.
是正确的直觉。 

669
00:31:04,180 --> 00:31:06,200
Then what kind of edge is it?
那是什么样的优势呢？ 

670
00:31:06,200 --> 00:31:08,759
AUDIENCE: Then it's the forward edge.
听众：那就是前沿。 

671
00:31:08,759 --> 00:31:12,359
PROFESSOR: So the edge is from u to v. If u is a parent of v,
教授：所以边是从u到v。如果u是v的父级， 

672
00:31:12,359 --> 00:31:13,039
forward edge.
前缘。 

673
00:31:13,039 --> 00:31:13,539
Good.
好。 

674
00:31:13,539 --> 00:31:17,076



675
00:31:17,076 --> 00:31:17,575
Otherwise?
除此以外？ 

676
00:31:17,575 --> 00:31:20,960



677
00:31:20,960 --> 00:31:21,875
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

678
00:31:21,875 --> 00:31:25,557



679
00:31:25,557 --> 00:31:26,140
PROFESSOR: OK.
教授：好的。 

680
00:31:26,140 --> 00:31:35,400



681
00:31:35,400 --> 00:31:36,429
Then?
然后？ 

682
00:31:36,429 --> 00:31:39,363
AUDIENCE: Then backward edge.
听众：然后落后。 

683
00:31:39,363 --> 00:31:40,629
Else cross edge.
其他边缘。 

684
00:31:40,829 --> 00:31:48,379



685
00:31:48,380 --> 00:31:49,859
PROFESSOR: Does this make sense?
教授：这有意义吗？ 

686
00:31:50,059 --> 00:31:52,129
So these are the four types of edges.
因此，这是四种类型的边。 

687
00:31:52,130 --> 00:31:54,690
DFS takes the edge, it's a forward edge.
 DFS占据了优势，这是一个前沿。 

688
00:31:54,690 --> 00:31:56,559
If not, we draw the DFS tree.
如果没有，我们绘制DFS树。 

689
00:31:56,559 --> 00:31:59,509
And we see does the edge go forward
我们看到优势在前进

690
00:31:59,509 --> 00:32:00,879
in the tree, forward edge.
在树上，向前边缘。 

691
00:32:00,880 --> 00:32:03,160
Does it go backward, backward edge.
它向后走，向后走。 

692
00:32:03,160 --> 00:32:07,734
Does it grow between completely unrelated nodes, cross edge.
它是否在完全不相关的节点之间交叉边缘增长。 

693
00:32:07,934 --> 00:32:11,350



694
00:32:11,351 --> 00:32:11,649
OK.
好。 

695
00:32:11,849 --> 00:32:13,709
Now let me ask another question.
现在让我问另一个问题。 

696
00:32:13,710 --> 00:32:16,669
Let's suppose we do this DFS thing again,
假设我们再次执行此DFS操作， 

697
00:32:16,869 --> 00:32:19,829
but let's suppose we do it on an undirected graph.
但是，假设我们在无向图上执行此操作。 

698
00:32:19,829 --> 00:32:23,581
What types of edges do I have?
我有哪些类型的边缘？ 

699
00:32:23,582 --> 00:32:26,753
Anyone remember off the top of their heads?
有人还记得吗？ 

700
00:32:26,953 --> 00:32:27,869
Don't think so, right?
不这样认为，对吧？ 

701
00:32:27,869 --> 00:32:29,035
So let's do it and find out.
因此，让我们去做并找出答案。 

702
00:32:29,036 --> 00:32:44,740



703
00:32:44,740 --> 00:32:51,349
So let me see where do I get some room.
所以，让我看看我在哪里可以得到一些空间。 

704
00:32:51,349 --> 00:32:55,379



705
00:32:55,380 --> 00:32:55,880
Here.
这里。 

706
00:32:55,880 --> 00:33:02,364



707
00:33:02,364 --> 00:33:04,279
Let's write the tree that's we're going to go.
让我们写一棵我们要去的树。 

708
00:33:04,279 --> 00:33:07,309
So let's do a VFS of this quickly and write the tree.
因此，让我们快速进行此VFS并编写树。 

709
00:33:07,309 --> 00:33:10,629
So we start at A, then what?
那么我们从A开始，那又如何呢？ 

710
00:33:10,630 --> 00:33:14,362



711
00:33:14,362 --> 00:33:14,862
Then?
然后？ 

712
00:33:14,862 --> 00:33:18,279



713
00:33:18,279 --> 00:33:19,990
Then?
然后？ 

714
00:33:19,990 --> 00:33:25,444
D. E.
德

715
00:33:25,444 --> 00:33:33,636
AUDIENCE: And go back to D. It could go from C to A.
听众：然后回到D。它可以从C到A。 

716
00:33:33,636 --> 00:33:34,220
PROFESSOR: OK.
教授：好的。 

717
00:33:34,220 --> 00:33:38,329
So we have C to A. What kind of edge is this?
所以我们有C到A。这是什么优势？ 

718
00:33:38,329 --> 00:33:40,386
AUDIENCE: Backward edge.
听众：向后边缘。 

719
00:33:40,386 --> 00:33:40,970
PROFESSOR: OK.
教授：好的。 

720
00:33:40,970 --> 00:33:44,549
So we still have tree edges for sure and backward edges.
因此，我们仍然具有确定的树边缘和向后的边缘。 

721
00:33:44,549 --> 00:33:47,871



722
00:33:47,872 --> 00:33:51,210
AUDIENCE: How do you get from C to A?
听众：您如何从C到A？ 

723
00:33:51,210 --> 00:33:53,569
PROFESSOR: This was supposed to happen way before.
教授：这应该是以前发生的。 

724
00:33:53,569 --> 00:33:59,644
So we went A, B, C, and then when we were at C, oh.
所以我们去了A，B，C，然后当我们在C时，哦。 

725
00:33:59,644 --> 00:34:01,910
Sorry.
抱歉。 

726
00:34:01,910 --> 00:34:04,970
My bad.
我的错。 

727
00:34:04,970 --> 00:34:07,279
So we went from A to B, B to C, and then A
所以我们从A到B，从B到C，再到A 

728
00:34:07,279 --> 00:34:09,179
was the first thing in C's adjacency list.
是C的邻接表中的第一件事。 

729
00:34:09,179 --> 00:34:10,980
So we saw this back edge.
因此，我们看到了此后边缘。 

730
00:34:10,980 --> 00:34:14,204
So C to D, D to E, D to F.
所以C到D，D到E，D到F。 

731
00:34:14,204 --> 00:34:15,438
AUDIENCE: E to F?
听众：从E到F？ 

732
00:34:15,637 --> 00:34:17,549
Or F to C?
还是F到C？ 

733
00:34:17,550 --> 00:34:20,134
PROFESSOR: And then F to C. So what kind of edge is this?
教授：然后是F到C。那么这是什么优势？ 

734
00:34:20,333 --> 00:34:21,125
AUDIENCE: Backward.
听众：向后。 

735
00:34:21,125 --> 00:34:23,690



736
00:34:23,690 --> 00:34:26,559
PROFESSOR: So none of these guys.
教授：所以这些家伙都不是。 

737
00:34:26,559 --> 00:34:32,882
And then we're all the way back at A, right?
然后我们一直回到A，对不对？ 

738
00:34:32,882 --> 00:34:37,520
A to-- oh.
哦〜 

739
00:34:37,521 --> 00:34:38,019
Sorry.
抱歉。 

740
00:34:38,019 --> 00:34:40,800
No we're not done.
不，我们还没有完成。 

741
00:34:40,800 --> 00:34:50,070
So C to D, D to E, D to F, then we're back at C. And C to G.
所以从C到D，从D到E，从D到F，然后我们回到C。从C到G。 

742
00:34:50,070 --> 00:34:53,719
AUDIENCE: There's supposed to be a line between C and F?
听众：应该在C和F之间有一条界线吗？ 

743
00:34:53,719 --> 00:34:54,860
PROFESSOR: Oh, yeah.
教授：哦，是的。 

744
00:34:54,860 --> 00:34:55,480
Sorry.
抱歉。 

745
00:34:55,480 --> 00:34:57,409
I guess I can't copy.
我想我不能复制。 

746
00:34:57,409 --> 00:35:01,382
One, two, three, four, five, six, seven, eight, nine.
一，二，三，四，五，六，七，八，九。 

747
00:35:01,382 --> 00:35:03,590
One, two, three, four, five, six, seven, eight, nine.
一，二，三，四，五，六，七，八，九。 

748
00:35:03,590 --> 00:35:05,880
Now it's right.
现在是对的。 

749
00:35:05,880 --> 00:35:07,349
Thank you.
谢谢。 

750
00:35:07,349 --> 00:35:07,849
OK.
好。 

751
00:35:07,849 --> 00:35:09,860
So what am I missing?
那我想念什么呢？ 

752
00:35:09,860 --> 00:35:18,795
Edge from C to G. What kind of edge?
从C到G的边缘。什么样的边缘？ 

753
00:35:18,795 --> 00:35:20,193
AUDIENCE: C and G?
听众：C和G？ 

754
00:35:20,193 --> 00:35:22,606



755
00:35:22,606 --> 00:35:23,190
PROFESSOR: OK.
教授：好的。 

756
00:35:23,190 --> 00:35:28,460
So we have tree edges and we have backward edges.
所以我们有树边，我们有后边。 

757
00:35:28,460 --> 00:35:29,630
What do we not have?
我们没有什么？ 

758
00:35:29,630 --> 00:35:32,519
Forward edges and cross edges, right?
前边缘和交叉边缘，对吗？ 

759
00:35:32,519 --> 00:35:39,391
AUDIENCE: You need one from A to G. A and G are related.
听众：您需要从A到G中的一个。A和G是相关的。 

760
00:35:39,391 --> 00:35:40,599
PROFESSOR: What edge is this?
教授：这是什么优势？ 

761
00:35:40,599 --> 00:35:43,029



762
00:35:43,030 --> 00:35:43,530
Cool.
凉。 

763
00:35:43,530 --> 00:35:44,210
Thanks.
谢谢。 

764
00:35:44,210 --> 00:35:47,030
AUDIENCE: You never add those, though, right?
听众：不过，您永远不会添加这些内容，对吗？ 

765
00:35:47,030 --> 00:35:51,614
You just see that A was in the parent's list, and be like, OK.
您只要看到A在父母的列表中，就可以了。 

766
00:35:51,813 --> 00:35:52,480
PROFESSOR: Yeah.
教授：是的。 

767
00:35:52,480 --> 00:35:54,570
So for all the edges that are not tree edges,
因此，对于不是树边缘的所有边缘， 

768
00:35:54,570 --> 00:35:57,539
DFS doesn't actually follow them.
 DFS实际上并没有遵循它们。 

769
00:35:57,539 --> 00:35:59,719
We just care about them because other algorithms
我们只关心它们，因为其他算法

770
00:35:59,719 --> 00:36:00,619
care about them.
关心他们。 

771
00:36:00,619 --> 00:36:03,639
They let you compute fancy things on the graph.
他们让您计算图表上的奇特事物。 

772
00:36:03,639 --> 00:36:05,639
OK.
好。 

773
00:36:05,639 --> 00:36:09,269
So are we good with the types?
那么我们对类型好吗？ 

774
00:36:09,269 --> 00:36:13,164
So why can't I have a forward edge?
那么，为什么我不能拥有前锋呢？ 

775
00:36:13,164 --> 00:36:15,039
So there are two types of edges I can't have,
所以我无法提供两种类型的边缘， 

776
00:36:15,039 --> 00:36:18,110
cross edges and forward edges.
交叉边缘和前边缘。 

777
00:36:18,110 --> 00:36:20,769
Why can't I have a forward edge?
为什么我不能拥有前锋？ 

778
00:36:20,769 --> 00:36:24,108



779
00:36:24,108 --> 00:36:26,016
On an undirected graph?
在无向图上？ 

780
00:36:26,016 --> 00:36:28,879



781
00:36:28,880 --> 00:36:30,539
So in order to have a forward edge,
因此，为了拥有前缘， 

782
00:36:30,739 --> 00:36:37,059
I would have to go C, D, F. And then not follow this edge.
我必须走C，D，F。然后再不走这条路。 

783
00:36:37,059 --> 00:36:39,409
I mean not see this edge here.
我的意思是在这里看不到这个优势。 

784
00:36:39,409 --> 00:36:42,239
Right?
对？ 

785
00:36:42,239 --> 00:36:43,759
If this edge would be undirected,
如果这条边是无方向的， 

786
00:36:43,760 --> 00:36:47,320
I would say, hey, it goes from F to C. It's a background edge.
我会说，嘿，它是从F到C。这是背景边缘。 

787
00:36:47,519 --> 00:36:50,659
So I would have seen this edge when I would have been in C.
所以当我在C语言中时，我会看到这种优势。 

788
00:36:50,659 --> 00:36:52,449
So I'm comparing this tree with this tree,
所以我要比较这棵树和这棵树， 

789
00:36:52,449 --> 00:36:54,407
and trying to figure out why they're different.
并试图弄清它们为何与众不同。 

790
00:36:54,407 --> 00:36:57,250



791
00:36:57,250 --> 00:37:00,032
How does a forward edge look like?
前缘看起来如何？ 

792
00:37:00,032 --> 00:37:05,480
You have a node u, then you have some more tree stuff.
您有一个节点u，那么您还有更多树内容。 

793
00:37:05,480 --> 00:37:09,000
And from here, you got to v. And then when you're at v,
然后从这里到v。然后在v处

794
00:37:09,000 --> 00:37:11,420
you didn't see the edge.
你没有看到边缘。 

795
00:37:11,420 --> 00:37:11,919
Right?
对？ 

796
00:37:11,920 --> 00:37:13,135
Because if you would have seen it,
因为如果您会看到它， 

797
00:37:13,335 --> 00:37:15,329
it would have been a background edge.
这本来是背景边缘。 

798
00:37:15,329 --> 00:37:18,469
So you can only see the edge from u to v later on.
因此，您以后只能看到从u到v的边缘。 

799
00:37:18,469 --> 00:37:21,159
So this is tree edges, a bunch of tree edges,
这就是树的边缘，一堆树的边缘， 

800
00:37:21,159 --> 00:37:23,009
and this is a forward edge.
这是一个前沿。 

801
00:37:23,010 --> 00:37:24,480
In an undirected graph, this never
在无向图中，这永远不会

802
00:37:24,480 --> 00:37:27,324
happens because when you're at v,
之所以发生是因为当您在v时， 

803
00:37:27,324 --> 00:37:29,069
you're going to see the edge.
您将看到边缘。 

804
00:37:29,070 --> 00:37:31,920
And you're going to mark it as a backward edge.
您将把它标记为向后边缘。 

805
00:37:32,119 --> 00:37:33,549
So forward edges can ever happen.
因此，可能会发生前缘。 

806
00:37:33,550 --> 00:37:37,289



807
00:37:37,489 --> 00:37:38,209
Yes?
是？ 

808
00:37:38,210 --> 00:37:40,130
No?
没有？ 

809
00:37:40,130 --> 00:37:42,480
Is everyone happy?
大家开心吗？ 

810
00:37:42,679 --> 00:37:43,449
So cross edges.
因此交叉边缘。 

811
00:37:43,449 --> 00:37:45,399
Why can't they happen?
他们为什么不能发生？ 

812
00:37:45,400 --> 00:37:48,070
A cross edge can never happen because in order
交叉边缘永远不会发生，因为顺序

813
00:37:48,070 --> 00:37:51,539
for a cross edge to happen, I would have to go A, B, C,
为了实现交叉优势，我必须走A，B，C， 

814
00:37:51,739 --> 00:37:56,750
visit C's children, then go up and go somewhere else.
拜访C的孩子，然后上去其他地方。 

815
00:37:56,750 --> 00:37:59,199
And then see this edge.
然后看到这个边缘。 

816
00:37:59,199 --> 00:38:02,419
But, hey, when I was at C, why didn't I see this edge?
但是，嘿，当我在C时，为什么没有看到这个优势？ 

817
00:38:02,420 --> 00:38:03,730
Why did I only see it later?
为什么我以后才看到？ 

818
00:38:03,929 --> 00:38:07,139
If it's an undirected graph, I would see this edge here
如果它是无向图，我会在这里看到此边缘

819
00:38:07,139 --> 00:38:09,230
and it would be a forward edge.
这将是一个前沿。 

820
00:38:09,230 --> 00:38:09,730
Sorry.
抱歉。 

821
00:38:09,730 --> 00:38:12,579
A tree edge, because that would take it.
树边缘，因为那样会占用它。 

822
00:38:12,579 --> 00:38:13,170
Yes?
是？ 

823
00:38:13,170 --> 00:38:15,168
AUDIENCE: So is it just when you're-- is it just
听众：只是当您在吗？ 

824
00:38:15,168 --> 00:38:17,849
because it's the way you traverse in DFS or would it
因为这是您在DFS中遍历的方式，还是会

825
00:38:17,849 --> 00:38:20,920
apply generally to VFS as well?
一般也适用于VFS？ 

826
00:38:20,920 --> 00:38:24,130
PROFESSOR: VFS doesn't have forward and backward.
教授：VFS没有前进和后退。 

827
00:38:24,130 --> 00:38:24,630
Yeah.
是的

828
00:38:24,630 --> 00:38:27,190
VFS is completely different.
 VFS完全不同。 

829
00:38:27,389 --> 00:38:31,730
So these are all DFS terms, purely DFS.
这些都是DFS术语，纯粹是DFS。 

830
00:38:31,730 --> 00:38:32,230
OK.
好。 

831
00:38:32,230 --> 00:38:34,400
So no forward edges, no cross edges.
因此，没有前边缘，没有交叉边缘。 

832
00:38:34,400 --> 00:38:36,730
And if you forget which ones you can and can't have,
而且，如果您忘记了哪些可以拥有和不能拥有， 

833
00:38:36,929 --> 00:38:40,829
now you know how to reason about it quickly and remember.
现在您知道了如何快速推理并记住。 

834
00:38:40,829 --> 00:38:42,769
Yes?
是？ 

835
00:38:42,769 --> 00:38:45,480
OK.
好。 

836
00:38:45,480 --> 00:38:46,440
So this is DFS.
这就是DFS。 

837
00:38:46,440 --> 00:38:49,130
Are we all happy with DFS?
我们都对DFS满意吗？ 

838
00:38:49,130 --> 00:38:51,690
Let's talk about topological sorting then.
然后让我们讨论拓扑排序。 

839
00:38:51,889 --> 00:38:53,179
Because it's really useful.
因为它真的很有用。 

840
00:38:53,179 --> 00:38:55,399
It's one of the few algorithms that is really useful
这是真正有用的少数算法之一

841
00:38:55,400 --> 00:38:58,329
and that you might have to write yourself later.
并且您以后可能不得不写自己。 

842
00:38:58,329 --> 00:39:01,650
So suppose these are classes.
因此，假设这些是类。 

843
00:39:01,650 --> 00:39:03,389
So let's get back to this oriented thing
让我们回到这个导向的东西

844
00:39:03,389 --> 00:39:05,389
and suppose these are classes.
并假设这些是类。 

845
00:39:05,389 --> 00:39:08,670
And the edges show prerequisites.
边缘显示了先决条件。 

846
00:39:08,670 --> 00:39:13,590
So A is a prerequisite of B. Like say A is 601
因此，A是B的先决条件。比如说A是601 

847
00:39:13,590 --> 00:39:14,880
and B is 6006.
 B是6006 

848
00:39:14,880 --> 00:39:17,610
And you have to take 601 before you take 6006.
而且您必须先取601，然后再取6006。 

849
00:39:17,610 --> 00:39:21,690
Otherwise you will cry during programming assignments.
否则，您将在编程作业期间哭泣。 

850
00:39:21,690 --> 00:39:24,190
So what we want to do is these are
所以我们要做的是

851
00:39:24,190 --> 00:39:27,030
all the classes you need to graduate.
您需要毕业的所有课程。 

852
00:39:27,030 --> 00:39:30,027
We need to come up with an order in which you can take them
我们需要拿出一个可以带他们去的订单

853
00:39:30,027 --> 00:39:32,610
so that when you take a class, you took all the prerequisites.
这样，当您上课时，您就具备了所有先决条件。 

854
00:39:32,610 --> 00:39:35,789
So you don't cry while you're taking that class.
因此，上课时您不会哭泣。 

855
00:39:35,789 --> 00:39:37,480
How do we do that?
我们该怎么做？ 

856
00:39:37,480 --> 00:39:39,434
And let's use this graph as an example.
让我们以该图为例。 

857
00:39:39,434 --> 00:39:43,166



858
00:39:43,166 --> 00:39:48,476
AUDIENCE: Use a directed graph that's acyclic?
听众：使用非循环有向图？ 

859
00:39:48,476 --> 00:39:49,059
PROFESSOR: OK.
教授：好的。 

860
00:39:49,059 --> 00:39:52,519
Is this graph acyclic?
该图是非循环的吗？ 

861
00:39:52,519 --> 00:39:54,246
AUDIENCE: No.
听众：不。 

862
00:39:54,246 --> 00:39:54,829
PROFESSOR: OK.
教授：好的。 

863
00:39:54,829 --> 00:39:57,088
So what then?
那又如何呢？ 

864
00:39:57,088 --> 00:39:58,005
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

865
00:39:58,005 --> 00:40:03,190



866
00:40:03,190 --> 00:40:06,054
PROFESSOR: So if the graph has a cycle,
教授：因此，如果图形具有循环， 

867
00:40:06,054 --> 00:40:07,019
you can't solve the problem.
你无法解决问题。 

868
00:40:07,219 --> 00:40:09,431
It has no solution.
它没有解决方案。 

869
00:40:09,431 --> 00:40:11,139
AUDIENCE: It's like those cardboard boxes
听众：就像那些纸板箱

870
00:40:11,139 --> 00:40:13,639
that [INAUDIBLE].
那个[听不清]。 

871
00:40:13,639 --> 00:40:16,139
It's really annoying.
真烦人。 

872
00:40:16,139 --> 00:40:21,014
PROFESSOR: I don't know the cardboard box problem.
教授：我不知道纸板箱有问题。 

873
00:40:21,014 --> 00:40:21,639
AUDIENCE: Yeah.
听众：是的。 

874
00:40:21,639 --> 00:40:25,509
You know those cardboard boxes with the four flaps
你知道那些带有四个口盖的纸板箱

875
00:40:25,510 --> 00:40:31,110
when you close them, and they close like-- Yeah.
当您关闭它们时，它们会像-是的那样关闭。 

876
00:40:31,110 --> 00:40:33,900
Those are so annoying.
那些真烦人。 

877
00:40:33,900 --> 00:40:36,461
That's just what this reminds me of.
这就是让我想起的。 

878
00:40:36,461 --> 00:40:37,039
That's all.
就这样。 

879
00:40:37,039 --> 00:40:37,380
Continue.
继续。 

880
00:40:37,380 --> 00:40:38,306
PROFESSOR: There's a cycle there,
教授：那里有一个循环， 

881
00:40:38,505 --> 00:40:40,000
so you can't just put them in an order.
所以你不能只是把它们整理好。 

882
00:40:40,000 --> 00:40:40,500
Right?
对？ 

883
00:40:40,500 --> 00:40:42,869
You have to violate the repeating variance somehow.
您必须以某种方式违反重复的方差。 

884
00:40:42,869 --> 00:40:45,949
And you do that by twisting the edges.
然后通过扭曲边缘来做到这一点。 

885
00:40:45,949 --> 00:40:50,159
So if we had classes A, B, C, you cannot take them in any
因此，如果我们有A，B，C类，则不能将它们带入任何

886
00:40:50,159 --> 00:40:50,659
order.
订购。 

887
00:40:50,659 --> 00:40:51,219
Right?
对？ 

888
00:40:51,219 --> 00:40:54,789
If you take A first, you would need C. If you take B first,
如果您先选择A，则需要C。如果您先选择B， 

889
00:40:54,789 --> 00:40:58,090
you would need A. If you take C first, you would need B.
您将需要A。如果您首先学习C，那么您将需要B。 

890
00:40:58,090 --> 00:41:00,820
So you can't start with any of them.
因此，您不能从任何一个开始。 

891
00:41:00,820 --> 00:41:03,340
So if you have a cycle in a graph,
因此，如果您在图中有一个循环， 

892
00:41:03,340 --> 00:41:04,579
it's not a dependency graph.
它不是依赖图。 

893
00:41:04,579 --> 00:41:07,539
You can't compute dependencies.
您无法计算依赖关系。 

894
00:41:07,539 --> 00:41:11,039
So topological sorts only works on cyclic graphs.
因此，拓扑排序仅适用于循环图。 

895
00:41:11,039 --> 00:41:15,610



896
00:41:15,610 --> 00:41:19,900
So acyclic graph.
所以无环图。 

897
00:41:19,900 --> 00:41:21,360
And what else?
还有什么？ 

898
00:41:21,360 --> 00:41:25,019
So a dependency graph is a special kind of graph.
因此，依赖图是一种特殊的图。 

899
00:41:25,219 --> 00:41:28,105
And I'm looking for three fancy words.
我正在寻找三个花哨的单词。 

900
00:41:28,106 --> 00:41:28,980
You already have two.
您已经有两个了。 

901
00:41:28,980 --> 00:41:31,635
So we have acyclic and we have graph.
所以我们有一个非循环的，我们有一个图。 

902
00:41:31,635 --> 00:41:32,135
Directed.
导演。 

903
00:41:32,135 --> 00:41:35,943



904
00:41:36,143 --> 00:41:37,559
So you have to have a directed, so
所以你必须有一个指导，所以

905
00:41:37,559 --> 00:41:40,059
that you know which class goes first.
您知道哪个班第一。 

906
00:41:40,059 --> 00:41:42,581
Needs to be acyclic, otherwise there's no solution.
需要是非循环的，否则没有解决方案。 

907
00:41:42,581 --> 00:41:44,039
Needs to be a graph, because that's
需要是一张图，因为那是

908
00:41:44,039 --> 00:41:45,081
what we're talking about.
我们在说什么。 

909
00:41:45,081 --> 00:41:48,599



910
00:41:48,599 --> 00:41:50,489
So the shortening for this is a DAG.
因此，简称DAG。 

911
00:41:50,489 --> 00:41:53,029



912
00:41:53,030 --> 00:41:53,530
OK.
好。 

913
00:41:53,530 --> 00:41:55,820
How do you compute an order?
您如何计算订单？ 

914
00:41:55,820 --> 00:41:57,570
So say we remove that edge.
所以说我们去掉那条边缘。 

915
00:41:57,570 --> 00:42:06,208



916
00:42:06,407 --> 00:42:09,766
How do we compute an order?
我们如何计算订单？ 

917
00:42:09,766 --> 00:42:16,134
AUDIENCE: You run DFS and then print out the reverse.
听众：运行DFS，然后打印相反的内容。 

918
00:42:16,134 --> 00:42:17,882
PROFESSOR: And then print out the reverse?
教授：然后打印出反面吗？ 

919
00:42:17,882 --> 00:42:20,519
AUDIENCE: Of your final output.
听众：您的最终输出。 

920
00:42:20,519 --> 00:42:22,927
PROFESSOR: Which is?
教授：那是什么？ 

921
00:42:22,927 --> 00:42:24,719
AUDIENCE: Your final output?
听众：您的最终输出？ 

922
00:42:24,719 --> 00:42:29,179
You want me to do it on a graph?
你要我在图表上做吗？ 

923
00:42:29,179 --> 00:42:31,824
PROFESSOR: You can tell me how to change the codes, too.
教授：您也可以告诉我如何更改密码。 

924
00:42:31,824 --> 00:42:34,449
So I'm not sure what-- you said print the reverse of something,
所以我不知道是什么-您说的是打印相反的东西， 

925
00:42:34,449 --> 00:42:35,672
but what's that thing?
那是什么

926
00:42:35,672 --> 00:42:37,639
AUDIENCE: So I go down a path, right,
听众：所以我走了一条路，对， 

927
00:42:37,639 --> 00:42:39,516
until you've hit all the nodes, then
直到您击中所有节点，然后

928
00:42:39,516 --> 00:42:41,688
basically you start from the last node
基本上你从最后一个节点开始

929
00:42:41,688 --> 00:42:44,929
you visited and print out the reverse of that.
您访问过并打印相反的内容。 

930
00:42:44,929 --> 00:42:46,349
Go back to the first node.
返回第一个节点。 

931
00:42:46,349 --> 00:42:46,932
PROFESSOR: OK.
教授：好的。 

932
00:42:46,932 --> 00:42:53,050
So you're saying I go A, B, C, D, E, and then
所以你说我去A，B，C，D，E，然后

933
00:42:53,050 --> 00:42:55,431
I print E, D, C, B, A?
我打印E，D，C，B，A吗？ 

934
00:42:55,630 --> 00:42:56,552
AUDIENCE: No.
听众：不。 

935
00:42:56,552 --> 00:42:58,531
Because that wouldn't hit all the nodes.
因为那不会覆盖所有节点。 

936
00:42:58,532 --> 00:42:58,914
PROFESSOR: OK.
教授：好的。 

937
00:42:59,114 --> 00:43:02,762



938
00:43:02,762 --> 00:43:07,130
He's on the right track, by the way, so that's why we're--
顺便说一句，他走的路正确，所以这就是我们- 

939
00:43:07,130 --> 00:43:10,500
AUDIENCE: You go A, B, C, D, E, F,
听众：您去A，B，C，D，E，F， 

940
00:43:10,699 --> 00:43:15,859
G, and you print G, F, E, D, C, B, A.
 G，然后打印G，F，E，D，C，B，A。 

941
00:43:15,860 --> 00:43:19,480
PROFESSOR: OK so we print them in the reverse.
教授：好的，所以我们将它们反向打印。 

942
00:43:19,480 --> 00:43:22,250
So you're printing them in the order in which you're
因此，您将按照打印顺序进行打印

943
00:43:22,250 --> 00:43:24,760
done with them after DFS?
 DFS之后对他们做了什么？ 

944
00:43:24,760 --> 00:43:25,260
No.
没有。 

945
00:43:25,260 --> 00:43:26,768
You're printing them in the reverse order
您以相反的顺序打印它们

946
00:43:26,967 --> 00:43:30,089
of the order which you visited them?
您去拜访他们的顺序？ 

947
00:43:30,090 --> 00:43:33,101
So you visited A, B, C, D, E, F, G,
因此，您访问了A，B，C，D，E，F，G， 

948
00:43:33,101 --> 00:43:35,920
so you're saying print G, F, E, D, C, B, A.
所以您说的是G，F，E，D，C，B，A 

949
00:43:35,920 --> 00:43:37,889
AUDIENCE: Yeah.
听众：是的。 

950
00:43:37,889 --> 00:43:39,230
Because in lecture wasn't it flipped,
因为不是在讲课中翻转， 

951
00:43:39,429 --> 00:43:44,804
so if an arrow points from A to B then A depends on B.
因此，如果箭头从A指向B，则A取决于B。 

952
00:43:44,804 --> 00:43:47,179
And we're looking at the other way around.
我们正在寻找另一种方式。 

953
00:43:47,179 --> 00:43:50,129



954
00:43:50,130 --> 00:43:51,730
In lecture, based on the graph you
在讲座中，基于图形

955
00:43:51,730 --> 00:43:55,572
gave, if the arrow goes from A to B, then A depends on B.
如果箭头从A到B，则A取决于B。 

956
00:43:55,572 --> 00:43:58,905
PROFESSOR: If the arrow goes from A to B, then what?
教授：如果箭头从A到B，那又如何？ 

957
00:43:58,905 --> 00:44:02,045
AUDIENCE: If you're saying A is a prerequisite for B and G,
听众：如果您说A是B和G的前提， 

958
00:44:02,045 --> 00:44:05,250
then we just sweep from left to right and say,
然后我们从左到右扫一下，然后说

959
00:44:05,449 --> 00:44:06,609
I have to do this.
我必须这样做

960
00:44:06,610 --> 00:44:08,309
And then those two.
然后是那两个。 

961
00:44:08,309 --> 00:44:08,692
PROFESSOR: No.
教授：不。 

962
00:44:08,891 --> 00:44:11,807
They have to--
他们必须 - 

963
00:44:11,807 --> 00:44:15,585
AUDIENCE: It's the order that-- because when you're doing DFS,
听众：这是顺序，因为在执行DFS时， 

964
00:44:15,585 --> 00:44:16,440
you recurse.
你递归。 

965
00:44:16,440 --> 00:44:19,364
It's the order that they finished the recurse.
他们完成递归的顺序是这样。 

966
00:44:19,364 --> 00:44:20,030
PROFESSOR: Yeah.
教授：是的。 

967
00:44:20,030 --> 00:44:21,250
You have the right answer.
您有正确的答案。 

968
00:44:21,250 --> 00:44:23,440
I'm just trying to build out the annotation for it.
我只是想为其建立注释。 

969
00:44:23,440 --> 00:44:27,510
I'm pretty sure this is the right way.
我很确定这是正确的方法。 

970
00:44:27,510 --> 00:44:30,561
I can look at this, but I can't promise you
我可以看一下，但是我不能答应你

971
00:44:30,760 --> 00:44:32,634
that this is the right way because I coded it
这是正确的方法，因为我编码了

972
00:44:32,635 --> 00:44:34,326
and it works.
而且有效。 

973
00:44:34,525 --> 00:44:36,739
So no.
所以不行。 

974
00:44:36,739 --> 00:44:39,989
This is the right way.
这是正确的方法。 

975
00:44:39,989 --> 00:44:40,489
Yes.
是。 

976
00:44:40,489 --> 00:44:42,155
This is the right way to represent them.
这是代表它们的正确方法。 

977
00:44:42,155 --> 00:44:50,880
So forward edge means B depends on A.
因此，前缘意味着B取决于A。 

978
00:44:50,880 --> 00:44:51,380
OK.
好。 

979
00:44:51,380 --> 00:44:54,139
So let's figure out how we do this.
因此，让我们弄清楚我们如何做到这一点。 

980
00:44:54,139 --> 00:44:55,730
Let's do this in pseudo-code and then build
让我们用伪代码执行此操作，然后构建

981
00:44:55,929 --> 00:44:57,339
the intuition for it.
直觉。 

982
00:44:57,340 --> 00:45:01,000
So you said reverse of the finishing times.
所以您说了整理时间的倒转。 

983
00:45:01,199 --> 00:45:04,960
So let's build a list that has all the nodes
因此，让我们建立一个包含所有节点的列表

984
00:45:04,960 --> 00:45:07,190
in the order of their finishing times.
按照完成时间的顺序。 

985
00:45:07,190 --> 00:45:14,851
So let's build a list finished that is empty at first.
因此，让我们建立一个最初为空的完成列表。 

986
00:45:14,851 --> 00:45:16,809
Then I'm going to add all the nodes in the list
然后，我将添加列表中的所有节点

987
00:45:16,809 --> 00:45:18,079
as I'm done with them.
因为我已经处理完了。 

988
00:45:18,079 --> 00:45:21,420
And then I'll reverse the list.
然后，我将反转列表。 

989
00:45:21,420 --> 00:45:23,452
Where do I add nodes to the list?
如何在列表中添加节点？ 

990
00:45:23,452 --> 00:45:28,072



991
00:45:28,271 --> 00:45:29,717
AUDIENCE: In the check.
听众：在支票上。 

992
00:45:29,717 --> 00:45:33,649



993
00:45:33,650 --> 00:45:38,365
Line 2.75.
行2.75。 

994
00:45:38,365 --> 00:45:39,240
PROFESSOR: Not quite.
教授：不完全是。 

995
00:45:39,240 --> 00:45:42,400



996
00:45:42,400 --> 00:45:46,614
So line 4.
所以第4行

997
00:45:46,813 --> 00:45:50,179
So I'm adding them in the order in which I'm done with them.
因此，我将按照完成它们的顺序添加它们。 

998
00:45:50,179 --> 00:45:53,409
So when I'm about to leave a node completely,
所以当我要完全离开一个节点时， 

999
00:45:53,409 --> 00:45:54,576
I'll add it to that list.
我将其添加到该列表中。 

1000
00:45:54,576 --> 00:46:02,679



1001
00:46:02,679 --> 00:46:03,730
Which node?
哪个节点？ 

1002
00:46:03,730 --> 00:46:05,414
What's the name?
什么名字？ 

1003
00:46:05,614 --> 00:46:08,389
AUDIENCE: V.
听众：V. 

1004
00:46:08,389 --> 00:46:09,420
PROFESSOR: OK.
教授：好的。 

1005
00:46:09,420 --> 00:46:12,858
And then where can I reverse the list?
然后在哪里可以倒转清单？ 

1006
00:46:12,858 --> 00:46:16,050
AUDIENCE: Line 4 of the first--
听众：第一行的第4行- 

1007
00:46:16,050 --> 00:46:17,300
PROFESSOR: OK.
教授：好的。 

1008
00:46:17,300 --> 00:46:20,110
How would I do this?
我该怎么做？ 

1009
00:46:20,110 --> 00:46:29,130
r dot finished dot reverse.
 r点完成点反转。 

1010
00:46:29,130 --> 00:46:31,202
Like this?
像这样？ 

1011
00:46:31,202 --> 00:46:33,090
AUDIENCE: I think that's OK in Python.
听众：我认为Python是可以的。 

1012
00:46:33,090 --> 00:46:35,460
PROFESSOR: I think so, too.
教授：我也这样认为。 

1013
00:46:35,460 --> 00:46:39,610
So this will give me a topological sort.
因此，这将给我一种拓扑结构。 

1014
00:46:39,610 --> 00:46:43,650
Let's figure out why this works intuitively.
让我们弄清楚为什么它直观地起作用。 

1015
00:46:43,650 --> 00:46:45,820
Yes?
是？ 

1016
00:46:45,820 --> 00:46:50,130
So while we're building the topological sort,
因此，当我们构建拓扑排序时， 

1017
00:46:50,329 --> 00:46:54,480
while we're building the inverse of the final list.
而我们正在建立最终列表的反面。 

1018
00:46:54,480 --> 00:46:56,250
So the first thing that we put in the list
所以我们放在清单中的第一件事

1019
00:46:56,250 --> 00:46:59,059
is the last class we're going to take.
是我们要参加的最后一堂课。 

1020
00:46:59,059 --> 00:47:02,039
So as I go forward in this graph,
所以当我在这张图中前进时， 

1021
00:47:02,039 --> 00:47:09,940
my VFS is going to go A, B, C, D, E. There's nothing after E.
我的VFS将转到A，B，C，D，E。E之后什么也没有。 

1022
00:47:09,940 --> 00:47:11,920
And it's done with E.
这是用E完成的。 

1023
00:47:11,920 --> 00:47:15,710
So this means there is no class that depends on E. Otherwise,
因此，这意味着不存在依赖于E的类。否则， 

1024
00:47:15,710 --> 00:47:18,409
DFS would keep recursing.
 DFS将继续递归。 

1025
00:47:18,409 --> 00:47:20,690
So E is the last class I take.
因此，E是我参加的最后一堂课。 

1026
00:47:20,690 --> 00:47:23,730
If I take this last, there's definitely no dependencies
如果我坚持下去，肯定没有依赖关系

1027
00:47:23,730 --> 00:47:25,449
that I'm violating.
我违反了。 

1028
00:47:25,449 --> 00:47:26,259
All right?
好吧？ 

1029
00:47:26,260 --> 00:47:35,110
So it's safe to start with E.
因此从E开始很安全。 

1030
00:47:35,309 --> 00:47:42,469
Now I'm out of E, I'm back to D. I go from D to F, I print that.
现在我不在E中，回到D。我从D转到F，然后打印出来。 

1031
00:47:42,469 --> 00:47:46,549
Let's not worry about this for a little bit.
让我们不必为此担心。 

1032
00:47:46,550 --> 00:47:52,210
And let's go back to D. When DFS comes
让我们回到D。 

1033
00:47:52,409 --> 00:47:55,629
back, it's going to print D. So I
返回，它将打印D。所以我

1034
00:47:55,630 --> 00:47:59,269
know that by the time DFS is out,
知道在DFS出现时， 

1035
00:47:59,469 --> 00:48:04,269
I printed all the classes that depend on D. Right?
我打印了所有依赖于D的类。对吗？ 

1036
00:48:04,269 --> 00:48:06,509
So when I'm at D, whenever I have forward
所以当我在D时，只要我向前

1037
00:48:06,510 --> 00:48:08,250
edges that I haven't visited yet,
我还没去过的地方

1038
00:48:08,449 --> 00:48:11,250
I will call DFS visit on them.
我将致电DFS访问他们。 

1039
00:48:11,250 --> 00:48:16,170
DFS visit returns before I can get out of D.
在我离开D之前，DFS访问将返回。 

1040
00:48:16,170 --> 00:48:20,039
So all the edges that depend on D have been printed.
因此，所有依赖于D的边缘均已打印。 

1041
00:48:20,039 --> 00:48:20,539
Sorry.
抱歉。 

1042
00:48:20,539 --> 00:48:23,949
All the nodes that depend on D have been printed.
依赖于D的所有节点均已打印。 

1043
00:48:23,949 --> 00:48:27,000
So when I get out of D, I know that all the nodes that
所以当我离开D时，我知道所有的节点

1044
00:48:27,000 --> 00:48:29,300
depend on D have been printed, so it's
取决于D已被打印，所以

1045
00:48:29,300 --> 00:48:32,880
safe to print D. This is the intuition
可以安全地打印D。这是直觉

1046
00:48:33,079 --> 00:48:36,449
behind topological sort.
后面的拓扑排序。 

1047
00:48:36,449 --> 00:48:41,579
So you can build sort of an induction proof based on this.
因此，您可以基于此构建归纳证明。 

1048
00:48:41,579 --> 00:48:46,590
So whenever I'm here, I assume that all the nodes
因此，只要我在这里，我就假设所有节点

1049
00:48:46,590 --> 00:48:49,670
that I have forward edges to are somewhere in my results.
在结果中我有前锋。 

1050
00:48:49,670 --> 00:48:51,769
So I can include my nodes.
因此，我可以包含我的节点。 

1051
00:48:51,769 --> 00:48:56,170
So this means that whenever you put a node here,
因此，这意味着每当您在此处放置节点时， 

1052
00:48:56,170 --> 00:49:00,019
all the nodes that have forward edges to this node
具有该节点的前向边缘的所有节点

1053
00:49:00,019 --> 00:49:03,590
have already been output.
已经输出。 

1054
00:49:03,590 --> 00:49:06,019
So this means that no dependency relationships
所以这意味着没有依赖关系

1055
00:49:06,019 --> 00:49:08,349
are going to be violated.
将会受到侵犯。 

1056
00:49:08,349 --> 00:49:08,849
OK.
好。 

1057
00:49:08,849 --> 00:49:11,230
Let's keep building this and see the result.
让我们继续构建它并查看结果。 

1058
00:49:11,230 --> 00:49:14,409
So D, E, F, we get out of B. We get out
所以D，E，F从B中脱身。 

1059
00:49:14,409 --> 00:49:18,960
of C. What do we do here?
 C.我们在这里做什么？ 

1060
00:49:18,960 --> 00:49:19,800
Print C, right?
打印C，对不对？ 

1061
00:49:19,800 --> 00:49:25,260



1062
00:49:25,260 --> 00:49:27,126
What classes depend on C?
哪些类取决于C？ 

1063
00:49:27,126 --> 00:49:33,630
D, E, and F. I had a tree edge to D.
 D，E和F。我对D有树的边缘。 

1064
00:49:33,630 --> 00:49:37,400
I had DFS visit here, so I know that all the classes that
我在这里访问了DFS，所以我知道

1065
00:49:37,400 --> 00:49:41,670
depend on C because they depend on D have been output.
依赖于C，因为它们依赖于D已被输出。 

1066
00:49:41,670 --> 00:49:44,780
And then I have a forward edge on F.
然后我在F上有优势。 

1067
00:49:44,780 --> 00:49:48,280
So I didn't recurse from C to F, but I
所以我没有从C递归到F，但是我

1068
00:49:48,280 --> 00:49:50,291
know that has been covered somewhere.
知道已经被某个地方覆盖了。 

1069
00:49:50,291 --> 00:49:50,789
Right?
对？ 

1070
00:49:50,789 --> 00:49:54,219
Forward edge means that I've already seen it in DFS,
前缘意味着我已经在DFS中看到了它， 

1071
00:49:54,219 --> 00:49:55,929
and that I've already returned from it.
而且我已经从中回来了。 

1072
00:49:55,929 --> 00:49:57,759
So it has already been printed.
因此它已经被打印了。 

1073
00:49:57,760 --> 00:50:02,800



1074
00:50:02,800 --> 00:50:05,670
So I'm going to write this.
所以我要写这个。 

1075
00:50:05,670 --> 00:50:14,389
Now I get out of C. I get out of B. I go into G. I get out of B,
现在我离开C。我离开B。我进入G。我离开B， 

1076
00:50:14,389 --> 00:50:20,819
and I go into A. And I go out of A, and I print it.
然后进入A。然后离开A，然后打印出来。 

1077
00:50:20,820 --> 00:50:21,320
OK.
好。 

1078
00:50:21,320 --> 00:50:24,539
So I have tree edges that I can handle.
所以我有可以处理的树边缘。 

1079
00:50:24,539 --> 00:50:29,019



1080
00:50:29,019 --> 00:50:30,259
So these are all tree edges.
这些都是树的边缘。 

1081
00:50:30,260 --> 00:50:33,730



1082
00:50:33,929 --> 00:50:40,309
And the reason that topological sorting works on tree edges
以及在树边缘进行拓扑排序的原因

1083
00:50:40,309 --> 00:50:46,480
is that I call DFS visit on the tree edge,
是我在树边缘调用DFS访问， 

1084
00:50:46,480 --> 00:50:49,119
and I know it returns by the time I return.
我知道当我回来的时候它会回来。 

1085
00:50:49,119 --> 00:50:51,309
So I know that whatever's underneath
所以我知道下面有什么

1086
00:50:51,309 --> 00:50:53,670
that tree has already been printed.
那棵树已经被打印了。 

1087
00:50:53,670 --> 00:50:58,250
I have forward edges that will just take me forward
我有前进的优势，只会带我前进

1088
00:50:58,449 --> 00:50:59,929
in the DFS.
在DFS中。 

1089
00:50:59,929 --> 00:51:03,489
So I know that by the time I return from a node,
所以我知道当我从节点返回时， 

1090
00:51:03,489 --> 00:51:05,446
I've already returned from all the nodes
我已经从所有节点回来了

1091
00:51:05,447 --> 00:51:07,280
that I have forward edges to because they're
我有前进的优势，因为他们

1092
00:51:07,280 --> 00:51:08,190
lower in the tree.
在树下。 

1093
00:51:08,190 --> 00:51:08,690
Right?
对？ 

1094
00:51:08,690 --> 00:51:10,360
Forward edges work like this.
前边缘的工作原理是这样的。 

1095
00:51:10,360 --> 00:51:11,900
So by the time I'm out of C, I've
所以当我没C的时候，我已经

1096
00:51:11,900 --> 00:51:21,039
definitely printed F. Now I have this cross edge from G to C.
绝对是F。现在我有了从G到C的交叉边缘。 

1097
00:51:21,239 --> 00:51:27,209
A cross edge means that there is no direct relationship here,
交叉边缘表示此处没有直接关系， 

1098
00:51:27,210 --> 00:51:32,250
but I've already visited C. If there's no direct relationship,
但我已经去过C。如果没有直接关系， 

1099
00:51:32,250 --> 00:51:34,760
it means that for sure I'm done visiting C
这意味着我肯定已经完成了C的访问

1100
00:51:34,760 --> 00:51:39,375
and I've returned so that I can get to G.
我回来了，这样我就可以去G了。 

1101
00:51:39,574 --> 00:51:44,409
So there's some common parent between C and G.
因此，C和G之间有一些共同的父母。 

1102
00:51:44,409 --> 00:51:46,849
I'm already done with C, and I've returned to that parent.
我已经用完C了，已经回到了那个父母那里。 

1103
00:51:46,849 --> 00:51:49,449
And then I went to G.
然后我去了G。 

1104
00:51:49,449 --> 00:51:53,839
So all the nodes that are pointed to my cross edges
所以所有指向我交叉边缘的节点

1105
00:51:53,840 --> 00:51:59,471
have also been printed in topological sort.
也以拓扑形式打印。 

1106
00:51:59,670 --> 00:52:00,169
OK.
好。 

1107
00:52:00,170 --> 00:52:01,559
Now what about back edges?
现在后边缘呢？ 

1108
00:52:01,559 --> 00:52:02,914
What if I had a back edge?
如果我有后缘怎么办？ 

1109
00:52:02,914 --> 00:52:05,420



1110
00:52:05,420 --> 00:52:08,510
What if I had this back edge between C and A?
如果我的后缘介于C和A之间怎么办？ 

1111
00:52:08,510 --> 00:52:09,210
What happens then?
那会发生什么呢？ 

1112
00:52:09,409 --> 00:52:15,589
If I had a back edge, then that would break topological sort.
如果我有后缘，那将破坏拓扑结构。 

1113
00:52:15,590 --> 00:52:16,090
Right?
对？ 

1114
00:52:16,090 --> 00:52:18,579
Because this is saying that hey, you
因为这是说嘿，你

1115
00:52:18,579 --> 00:52:22,000
should print A before you print C.
在打印C之前应打印A。 

1116
00:52:22,000 --> 00:52:24,110
But I know that I'm going to come out of C way
但是我知道我会从C语言中脱颖而出

1117
00:52:24,110 --> 00:52:27,039
before I have a chance to come out of A.
在我有机会从A出来之前

1118
00:52:27,039 --> 00:52:30,469
So if I have a back edge, topological sort doesn't work.
因此，如果我有后端，则无法进行拓扑排序。 

1119
00:52:30,469 --> 00:52:33,739
When do I have a back edge?
什么时候有后缘？ 

1120
00:52:33,739 --> 00:52:35,199
When I have a cycle.
当我有一个周期。 

1121
00:52:35,199 --> 00:52:37,649
So this is why I don't care about back edges.
因此，这就是为什么我不在乎后边缘的原因。 

1122
00:52:37,650 --> 00:52:41,300
Back edges [INAUDIBLE] cycles.
后边缘[音频不清晰]循环。 

1123
00:52:41,300 --> 00:52:44,269
So back edge means I have a path forward.
所以后缘意味着我有前进的道路。 

1124
00:52:44,469 --> 00:52:47,119
And I have a path backward.
我有一条向后的路。 

1125
00:52:47,119 --> 00:52:48,059
That does a cycle.
那做一个循环。 

1126
00:52:48,059 --> 00:52:53,820



1127
00:52:53,820 --> 00:52:54,320
OK.
好。 

1128
00:52:54,320 --> 00:52:57,690
There's an awful lot of silence here.
这里有很多沉默。 

1129
00:52:57,889 --> 00:52:59,289
Does everything makes sense or?
一切都有意义吗？ 

1130
00:52:59,289 --> 00:53:02,911



1131
00:53:02,911 --> 00:53:03,409
OK.
好。 

1132
00:53:03,409 --> 00:53:03,992
Any questions?
任何问题？ 

1133
00:53:03,992 --> 00:53:06,690



1134
00:53:06,690 --> 00:53:07,189
Nope?
不？ 

1135
00:53:07,190 --> 00:53:08,050
Everyone's happy?
大家开心吗

1136
00:53:08,050 --> 00:53:10,760



1137
00:53:10,960 --> 00:53:12,959
So you don't need to reason about this formally.
因此，您无需正式地对此进行推理。 

1138
00:53:12,960 --> 00:53:16,750
Just remember the intuition that the reason we're printing them
只要记住直觉，我们打印它们的原因

1139
00:53:16,750 --> 00:53:20,320
in this order is the first thing you
按此顺序是您的第一件事

1140
00:53:20,320 --> 00:53:23,039
print is the last class you're going to take.
打印是您要参加的最后一堂课。 

1141
00:53:23,039 --> 00:53:27,619
Because for sure there are no dependencies left on it,
因为可以肯定的是，这里没有任何依赖关系， 

1142
00:53:27,619 --> 00:53:29,380
otherwise DFS would keep recursing.
否则，DFS将继续递归。 

1143
00:53:29,380 --> 00:53:32,070
And then there's that recursive structure that makes this work.
然后有一个递归结构使这项工作有效。 

1144
00:53:32,070 --> 00:53:35,800



1145
00:53:35,800 --> 00:53:36,300
OK.
好。 

1146
00:53:36,300 --> 00:53:37,784
Cool.
凉。 

1147
00:53:37,784 --> 00:53:42,784



