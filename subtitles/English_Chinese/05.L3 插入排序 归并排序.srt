1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,228
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,228 --> 00:00:17,853
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,853 --> 00:00:23,089



10
00:00:23,289 --> 00:00:27,009
PROFESSOR: So today's lecture is on sorting.
教授：所以今天的演讲是关于分类的。 

11
00:00:27,010 --> 00:00:31,109
We'll be talking about specific sorting algorithms today.
今天我们将讨论特定的排序算法。 

12
00:00:31,309 --> 00:00:34,570
I want to start by motivating why
我想从动机开始

13
00:00:34,570 --> 00:00:36,904
we're interested in sorting, which should be fairly easy.
我们对排序很感兴趣，这应该很容易。 

14
00:00:37,104 --> 00:00:39,689



15
00:00:39,689 --> 00:00:42,489
Then I want to discuss a particular sorting
然后，我想讨论一个特定的排序

16
00:00:42,490 --> 00:00:45,469
algorithm that's called insertion sort.
称为插入排序的算法。 

17
00:00:45,469 --> 00:00:47,859
That's probably the simplest sorting algorithm
那可能是最简单的排序算法

18
00:00:47,859 --> 00:00:51,942
you can write, it's five lines of code.
您可以编写，这是五行代码。 

19
00:00:51,942 --> 00:00:53,399
It's not the best sorting algorithm
这不是最好的排序算法

20
00:00:53,399 --> 00:00:57,429
that's out there and so we'll try and improve it.
在那里，因此我们将尝试对其进行改进。 

21
00:00:57,429 --> 00:01:00,469
We'll also talk about merge sort, which is a divide
我们还将讨论合并排序，这是一个划分

22
00:01:00,469 --> 00:01:03,250
and conquer algorithm and that's going
和征服算法，这就是

23
00:01:03,250 --> 00:01:09,010
to motivate the last thing that I want to spend time on,
激发我想花时间的最后一件事， 

24
00:01:09,010 --> 00:01:12,099
which is recurrences and how you solve recurrences.
这就是重复以及如何解决重复。 

25
00:01:12,299 --> 00:01:14,230
Typically the recurrences that we'll
通常情况下， 

26
00:01:14,230 --> 00:01:18,120
be looking at in double o six are going to come from divide
双看o六将来自鸿沟

27
00:01:18,120 --> 00:01:20,760
and conquer problems like merge sort
并征服诸如合并排序之类的问题

28
00:01:20,760 --> 00:01:24,099
but you'll see this over and over.
但您会一遍又一遍地看到它。 

29
00:01:24,299 --> 00:01:26,965
So let's talk about why we're interested in sorting.
因此，让我们谈谈为什么我们对排序感兴趣。 

30
00:01:26,965 --> 00:01:30,109



31
00:01:30,109 --> 00:01:34,370
There's some fairly obvious applications
有一些相当明显的应用

32
00:01:34,370 --> 00:01:37,289
like if you want to maintain a phone book,
例如，如果您想维护电话簿， 

33
00:01:37,489 --> 00:01:42,009
you've got a bunch of names and numbers corresponding
你有一堆对应的名字和数字

34
00:01:42,010 --> 00:01:44,829
to a telephone directory and you want
到电话簿，您要

35
00:01:44,829 --> 00:01:46,329
to keep them in sorted order so it's
使它们保持排序顺序

36
00:01:46,329 --> 00:01:51,509
easy to search, mp3 organizers, spreadsheets, et cetera.
易于搜索，mp3组织者，电子表格等。 

37
00:01:51,510 --> 00:01:54,590
So there's lots of obvious applications.
因此，有许多显而易见的应用程序。 

38
00:01:54,590 --> 00:01:59,429
There's also some interesting problems
还有一些有趣的问题

39
00:01:59,629 --> 00:02:05,899
that become easy once items are sorted.
对项目进行排序后，变得很容易。 

40
00:02:05,900 --> 00:02:13,789



41
00:02:13,789 --> 00:02:18,169
One example of that is finding a median.
一个例子是求中位数。 

42
00:02:18,169 --> 00:02:23,859



43
00:02:23,860 --> 00:02:27,020
So let's say that you have a bunch of items
假设您有一堆物品

44
00:02:27,219 --> 00:02:36,210
in an array a zero through n and a zero through n
在数组中，零到n和零到n 

45
00:02:36,210 --> 00:02:38,650
contains n numbers and they're not sorted.
包含n个数字，但未排序。 

46
00:02:38,650 --> 00:02:44,849



47
00:02:44,849 --> 00:02:48,949
When you sort, you turn this into b 0
排序时，将其变成b 0 

48
00:02:48,949 --> 00:02:52,759
through n, where if it's just numbers, then
到n，如果只是数字，则

49
00:02:52,759 --> 00:02:55,659
you may sort them in increasing order or decreasing order.
您可以按升序或降序对它们进行排序。 

50
00:02:55,659 --> 00:02:58,689
Let's just call it increasing order for now.
现在我们就称其为递增顺序。 

51
00:02:58,689 --> 00:03:01,650
Or if they're records, and they're not numbers,
或者如果它们是记录而不是数字， 

52
00:03:01,650 --> 00:03:04,520
then you have to provide a comparison function
那么你必须提供一个比较功能

53
00:03:04,520 --> 00:03:08,050
to determine which record is smaller than another record.
确定哪个记录比另一个记录小。 

54
00:03:08,050 --> 00:03:09,520
And that's another input that you
这是你的另一项投入

55
00:03:09,520 --> 00:03:12,780
have to have in order to do the sorting.
必须要进行排序。 

56
00:03:12,979 --> 00:03:15,310
So it doesn't really matter what the items are
所以什么东西真的没关系

57
00:03:15,310 --> 00:03:17,580
as long as you have the comparison function.
只要您具有比较功能。 

58
00:03:17,580 --> 00:03:19,930
Think of it as less than or equal to.
认为它小于或等于。 

59
00:03:19,930 --> 00:03:23,750
And if you have that and it's straightforward,
如果有的话很简单， 

60
00:03:23,750 --> 00:03:27,090
obviously, to check that 3 is less than 4, et cetera.
显然，要检查3是否小于4，等等。 

61
00:03:27,090 --> 00:03:29,439
But it may be a little more complicated
但这可能有点复杂

62
00:03:29,639 --> 00:03:32,989
for more sophisticated sorting applications.
适用于更复杂的分拣应用。 

63
00:03:32,990 --> 00:03:36,370
But the bottom line is that if you have your algorithm that
但最重要的是，如果您有算法

64
00:03:36,569 --> 00:03:39,120
takes a comparison function as an input,
将比较功能作为输入， 

65
00:03:39,120 --> 00:03:42,469
you're going to be able to, after a certain amount of time,
经过一段时间后，您将能够

66
00:03:42,669 --> 00:03:45,099
get B 0 n.
得到B 0 n。 

67
00:03:45,099 --> 00:03:48,680
Now if you wanted to find the median of the set of numbers
现在，如果您想找到一组数字的中位数

68
00:03:48,680 --> 00:03:51,719
that were originally in the array A,
最初在数组A中

69
00:03:51,719 --> 00:03:56,090
what would you do once you have the sorted array B?
拥有排序的数组B后，您将怎么办？ 

70
00:03:56,090 --> 00:03:59,123
AUDIENCE: Isn't there a more efficient algorithm for median?
听众：有没有更有效的中位数算法？ 

71
00:03:59,123 --> 00:04:00,039
PROFESSOR: Absolutely.
教授：当然可以。 

72
00:04:00,039 --> 00:04:08,120
But this is sort of a side effect of having a sorted list.
但这是排序列表的一种副作用。 

73
00:04:08,120 --> 00:04:10,240
If you happen to have a sorted list,
如果您碰巧有一个排序列表， 

74
00:04:10,240 --> 00:04:15,090
there's many ways that you could imagine
您可以想象有很多方式

75
00:04:15,090 --> 00:04:16,310
building up a sorted list.
建立一个排序列表。 

76
00:04:16,310 --> 00:04:19,778
One way is you have something that's completely unsorted
一种方法是您拥有完全未分类的东西

77
00:04:19,778 --> 00:04:22,620
and you run insertion sort or merge sort.
然后运行插入排序或合并排序。 

78
00:04:22,620 --> 00:04:25,139
Another way would be to maintain a sorted list as you're
另一种方法是在您

79
00:04:25,139 --> 00:04:27,659
getting items put into the list.
将物品放入清单。 

80
00:04:27,660 --> 00:04:29,439
So if you happened to have a sorted list
因此，如果您碰巧有一个排序列表

81
00:04:29,639 --> 00:04:32,599
and you need to have this sorted list for some reason,
并且出于某种原因，您需要具有此排序列表， 

82
00:04:32,600 --> 00:04:35,439
the point I'm making here is that finding the median
我要说的是找到中位数

83
00:04:35,439 --> 00:04:37,139
is easy.
简单。 

84
00:04:37,139 --> 00:04:39,430
And it's easy because all you have to do
这很容易，因为您要做的一切

85
00:04:39,430 --> 00:04:43,805
is look at-- depending on whether n is odd
看-取决于n是否为奇数

86
00:04:43,805 --> 00:04:47,526
or even-- look at B of n over 2.
甚至-看n超过2的B. 

87
00:04:47,526 --> 00:04:49,360
That would give you the median because you'd
那会给你中位数，因为你会

88
00:04:49,360 --> 00:04:54,009
have a bunch of numbers that are less than that
有一堆小于这个数字

89
00:04:54,209 --> 00:04:56,829
and the equal set of numbers that are greater than that,
和相等的一组数字，大于

90
00:04:56,829 --> 00:04:59,769
which is the definition of median.
这是中位数的定义。 

91
00:04:59,769 --> 00:05:05,029
So this is not necessarily the best way, as you pointed out,
因此，正如您所指出的，这不一定是最好的方法， 

92
00:05:05,029 --> 00:05:06,399
of finding the median.
找到中位数

93
00:05:06,399 --> 00:05:11,319
But it's constant time if you have a sorted list.
但是，如果您有一个已排序的列表，这将是固定时间。 

94
00:05:11,319 --> 00:05:14,649
That's the point I wanted to make.
这就是我要提出的重点。 

95
00:05:14,649 --> 00:05:16,719
There are other things that you could do.
您还可以做其他事情。 

96
00:05:16,720 --> 00:05:20,579
And this came up in Erik's lecture,
在埃里克的演讲中， 

97
00:05:20,779 --> 00:05:25,569
which is the notion of binary search-- finding
二进制搜索的概念-查找

98
00:05:25,569 --> 00:05:28,649
an element in an array-- a specific element.
数组中的元素-特定元素。 

99
00:05:28,649 --> 00:05:34,089
You have a list of items-- again a 0 through n.
您有一个项目列表-也是0到n。 

100
00:05:34,089 --> 00:05:39,599
And you're looking for a specific number or item.
您正在寻找一个特定的编号或项目。 

101
00:05:39,600 --> 00:05:43,550



102
00:05:43,550 --> 00:05:46,639
You could, obviously, scan the array,
显然，您可以扫描阵列， 

103
00:05:46,639 --> 00:05:50,259
and that would take you linear time to find this item.
这将花费您线性时间才能找到该物品。 

104
00:05:50,259 --> 00:05:53,099
If the array happened to be sorted,
如果数组碰巧被排序， 

105
00:05:53,100 --> 00:05:58,329
then you can find this in logarithmic time
然后您可以在对数时间找到它

106
00:05:58,529 --> 00:06:00,294
using what's called binary search.
使用所谓的二进制搜索。 

107
00:06:00,295 --> 00:06:03,600



108
00:06:03,600 --> 00:06:05,879
Let's say you're looking for a specific item.
假设您要寻找特定商品。 

109
00:06:05,879 --> 00:06:08,279
Let's call it k.
我们称它为k。 

110
00:06:08,279 --> 00:06:11,139
Binary search, roughly speaking, would
粗略地说，二进制搜索会

111
00:06:11,139 --> 00:06:20,199
work like-- you go compare k to, again, B of n over 2,
就像-您将k再次与n等于2的B进行比较

112
00:06:20,199 --> 00:06:23,779
and decide, given that B is sorted,
并确定，鉴于B已排序， 

113
00:06:23,779 --> 00:06:28,399
you get to look at 1/2 of the array.
您可以看一下数组的1/2。 

114
00:06:28,399 --> 00:06:33,079
If B of n over 2 is not exactly k, then-- well,
如果n大于2的B不完全是k，那么- 

115
00:06:33,079 --> 00:06:34,389
if it's exactly k you're done.
如果恰好是k，那么您就完成了。 

116
00:06:34,389 --> 00:06:36,769
Otherwise, you look at the left half.
否则，请看左半部分。 

117
00:06:36,769 --> 00:06:39,669
You do your divide and conquer paradigm.
您可以进行分而治之。 

118
00:06:39,670 --> 00:06:42,819
And you can do this in logarithmic time.
您可以在对数时间内完成此操作。 

119
00:06:42,819 --> 00:06:45,699
So keep this in mind, because binary search
因此请记住这一点，因为二进制搜索

120
00:06:45,699 --> 00:06:48,529
is going to come up in today's lecture
在今天的演讲中

121
00:06:48,529 --> 00:06:50,759
and again in other lectures.
在其他讲座中

122
00:06:50,759 --> 00:06:53,750
It's really a great paradigm of divide
这确实是一个很好的鸿沟范式

123
00:06:53,750 --> 00:06:56,019
and conquer-- probably the simplest.
征服-可能是最简单的。 

124
00:06:56,019 --> 00:06:57,689
And it, essentially, takes something
从本质上讲，它需要一些东西

125
00:06:57,689 --> 00:07:01,040
that's linear-- a linear search--
这是线性的-线性搜索- 

126
00:07:01,040 --> 00:07:03,569
and turns it into logarithmic search.
并将其转换为对数搜索。 

127
00:07:03,769 --> 00:07:06,539
So those are a couple of problems
所以这是几个问题

128
00:07:06,540 --> 00:07:10,750
that become easy if you have a sorted list.
如果您有一个排序列表，这将变得很容易。 

129
00:07:10,949 --> 00:07:21,269
And there's some not so obvious applications
还有一些不太明显的应用

130
00:07:21,269 --> 00:07:25,149
of sorting-- for example, data compression.
排序-例如数据压缩。 

131
00:07:25,149 --> 00:07:27,789
If you wanted to compress a file,
如果您要压缩文件， 

132
00:07:27,790 --> 00:07:30,329
one of the things that you could do is to--
您可以做的一件事是- 

133
00:07:30,529 --> 00:07:35,329
and it's a set of items-- you could sort the items.
这是一组项目-您可以对这些项目进行排序。 

134
00:07:35,329 --> 00:07:37,870
And that automatically finds duplicates.
并自动查找重复项。 

135
00:07:37,870 --> 00:07:42,939
And you could say, if I have 100 items that are all identical,
你可能会说，如果我有100个完全相同的项目， 

136
00:07:42,939 --> 00:07:47,778
I'm going to compress the file by representing the item once
我将通过一次表示项目来压缩文件

137
00:07:47,778 --> 00:07:49,319
and, then, having a number associated
然后，关联一个数字

138
00:07:49,319 --> 00:07:52,769
with the frequency of that item-- similar to what
与该项目的频率相似

139
00:07:52,769 --> 00:07:54,439
document distance does.
文件距离呢。 

140
00:07:54,439 --> 00:07:57,750
Document distance can be viewed as a way
可以将文档距离视为一种方式

141
00:07:57,750 --> 00:07:59,769
of compressing your initial input.
压缩您的初始输入。 

142
00:07:59,769 --> 00:08:03,240
Obviously, you lose the works of Shakespeare or whatever it was.
显然，您会失去莎士比亚的作品或其他作品。 

143
00:08:03,240 --> 00:08:06,560
And it becomes a bunch of words and frequencies.
它变成了一堆单词和频率。 

144
00:08:06,560 --> 00:08:12,870
But it is something that compresses the input
但这会压缩输入

145
00:08:12,870 --> 00:08:15,389
and gives you a different representation.
并为您提供了不同的表示形式。 

146
00:08:15,589 --> 00:08:20,394
And so people use sorting as a subroutine in data compression.
因此，人们将排序用作数据压缩中的子例程。 

147
00:08:20,394 --> 00:08:23,189



148
00:08:23,189 --> 00:08:27,360
Computer graphics uses sorting.
计算机图形学使用排序。 

149
00:08:27,360 --> 00:08:30,560
Most of the time, when you render
大多数时候，当您渲染

150
00:08:30,560 --> 00:08:32,870
scenes in computer graphics, you have many layers
计算机图形学中的场景，您有很多层

151
00:08:32,870 --> 00:08:34,558
corresponding to the scenes.
对应于场景。 

152
00:08:34,558 --> 00:08:38,549
It turns out that, in computer graphics,
事实证明，在计算机图形学中， 

153
00:08:38,549 --> 00:08:40,298
most of the time you're actually rendering
大多数情况下，您实际上是在渲染

154
00:08:40,298 --> 00:08:44,409
front to back because, when you have a big opaque
从前到后，因为当您不透明时

155
00:08:44,409 --> 00:08:48,886
object in front, you want to render that first,
前面的对象，您要先渲染

156
00:08:48,886 --> 00:08:50,969
so you don't have to worry about everything that's
这样您就不必担心一切

157
00:08:50,970 --> 00:08:53,859
occluded by this big opaque object.
被这个大的不透明物体遮挡。 

158
00:08:54,059 --> 00:08:56,589
And that makes things more efficient.
这使事情变得更有效率。 

159
00:08:56,590 --> 00:08:58,700
And so you keep things sorted front to back,
因此，您可以将事情从头到尾排序， 

160
00:08:58,700 --> 00:09:00,959
most of the time, in computer graphics rendering.
大多数时候，是在计算机图形渲染中。 

161
00:09:01,159 --> 00:09:03,860
But some of the time, if you're worried about transparency,
但是有时候，如果您担心透明度， 

162
00:09:03,860 --> 00:09:05,659
you have to render things back to front.
您必须将内容渲染回前端。 

163
00:09:05,659 --> 00:09:08,389
So typically, you have sorted lists
因此，通常情况下，您对列表进行了排序

164
00:09:08,389 --> 00:09:11,549
corresponding to the different objects in both orders--
对应于两个订单中的不同对象- 

165
00:09:11,549 --> 00:09:13,729
both increasing order and decreasing order.
递增顺序和递减顺序。 

166
00:09:13,730 --> 00:09:15,230
And you're maintaining that.
而您正在维护。 

167
00:09:15,230 --> 00:09:19,190
So sorting is a real important subroutine
所以排序是一个真正重要的子程序

168
00:09:19,190 --> 00:09:23,090
in pretty much any sophisticated application you look at.
几乎可以在任何复杂的应用程序中看到。 

169
00:09:23,090 --> 00:09:26,579
So it's worthwhile to look at the variety of sorting
因此，值得一看的是各种分类

170
00:09:26,779 --> 00:09:28,350
algorithms that are out there.
现有的算法。 

171
00:09:28,350 --> 00:09:30,432
And we're going to do some simple ones, today.
今天，我们将做一些简单的事情。 

172
00:09:30,432 --> 00:09:31,889
But if you go and look at Wikipedia
但是如果你去看维基百科

173
00:09:31,889 --> 00:09:35,269
and do a Google search, there's all sorts
并进行Google搜索，种类繁多

174
00:09:35,269 --> 00:09:38,029
of sorts like cocktail sort, and bitonic sort,
像鸡尾酒式和双调式

175
00:09:38,029 --> 00:09:41,899
and what have you.
还有你呢

176
00:09:41,899 --> 00:09:45,899
And there's reasons why each of these sorting algorithms exist.
并且存在每种分类算法都存在的原因。 

177
00:09:45,899 --> 00:09:49,829
Because in specific cases, they end up
因为在特定情况下，它们最终会

178
00:09:49,830 --> 00:09:52,854
winning on types of inputs or types of problems.
在投入类型或问题类型上获胜。 

179
00:09:53,054 --> 00:09:55,659



180
00:09:55,659 --> 00:09:59,469
So let's take a look at our first sorting algorithm.
因此，让我们看一下第一个排序算法。 

181
00:09:59,470 --> 00:10:03,639
I'm not going to write code but it will be in the notes.
我不会编写代码，但是会在注释中。 

182
00:10:03,639 --> 00:10:08,860
And it is in your document distance Python files.
它在您的文档中距离Python文件。 

183
00:10:08,860 --> 00:10:10,769
But I'll just give you pseudocode here
但是我只给你伪代码

184
00:10:10,769 --> 00:10:13,750
and walk through what insertion sort looks like
并浏览一下插入排序的样子

185
00:10:13,750 --> 00:10:17,460
because the purpose of describing
因为描述的目的

186
00:10:17,460 --> 00:10:20,555
this algorithm to you is to analyze its complexity.
这个算法对您来说就是分析它的复杂性。 

187
00:10:20,755 --> 00:10:22,129
We need to do some counting here,
我们需要在这里做一些计数

188
00:10:22,129 --> 00:10:25,230
with respect to this algorithm, to figure out
关于这个算法，找出

189
00:10:25,230 --> 00:10:28,610
how fast it's going to run in and what the worst case
它要运行多快，最坏的情况是什么

190
00:10:28,610 --> 00:10:30,279
complexity is.
复杂性是。 

191
00:10:30,279 --> 00:10:32,584
So what is insertion sort?
那么什么是插入排序？ 

192
00:10:32,585 --> 00:10:41,579
For i equals 1, 2, through n, given an input to be sorted,
对于i等于1、2到n，给定要排序的输入， 

193
00:10:41,779 --> 00:10:46,600
what we're going to do is we're going to insert A of i
我们要做的是插入i的A 

194
00:10:46,600 --> 00:10:48,470
in the right position.
在正确的位置。 

195
00:10:48,470 --> 00:10:50,969
And we're going to assume that we
我们将假设我们

196
00:10:51,169 --> 00:10:55,219
are sort of midway through the sorting process, where
在排序过程中处于中间位置， 

197
00:10:55,220 --> 00:11:00,719
we have sorted A 0 through i minus 1.
我们将A 0排序为i减去1。 

198
00:11:00,919 --> 00:11:04,339
And we're going to expand this to this array
我们将扩展到这个数组

199
00:11:04,340 --> 00:11:07,590
to have i plus 1 elements.
让我加1个元素。 

200
00:11:07,590 --> 00:11:09,649
And A of i is going to get inserted
我的A将被插入

201
00:11:09,649 --> 00:11:12,829
into the correct position.
正确的位置。 

202
00:11:12,830 --> 00:11:23,639
And we're going to do this by pairwise swaps
我们将通过成对交换来做到这一点

203
00:11:23,639 --> 00:11:32,730
down to the correct position for the number that is initially
下降到最初数字的正确位置

204
00:11:32,730 --> 00:11:33,490
in A of i.
在我的A中

205
00:11:33,490 --> 00:11:36,049



206
00:11:36,049 --> 00:11:42,409
So let's go through an example of this.
因此，让我们来看一个例子。 

207
00:11:42,409 --> 00:11:44,839
We're going to sort in increasing order.
我们将按升序排序。 

208
00:11:44,840 --> 00:11:45,884
Just have six numbers.
只要有六个数字。 

209
00:11:45,884 --> 00:11:50,429



210
00:11:50,429 --> 00:11:54,804
And initially, we have 5, 2, 4, 6, 1, 3.
最初，我们有5、2、4、6、1、3。 

211
00:11:54,804 --> 00:11:56,429
And we're going to take a look at this.
我们将对此进行研究。 

212
00:11:56,429 --> 00:12:00,549
And you start with the index 1, or the second element,
然后从索引1或第二个元素开始， 

213
00:12:00,549 --> 00:12:03,620
because the very first element-- it's a single element
因为第一个元素-它是一个元素

214
00:12:03,620 --> 00:12:06,049
and it's already sorted by definition.
并且已经按定义排序。 

215
00:12:06,049 --> 00:12:07,929
But you start from here.
但是你从这里开始。 

216
00:12:07,929 --> 00:12:10,889
And this is what we call our key.
这就是我们所谓的关键。 

217
00:12:10,889 --> 00:12:15,250
And that's essentially a pointer to where we're at, right now.
从本质上讲，这是目前我们所处位置的指针。 

218
00:12:15,250 --> 00:12:17,019
And the key keeps moving to the right
而且钥匙一直向右移动

219
00:12:17,019 --> 00:12:20,006
as we go through the different steps of the algorithm.
当我们经历算法的不同步骤时。 

220
00:12:20,006 --> 00:12:21,589
And so what you do is you look at this
所以你要做的就是看这个

221
00:12:21,590 --> 00:12:24,830
and you have-- this is A of i.
而您有-这是i的A。 

222
00:12:24,830 --> 00:12:25,829
That's your key.
那是你的钥匙。 

223
00:12:26,029 --> 00:12:30,069
And you have A of 0 to 0, which is 5.
您的A为0到0，即5。 

224
00:12:30,070 --> 00:12:34,059
And since we want to sort in increasing order,
由于我们想按升序排序， 

225
00:12:34,259 --> 00:12:35,939
this is not sorted.
这没有排序。 

226
00:12:35,940 --> 00:12:37,720
And so we do a swap.
因此，我们进行了交换。 

227
00:12:37,720 --> 00:12:42,399
So what this would do in this step is to do a swap.
因此，此步骤将要做的是交换。 

228
00:12:42,399 --> 00:12:51,829
And we would go obtain 2, 5, 4, 6, 1, 3.
然后我们将获得2、5、4、6、1、3。 

229
00:12:51,830 --> 00:12:55,080
So all that's happened here, in this step-- in the very
所以所有的事情都在这里发生了

230
00:12:55,080 --> 00:12:57,360
first step where the key is in the second position--
钥匙位于第二位置的第一步- 

231
00:12:57,360 --> 00:13:00,019
is one swap happened.
是一次交换发生了。 

232
00:13:00,019 --> 00:13:03,340
Now, your key is here, at item 4.
现在，您的钥匙在这里，第4项。 

233
00:13:03,340 --> 00:13:05,980
Again, you need to put 4 into the right spot.
同样，您需要将4放置在正确的位置。 

234
00:13:05,980 --> 00:13:08,469
And so you do pairwise swaps.
因此，您进行成对交换。 

235
00:13:08,669 --> 00:13:11,279
And in this case, you have to do one swap.
在这种情况下，您必须进行一次交换。 

236
00:13:11,279 --> 00:13:12,750
And you get 2, 4, 5.
然后您得到2、4、5。 

237
00:13:12,750 --> 00:13:15,649
And you're done with this iteration.
这样的迭代就完成了。 

238
00:13:15,649 --> 00:13:27,850
So what happens here is you have 2, 4, 5, 6, 1, 3.
所以这里发生的是您有2，4，5，6，1，3。 

239
00:13:27,850 --> 00:13:33,009
And now, the key is over here, at 6.
现在，关键就在这里，即6点。 

240
00:13:33,009 --> 00:13:37,860
Now, at this point, things are kind of easy,
现在，这很容易

241
00:13:37,860 --> 00:13:40,979
in the sense that you look at it and you say, well, I
从某种意义上说，你说，嗯，我

242
00:13:41,179 --> 00:13:43,479
know this part is already started.
知道这部分已经开始。 

243
00:13:43,480 --> 00:13:44,970
6 is greater than 5.
 6大于5。 

244
00:13:44,970 --> 00:13:47,000
So you have to do nothing.
因此，您无需执行任何操作。 

245
00:13:47,000 --> 00:13:51,529
So there's no swaps that happen in this step.
因此，在此步骤中不会发生任何交换。 

246
00:13:51,529 --> 00:13:56,439
So all that happens here is you're
所以这里发生的一切就是你

247
00:13:56,440 --> 00:14:02,079
going to move the key to one step to the right.
将键向右移动一步。 

248
00:14:02,279 --> 00:14:06,370
So you have 2, 4, 5, 6, 1, 3.
所以你有2、4、5、6、1、3 

249
00:14:06,370 --> 00:14:10,269
And your key is now at 1.
现在您的密钥是1。 

250
00:14:10,269 --> 00:14:11,909
Here, you have to do more work.
在这里，您必须做更多的工作。 

251
00:14:11,909 --> 00:14:16,769
Now, you see one aspect of the complexity of this algorithm--
现在，您将看到此算法复杂性的一个方面- 

252
00:14:16,769 --> 00:14:19,470
given that you're doing pairwise swaps-- the way
鉴于您正在进行成对交换- 

253
00:14:19,470 --> 00:14:23,219
this algorithm was defined, in pseudocode, out there, was I'm
这个算法是用伪代码定义的，我在

254
00:14:23,419 --> 00:14:27,759
going to use pairwise swaps to find the correct position.
将使用成对掉期来查找正确的位置。 

255
00:14:27,759 --> 00:14:29,639
So what you're going to do is you're
所以你要做的就是

256
00:14:29,639 --> 00:14:34,080
going to have to swap first 1 and 6.
必须先交换1和6。 

257
00:14:34,080 --> 00:14:36,109
And then you'll swap-- 1 is over here.
然后您将交换-1在这里。 

258
00:14:36,309 --> 00:14:39,969
So you'll swap this position and that position.
因此，您将交换该职位和该职位。 

259
00:14:39,970 --> 00:14:44,580
And then you'll swap-- essentially,
然后您将交换-本质上， 

260
00:14:44,580 --> 00:14:49,709
do 4 swaps to get to the point where you have
进行4次互换以达到您拥有的位置

261
00:14:49,909 --> 00:14:52,969
1, 2, 4, 5, 6, 3.
 1，2，4，5，6，3。 

262
00:14:52,970 --> 00:14:56,649
So this is the result.
所以这就是结果。 

263
00:14:56,649 --> 00:14:59,189



264
00:14:59,190 --> 00:15:03,569
1, 2, 4, 5, 6, 3.
 1，2，4，5，6，3。 

265
00:15:03,769 --> 00:15:06,360
And the important thing to understand, here,
这里要了解的重要一点是

266
00:15:06,360 --> 00:15:08,849
is that you've done four swaps to get 1
是您已经进行了四次交换以获得1 

267
00:15:09,049 --> 00:15:10,159
to the correct position.
到正确的位置。 

268
00:15:10,159 --> 00:15:12,480
Now, you could imagine a different data structure
现在，您可以想象一个不同的数据结构

269
00:15:12,480 --> 00:15:15,470
where you move this over there and you shift them
你把它移到那边，然后转移它们

270
00:15:15,470 --> 00:15:16,729
all to the right.
所有的权利。 

271
00:15:16,929 --> 00:15:20,229
But in fact, that shifting of these four elements
但实际上，这四个要素的转移

272
00:15:20,230 --> 00:15:23,629
is going to be computed in our model as four
将在我们的模型中计算为四个

273
00:15:23,629 --> 00:15:26,244
operations, or four steps, anyway.
操作或四个步骤。 

274
00:15:26,244 --> 00:15:27,709
So there's no getting away from the fact
所以没有远离事实

275
00:15:27,909 --> 00:15:30,659
that you have to do four things here.
您必须在这里做四件事。 

276
00:15:30,659 --> 00:15:36,829
And the way the code that we have for insertion sort
以及我们插入代码的方式

277
00:15:36,830 --> 00:15:39,199
does this is by using pairwise swaps.
这是通过使用成对交换来实现的。 

278
00:15:39,399 --> 00:15:41,470
So we're almost done.
这样我们就快完成了。 

279
00:15:41,470 --> 00:15:49,490
Now, we have the key at 3.
现在，我们将密钥设置为3。 

280
00:15:49,490 --> 00:15:52,909
And now, 3 needs to get put into the correct position.
现在，需要将3个放到正确的位置。 

281
00:15:52,909 --> 00:15:55,350
And so you've got to do a few swaps.
因此，您必须进行一些交换。 

282
00:15:55,350 --> 00:15:58,320
This is the last step.
这是最后一步。 

283
00:15:58,320 --> 00:16:03,580
And what happens here is 3 is going to get swapped with 6.
而这里发生的是3将与6交换。 

284
00:16:03,580 --> 00:16:06,319
And then 3 needs to get swapped with 5.
然后3需要与5交换。 

285
00:16:06,519 --> 00:16:09,769
And then 3 needs to get swapped with 4.
然后3需要与4交换。 

286
00:16:09,769 --> 00:16:12,985
And then, since 3 is greater than 2, you're done.
然后，由于3大于2，您就完成了。 

287
00:16:12,985 --> 00:16:16,325
So you have 1, 2, 3, 4, 5, 6.
所以你有1，2，3，4，5，6 

288
00:16:16,325 --> 00:16:18,879



289
00:16:18,879 --> 00:16:21,179
And that's it.
就是这样。 

290
00:16:21,179 --> 00:16:22,819
So, analysis.
因此，分析。 

291
00:16:22,820 --> 00:16:25,379



292
00:16:25,379 --> 00:16:26,629
How many steps do I have?
我要执行几个步骤？ 

293
00:16:26,629 --> 00:16:30,669



294
00:16:30,669 --> 00:16:32,149
AUDIENCE: n squared?
听众：n平方？ 

295
00:16:32,149 --> 00:16:36,309
PROFESSOR: No, how many steps do I have?
教授：不，我有多少步骤？ 

296
00:16:36,309 --> 00:16:40,119
I guess that wasn't a good question.
我想这不是一个好问题。 

297
00:16:40,120 --> 00:16:43,929
If I think of a step as being a movement of the key,
如果我认为一步是钥匙的运动， 

298
00:16:43,929 --> 00:16:46,214
how many steps do I have?
我要执行几个步骤？ 

299
00:16:46,215 --> 00:16:49,729
I have theta n steps.
我有步骤。 

300
00:16:49,929 --> 00:16:56,569
And in this case, you can think of it as n minus 1 steps,
在这种情况下，您可以将其视为n减去1步， 

301
00:16:56,570 --> 00:16:57,829
since you started with 2.
自从2开始

302
00:16:58,029 --> 00:17:03,899
But let's just call it theta n steps,
但是，让我们称其为“一步” 

303
00:17:03,899 --> 00:17:06,779
in terms of key positions.
在关键职位上。 

304
00:17:06,779 --> 00:17:10,059



305
00:17:10,059 --> 00:17:11,149
And you're right.
而且你是对的。 

306
00:17:11,150 --> 00:17:15,148
It is n square because, at any given step,
它是n平方，因为在任何给定步骤中， 

307
00:17:15,348 --> 00:17:19,730
it's quite possible that I have to do theta n work.
我很有可能必须做theta n工作。 

308
00:17:19,730 --> 00:17:22,400
And one example is this one, right here,
一个例子就是这个，就在这里， 

309
00:17:22,400 --> 00:17:25,160
where I had to do four swaps.
我必须做四个交换。 

310
00:17:25,160 --> 00:17:27,398
And in general, you can construct a scenario
通常，您可以构建一个方案

311
00:17:27,598 --> 00:17:31,470
where, towards the end of the algorithm,
在算法的末尾， 

312
00:17:31,470 --> 00:17:33,919
you'd have to do theta n work.
您需要做theta n工作。 

313
00:17:34,119 --> 00:17:37,559
But if you had a list that was reverse sorted.
但是，如果您有一个被反向排序的列表。 

314
00:17:37,559 --> 00:17:40,960
You would, essentially, have to do, on an average n
从本质上讲，您实际上必须平均

315
00:17:40,960 --> 00:17:43,649
by two swaps as you go through each of the steps.
在完成每个步骤时，需要进行两次互换。 

316
00:17:43,849 --> 00:17:45,299
And that's theta n.
那就是theta n。 

317
00:17:45,299 --> 00:17:52,149
So each step is theta n swaps.
因此，每一步都是theta n交换。 

318
00:17:52,150 --> 00:17:55,930



319
00:17:55,930 --> 00:17:58,740
And when I say swaps, I could also
当我说交换时，我也可以

320
00:17:58,740 --> 00:18:06,644
say each step is theta n compares and swaps.
说每个步骤都是比较和交换。 

321
00:18:06,644 --> 00:18:08,019
And this is going to be important
这将很重要

322
00:18:08,019 --> 00:18:10,430
because I'm going to ask you an interesting question
因为我要问你一个有趣的问题

323
00:18:10,430 --> 00:18:11,700
in a minute.
在一分钟内。 

324
00:18:11,700 --> 00:18:13,639
But let me summarize.
但让我总结一下。 

325
00:18:13,839 --> 00:18:16,470
What I have here is a theta n squared algorithm.
我在这里有一个theta n平方算法。 

326
00:18:16,470 --> 00:18:17,970
The reason this is a theta n squared
这是theta n平方的原因

327
00:18:17,970 --> 00:18:22,759
algorithm is because I have theta n steps
算法是因为我有theta n步骤

328
00:18:22,759 --> 00:18:26,859
and each step is theta n.
每一步都是theta n。 

329
00:18:26,859 --> 00:18:29,139
When I'm counting, what am I counting
当我数数时，我在数数

330
00:18:29,140 --> 00:18:30,730
it terms of operations?
它的运营条款？ 

331
00:18:30,730 --> 00:18:33,509
The assumption here-- unspoken assumption--
这里的假设-不言而喻的假设- 

332
00:18:33,509 --> 00:18:36,809
has been that an operation is a compare and a swap
一直是一个操作是一个比较和交换

333
00:18:36,809 --> 00:18:39,539
and they're, essentially, equal in cost.
从本质上讲，它们的成本是相等的。 

334
00:18:39,539 --> 00:18:41,849
And in most computers, that's true.
在大多数计算机上都是如此。 

335
00:18:41,849 --> 00:18:45,209
You have a single instruction and, say, the x86
您只有一条指令，例如x86 

336
00:18:45,210 --> 00:18:47,700
or the MIPS architecture that can do a compare,
或可以进行比较的MIPS架构， 

337
00:18:47,700 --> 00:18:50,660
and the same thing for swapping registers.
与交换寄存器的操作相同。 

338
00:18:50,660 --> 00:18:52,640
So perfectly reasonably assumption
如此完全合理的假设

339
00:18:52,640 --> 00:18:56,480
that compares and swaps for numbers
比较并交换数字

340
00:18:56,480 --> 00:18:58,410
have exactly the same cost.
费用完全相同。 

341
00:18:58,410 --> 00:19:01,900
But if you had a record and you were comparing records,
但是，如果您有记录，并且正在比较记录， 

342
00:19:01,900 --> 00:19:05,700
and the comparison function that you used for the records was
您用于记录的比较功能是

343
00:19:05,700 --> 00:19:08,819
in itself a method call or a subroutine,
本身就是方法调用或子例程， 

344
00:19:08,819 --> 00:19:11,289
it's quite possible that all you're doing
您正在做的事情很有可能

345
00:19:11,289 --> 00:19:15,599
is swapping pointers or references to do the swap,
正在交换指针或引用以进行交换， 

346
00:19:15,599 --> 00:19:17,984
but the comparison could be substantially more expensive.
但比较起来可能会贵得多。 

347
00:19:17,984 --> 00:19:22,869



348
00:19:22,869 --> 00:19:24,919
Most of the time-- and we'll differentiate
大多数时候-我们将与众不同

349
00:19:24,920 --> 00:19:27,150
if it becomes necessary-- we're going
如果有必要-我们要

350
00:19:27,150 --> 00:19:29,359
to be counting comparisons in the sorting algorithms
计数排序算法中的比较

351
00:19:29,559 --> 00:19:31,230
that we'll be putting out.
我们将推出。 

352
00:19:31,230 --> 00:19:36,130
And we'll be assuming that either comparison swaps are
并且我们假设比较交换是

353
00:19:36,130 --> 00:19:40,839
roughly the same or that compares are--
大致相同或比较为- 

354
00:19:41,039 --> 00:19:44,569
and we'll say which one, of course-- that compares
我们当然会说哪个

355
00:19:44,569 --> 00:19:47,829
are substantially more expensive than swaps.
比掉期要贵得多。 

356
00:19:47,829 --> 00:19:52,269
So if you had either of those cases for insertion sort,
因此，如果您有两种情况需要插入排序， 

357
00:19:52,269 --> 00:19:54,225
you have a theta n squared algorithm.
您有一个theta n平方算法。 

358
00:19:54,226 --> 00:19:55,399
You have theta n squared compares
你有平方的比较

359
00:19:55,599 --> 00:19:58,199
and theta n squared swaps.
和theta n平方掉期。 

360
00:19:58,200 --> 00:20:00,779
Now, here's a question.
现在，这是一个问题。 

361
00:20:00,779 --> 00:20:11,178
Let's say that compares are more expensive than swaps.
假设比较比交换更昂贵。 

362
00:20:11,179 --> 00:20:12,720
And so, I'm concerned about the theta
因此，我担心theta 

363
00:20:12,720 --> 00:20:14,750
n squared comparison cost.
 n比较成本的平方。 

364
00:20:14,750 --> 00:20:17,269



365
00:20:17,269 --> 00:20:20,879
I'm not as concerned, because of the constant factors involved,
由于涉及的因素不断，我并不担心， 

366
00:20:20,880 --> 00:20:22,710
with the theta n squared swap cost.
与theta n平方掉期成本。 

367
00:20:22,710 --> 00:20:25,410



368
00:20:25,410 --> 00:20:28,730
This is a question question.
这是一个问题。 

369
00:20:28,730 --> 00:20:33,589
What's a simple fix-- change to this algorithm that
什么是简单的解决方法-对此算法进行更改即可

370
00:20:33,589 --> 00:20:37,259
would give me a better complexity in the case
在这种情况下会给我带来更好的复杂性

371
00:20:37,259 --> 00:20:39,900
where compares are more expensive,
比较起来比较贵的地方

372
00:20:39,900 --> 00:20:43,099
or I'm only looking at the complexity of compares.
或者我只是在看比较的复杂性。 

373
00:20:43,299 --> 00:20:46,990
So the theta whatever of compares.
因此，theta不论比较。 

374
00:20:46,990 --> 00:20:47,950
Anyone?
任何人？ 

375
00:20:47,950 --> 00:20:48,661
Yeah, back there.
是的，回到那里。 

376
00:20:48,661 --> 00:20:49,536
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

377
00:20:49,536 --> 00:20:56,355



378
00:20:56,355 --> 00:20:58,230
PROFESSOR: You could compare with the middle.
教授：您可以与中间人进行比较。 

379
00:20:58,230 --> 00:20:59,020
What did I call it?
我叫什么

380
00:20:59,020 --> 00:21:01,909



381
00:21:01,910 --> 00:21:02,919
I called it something.
我给它打电话。 

382
00:21:03,119 --> 00:21:06,160
What you just said, I called it something.
你刚才说的，我给它打电话。 

383
00:21:06,161 --> 00:21:07,160
AUDIENCE: Binary search.
受众：二进制搜索。 

384
00:21:07,160 --> 00:21:07,740
PROFESSOR: Binary search.
教授：二进制搜索。 

385
00:21:07,740 --> 00:21:08,309
That's right.
那就对了。 

386
00:21:08,309 --> 00:21:10,279
Two cushions for this one.
这个有两个垫子。 

387
00:21:10,279 --> 00:21:12,221
So you pick them up after lecture.
因此，您可以在演讲后接他们。 

388
00:21:12,221 --> 00:21:13,220
So you're exactly right.
所以你说的很对。 

389
00:21:13,220 --> 00:21:13,928
You got it right.
你做对了。 

390
00:21:13,928 --> 00:21:18,160
I called it binary search, up here.
我称它为二进制搜索，就在这里。 

391
00:21:18,160 --> 00:21:21,419
And so you can take insertion sort
这样您就可以进行插入排序

392
00:21:21,619 --> 00:21:24,799
and you can sort of trivially turn it into a theta n log n
您可以轻松地将其变成theta n log n 

393
00:21:24,799 --> 00:21:27,200
algorithm if we are talking about n
如果我们在谈论n 

394
00:21:27,200 --> 00:21:29,910
being the number of compares.
是比较数。 

395
00:21:29,910 --> 00:21:32,224
And all you have to do to do that is to say,
而您要做的就是说， 

396
00:21:32,424 --> 00:21:34,279
you know what, I'm going to replace
你知道吗，我要替换

397
00:21:34,279 --> 00:21:37,950
this with binary search.
这与二进制搜索。 

398
00:21:37,950 --> 00:21:42,720
And you can do that-- and that was the key observation--
您可以做到这一点-这是关键的观察- 

399
00:21:42,720 --> 00:21:47,990
because A of 0 through i minus 1 is already sorted.
因为从0到i减去1的A已被排序。 

400
00:21:47,990 --> 00:21:51,909
And so you can do binary search on that part of the array.
因此，您可以在数组的该部分上执行二进制搜索。 

401
00:21:51,909 --> 00:21:53,200
So let me just write that down.
所以，让我写下来。 

402
00:21:53,200 --> 00:21:56,750



403
00:21:56,750 --> 00:22:04,000
Do a binary search on A of 0 through i minus 1,
对A的0到i减去1进行二进制搜索。 

404
00:22:04,000 --> 00:22:05,095
which is already sorted.
已经排序。 

405
00:22:05,095 --> 00:22:10,539



406
00:22:10,539 --> 00:22:16,779
And essentially, you can think of it as theta log i time,
本质上，您可以将其视为时间的theta日志， 

407
00:22:16,779 --> 00:22:18,069
and for each of those steps.
对于每个步骤。 

408
00:22:18,069 --> 00:22:27,250
And so then you get your theta n log n theta n log
这样您就可以得到theta n log n theta n log 

409
00:22:27,250 --> 00:22:30,410
n in terms of compares.
 n在比较方面。 

410
00:22:30,410 --> 00:22:37,940
Does this help the swaps for an array data structure?
这是否有助于交换数组数据结构？ 

411
00:22:37,940 --> 00:22:41,279
No, because binary search will require insertion
否，因为二进制搜索将需要插入

412
00:22:41,279 --> 00:22:44,670
into A of 0 though i minus 1.
虽然我减去1.变成0的A。 

413
00:22:44,670 --> 00:22:45,880
So here's the problem.
这就是问题所在。 

414
00:22:45,880 --> 00:22:50,430
Why don't we have a full-fledged theta n log n algorithm,
为什么我们没有完善的theta n log n算法， 

415
00:22:50,430 --> 00:22:53,940
regardless of the cost of compares or swaps?
不管比较或掉期的成本？ 

416
00:22:53,940 --> 00:22:55,470
We don't quite have that.
我们还没有。 

417
00:22:55,470 --> 00:23:02,950
We don't quite have that because we need to insert our A of i
我们还没有，因为我们需要插入我的A 

418
00:23:02,950 --> 00:23:07,649
into the right position into A of 0 through i minus 1.
通过i减去1到A的正确位置

419
00:23:07,849 --> 00:23:09,789
You do that if you have an array structure,
如果您具有数组结构，则可以这样做

420
00:23:09,789 --> 00:23:10,998
it might get into the middle.
它可能会进入中间。 

421
00:23:10,998 --> 00:23:13,336
And you have to shift things over to the right.
而且您必须将事情移到右边。 

422
00:23:13,336 --> 00:23:15,170
And when you shift things over to the right,
当您将内容移至右侧时， 

423
00:23:15,170 --> 00:23:16,889
in the worst case, you may be shifting a lot of things
在最坏的情况下，您可能会转移很多东西

424
00:23:17,089 --> 00:23:17,980
over to the right.
在右边。 

425
00:23:17,980 --> 00:23:20,630
And that gets back to worst case complexity of theta n.
这又回到了最坏情况下的θn复杂性。 

426
00:23:20,630 --> 00:23:23,200



427
00:23:23,200 --> 00:23:27,000
So a binary search in insertion sort
所以在插入排序中进行二进制搜索

428
00:23:27,000 --> 00:23:29,196
gives you theta n log n for compares.
给您then n log n进行比较。 

429
00:23:29,196 --> 00:23:30,904
But it's still theta n squared for swaps.
但这仍然是交换交易的平方。 

430
00:23:30,904 --> 00:23:35,000



431
00:23:35,000 --> 00:23:36,805
So as you can see, there's many varieties
如您所见，有很多品种

432
00:23:36,805 --> 00:23:37,769
of sorting algorithms.
排序算法。 

433
00:23:37,769 --> 00:23:39,849
We just looked at a couple of them.
我们只是看了几个。 

434
00:23:39,849 --> 00:23:43,009
And they were both insertion sort.
而且它们都是插入排序。 

435
00:23:43,009 --> 00:23:45,039
The second one that I just put up
我刚提出的第二个

436
00:23:45,039 --> 00:23:48,899
is, I guess, technically called binary insertion sort
我猜是技术上称为二进制插入排序

437
00:23:48,900 --> 00:23:50,710
because it does binary search.
因为它执行二进制搜索。 

438
00:23:50,710 --> 00:23:53,000
And the vanilla insertion sort is
和香草插入排序是

439
00:23:53,000 --> 00:23:56,675
the one that you have the code for in the doc dis program,
您在doc dis程序中拥有代码的代码， 

440
00:23:56,675 --> 00:23:59,399
or at least one of the doc dis files.
或至少一个doc dis文件。 

441
00:23:59,400 --> 00:24:04,419
So let's move on and talk about a different algorithm.
因此，让我们继续讨论另一种算法。 

442
00:24:04,619 --> 00:24:06,829
So what we'd like to do, now-- this class
所以我们现在想做什么

443
00:24:06,829 --> 00:24:09,119
is about constant improvement.
关于持续改进。 

444
00:24:09,119 --> 00:24:11,479
We're never happy.
我们永远不会幸福。 

445
00:24:11,480 --> 00:24:14,169
We always want to do a little bit better.
我们一直想做得更好。 

446
00:24:14,369 --> 00:24:16,863
And eventually, once we run out of room
最终，一旦我们的房间用完了

447
00:24:16,864 --> 00:24:18,279
from an asymptotic standpoint, you
从渐近的角度来看， 

448
00:24:18,279 --> 00:24:20,363
take these other classes where you try and improve
尝试其他这些课程并加以改进

449
00:24:20,363 --> 00:24:24,380
constant factors and get 10%, and 5%, and 1%,
常数因子得到10％，5％和1％， 

450
00:24:24,380 --> 00:24:25,359
and so on, and so forth.
等等等等。 

451
00:24:25,559 --> 00:24:31,200
But we'll stick to improving asymptotic complexity.
但是我们将坚持改善渐近复杂性。 

452
00:24:31,200 --> 00:24:34,190
And we're not quite happy with binary insertion sort
而且我们对二进制插入排序不满意

453
00:24:34,190 --> 00:24:37,049
because, in the case of numbers, our binary insertion sort
因为，对于数字，我们的二进制插入排序

454
00:24:37,049 --> 00:24:40,709
has theta n squared complexity, if you look at swaps.
如果您查看交换，则具有平方复杂度。 

455
00:24:40,709 --> 00:24:42,841
So we'd like to go find an algorithm that is theta n log
因此，我们想找到一种算法，即

456
00:24:43,041 --> 00:24:44,809
n.
 。 

457
00:24:44,809 --> 00:24:49,599
And I guess, eventually, we'll have to stop.
我想，最终，我们将不得不停止。 

458
00:24:49,599 --> 00:24:51,259
But Erik will take care of that.
但是Erik会照顾好这个。 

459
00:24:51,259 --> 00:24:53,900



460
00:24:53,900 --> 00:24:54,970
There's a reason to stop.
有停止的理由。 

461
00:24:54,970 --> 00:24:58,419
It's when you can prove that you can't do any better.
这是您可以证明自己无法做得更好的时候。 

462
00:24:58,619 --> 00:25:01,209
And so we'll get to that, eventually.
因此，我们最终将解决这个问题。 

463
00:25:01,210 --> 00:25:04,684
So merge sort is also something that you've probably seen.
因此，合并排序也是您可能已经看到的东西。 

464
00:25:04,684 --> 00:25:07,277



465
00:25:07,277 --> 00:25:08,534
But there probably will be a couple
但是可能会有一对

466
00:25:08,734 --> 00:25:12,439
of subtleties that come out as I describe this algorithm that,
我描述此算法时会发现一些微妙之处， 

467
00:25:12,440 --> 00:25:15,139
hopefully, will be interesting to those of you who already
希望对那些已经

468
00:25:15,339 --> 00:25:16,809
know merge sort.
知道合并排序。 

469
00:25:16,809 --> 00:25:21,029
And for those of you who don't, it's a very pretty algorithm.
对于那些不这样做的人来说，这是一个非常漂亮的算法。 

470
00:25:21,029 --> 00:25:26,930
It's a standard recursion algorithm-- recursive
这是标准的递归算法-递归

471
00:25:26,930 --> 00:25:30,419
algorithm-- similar to a binary search.
算法-类似于二进制搜索。 

472
00:25:30,619 --> 00:25:34,779
What we do, here, is we have an array, A. We split it
在这里，我们要做的是有一个数组A。我们将其拆分

473
00:25:34,779 --> 00:25:42,095
into two parts, L and R. And essentially, we kind of
分为L和R两部分。从本质上讲，我们有点

474
00:25:42,095 --> 00:25:43,950
do no work, really.
没事，真的。 

475
00:25:43,950 --> 00:25:49,814
In terms of the L and R in the sense that we just call,
就我们刚才所说的L和R而言， 

476
00:25:49,814 --> 00:25:51,480
we keep splitting, splitting, splitting.
我们不断分裂，分裂，分裂。 

477
00:25:51,480 --> 00:25:54,019
And all the work is done down at the bottom
所有工作都在底部完成

478
00:25:54,019 --> 00:25:57,569
in this routine called merge, where we are merging
在这个称为合并的例程中，我们正在合并

479
00:25:57,569 --> 00:26:00,109
a pair of elements at the leaves.
叶子上的一对元素。 

480
00:26:00,109 --> 00:26:04,490
And then, we merge two pairs and get four elements.
然后，我们合并两对并获得四个元素。 

481
00:26:04,490 --> 00:26:08,630
And then we merge four tuples of elements, et cetera,
然后我们合并元素的四个元组，等等

482
00:26:08,630 --> 00:26:09,879
and go all the way up.
并一直上升。 

483
00:26:10,079 --> 00:26:18,990
So while I'm just saying L terms into L prime, out here,
因此，虽然我只是说L个词成L个质数，但在这里， 

484
00:26:18,990 --> 00:26:20,990
there's no real explicit code that you
没有真正的显式代码

485
00:26:20,990 --> 00:26:23,669
can see that turns L into L prime.
可以看到将L变成L素数。 

486
00:26:23,869 --> 00:26:25,629
It happens really later.
真的会在以后发生。 

487
00:26:25,630 --> 00:26:27,190
There's no real sorting code, here.
这里没有真正的排序代码。 

488
00:26:27,190 --> 00:26:28,789
It happens in the merge routine.
它发生在合并例程中。 

489
00:26:28,789 --> 00:26:30,648
And you'll see that quite clearly
而且您会清楚地看到

490
00:26:30,648 --> 00:26:31,939
when we run through an example.
当我们通过一个例子。 

491
00:26:31,940 --> 00:26:34,960



492
00:26:34,960 --> 00:26:41,500
So you have L and R turn into L prime and R prime.
因此，您有L和R变成L素数和R素数。 

493
00:26:41,500 --> 00:26:52,309
And what we end up getting is a sorted array, A.
我们最终得到的是一个排序的数组A。 

494
00:26:52,309 --> 00:26:58,899
And we have what's called a merge routine that
我们有一个所谓的合并例程

495
00:26:58,900 --> 00:27:00,909
takes L prime and R prime and merges them
接受L素数和R素数并将它们合并

496
00:27:01,109 --> 00:27:02,399
into the sorted array.
进入排序后的数组。 

497
00:27:02,400 --> 00:27:09,269
So at the top level, what you see is split into two,
因此，在顶层，您看到的内容分为两部分， 

498
00:27:09,269 --> 00:27:13,279
and do a merge, and get to the sorted array.
并进行合并，然后进入排序后的数组。 

499
00:27:13,279 --> 00:27:16,680
The input is of size n.
输入的大小为n。 

500
00:27:16,680 --> 00:27:24,690
You have two arrays of size n over 2.
您有两个大小为n大于2的数组。 

501
00:27:24,690 --> 00:27:33,210
These are two sorted arrays of size n over 2.
这是大小为n大于2的两个排序数组。 

502
00:27:33,210 --> 00:27:39,480
And then, finally, you have a sorted array of size n.
然后，最后，您得到大小为n的排序数组。 

503
00:27:39,480 --> 00:27:42,115



504
00:27:42,115 --> 00:27:44,240
So if you want to follow the recursive of execution
因此，如果要遵循递归执行

505
00:27:44,240 --> 00:27:49,669
of this in a small example, then you'll
在一个小例子中，那么您将

506
00:27:49,869 --> 00:27:53,789
be able to see how this works.
能够看到它是如何工作的。 

507
00:27:53,789 --> 00:27:56,119
And we'll do a fairly straightforward example
我们将做一个非常简单的例子

508
00:27:56,119 --> 00:27:58,199
with 8 elements.
有8个元素。 

509
00:27:58,200 --> 00:28:03,180
So at the top level-- before we get there, merge
因此，在顶层-在我们到达那里之前，先合并

510
00:28:03,180 --> 00:28:08,640
is going to assume that you have two sorted arrays,
假设您有两个排序的数组， 

511
00:28:08,640 --> 00:28:11,700
and merge them together.
并合并在一起。 

512
00:28:11,700 --> 00:28:15,960
That's the invariant in merge sort, or for the merge routine.
这是合并排序或合并例程中的不变式。 

513
00:28:15,960 --> 00:28:19,569
It assumes the inputs are sorted-- L and R. Actually
假设输入已排序-L和R。实际上

514
00:28:19,569 --> 00:28:22,799
I should say, L prime and R prime.
我应该说，L素数和R素数。 

515
00:28:22,799 --> 00:28:27,624
So let's say you have 20, 13, 7, and 2.
假设您有20、13、7和2。 

516
00:28:27,624 --> 00:28:31,319
You have 12, 11, 9, and 1.
您有12、11、9和1。 

517
00:28:31,319 --> 00:28:33,399
And this could be L prime.
这可能是L素数。 

518
00:28:33,400 --> 00:28:36,639
And this could be R prime.
这可能是R素数。 

519
00:28:36,839 --> 00:28:39,649
What you have is what we call a two finger algorithm.
您拥有的就是所谓的两指算法。 

520
00:28:39,650 --> 00:28:42,380
And so you've got two fingers and each of them
因此，您有两个手指，每个手指

521
00:28:42,380 --> 00:28:44,162
point to something.
指向某事。 

522
00:28:44,162 --> 00:28:45,669
And in this case, one of them is pointing
在这种情况下，其中一个指向

523
00:28:45,869 --> 00:28:49,189
to L. My left finger is pointing to L prime,
我的左手指指向L素数， 

524
00:28:49,190 --> 00:28:50,799
or some element L prime.
或某些元素L素数。 

525
00:28:50,799 --> 00:28:53,849
My right finger is pointing to some element in R prime.
我的右手指指向R素数中的某个元素。 

526
00:28:53,849 --> 00:28:56,819
And I'm going to compare the two elements
我将比较这两个元素

527
00:28:56,819 --> 00:28:58,740
that my fingers are pointing to.
我的手指指向的地方。 

528
00:28:58,740 --> 00:29:02,170
And I'm going to choose, in this case,
在这种情况下，我将选择

529
00:29:02,170 --> 00:29:03,639
the smaller of those elements.
这些元素中较小的一个。 

530
00:29:03,839 --> 00:29:07,789
And I'm going to put them into the sorted array.
我将它们放入已排序的数组中。 

531
00:29:07,789 --> 00:29:10,970
So start out here.
所以从这里开始。 

532
00:29:10,970 --> 00:29:12,480
Look at that and that.
看那个那个。 

533
00:29:12,480 --> 00:29:14,266
And I compared 2 and 1.
我比较了2和1。 

534
00:29:14,266 --> 00:29:15,140
And which is smaller?
哪个更小？ 

535
00:29:15,140 --> 00:29:16,109
1 is smaller.
 1较小。 

536
00:29:16,309 --> 00:29:19,129
So I'm going to write 1 down.
所以我要写下1。 

537
00:29:19,130 --> 00:29:23,720
This is a two finger algo for merge.
这是一个用于合并的两指算法。 

538
00:29:23,720 --> 00:29:24,880
And I put 1 down.
我放下1。 

539
00:29:24,880 --> 00:29:27,380
When I put 1 down, I had to cross out 1.
当我放下1时，我必须剔除1。 

540
00:29:27,380 --> 00:29:29,194
So effectively, what happens is-- let
如此有效地发生了- 

541
00:29:29,394 --> 00:29:31,460
me just circle that instead of crossing it out.
我只是圈出它而不是划掉它。 

542
00:29:31,460 --> 00:29:35,450
And my finger moves up to 9.
我的手指向上移动到9。 

543
00:29:35,450 --> 00:29:37,909
So now I'm pointing at 2 and 9.
所以现在我指的是2和9。 

544
00:29:38,109 --> 00:29:40,079
And I repeat this step.
我重复此步骤。 

545
00:29:40,079 --> 00:29:41,869
So now, in this case, 2 is smaller.
所以现在，在这种情况下，2较小。 

546
00:29:41,869 --> 00:29:44,039
So I'm going to go ahead and write 2 down.
所以我要继续写下2。 

547
00:29:44,039 --> 00:29:49,420
And I can cross out 2 and move my finger up to 7.
我可以划掉2并将手指移至7。 

548
00:29:49,420 --> 00:29:50,639
And so that's it.
就是这样。 

549
00:29:50,839 --> 00:29:54,009
I won't bore you with the rest of the steps.
其余步骤将不会让您感到厌烦。 

550
00:29:54,009 --> 00:29:56,114
It's essentially walking up.
它实际上是在走。 

551
00:29:56,114 --> 00:29:57,779
You have a couple of pointers and you're
你有几个指针，你是

552
00:29:57,779 --> 00:29:59,920
walking up these two arrays.
走这两个阵列。 

553
00:29:59,920 --> 00:30:07,230
And you're writing down 1, 2, 7, 9, 11, 12, 13, 20.
您正在写下1，2，7，9，9，11，12，13，20。 

554
00:30:07,230 --> 00:30:08,730
And that's your merge routine.
这就是您的合并例程。 

555
00:30:08,730 --> 00:30:12,329
And all of the work, really, is done in the merge routine
实际上，所有工作都是在合并例程中完成的

556
00:30:12,329 --> 00:30:15,460
because, other than that, the body is simply
因为除此之外，身体只是

557
00:30:15,460 --> 00:30:16,419
a recursive call.
递归调用。 

558
00:30:16,619 --> 00:30:18,419
You have to, obviously, split the array.
显然，您必须拆分数组。 

559
00:30:18,420 --> 00:30:19,909
But that's fairly straightforward.
但这很简单。 

560
00:30:20,109 --> 00:30:24,599
If you have an array, A 0 through n-- and depending on
如果您有一个数组，则A 0到n--并取决于

561
00:30:24,599 --> 00:30:28,299
whether n is odd or even-- you could
无论n是奇数还是偶数-您都可以

562
00:30:28,299 --> 00:30:38,529
imagine that you set L to be A 0 n by 2 minus 1,
假设您将L设置为A 0 n 2减去1， 

563
00:30:38,529 --> 00:30:41,420
and R similarly.
和R类似。 

564
00:30:41,420 --> 00:30:44,086
And so you just split it halfway in the middle.
因此，您只需要在中间将其拆分即可。 

565
00:30:44,086 --> 00:30:45,710
I'll talk about that a little bit more.
我再说一点。 

566
00:30:45,710 --> 00:30:47,334
There's a subtlety associated with that
有一个与之相关的微妙之处

567
00:30:47,334 --> 00:30:51,200
that we'll get to in a few minutes.
我们将在几分钟后到达。 

568
00:30:51,200 --> 00:30:55,279
But to finish up in terms of the computation of merge sort.
但是要完成合并排序的计算。 

569
00:30:55,279 --> 00:30:56,109
This is it.
就是这个。 

570
00:30:56,109 --> 00:31:00,826
The merge routine is doing most, if not all, of the work.
合并例程正在执行大部分（如果不是全部）工作。 

571
00:31:00,826 --> 00:31:02,410
And this two finger algorithm is going
而这两个手指算法正在

572
00:31:02,410 --> 00:31:04,630
to be able to take two sorted arrays
能够接受两个排序的数组

573
00:31:04,630 --> 00:31:09,349
and put them into a single sorted array
并将它们放入单个排序的数组中

574
00:31:09,549 --> 00:31:13,149
by interspersing, or interleaving, these elements.
通过散布或交错这些元素。 

575
00:31:13,150 --> 00:31:15,000
And what's the complexity of merge
合并的复杂性是什么

576
00:31:15,000 --> 00:31:18,710
if I have two arrays of size n over 2, here?
如果我有两个大小为n大于2的数组，在这里？ 

577
00:31:18,710 --> 00:31:21,809
What do I have?
我有什么？ 

578
00:31:21,809 --> 00:31:22,589
AUDIENCE: n.
听众： 

579
00:31:22,589 --> 00:31:23,730
PROFESSOR: n.
教授： 

580
00:31:23,730 --> 00:31:24,980
We'll give you a cushion, too.
我们也会给您垫子。 

581
00:31:24,980 --> 00:31:28,049



582
00:31:28,049 --> 00:31:29,164
theta n complexity.
复杂度。 

583
00:31:29,164 --> 00:31:35,470



584
00:31:35,470 --> 00:31:36,289
So far so good.
到现在为止还挺好。 

585
00:31:36,289 --> 00:31:38,829



586
00:31:38,829 --> 00:31:41,639
I know you know the answer as to what
我知道你知道答案

587
00:31:41,640 --> 00:31:43,349
the complexity of merge sort is.
合并排序的复杂度是。 

588
00:31:43,549 --> 00:31:45,180
But I'm guessing that most of you
但我猜你们大多数人

589
00:31:45,180 --> 00:31:47,900
won't be able to prove it to me because I'm kind of a hard guy
无法证明给我，因为我有点硬汉

590
00:31:47,900 --> 00:31:50,920
to prove something to.
证明一些东西。 

591
00:31:50,920 --> 00:31:53,039
And I could always say, no, I don't believe you
我总是可以说，不，我不相信你

592
00:31:53,039 --> 00:31:53,955
or I don't understand.
不然我听不懂

593
00:31:53,955 --> 00:31:57,959



594
00:31:57,960 --> 00:32:00,880
The complexity-- and you've said this before, in class,
复杂性-您之前在课堂上已经说过了， 

595
00:32:00,880 --> 00:32:02,379
and I think Erik's mentioned it--
我认为Erik提到了- 

596
00:32:02,579 --> 00:32:08,369
the overall complexity of this algorithm is theta n log n
该算法的整体复杂度为theta n log n 

597
00:32:08,369 --> 00:32:09,809
And where does that come from?
那是从哪里来的？ 

598
00:32:09,809 --> 00:32:11,789
How do you prove that?
您如何证明这一点？ 

599
00:32:11,789 --> 00:32:16,839
And so what we'll do, now, is take a look at merge sort.
因此，我们现在要看看合并排序。 

600
00:32:16,839 --> 00:32:19,069
And we'll look at the recursion tree.
我们来看一下递归树。 

601
00:32:19,069 --> 00:32:20,694
And we'll try and-- there are many ways
我们将尝试-有很多方法

602
00:32:20,694 --> 00:32:23,369
of proving that merge sort is theta n log n.
证明合并排序是the n log n。 

603
00:32:23,369 --> 00:32:25,859
The way we're going to do this is
我们要做的是

604
00:32:25,859 --> 00:32:28,639
what's called proof by picture.
所谓的图片证明。 

605
00:32:28,640 --> 00:32:32,089
And it's not an established proof technique,
这不是既定的证明技术， 

606
00:32:32,289 --> 00:32:35,019
but it's something that is very helpful
但这很有帮助

607
00:32:35,019 --> 00:32:38,099
to get an intuition behind the proof
得到证明的直觉

608
00:32:38,099 --> 00:32:40,440
and why the result is true.
以及为什么结果是正确的。 

609
00:32:40,441 --> 00:32:41,940
And you can always take that and you
而且你总是可以接受而你

610
00:32:41,940 --> 00:32:47,029
can formalize it and make this something
可以将其形式化并使其成为某种东西

611
00:32:47,029 --> 00:32:49,680
that everyone believes.
每个人都相信。 

612
00:32:49,680 --> 00:32:52,960
And we'll also look at substitution, possibly
我们还将研究替代

613
00:32:52,960 --> 00:32:56,309
in section tomorrow, for recurrence solving.
在明天的部分中，以解决复发问题。 

614
00:32:56,309 --> 00:33:00,539
So where we're right now is that we have a divide and conquer
因此，我们现在所处的是分而治之

615
00:33:00,539 --> 00:33:07,710
algorithm that has a merge step that is theta n.
合并步骤为theta n的算法。 

616
00:33:07,710 --> 00:33:12,539
And so, if I just look at this structure that I have here,
因此，如果我只看这里的结构， 

617
00:33:12,539 --> 00:33:16,149
I can write a recurrence for merge sort
我可以为合并排序写一个循环

618
00:33:16,150 --> 00:33:17,765
that looks like this.
看起来像这样。 

619
00:33:17,965 --> 00:33:22,719
So when I say complexity, I can say
所以当我说复杂性时，我可以说

620
00:33:22,720 --> 00:33:26,230
T of n, which is the work done for n items,
 T的n，这是对n个项目所做的工作， 

621
00:33:26,230 --> 00:33:28,910
is going to be some constant time in order
将会是一些固定的时间

622
00:33:28,910 --> 00:33:31,940
to divide the array.
分割数组。 

623
00:33:31,940 --> 00:33:34,200
So this could be the part corresponding
所以这可能是对应的部分

624
00:33:34,200 --> 00:33:36,159
to dividing the array.
划分数组。 

625
00:33:36,359 --> 00:33:40,359
And there's going to be two problems of size n over 2.
并且将存在两个大小大于2的问题。 

626
00:33:40,359 --> 00:33:42,809
And so I have 2 T of n over 2.
所以我有2 T大于2。 

627
00:33:42,809 --> 00:33:44,710
And this is the recursive part.
这是递归的部分。 

628
00:33:44,710 --> 00:33:48,650



629
00:33:48,650 --> 00:33:53,960
And I'm going to have c times n, which is the merge part.
我将得到c乘以n，这是合并部分。 

630
00:33:53,960 --> 00:33:58,910
And that's some constant times n, which is what we have,
那就是我们所拥有的恒定时间n 

631
00:33:58,910 --> 00:34:01,890
here, with respect to the theta n complexity.
这里，关于theta n复杂性。 

632
00:34:01,890 --> 00:34:04,980
So you have a recurrence like this and I know some of you
所以你有这样的复发，我认识一些人

633
00:34:04,980 --> 00:34:07,150
have seen recurrences in 6.042.
在6.042中看到了复发。 

634
00:34:07,150 --> 00:34:09,239
And you know how to solve this.
而且您知道如何解决此问题。 

635
00:34:09,239 --> 00:34:14,469
What I'd like to do is show you this recursion tree expansion
我想做的就是向您展示此递归树扩展

636
00:34:14,469 --> 00:34:17,989
that, not only tells you how to solve this occurrence,
那不仅告诉您如何解决这种情况， 

637
00:34:17,989 --> 00:34:23,101
but also gives you a means of solving recurrences where,
而且还为您提供了一种解决重复发生的方法， 

638
00:34:23,101 --> 00:34:25,559
instead of having c of n, you have something else out here.
而不是c等于n，您这里还有其他内容。 

639
00:34:25,559 --> 00:34:27,789
You have f of n, which is a different function
您有n个f，这是一个不同的函数

640
00:34:27,789 --> 00:34:29,279
from the linear function.
从线性函数。 

641
00:34:29,280 --> 00:34:33,750
And this recursion tree is, in my mind,
在我看来，这棵递归树是

642
00:34:33,750 --> 00:34:38,650
the simplest way of arguing the theta n log n
争论then n的最简单方法

643
00:34:38,650 --> 00:34:41,099
complexity of merge sort.
合并排序的复杂性。 

644
00:34:41,099 --> 00:34:44,338
So what I want to do is expand this recurrence out.
因此，我想做的就是扩大此重复范围。 

645
00:34:44,338 --> 00:34:45,505
And let's do that over here.
让我们在这里做。 

646
00:34:45,505 --> 00:35:06,829



647
00:35:06,829 --> 00:35:10,949
So I have c of n on top.
所以我在n的c上面。 

648
00:35:10,949 --> 00:35:15,849
I'm going to ignore this constant factor because c of n
我将忽略此常数，因为n为c 

649
00:35:15,849 --> 00:35:16,549
dominates.
占主导地位。 

650
00:35:16,550 --> 00:35:17,880
So I'll just start with c of n.
因此，我将从n的c开始。 

651
00:35:18,079 --> 00:35:23,449
I want to break things up, as I do the recursion.
我想分手，就像做递归一样。 

652
00:35:23,449 --> 00:35:26,960
So when I go c of n, at the top level-- that's
因此，当我在n处求c时，在最高层- 

653
00:35:26,960 --> 00:35:29,750
the work I have to do at the merge, at the top level.
在合并中，我必须在顶层完成的工作。 

654
00:35:29,750 --> 00:35:33,110
And then when I go down to two smaller problems, each of them
然后当我涉及两个较小的问题时，每个问题

655
00:35:33,110 --> 00:35:34,480
is size n over 2.
大小n大于2。 

656
00:35:34,480 --> 00:35:38,440
So I do c times n divided by 2 [INAUDIBLE].
所以我用c乘以n除以2 [听不清]。 

657
00:35:38,440 --> 00:35:41,617
So this is just a constant c.
所以这只是一个常数c。 

658
00:35:41,617 --> 00:35:43,000
I didn't want to write thetas up here.
我不想在这里写thetas。 

659
00:35:43,199 --> 00:35:44,439
You could.
你可以。 

660
00:35:44,440 --> 00:35:46,760
And I'll say a little bit more about that later.
我稍后再说更多。 

661
00:35:46,760 --> 00:35:48,980
But think of this cn as representing the theta n
但是认为这个cn代表theta n 

662
00:35:49,179 --> 00:35:50,259
complexity.
复杂。 

663
00:35:50,260 --> 00:35:52,590
And c is this constant.
 c是这个常数。 

664
00:35:52,789 --> 00:35:57,960
So c times n, here. c times n over 2, here.
所以c乘以n，在这里。 c乘以n等于2。 

665
00:35:57,960 --> 00:36:01,760
And then when I keep going, I have c times n over 4,
然后，当我继续前进时，我得到n的c乘以4， 

666
00:36:01,760 --> 00:36:08,710
c times n over 4, et cetera, and so on, and so forth.
 c乘以n等于4，等等，依此类推。 

667
00:36:08,909 --> 00:36:10,649
And when I come down all the way here,
当我一路下来

668
00:36:10,650 --> 00:36:16,670
n is eventually going to become 1-- or essentially a constant--
 n最终将变成1或基本上是一个常数

669
00:36:16,670 --> 00:36:20,789
and I'm going to have a bunch of c's here.
我这里会有很多c。 

670
00:36:20,789 --> 00:36:27,050
So here's another question, that I'd like you to answer.
所以这是另一个问题，我想请你回答。 

671
00:36:27,050 --> 00:36:31,210
Someone tell me what the number of levels in this tree are,
有人告诉我这棵树的层数是多少， 

672
00:36:31,210 --> 00:36:34,059
precisely, and the number of leaves in this tree are,
确切地说，这棵树的叶子数是

673
00:36:34,059 --> 00:36:35,570
precisely.
恰好。 

674
00:36:35,570 --> 00:36:38,061
AUDIENCE: The number of levels is log n plus 1.
听众：级别数为log n加1。 

675
00:36:38,061 --> 00:36:39,059
PROFESSOR: Log n plus 1.
教授：Log n加1。 

676
00:36:39,059 --> 00:36:41,168
Log to the base 2 plus 1.
登录以2为底的加1。 

677
00:36:41,168 --> 00:36:42,210
And the number of leaves?
和多少叶子？ 

678
00:36:42,210 --> 00:36:48,429



679
00:36:48,429 --> 00:36:50,579
You raised your hand back there, first.
首先，您举起手回到那里。 

680
00:36:50,579 --> 00:36:51,429
Number of leaves.
叶数。 

681
00:36:51,429 --> 00:36:52,879
AUDIENCE: I think n.
听众：我认为是。 

682
00:36:52,880 --> 00:36:54,130
PROFESSOR: Yeah, you're right.
教授：是的，您是对的。 

683
00:36:54,130 --> 00:36:56,210
You think right.
您认为正确。 

684
00:36:56,210 --> 00:37:02,519
So 1 plus log n and n leaves.
所以1加log n和n离开。 

685
00:37:02,519 --> 00:37:05,869
When n becomes 1, how many of them do you have?
当n变为1时，您有几个？ 

686
00:37:05,869 --> 00:37:09,469
You're down to a single element, which is, by definition,
您只有一个元素，根据定义， 

687
00:37:09,469 --> 00:37:10,579
sorted.
排序。 

688
00:37:10,579 --> 00:37:13,730
And you have n leaves.
你有n片叶子。 

689
00:37:13,730 --> 00:37:17,019
So now let's add up the work.
现在让我们加起来。 

690
00:37:17,019 --> 00:37:20,230
I really like this picture because it's just
我真的很喜欢这张照片，因为它只是

691
00:37:20,230 --> 00:37:23,449
so intuitive in terms of getting us the result
在获得结果方面非常直观

692
00:37:23,449 --> 00:37:25,089
that we're looking for.
我们正在寻找。 

693
00:37:25,090 --> 00:37:30,079
So you add up the work in each of the levels of this tree.
因此，您需要在该树的每个级别中添加工作。 

694
00:37:30,079 --> 00:37:32,190
So the top level is cn.
因此，顶层是cn。 

695
00:37:32,190 --> 00:37:39,789
The second level is cn because I added 1/2 and 1/2, cn, cn.
第二个级别是cn，因为我加了1/2和1/2，cn，cn。 

696
00:37:39,789 --> 00:37:40,750
Wow.
哇。 

697
00:37:40,750 --> 00:37:43,010
What symmetry.
什么对称。 

698
00:37:43,010 --> 00:37:50,500
So you're doing the same amount of work modulo
因此，您正在做相同数量的模运算

699
00:37:50,500 --> 00:37:54,050
the constant factors, here, with what's
恒定因素，这里是什么

700
00:37:54,050 --> 00:37:56,280
going on with the c1, which we've ignored,
继续我们忽略的c1 

701
00:37:56,280 --> 00:37:59,670
but roughly the same amount of work in each of the levels.
但每个级别的工作量大致相同。 

702
00:37:59,869 --> 00:38:02,569
And now, you know how many levels there are.
现在，您知道有多少个级别。 

703
00:38:02,570 --> 00:38:04,650
It's 1 plus log n.
它是1加log n。 

704
00:38:04,849 --> 00:38:11,929
So if you want to write an equation for T of n,
因此，如果您要为n的T编写方程， 

705
00:38:11,929 --> 00:38:23,029
it's 1 plus log n times c of n, which is theta of n log n.
它是1加log n乘以n的c，即n log n的θ。 

706
00:38:23,030 --> 00:38:26,519



707
00:38:26,519 --> 00:38:31,048
So I've mixed in constants c and thetas.
所以我混合了常数c和thetas。 

708
00:38:31,048 --> 00:38:32,590
For the purposes of this description,
为了便于说明， 

709
00:38:32,590 --> 00:38:33,750
they're interchangeable.
它们是可互换的。 

710
00:38:33,949 --> 00:38:38,094
You will see recurrences that look like this, in class.
在课堂上，您将看到类似这样的重复发生。 

711
00:38:38,094 --> 00:38:45,209



712
00:38:45,210 --> 00:38:46,860
And things like that.
这样的事情。 

713
00:38:46,860 --> 00:38:48,170
Don't get confused.
不要感到困惑。 

714
00:38:48,369 --> 00:38:51,150
It's just a constant multiplicative factor
这只是一个恒定的乘法因子

715
00:38:51,150 --> 00:38:54,510
in front of the function that you have.
在您拥有的功能之前

716
00:38:54,510 --> 00:38:56,230
And it's just a little easier, I think,
我认为这要容易一些， 

717
00:38:56,230 --> 00:38:58,139
to write down these constant factors
写下这些恒定因素

718
00:38:58,139 --> 00:39:00,509
and realize that the amount of work done
并意识到完成的工作量

719
00:39:00,510 --> 00:39:02,980
is the same in each of the leaves.
每一片叶子都一样

720
00:39:02,980 --> 00:39:06,010
And once you know the dimensions of this tree,
一旦知道了这棵树的尺寸， 

721
00:39:06,010 --> 00:39:08,730
in terms of levels and in terms of the number of leaves,
就级别和叶子数量而言， 

722
00:39:08,929 --> 00:39:10,960
you get your result.
你得到你的结果。 

723
00:39:10,960 --> 00:39:14,559



724
00:39:14,559 --> 00:39:17,424
So we've looked at two algorithm, so far.
到目前为止，我们已经研究了两种算法。 

725
00:39:17,425 --> 00:39:25,960



726
00:39:26,159 --> 00:39:29,539
And insertion sort, if you talk about numbers,
插入排序，如果您谈论数字， 

727
00:39:29,539 --> 00:39:31,963
is theta n squared for swaps.
是交换的平方。 

728
00:39:31,963 --> 00:39:33,130
Merge sort is theta n log n.
合并排序为the log n。 

729
00:39:33,130 --> 00:39:36,269



730
00:39:36,269 --> 00:39:38,679
Here's another interesting question.
这是另一个有趣的问题。 

731
00:39:38,679 --> 00:39:44,719
What is one advantage of insertion sort over merge sort?
插入排序优于合并排序的一个优点是什么？ 

732
00:39:44,719 --> 00:39:50,175



733
00:39:50,175 --> 00:39:51,179
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

734
00:39:51,179 --> 00:39:52,731
PROFESSOR: What does that mean?
教授：那是什么意思？ 

735
00:39:52,731 --> 00:39:54,773
AUDIENCE: You don't have to move elements outside
听众：您不必将元素移到外面

736
00:39:54,773 --> 00:39:56,960
of [INAUDIBLE].
的[音频不清晰]。 

737
00:39:56,960 --> 00:39:58,420
PROFESSOR: That's exactly right.
教授：完全正确。 

738
00:39:58,420 --> 00:40:01,329
That's exactly right.
没错

739
00:40:01,329 --> 00:40:03,269
So the two guys who answered the questions
所以两个回答问题的家伙

740
00:40:03,269 --> 00:40:05,840
before with the levels, and you.
在关卡之前，还有你。 

741
00:40:05,840 --> 00:40:07,539
Come to me after class.
下课后过来找我。 

742
00:40:07,739 --> 00:40:09,689
So that's a great answer.
因此，这是一个很好的答案。 

743
00:40:09,690 --> 00:40:12,179
It's in-place sorting is something
就地分拣是什么

744
00:40:12,179 --> 00:40:14,819
that has to do with auxiliary space.
与辅助空间有关。 

745
00:40:14,820 --> 00:40:19,280
And so what you see, here-- and it was a bit hidden, here.
所以您在这里看到的东西-在这里有些隐蔽。 

746
00:40:19,280 --> 00:40:21,940
But the fact of the matter is that you
但事实是，你

747
00:40:21,940 --> 00:40:25,530
had L prime and R prime.
有L素数和R素数。 

748
00:40:25,530 --> 00:40:29,710
And L prime and R prime are different from L and R, which
并且L素数和R素数与L和R不同，后者

749
00:40:29,909 --> 00:40:33,440
were the initial halves of the inputs to the sorting
是排序输入的最初一半

750
00:40:33,440 --> 00:40:34,789
algorithm.
算法。 

751
00:40:34,989 --> 00:40:38,629
And what I said here is, we're going to dump this into A.
我在这里说的是，我们要将其转储到A中。 

752
00:40:38,630 --> 00:40:40,440
That's what this picture shows.
这就是这张图片所显示的。 

753
00:40:40,440 --> 00:40:43,340
This says sorted array, A. And so you
这就是说排序数组A。所以你

754
00:40:43,340 --> 00:40:48,519
had to make a copy of the array-- the two halves L
必须制作数组的副本-L的两半

755
00:40:48,719 --> 00:40:52,269
and R-- in order to do the recursion,
和R--为了进行递归， 

756
00:40:52,269 --> 00:40:54,489
and then to take the results and put them
然后把结果放进去

757
00:40:54,489 --> 00:40:56,789
into the sorted array, A.
进入排序后的数组A 

758
00:40:56,789 --> 00:40:59,219
So you needed-- in merge sort-- you
因此，您需要-在合并排序中- 

759
00:40:59,219 --> 00:41:04,059
needed theta n auxiliary space.
需要的辅助空间。 

760
00:41:04,059 --> 00:41:10,369
So merge sort, you need theta n extra space.
因此，合并排序时，您需要额外的空间。 

761
00:41:10,369 --> 00:41:17,380
And the definition of in-place sorting
以及就地排序的定义

762
00:41:17,380 --> 00:41:21,375
implies that you have theta 1-- constant-- auxiliary space.
表示您有theta 1（常数）辅助空间。 

763
00:41:21,574 --> 00:41:24,579



764
00:41:24,579 --> 00:41:27,329
The auxiliary space for insertion sort
辅助排序空间

765
00:41:27,329 --> 00:41:30,449
is simply that temporary variable
只是那个临时变量

766
00:41:30,449 --> 00:41:33,309
that you need when you swap two elements.
交换两个元素时需要的。 

767
00:41:33,309 --> 00:41:35,519
So when you want to swap a couple of registers,
因此，当您想交换几个寄存器时， 

768
00:41:35,519 --> 00:41:38,070
you gotta store one of the values in a temporary location,
您必须将其中一个值存储在一个临时位置， 

769
00:41:38,070 --> 00:41:39,400
override the other, et cetera.
覆盖其他等等。 

770
00:41:39,599 --> 00:41:43,190
And that's the theta 1 auxiliary space for insertion sort.
这就是用于插入排序的theta 1辅助空间。 

771
00:41:43,190 --> 00:41:47,329
So there is an advantage of the version of insertion sort
所以插入排序的版本有一个优势

772
00:41:47,329 --> 00:41:49,139
we've talked about, today, over merge sort.
今天，我们已经讨论过合并排序。 

773
00:41:49,139 --> 00:41:52,826
And if you have a billion elements, that's potentially
如果您有十亿个元素，则可能

774
00:41:52,827 --> 00:41:54,460
something you don't want to store in memory.
您不想存储在内存中的东西。 

775
00:41:54,659 --> 00:41:57,549
If you want to do something really fast and do everything
如果您想快速地做某事并做所有事情

776
00:41:57,550 --> 00:42:00,400
in cache or main memory, and you want
在缓存或主存储器中，并且您想要

777
00:42:00,400 --> 00:42:03,610
to sort billions are maybe even trillions of items,
数十亿甚至数万亿个项目， 

778
00:42:03,610 --> 00:42:07,539
this becomes an important consideration.
这成为重要的考虑因素。 

779
00:42:07,739 --> 00:42:12,929
I will say that you can reduce the constant factor
我会说你可以减少常数因子

780
00:42:12,929 --> 00:42:14,529
of the theta n.
的

781
00:42:14,530 --> 00:42:16,590
So in the vanilla scheme, you could
因此，在香草方案中，您可以

782
00:42:16,590 --> 00:42:18,690
imagine that you have to have a copy of the array.
假设您必须拥有阵列的副本。 

783
00:42:18,690 --> 00:42:20,900
So if you had n elements, you essentially
因此，如果您有n个元素， 

784
00:42:20,900 --> 00:42:24,289
have n extra items of storage.
有n个额外的存储空间。 

785
00:42:24,489 --> 00:42:28,129
You can make that n over 2 with a simple coding trick
您可以使用简单的编码技巧使n超过2 

786
00:42:28,130 --> 00:42:32,710
by keeping 1/2 of A.
保持A的1/2。 

787
00:42:32,710 --> 00:42:35,800
You can throw away one of the L's or one of the R's.
您可以扔掉L之一或R之一。 

788
00:42:35,800 --> 00:42:37,637
And you can get it down to n over 2.
您可以将其降低到2以上的n。 

789
00:42:37,637 --> 00:42:39,269
And that turns out-- it's a reasonable thing
事实证明-这是合理的事情

790
00:42:39,469 --> 00:42:41,409
to do if you have a billion elements
如果您有十亿个元素，该怎么办

791
00:42:41,409 --> 00:42:45,399
and you want to reduce your storage by a constant factor.
并且您希望将存储空间减少一定的比例。 

792
00:42:45,400 --> 00:42:47,130
So that's one coding trick.
这就是编码技巧。 

793
00:42:47,130 --> 00:42:49,630
Now it turns out that you can actually go further.
现在事实证明，您实际上可以走得更远。 

794
00:42:49,630 --> 00:42:52,130
And there's a fairly sophisticated algorithm
而且有一个相当复杂的算法

795
00:42:52,130 --> 00:42:54,539
that's sort of beyond the scope of 6.006
这超出了6.006的范围

796
00:42:54,739 --> 00:42:56,419
that's an in-place merge sort.
这是就地合并排序。 

797
00:42:56,420 --> 00:42:59,309



798
00:42:59,309 --> 00:43:03,070
And this in-place merge sort is kind of
这种就地合并方式是

799
00:43:03,070 --> 00:43:08,590
impractical in the sense that it doesn't do very well
就它做得不好而言，这是不切实际的

800
00:43:08,590 --> 00:43:09,940
in terms of the constant factors.
就恒定因素而言。 

801
00:43:10,139 --> 00:43:15,119
So while it's in-place and it's still theta n log n.
因此，尽管它就位并且仍然是n n log n。 

802
00:43:15,119 --> 00:43:19,719
The problem is that the running time of an in-place merge sort
问题是就地合并排序的运行时间

803
00:43:19,719 --> 00:43:23,209
is much worse than the regular merge sort that
比常规的合并排序要差得多

804
00:43:23,210 --> 00:43:25,510
uses theta n auxiliary space.
使用辅助空间。 

805
00:43:25,510 --> 00:43:27,900
So people don't really use in-place merge sort.
因此人们并不真正使用就地合并排序。 

806
00:43:28,099 --> 00:43:29,360
It's a great paper.
这是一篇很棒的论文。 

807
00:43:29,360 --> 00:43:31,800
It's a great thing to read.
读起来很棒。 

808
00:43:31,800 --> 00:43:36,880
Its analysis is a bit sophisticated for double 0 6.
对于双精度0 6，它的分析有点复杂。 

809
00:43:37,079 --> 00:43:39,029
So we wont go there.
所以我们不会去那里。 

810
00:43:39,030 --> 00:43:40,130
But it does exist.
但是它确实存在。 

811
00:43:40,329 --> 00:43:42,002
So you can take merge sort, and I just
所以您可以进行合并排序，而我只是

812
00:43:42,003 --> 00:43:45,230
want to let you know that you can do things in-place.
希望让您知道您可以就地做事。 

813
00:43:45,230 --> 00:43:50,559
In terms of numbers, some experiments we ran a few years
在数量方面，我们进行了一些实验

814
00:43:50,559 --> 00:43:54,650
ago-- so these may not be completely valid
以前-因此这些可能并不完全有效

815
00:43:54,650 --> 00:43:56,650
because I'm going to actually give you numbers--
因为我实际上要给你数字- 

816
00:43:56,650 --> 00:44:07,380
but merge sort in Python, if you write a little curve fit
但是如果您编写一些曲线拟合，则可以在Python中合并排序

817
00:44:07,380 --> 00:44:17,789
program to do this, is 2.2n log n microseconds for a given n.
程序执行此操作，对于给定的n是2.2n log n微秒。 

818
00:44:17,789 --> 00:44:19,625
So this is the merge sort routine.
这就是合并排序例程。 

819
00:44:19,625 --> 00:44:22,449



820
00:44:22,449 --> 00:44:32,230
And if you look at insertion sort, in Python,
如果您看一下插入排序，在Python中， 

821
00:44:32,230 --> 00:44:39,409
that's something like 0.2 n square microseconds.
大约是0.2 n平方微秒。 

822
00:44:39,409 --> 00:44:42,699
So you see the constant factors here.
因此，您在这里看到了恒定因素。 

823
00:44:42,699 --> 00:44:48,230
If you do insertion sort in C, which is a compiled language,
如果您使用C（一种已编译的语言）进行插入排序， 

824
00:44:48,230 --> 00:44:50,420
then, it's much faster.
然后，它要快得多。 

825
00:44:50,420 --> 00:44:52,934
It's about 20 times faster.
大约快20倍。 

826
00:44:52,934 --> 00:44:55,440



827
00:44:55,440 --> 00:44:59,230
It's 0.01 n squared microseconds.
 0.01 n平方微秒。 

828
00:44:59,230 --> 00:45:00,960
So a little bit of practice on the side.
因此，在侧面进行一些练习。 

829
00:45:00,960 --> 00:45:02,713
We do ask you to write code.
我们确实要求您编写代码。 

830
00:45:02,713 --> 00:45:03,630
And this is important.
这很重要。 

831
00:45:03,630 --> 00:45:04,730
The reason we're interested in algorithms
我们对算法感兴趣的原因

832
00:45:04,929 --> 00:45:06,769
is because people want to run them.
是因为人们想要运行它们。 

833
00:45:06,769 --> 00:45:13,860
And what you can see is that you can actually find an n-- so
您会看到，您实际上可以找到一个n 

834
00:45:13,860 --> 00:45:16,300
regardless of whether you're Python or C,
无论您是Python还是C， 

835
00:45:16,300 --> 00:45:20,019
this tells you that asymptotic complexity is pretty important
这告诉你渐进复杂性非常重要

836
00:45:20,019 --> 00:45:24,139
because, once n gets beyond about 4,000,
因为，一旦n超过4,000， 

837
00:45:24,139 --> 00:45:27,259
you're going to see that merge sort in Python
您将在Python中看到合并排序

838
00:45:27,260 --> 00:45:30,150
beats insertion sort in C.
在C中胜过插入排序。 

839
00:45:30,349 --> 00:45:35,429
So the constant factors get subsumed
因此常数因素被包含在内

840
00:45:35,429 --> 00:45:37,159
beyond certain values of n.
超过n的某些值。 

841
00:45:37,159 --> 00:45:39,835
So that's why asymptotic complexity is important.
这就是为什么渐进复杂性很重要的原因。 

842
00:45:39,835 --> 00:45:41,210
You do have a factor of 20, here,
你的确有20倍， 

843
00:45:41,210 --> 00:45:43,269
but that doesn't really help you in terms
但这并不能真正帮助您

844
00:45:43,269 --> 00:45:47,440
of keeping an n square algorithm competitive.
保持n平方算法具有竞争力。 

845
00:45:47,440 --> 00:45:49,400
It stays competitive for a little bit longer,
它可以保持更长的竞争力， 

846
00:45:49,400 --> 00:45:50,510
but then falls behind.
但后来落后了。 

847
00:45:50,510 --> 00:45:54,320



848
00:45:54,519 --> 00:45:57,387
That's what I wanted to cover for sorting.
这就是我要涵盖的排序内容。 

849
00:45:57,387 --> 00:45:58,769
So hopefully, you have a sense of what
因此，希望您对

850
00:45:58,969 --> 00:46:02,039
happens with these two sorting algorithms.
这两种排序算法都会发生这种情况。 

851
00:46:02,039 --> 00:46:05,199
We'll look at a very different sorting algorithm next time,
下次我们将讨论一种非常不同的排序算法， 

852
00:46:05,199 --> 00:46:08,460
using heaps, which is a different data structure.
使用堆，这是不同的数据结构。 

853
00:46:08,460 --> 00:46:11,329
The last thing I want to do in the couple minutes I have left
我想在剩下的几分钟内做的最后一件事

854
00:46:11,329 --> 00:46:14,809
is give you a little more intuition as to recurrence
让您对复发有更多的直觉

855
00:46:14,809 --> 00:46:18,679
solving based on this diagram that I wrote up there.
根据我在那里写的这张图求解。 

856
00:46:18,679 --> 00:46:21,460
And so we're going to use exactly this structure.
因此，我们将完全使用此结构。 

857
00:46:21,460 --> 00:46:24,250
And we're going to look at a couple of different recurrences
我们将研究几种不同的复发

858
00:46:24,250 --> 00:46:26,360
that I won't really motivate in terms
我不会真正用语言激励

859
00:46:26,360 --> 00:46:29,420
of having a specific algorithm, but I'll just
具有特定算法的方法，但我只是

860
00:46:29,420 --> 00:46:31,150
write out the recurrence.
写出复发。 

861
00:46:31,150 --> 00:46:36,340
And we'll look at the recursion tree for that.
我们将为此查看递归树。 

862
00:46:36,340 --> 00:46:41,900
And I'll try and tease out of you the complexity associated
我会尝试从中挑剔出相关的复杂性

863
00:46:41,900 --> 00:46:45,635
with these recurrences of the overall complexity.
这些重复的整体复杂性。 

864
00:46:45,635 --> 00:46:49,480



865
00:46:49,480 --> 00:46:58,000
So let's take a look at T of n equals 2 T of n over 2
因此，让我们看一下n中的T等于2中n的2 T 

866
00:46:58,000 --> 00:47:00,309
plus c n squared.
加cn平方。 

867
00:47:00,309 --> 00:47:02,820



868
00:47:02,820 --> 00:47:08,360
Let me just call that c-- no need for the brackets.
让我称呼c--不需要括号。 

869
00:47:08,360 --> 00:47:10,769
So constant c times n squared.
因此常数c乘以n的平方。 

870
00:47:10,969 --> 00:47:13,199
So if you had a crummy merge routine,
因此，如果您的合并程序很简陋， 

871
00:47:13,199 --> 00:47:18,019
and it was taking n square, and you coded it up wrong.
它占用了n平方，而您将其编码错误。 

872
00:47:18,019 --> 00:47:20,050
It's not a great motivation for this recurrence,
这种复发不是很大的动力， 

873
00:47:20,050 --> 00:47:23,980
but it's a way this recurrence could have come up.
但这是复发的一种方式。 

874
00:47:23,980 --> 00:47:27,469
So what does this recursive tree look like?
那么，这棵递归树是什么样的呢？ 

875
00:47:27,469 --> 00:47:29,579
Well it looks kind of the same, obviously.
好吧，看起来很像。 

876
00:47:29,579 --> 00:47:33,210
You have c n square; you have c n square divided by 4;
您有cn广场；您的cn平方除以4; 

877
00:47:33,210 --> 00:47:36,619
c n square divided by 4; c n square divided
 cn平方除以4; cn平方划分

878
00:47:36,619 --> 00:47:40,619
by 16, four times.
乘以16，四次

879
00:47:40,619 --> 00:47:44,460
Looking a little bit different from the other one.
看起来与其他人有些不同。 

880
00:47:44,460 --> 00:47:47,559
The levels and the leaves are exactly the same.
级别和叶子完全相同。 

881
00:47:47,559 --> 00:47:49,719
Eventually n is going to go down to 1.
最终，n将降至1。 

882
00:47:49,719 --> 00:47:53,279
So you will see c all the way here.
因此，您将在这里看到c。 

883
00:47:53,280 --> 00:47:54,735
And you're going to have n leaves.
而且您将拥有n片叶子。 

884
00:47:54,735 --> 00:47:57,880



885
00:47:57,880 --> 00:48:03,380
And you will have, as before, 1 plus log n levels.
和以前一样，您将拥有1加log n级别。 

886
00:48:03,380 --> 00:48:05,070
Everything is the same.
一切都一样。 

887
00:48:05,070 --> 00:48:07,590
And this is why I like this recursive tree formulation so
这就是为什么我喜欢这种递归树公式的原因

888
00:48:07,590 --> 00:48:09,170
much because, now, all I have to do
这是因为，现在我要做的就是

889
00:48:09,369 --> 00:48:14,710
is add up the work associated with each of the levels
将与每个级别相关的工作加起来

890
00:48:14,710 --> 00:48:17,099
to get the solution to the recurrence.
获得复发的解决方案。 

891
00:48:17,099 --> 00:48:18,769
Now, take a look at what happens, here.
现在，在这里看看会发生什么。 

892
00:48:18,769 --> 00:48:25,349
c n square; c n square divided by 2; c n square divided by 4.
 cn广场cn平方除以2; cn平方除以4。 

893
00:48:25,349 --> 00:48:27,889
And this is n times c.
这是n次c。 

894
00:48:27,889 --> 00:48:30,889



895
00:48:30,889 --> 00:48:34,315
So what does that add up to?
那加起来是什么呢？ 

896
00:48:34,315 --> 00:48:35,838
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

897
00:48:35,838 --> 00:48:36,880
PROFESSOR: Yeah, exactly.
教授：好的。 

898
00:48:36,880 --> 00:48:37,920
Exactly right.
非常正确。 

899
00:48:37,920 --> 00:48:40,230
So if you look at what happens, here, this dominates.
因此，如果您看看发生了什么，那么这里就占主导地位。 

900
00:48:40,429 --> 00:48:44,339



901
00:48:44,340 --> 00:48:47,519
All of the other things are actually less than that.
所有其他事情实际上都少于这个。 

902
00:48:47,519 --> 00:48:49,250
And you said bounded by two c n square
而你说的是两个cn平方的界限

903
00:48:49,250 --> 00:48:51,420
because this part is bounded by c n square
因为这部分受cn平方限制

904
00:48:51,420 --> 00:48:54,289
and I already have c n square up at the top.
并且我已经在顶部放了cn square。 

905
00:48:54,489 --> 00:48:58,099
So this particular algorithm that corresponds to this crummy
因此，对应于这种笨拙的特定算法

906
00:48:58,099 --> 00:49:02,299
merge sort, or wherever this recurrence came from,
合并排序或这种重复发生的来源， 

907
00:49:02,300 --> 00:49:06,500
is a theta n squared algorithm.
是一个θ平方算法。 

908
00:49:06,699 --> 00:49:10,519
And in this case, all of the work done
在这种情况下，所有完成的工作

909
00:49:10,519 --> 00:49:15,360
is at the root-- at the top level of the recursion.
是根源-在递归的顶层。 

910
00:49:15,360 --> 00:49:17,650
Here, there was a roughly equal amount
在这里，大致相等

911
00:49:17,650 --> 00:49:21,630
of work done in each of the different levels.
每个不同级别完成的工作。 

912
00:49:21,630 --> 00:49:26,610
Here, all of the work was done at the root.
在这里，所有工作都是从根本上完成的。 

913
00:49:26,610 --> 00:49:29,460
And so to close up shop, here, let
所以要关闭商店，在这里，让

914
00:49:29,460 --> 00:49:34,210
me just give you real quick a recurrence where
我给你一个真正的快速复发

915
00:49:34,210 --> 00:49:40,269
all of the work is done at the leaves, just for closure.
所有工作都在叶子处完成，仅用于封闭。 

916
00:49:40,469 --> 00:49:45,769
So if I had, magically, a merge routine that actually happened
因此，如果我神奇地拥有实际上发生的合并例程

917
00:49:45,769 --> 00:49:48,710
in constant time, either through buggy analysis,
在恒定的时间内，通过错误分析

918
00:49:48,710 --> 00:49:51,889
or because of it was buggy, then what
还是因为它有越野车，那

919
00:49:51,889 --> 00:49:55,650
does the tree look like for that?
树看起来像那样吗？ 

920
00:49:55,650 --> 00:49:58,280
And I can think of this as being theta 1.
我可以认为这是theta 1。 

921
00:49:58,280 --> 00:50:00,956
Or I can think of this as being just a constant c.
或者我可以认为这仅仅是一个常数c。 

922
00:50:01,155 --> 00:50:02,029
I'll stick with that.
我会坚持下去。 

923
00:50:02,030 --> 00:50:05,246
So I have c, c, c.
所以我有c，c，c。 

924
00:50:05,246 --> 00:50:09,889



925
00:50:09,889 --> 00:50:11,349
Woah, I tried to move that up.
哇，我试图将其调高。 

926
00:50:11,349 --> 00:50:13,750
That doesn't work.
那不行

927
00:50:13,750 --> 00:50:15,545
So I have n leaves, as before.
所以我和以前一样有n片叶子。 

928
00:50:15,545 --> 00:50:18,313



929
00:50:18,313 --> 00:50:19,980
And so if I look at what I have, here, I
因此，如果我看看自己拥有的东西，在这里，我

930
00:50:19,980 --> 00:50:21,840
have c at the top level.
在顶层有c。 

931
00:50:21,840 --> 00:50:25,670
I have 2c, and so on and so forth.
我有2c，依此类推。 

932
00:50:25,869 --> 00:50:26,929
4c.
 4c。 

933
00:50:26,929 --> 00:50:30,940
And then I go all the way down to nc.
然后我一直走到nc。 

934
00:50:30,940 --> 00:50:33,380
And so what happens here is this dominates.
因此，这里发生的事情占主导地位。 

935
00:50:33,380 --> 00:50:36,010



936
00:50:36,010 --> 00:50:41,400
And so, in this recurrence, the whole thing runs in theta n.
因此，在这种情况下，整个过程都在theta n中运行。 

937
00:50:41,599 --> 00:50:46,299
So the solution to that is theta n.
因此，解决方案是theta n。 

938
00:50:46,300 --> 00:50:50,769
And what you have here is all of the work
您在这里拥有的全部工作

939
00:50:50,969 --> 00:50:54,449
being done at the leaves.
在叶子上完成。 

940
00:50:54,449 --> 00:50:58,439
We're not going to really cover this theorem that gives you
我们不会真正讨论这个给您的定理

941
00:50:58,440 --> 00:51:02,340
a mechanical way of figuring this out because we think
解决这一问题的机械方法，因为我们认为

942
00:51:02,340 --> 00:51:05,780
the recursive tree is a better way of looking at.
递归树是一种更好的观察方法。 

943
00:51:05,780 --> 00:51:08,920
But you can see that, depending on what that function is,
但是您可以看到，取决于该功能是什么， 

944
00:51:08,920 --> 00:51:12,130
in terms of the work being done in the merge routine,
就合并例程中完成的工作而言， 

945
00:51:12,130 --> 00:51:14,289
you'd have different versions of recurrences.
您将有不同版本的重复发生。 

946
00:51:14,489 --> 00:51:16,989
I'll stick around, and people who answered questions, please
我会留下来，请回答问题的人

947
00:51:16,989 --> 00:51:18,269
pick up you cushions.
拿起你的垫子。 

948
00:51:18,269 --> 00:51:23,269
See you next time.
下次见。 

