1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,320
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,320 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:22,120



10
00:00:22,120 --> 00:00:25,769
PROFESSOR: [INAUDIBLE] audio.
教授：[音频不清晰]。 

11
00:00:25,769 --> 00:00:32,310
We're going to have a series of lectures on shortest paths.
我们将在最短路径上进行一系列讲座。 

12
00:00:32,310 --> 00:00:36,380
And one of the big differences between this module
而这个模块之间的最大区别之一

13
00:00:36,380 --> 00:00:39,739
and the previous one, at least from a mathematical standpoint,
至少从数学的角度来看， 

14
00:00:39,939 --> 00:00:41,460
is that we're going to be looking
是我们要去寻找

15
00:00:41,460 --> 00:00:44,780
at graphs that have weights on their edges.
在边缘具有权重的图形上。 

16
00:00:44,780 --> 00:00:47,689
So when Eric talked about depth first search and breadth
因此，当埃里克（Eric）谈论深度优先搜索和广度时

17
00:00:47,689 --> 00:00:50,140
first search in the last couple of lectures,
在最后两节课中首次搜索， 

18
00:00:50,140 --> 00:00:54,159
we had directed graphs and undirected graphs.
我们有向图和无向图。 

19
00:00:54,159 --> 00:00:57,269
But we didn't really have attributes on the edges.
但是，我们实际上并没有边缘属性。 

20
00:00:57,270 --> 00:01:00,489
In particular, you have a much richer class
特别是您的班级要丰富得多

21
00:01:00,689 --> 00:01:03,189
of problems and applications if you
问题和应用程序，如果您

22
00:01:03,189 --> 00:01:07,700
allow for weights on graph edges.
允许在图形边缘上加权。 

23
00:01:07,700 --> 00:01:12,819
And these weights can be integers.
这些权重可以是整数。 

24
00:01:13,019 --> 00:01:15,269
They could be real numbers, irrationals.
它们可能是实数，是非理性的。 

25
00:01:15,269 --> 00:01:17,560
They could be negative, what have you.
他们可能是负面的，你有什么。 

26
00:01:17,560 --> 00:01:22,030
And for different classes of graphs
对于不同类别的图

27
00:01:22,030 --> 00:01:25,790
and different restrictions on weights,
以及不同的重量限制

28
00:01:25,790 --> 00:01:29,259
there's really a set of shortest path algorithms,
确实有一组最短路径算法， 

29
00:01:29,459 --> 00:01:33,149
that we'll look at in the next few lectures, which
我们将在接下来的几节课中介绍

30
00:01:33,150 --> 00:01:36,849
are kind of optimized for a particular application.
针对特定应用进行了优化。 

31
00:01:37,049 --> 00:01:41,899
So we won't do specific algorithms today.
因此，我们今天不做特定的算法。 

32
00:01:41,900 --> 00:01:43,569
But we'll set up the problem.
但是，我们将解决问题。 

33
00:01:43,769 --> 00:01:46,049
We'll talk about the general approach
我们将讨论一般方法

34
00:01:46,049 --> 00:01:48,969
that most shortest path algorithms take
最短路径算法需要的

35
00:01:48,969 --> 00:01:52,010
to solve a particular instance of a problem.
解决特定的问题实例。 

36
00:01:52,010 --> 00:01:56,810
And then we'll close with talking
然后，我们将结束交谈

37
00:01:56,810 --> 00:01:59,390
about a particular property that's pretty important.
关于非常重要的特定财产。 

38
00:01:59,390 --> 00:02:03,290
That's called the optimum or optimal substructure property.
这称为最佳或最佳子结构属性。 

39
00:02:03,290 --> 00:02:06,703
That is a technique that most shortest path algorithms,
这是最短路径算法中的一项技术， 

40
00:02:06,903 --> 00:02:08,569
or actually all shortest path algorithms
或实际上所有最短路径算法

41
00:02:08,569 --> 00:02:14,689
use to get efficient complexity.
用于获得有效的复杂性。 

42
00:02:14,689 --> 00:02:18,889
So asymptotic complexity is important, obviously.
因此，渐近复杂度很重要。 

43
00:02:18,889 --> 00:02:22,579
And we're always looking for the best algorithm with the best
而且我们一直在寻找具有最佳性能的最佳算法

44
00:02:22,580 --> 00:02:23,930
asymptotic complexity.
渐进复杂度。 

45
00:02:23,930 --> 00:02:26,710
And optimal substructure is a hammer
最佳的子结构是一把锤子

46
00:02:26,710 --> 00:02:30,990
that we're going to use to get that.
我们将用来获得它。 

47
00:02:30,990 --> 00:02:35,650
So the canonical motivation, of course, for shortest paths
因此，当然，最短路径的规范动机

48
00:02:35,849 --> 00:02:38,009
is-- now, if you want to steal, or I
现在-如果您想偷东西，或者我

49
00:02:38,009 --> 00:02:40,639
guess borrow, a cannon from Caltech
猜猜借来，来自加州理工学院的一门大炮

50
00:02:40,639 --> 00:02:43,859
and bring it over to MIT, then you
交给麻省理工学院，然后你

51
00:02:43,860 --> 00:02:52,310
want the fastest way of getting here with your illegal goods.
希望以最快的方式带走您的非法物品。 

52
00:02:52,509 --> 00:02:56,229
And you want to find the shortest way or the fastest
而您想找到最短的方法或最快的方法

53
00:02:56,229 --> 00:02:59,079
way of getting from one location to another.
从一个位置到达另一位置的方法。 

54
00:02:59,080 --> 00:03:03,500
So Google Maps go from point A to point
因此，Google Maps从A点移到了

55
00:03:03,500 --> 00:03:09,210
B. That's a classic application of the shortest path problem.
 B.这是最短路径问题的经典应用。 

56
00:03:09,210 --> 00:03:13,000
In this case, you could imagine that distance
在这种情况下，您可以想象该距离

57
00:03:13,000 --> 00:03:16,110
would be something that would be a very simple metric that you
将会是一个非常简单的指标

58
00:03:16,110 --> 00:03:19,120
could use for the weights on the edges.
可用于边缘的权重。 

59
00:03:19,120 --> 00:03:23,360
So for this entire module, we're going
因此，对于整个模块，我们将

60
00:03:23,360 --> 00:03:31,189
to be looking at a graph G V, E, W.
看图GV，E，W 

61
00:03:31,389 --> 00:03:32,659
And you know what V and E are.
而且您知道V和E是什么。 

62
00:03:32,659 --> 00:03:38,359
They're the vertices and the edges.
它们是顶点和边缘。 

63
00:03:38,360 --> 00:03:47,020
And W is a weight function that maps edges to weights.
 W是将边缘映射到权重的权重函数。 

64
00:03:47,020 --> 00:03:50,310
And so we're adding that in here.
因此，我们将其添加到此处。 

65
00:03:50,509 --> 00:03:59,139
And so W would be E to R. So the set of real numbers.
因此W将是E到R。因此是实数集。 

66
00:03:59,139 --> 00:04:02,989
We're going to be looking at two different algorithms
我们将要研究两种不同的算法

67
00:04:02,990 --> 00:04:04,629
in subsequent lectures.
在随后的讲座中。 

68
00:04:04,629 --> 00:04:07,085
And you'll implement one of them in your problem set.
您将在问题集中实施其中之一。 

69
00:04:07,085 --> 00:04:10,379



70
00:04:10,379 --> 00:04:15,030
The simpler algorithm, which we'll look at first,
首先我们来看一下更简单的算法， 

71
00:04:15,030 --> 00:04:18,509
is called Dijkstra, after Edsger Dijkstra, who
以Edsger Dijkstra的名字命名为Dijkstra， 

72
00:04:18,509 --> 00:04:21,969
did some similar work in concurrent programming,
在并发编程中做了一些类似的工作， 

73
00:04:21,970 --> 00:04:23,120
won the Turing Award.
荣获图灵奖。 

74
00:04:23,319 --> 00:04:26,790
But on the side invented this cool algorithm--
但是在一边发明了这个很酷的算法

75
00:04:26,790 --> 00:04:30,129
or at least gets credit for it-- called Dijkstra's algorithm
或至少得到赞誉-称为Dijkstra算法

76
00:04:30,329 --> 00:04:36,529
that assumes non-negative weight edges.
假定非负权重边。 

77
00:04:36,529 --> 00:04:38,029
So I should really say non-negative.
所以我真的应该说非负面的。 

78
00:04:38,029 --> 00:04:40,689
So read that as non-negative.
因此，将其视为非负数。 

79
00:04:40,689 --> 00:04:51,509
And that has a complexity of order V log V plus E.
复杂度为V log V加上E。 

80
00:04:51,509 --> 00:04:52,289
All right.
好吧。 

81
00:04:52,290 --> 00:04:58,129
So this is practically linear time.
因此，这实际上是线性时间。 

82
00:04:58,329 --> 00:05:01,909
And typically, you're going to be dominated in many cases
通常，在许多情况下，您将被统治

83
00:05:01,910 --> 00:05:10,060
by E. In general, if you talk about a simple graph, what's
通常，如果您谈论一个简单的图，那是什么

84
00:05:10,060 --> 00:05:13,689
the asymptotic relationship between E and V?
 E和V之间的渐近关系？ 

85
00:05:13,689 --> 00:05:19,430



86
00:05:19,430 --> 00:05:21,040
Can you relate E to V?
你能把E和V联系起来吗？ 

87
00:05:21,040 --> 00:05:22,874
Can you give me a bound?
你能给我束缚吗？ 

88
00:05:22,874 --> 00:05:23,942
AUDIENCE: V squared.
听众：V平方。 

89
00:05:23,942 --> 00:05:24,449
PROFESSOR: Sorry?
教授：对不起？ 

90
00:05:24,649 --> 00:05:25,969
V squared, thanks.
 V平方，谢谢。 

91
00:05:25,970 --> 00:05:27,500
That's good.
那很好。 

92
00:05:27,699 --> 00:05:33,279
So you can think of E as being order V square.
因此，您可以将E视为V阶。 

93
00:05:33,279 --> 00:05:36,469
And you can certainly have-- that's worth recursion.
而且您当然可以拥有-值得递归。 

94
00:05:36,470 --> 00:05:41,310



95
00:05:41,310 --> 00:05:44,540
So now, you can kind of imagine a complete graph.
所以现在，您可以想象一个完整的图形。 

96
00:05:44,540 --> 00:05:46,189
And a complete graph is something
完整的图形是

97
00:05:46,389 --> 00:05:52,979
that has an edge between each pair of vertices.
在每对顶点之间都有一条边。 

98
00:05:52,980 --> 00:05:57,509
And that's where you'll get E being k w squared.
这就是E被平方平方的地方。 

99
00:05:57,709 --> 00:05:59,370
So when you say simple graph, you're
因此，当您说简单图形时， 

100
00:05:59,370 --> 00:06:03,629
saying you have at most one edge between any pair of vertices.
说您在任何一对顶点之间最多有一个边。 

101
00:06:03,629 --> 00:06:05,159
A multigraph is something that could
多重图形可以

102
00:06:05,160 --> 00:06:07,939
have multiple edges between pairs of vertices.
在成对的顶点之间有多个边。 

103
00:06:08,139 --> 00:06:10,479
We won't really be talking about multigraphs
我们真的不会谈论多图

104
00:06:10,480 --> 00:06:12,639
in this sequence of lectures.
在这一系列的讲座中。 

105
00:06:12,839 --> 00:06:19,419
But something to think about or keep in the back of your mind
但是有些事情需要考虑或留在脑海中

106
00:06:19,420 --> 00:06:21,129
as we go through these algorithms.
当我们经历这些算法时。 

107
00:06:21,129 --> 00:06:25,810
And so the dominating factor here, and in many cases really,
所以这里是主要因素，在很多情况下， 

108
00:06:25,810 --> 00:06:30,389
is E. And Dijkstra is a nice algorithm, because it's
是E。Dijkstra是一个很好的算法，因为它是

109
00:06:30,389 --> 00:06:34,079
linear in the number of edges.
边数线性。 

110
00:06:34,079 --> 00:06:35,899
So that's Dijkstra.
那就是Dijkstra。 

111
00:06:35,899 --> 00:06:38,089
And that's the first of the algorithms
这是第一个算法

112
00:06:38,089 --> 00:06:40,750
that we'll look at next time.
下次再看。 

113
00:06:40,750 --> 00:06:44,069
But we'll see the general structure of Dijkstra today.
但是，今天我们将看到Dijkstra的一般结构。 

114
00:06:44,069 --> 00:06:50,879
And then there's the Bellman-Ford algorithm
然后是Bellman-Ford算法

115
00:06:50,879 --> 00:06:56,889
that works on positive and negative edges, weight edges.
适用于正负边缘，权重边缘。 

116
00:06:56,889 --> 00:07:03,629
And this has a complexity order V E.
这具有复杂度阶V E。 

117
00:07:03,629 --> 00:07:06,240
So you could imagine a particular implementation
所以你可以想象一个特定的实现

118
00:07:06,240 --> 00:07:10,060
of Bellman-Ford running in order V cubed time.
 Bellman-Ford的运行顺序为V的立方时间。 

119
00:07:10,060 --> 00:07:12,360
Because E could be V square.
因为E可以是V平方。 

120
00:07:12,360 --> 00:07:14,610
And you've got this additional E factor.
而且您还有其他E因子。 

121
00:07:14,610 --> 00:07:17,800
So it's order V cubed versus order V log V.
因此，这是订单V的立方与订单V的对数V。 

122
00:07:17,800 --> 00:07:21,000
So when you have a chance, use Dijkstra.
因此，如果有机会，请使用Dijkstra。 

123
00:07:21,000 --> 00:07:25,670
When you're stuck, you'd want to do Bellman-Ford,
当您陷入困境时，您想要做Bellman-Ford， 

124
00:07:25,670 --> 00:07:27,665
because you have these negative weight edges.
因为您有这些负重边缘。 

125
00:07:27,665 --> 00:07:29,790
And one of the challenges in negative weight edges,
负边缘带来的挑战之一是

126
00:07:29,790 --> 00:07:32,550
and I'll say a little bit more as we go along,
我们继续讲的话， 

127
00:07:32,550 --> 00:07:37,050
is that you end up having to have
是你最终不得不

128
00:07:37,050 --> 00:07:41,720
to find cycles that are of a negative weight,
寻找负重量的自行车， 

129
00:07:41,720 --> 00:07:44,639
because they kind of throw off your shortest path algorithm
因为它们有点像您的最短路径算法

130
00:07:44,839 --> 00:07:49,589
if you were just assuming that shortest path lengths are only
如果您只是假设最短路径长度仅

131
00:07:49,589 --> 00:07:51,179
going to decrease.
会减少。 

132
00:07:51,180 --> 00:07:55,459
But when you have negative weights, you might take a step
但是当您的负体重不定时，您可以采取一些措施

133
00:07:55,459 --> 00:07:57,899
and the overall weight might decrease.
并且总重量可能会减少。 

134
00:07:57,899 --> 00:08:01,149
So it's kind of a longer path in terms of the number of edges.
因此，就边缘数量而言，这是一条较长的路径。 

135
00:08:01,149 --> 00:08:02,599
But the weight is smaller.
但是重量更小。 

136
00:08:02,600 --> 00:08:05,970
And that kind of makes the algorithm more complicated.
这样会使算法更加复杂。 

137
00:08:05,970 --> 00:08:07,362
And it has to do more work.
它必须做更多的工作。 

138
00:08:07,362 --> 00:08:09,620
So that's really why there's a difference between these two
所以这就是为什么这两者之间会有区别的原因

139
00:08:09,819 --> 00:08:10,759
complexities.
复杂性。 

140
00:08:10,759 --> 00:08:14,199
And I guarantee you, you'll understand this much better
我向您保证，您会更好地理解这一点

141
00:08:14,199 --> 00:08:16,699
after we're done with the lectures on Dijkstra
在完成关于迪克斯特拉的讲座之后

142
00:08:16,699 --> 00:08:20,019
and the lectures on Bellman-Ford.
以及关于贝尔曼福特的讲座。 

143
00:08:20,019 --> 00:08:21,560
So that's the set up for the problem.
这就是解决问题的方法。 

144
00:08:21,560 --> 00:08:23,829
That's what we're going to be looking at.
这就是我们要研究的内容。 

145
00:08:24,029 --> 00:08:27,829
Let's look at a couple more definitions
让我们再看几个定义

146
00:08:27,829 --> 00:08:34,548
beyond what I have here with respect to just the notation.
超出了我在此处仅涉及的符号。 

147
00:08:34,548 --> 00:08:46,882
And you can think of path p as a sequence of vertices-- V0, V1,
您可以将路径p视为一个顶点序列-V0，V1， 

148
00:08:46,883 --> 00:08:49,879
et cetera, to Vk.
等，到Vk。 

149
00:08:49,879 --> 00:08:57,649
And this is the path if Vi, Vi plus 1
这是Vi，Vi加1时的路径

150
00:08:57,649 --> 00:09:03,319
belongs to E for 0 less than or equal to i less than
属于E且0小于或等于i小于

151
00:09:03,320 --> 00:09:05,210
or equal to k.
或等于k。 

152
00:09:05,210 --> 00:09:08,089
So a path is a sequence of edges.
因此，路径是一系列边沿。 

153
00:09:08,289 --> 00:09:10,669
And each of those edges has to be in the graph,
每个边都必须在图中

154
00:09:10,669 --> 00:09:15,529
has to be in the set of edges E.
必须在边E的集合中。 

155
00:09:15,529 --> 00:09:20,089
And W of p, which is the weight of the path,
而W，即路径的权重， 

156
00:09:20,090 --> 00:09:22,860
we know that by the weight of edges, those are easy.
我们知道，通过边缘的重量，这些都很容易。 

157
00:09:22,860 --> 00:09:24,970
They're given by the W function.
它们由W函数给出。 

158
00:09:24,970 --> 00:09:27,840
The weight of the path is simply the summation
路径的权重只是总和

159
00:09:27,840 --> 00:09:29,620
of the weights of the edges.
边缘的权重。 

160
00:09:29,620 --> 00:09:33,100



161
00:09:33,100 --> 00:09:33,620
All right.
好吧。 

162
00:09:33,620 --> 00:09:35,610
So fairly obvious definitions.
如此明显的定义。 

163
00:09:35,610 --> 00:09:37,730
But obviously, we have to get these right in order
但是显然，我们必须正确地处理这些问题

164
00:09:37,730 --> 00:09:40,350
to actually solve the problem correctly.
真正正确地解决问题。 

165
00:09:40,350 --> 00:09:43,029



166
00:09:43,029 --> 00:09:49,759
And the shortest path problem is, as you can imagine,
如您所想，最短路径问题是

167
00:09:49,759 --> 00:10:00,049
something that tries to find a path p that has minimum weight.
试图找到具有最小权重的路径p的东西。 

168
00:10:00,049 --> 00:10:03,839
So in general, you have some set up for the problem.
因此，总的来说，您已经为该问题做了一些准备。 

169
00:10:03,840 --> 00:10:07,350
But it comes down to find p with--
但是归结为找到- 

170
00:10:07,350 --> 00:10:13,259



171
00:10:13,259 --> 00:10:16,599
And there are many, many possible paths.
并且有很多很多可能的途径。 

172
00:10:16,599 --> 00:10:18,439
You have to understand that there are potentially
您必须了解潜在的

173
00:10:18,639 --> 00:10:22,081
an exponential number of paths in the graphs
图中路径的指数数量

174
00:10:22,081 --> 00:10:23,039
that we would consider.
我们会考虑的。 

175
00:10:23,039 --> 00:10:26,610
And here's a real simple example where
这是一个真正简单的例子， 

176
00:10:26,610 --> 00:10:33,360
you would have an exponential number of paths.
您将拥有指数级的路径。 

177
00:10:33,360 --> 00:10:38,539
And we'll come back to this example later in the lecture.
我们将在稍后的演讲中回到这个例子。 

178
00:10:38,539 --> 00:10:41,389
But let's assume that all the directions go this way.
但让我们假设所有方向都是这样。 

179
00:10:41,389 --> 00:10:44,049



180
00:10:44,049 --> 00:10:46,500
And it's a directed graph.
这是有向图。 

181
00:10:46,500 --> 00:10:49,245
Well, you could have the path that goes all the way here.
好吧，您可能会一直走到这里。 

182
00:10:49,245 --> 00:10:52,220
But you could have the path that goes on top
但您可能会走上一条路

183
00:10:52,220 --> 00:10:53,700
and all the way this way.
一直这样。 

184
00:10:53,700 --> 00:10:57,509
You have basically two choices on getting to this vertex.
到达该顶点基本上有两种选择。 

185
00:10:57,509 --> 00:10:59,189
Then you've got, given the two ways
然后，有两种方法

186
00:10:59,190 --> 00:11:01,320
you have of getting to this vertex.
你必须要达到这个顶点。 

187
00:11:01,320 --> 00:11:03,580
You've got four ways of getting here.
您有四种到达这里的方式。 

188
00:11:03,580 --> 00:11:06,240
And then, you have eight ways of getting there.
然后，您有八种到达那里的方法。 

189
00:11:06,240 --> 00:11:07,870
So on and so forth.
等等等等。 

190
00:11:07,870 --> 00:11:10,750
So there's an exponential number of paths potentially.
因此，潜在的路径数量呈指数级增长。 

191
00:11:10,750 --> 00:11:12,970
The other thing that's interesting here,
另一个有趣的地方是

192
00:11:12,970 --> 00:11:15,899
which is important in terms of this complexity
就这种复杂性而言，这很重要

193
00:11:15,899 --> 00:11:19,579
is, what's interesting about what you see here
是，你在这里看到的有趣的是

194
00:11:19,580 --> 00:11:23,379
with respect to the complexity and what you see here.
关于复杂性以及您在这里看到的内容。 

195
00:11:23,379 --> 00:11:25,590
Anybody want to point that out?
有人要指出这一点吗？ 

196
00:11:25,590 --> 00:11:30,709
So I have this complexity here and order VE out there.
所以我这里很复杂，在那里订购VE。 

197
00:11:30,909 --> 00:11:34,761
What's an interesting observation
有什么有趣的发现

198
00:11:34,761 --> 00:11:37,094
if you look at this board here and the two complexities?
如果您在这里查看此板以及两个复杂性？ 

199
00:11:37,095 --> 00:11:40,629



200
00:11:40,629 --> 00:11:41,809
Anybody?
有人吗

201
00:11:41,809 --> 00:11:42,579
Yeah, back there.
是的，回到那里。 

202
00:11:42,580 --> 00:11:44,330
AUDIENCE: It's not a function of weight.
听众：这不是体重的函数。 

203
00:11:44,330 --> 00:11:45,690
PROFESSOR: It's not a function of weight.
教授：这不是体重的函数。 

204
00:11:45,690 --> 00:11:46,190
Great.
大。 

205
00:11:46,190 --> 00:11:48,449
That's definitely worth recursion.
绝对值得递归。 

206
00:11:48,649 --> 00:11:50,179
And I'll let you throw this one.
我让你扔这个。 

207
00:11:50,179 --> 00:11:53,120



208
00:11:53,120 --> 00:11:55,990
All the way back there, all right?
一路回到那里，好吗？ 

209
00:11:55,990 --> 00:11:57,899
Right.
对。 

210
00:11:57,899 --> 00:11:58,579
All right, good.
好，好

211
00:11:58,580 --> 00:11:59,537
Good, good.
好好。 

212
00:11:59,537 --> 00:12:00,120
That was good.
那很好。 

213
00:12:00,120 --> 00:12:01,450
That was better than what I could do.
那比我能做的更好。 

214
00:12:01,450 --> 00:12:01,979
No, not really.
不，不是。 

215
00:12:02,179 --> 00:12:09,389
But I would've been right in his hands right there.
但是我会一直在他的手中。 

216
00:12:09,389 --> 00:12:12,939
Anyway, so that's a great observation, actually.
无论如何，实际上这是一个很好的观察。 

217
00:12:12,940 --> 00:12:14,940
And I should have pointed it out right up front.
我应该事先指出这一点。 

218
00:12:14,940 --> 00:12:17,679
But I'm glad I got it out of you.
但是我很高兴我从你那得到了。 

219
00:12:17,879 --> 00:12:22,159
W doesn't exist in the complexity.
 W不存在复杂性。 

220
00:12:22,159 --> 00:12:23,649
This is pretty important.
这很重要。 

221
00:12:23,649 --> 00:12:26,409
W could be a large number.
 W可能很大。 

222
00:12:26,409 --> 00:12:29,029
I mean, it could be 2 raised to 64.
我的意思是，可以将2提高到64。 

223
00:12:29,029 --> 00:12:34,639
The fact is that there's only E square different values
事实是，只有E平方不同的值

224
00:12:34,639 --> 00:12:37,169
possible for a weight, right.
可能的重量吧。 

225
00:12:37,169 --> 00:12:38,729
I mean, roughly speaking.
我的意思是，粗略地说。 

226
00:12:38,730 --> 00:12:41,389
If you have a complete graph, it's a simple graph,
如果您有完整的图形，那是一个简单的图形， 

227
00:12:41,389 --> 00:12:45,159
there's order E square possible weights.
有E阶可能的权重。 

228
00:12:45,159 --> 00:12:49,829
But the range of the weights could be exponential.
但是权重的范围可能是指数的。 

229
00:12:49,830 --> 00:12:54,480
I could have an edge weight of 0.0001
我的边缘权重为0.0001 

230
00:12:54,480 --> 00:12:58,090
and a different edge weight of 10 raised to 98.
然后将另一种边缘权重10提高到98。 

231
00:12:58,090 --> 00:13:01,190
There's nothing that's stopping me
没有什么可以阻止我

232
00:13:01,190 --> 00:13:03,839
from doing that or putting a specification like that.
避免这样做或提出类似的规范。 

233
00:13:04,039 --> 00:13:06,829
But the nice thing about Dijkstra, and Bellman-Ford,
但是关于Dijkstra和Bellman-Ford的好处是， 

234
00:13:06,830 --> 00:13:08,829
and virtually all of the algorithms
几乎所有的算法

235
00:13:09,029 --> 00:13:10,959
that are useful in practice is that they
在实践中有用的是

236
00:13:10,960 --> 00:13:15,450
don't depend on the dynamic range of the weights.
不取决于权重的动态范围。 

237
00:13:15,450 --> 00:13:17,720
And so keep that in mind as you think
因此，请记住您的想法

238
00:13:17,720 --> 00:13:19,421
of shortest path algorithms.
最短路径算法。 

239
00:13:19,621 --> 00:13:22,079
And we'll talk a little bit about this in section tomorrow,
明天我们将在本节中对此进行一些讨论， 

240
00:13:22,080 --> 00:13:26,389
or the TAs will, as to why breadth first search and depth
还是TA会问，为什么要进行广度优先搜索和深度

241
00:13:26,389 --> 00:13:30,379
first search aren't directly applicable to the shortest path
首次搜索不适用于最短路径

242
00:13:30,379 --> 00:13:31,610
problem.
问题。 

243
00:13:31,610 --> 00:13:36,480
And the hint really is the dynamic range of the weights.
提示实际上是权重的动态范围。 

244
00:13:36,480 --> 00:13:37,769
So keep that in mind.
所以记住这一点。 

245
00:13:37,769 --> 00:13:40,970
So a couple things why this is an interesting algorithm,
所以有几件事为什么这是一个有趣的算法， 

246
00:13:40,970 --> 00:13:44,109
or interesting problem to solve, and harder than the problems
或有趣的问题要解决，比问题更难

247
00:13:44,309 --> 00:13:47,069
we've looked at so far like sorting and search,
到目前为止，我们一直在进行排序和搜索， 

248
00:13:47,070 --> 00:13:49,559
is that you have an exponential number of paths.
就是您的路径数是指数的。 

249
00:13:49,759 --> 00:13:51,539
And then the dynamic range of the weights
然后权重的动态范围

250
00:13:51,539 --> 00:13:53,699
can be very, very large.
可以非常非常大。 

251
00:13:53,700 --> 00:13:55,339
And it's not linear by any means.
而且它绝不是线性的。 

252
00:13:55,539 --> 00:13:56,039
All right.
好吧。 

253
00:13:56,039 --> 00:13:59,019
So these algorithms are going to have to have some smarts.
因此，这些算法将必须具有一些智能。 

254
00:13:59,019 --> 00:14:00,809
And the optimal substructure property
以及最佳的子结构属性

255
00:14:00,809 --> 00:14:03,669
that we'll look at towards the end of today's lecture
我们将在今天的演讲快结束时看一下

256
00:14:03,669 --> 00:14:06,069
will give you a sense of how these algorithms actually
让您了解这些算法的实际效果

257
00:14:06,070 --> 00:14:08,980
work in basically linear time.
在基本上线性的时间内工作。 

258
00:14:08,980 --> 00:14:12,109
Or VE, you could think of that as being
或VE，您可能会认为这是

259
00:14:12,309 --> 00:14:17,329
cubic time in terms of the vertices.
以顶点表示的立方时间。 

260
00:14:17,330 --> 00:14:19,329
So keep that in mind.
所以记住这一点。 

261
00:14:19,529 --> 00:14:23,470
Let's talk a little bit more about weighted graphs.
让我们再谈谈加权图。 

262
00:14:23,470 --> 00:14:24,990
I want a little bit more notation.
我想要更多的符号。 

263
00:14:24,990 --> 00:14:31,940



264
00:14:31,940 --> 00:14:37,969
And what I have is V0 using path p to Vk.
我拥有的是使用路径p到Vk的V0。 

265
00:14:38,169 --> 00:14:40,469
So I'm going to write that to say that there's
所以我要写的是说

266
00:14:40,470 --> 00:14:43,609
a particular path of V0 to Vk.
 V0到Vk的特定路径。 

267
00:14:43,809 --> 00:14:48,899
Sometimes I'm searching for the path p with a minimum weight.
有时我正在寻找最小重量的路径p。 

268
00:14:48,899 --> 00:14:51,189
And that's how I'm going to represent that.
这就是我要代表的方式。 

269
00:14:51,190 --> 00:14:56,120
V0, which is a single vertex path,
 V0，这是一个单一的顶点路径， 

270
00:14:56,120 --> 00:15:00,580
is the path from V0 to V0.
是从V0到V0的路径。 

271
00:15:00,580 --> 00:15:03,479
So it's really a 0 length path.
因此，这实际上是长度为0的路径。 

272
00:15:03,679 --> 00:15:07,629
And it has weight 0.
权重为0。 

273
00:15:07,629 --> 00:15:09,409
So that's one condition.
这是一个条件。 

274
00:15:09,409 --> 00:15:12,669
The other condition that we need to look at,
我们需要考虑的另一个条件是

275
00:15:12,669 --> 00:15:18,120
which is the other case, is what if there isn't a path?
否则，如果没有路径怎么办？ 

276
00:15:18,120 --> 00:15:20,820
So I want to put those two things together,
所以我想把这两件事放在一起， 

277
00:15:20,820 --> 00:15:23,610
the two extremes, and of course all of the cases
这两个极端，当然，所有情况

278
00:15:23,610 --> 00:15:29,609
in between, in this definition of the shortest pathway.
在这两者之间，在最短路径的定义中。 

279
00:15:29,809 --> 00:15:33,989
And so I'm going to talk about the shortest path
因此，我将讨论最短的路径

280
00:15:33,990 --> 00:15:38,990
value of the weight of the shortest path between u and v
 u和v之间最短路径的权重值

281
00:15:38,990 --> 00:15:43,610
as delta, u, v. And my goal is to find delta.
 u，v。作为三角洲，我的目标是找到三角洲。 

282
00:15:43,610 --> 00:15:45,359
It's also to find the path.
这也是寻找路径。 

283
00:15:45,559 --> 00:15:48,889
It doesn't help you very much if you
如果您没有太大帮助

284
00:15:48,889 --> 00:15:53,269
know that there's a way of getting from here to Lexington
知道有一种从这里到列克星敦的方式

285
00:15:53,269 --> 00:15:56,829
within 14 miles if you don't know what that path is, right.
如果您不知道那条路在14英里之内，那就对了。 

286
00:15:56,830 --> 00:15:59,690
So that's one aspect of it, which
这是它的一方面， 

287
00:15:59,690 --> 00:16:01,110
is you want to get the weight.
你想减肥吗？ 

288
00:16:01,110 --> 00:16:02,970
But you want to get the path as well.
但是，您也想获得一条路。 

289
00:16:02,970 --> 00:16:06,230
And these algorithms will do that for you.
这些算法将为您做到这一点。 

290
00:16:06,230 --> 00:16:10,149
And in particular, what we want is
特别是我们想要的是

291
00:16:10,149 --> 00:16:24,100
delta u, v to be the minimum over all the paths W p,
在所有路径W p上，delta u，v为最小值， 

292
00:16:24,100 --> 00:16:30,730
such that p is in fact the path from u to v.
这样p实际上就是从u到v的路径。 

293
00:16:30,730 --> 00:16:40,490
And this is the case where if there exists any such path,
在这种情况下，如果存在任何此类路径， 

294
00:16:40,490 --> 00:16:44,919
and the last thing is you want this to be infinity,
最后一件事是你希望这个无限

295
00:16:44,919 --> 00:16:47,184
the weight to be infinity otherwise.
否则权重将为无穷大。 

296
00:16:47,184 --> 00:16:51,289



297
00:16:51,289 --> 00:16:56,490
So if you're only talking about roads going from here to Tokyo,
因此，如果您只是在谈论从这里到东京的道路， 

298
00:16:56,490 --> 00:16:59,539
should have length infinity.
应该具有无限长。 

299
00:16:59,539 --> 00:17:04,098
A little matter of the Pacific Ocean in between.
两者之间有一点太平洋问题。 

300
00:17:04,098 --> 00:17:08,970
So that's the set up in terms of the numbers
这就是数字设置

301
00:17:08,970 --> 00:17:11,039
that we want to see.
我们想要看到的。 

302
00:17:11,039 --> 00:17:13,799
If you're starting from a particular point,
如果您是从某个特定的角度出发， 

303
00:17:13,799 --> 00:17:18,720
you can think of the shortest path length from your source
您可以想到来源中最短的路径长度

304
00:17:18,720 --> 00:17:20,240
as being a 0.
为0。 

305
00:17:20,240 --> 00:17:22,150
Initially, everything is infinity
最初，一切都是无限的

306
00:17:22,150 --> 00:17:24,589
because you haven't found any paths yet.
因为您还没有找到任何路径。 

307
00:17:24,789 --> 00:17:28,450
And what you're going to do is try and reduce these infinities
而您要做的就是尝试减少这些无穷大

308
00:17:28,450 --> 00:17:31,970
down for all of the vertices that
向下的所有顶点

309
00:17:31,970 --> 00:17:34,039
are reachable from the source vertex.
可以从源顶点到达。 

310
00:17:34,039 --> 00:17:37,579
And it's quite possible that you may be given a graph where
而且很可能会给你一张图，其中

311
00:17:37,579 --> 00:17:40,740
a particular vertices, or in your set
特定的顶点，或在您的集合中

312
00:17:40,740 --> 00:17:44,029
V, that can't be reached from the particular source
 V，无法从特定来源获得

313
00:17:44,029 --> 00:17:45,289
that you started with.
是您开始的。 

314
00:17:45,289 --> 00:17:50,649
And for those vertices, you're going to have your delta u,
对于那些顶点，您将拥有自己的增量， 

315
00:17:50,650 --> 00:17:56,650
v. If v is unreachable from you, it will stay at infinity.
 v。如果v无法到达您，它将保持无限。 

316
00:17:56,650 --> 00:17:58,390
So let's look at an example.
因此，让我们看一个例子。 

317
00:17:58,390 --> 00:18:03,710



318
00:18:03,710 --> 00:18:12,980
Let's take-- it's going to be an iterative process here
让我们来-这将是一个迭代过程

319
00:18:12,980 --> 00:18:18,150
of finding the shortest paths.
寻找最短路径。 

320
00:18:18,150 --> 00:18:21,899
And so let's take an example that
因此，让我们举一个例子

321
00:18:22,099 --> 00:18:27,769
corresponds to a fairly complex graph,
对应一个相当复杂的图， 

322
00:18:27,769 --> 00:18:31,329
or at least a nontrivial one, where that's my source vertex.
或至少是一个平凡的，这就是我的原始顶点。 

323
00:18:31,329 --> 00:18:35,419
And I've labeled these other vertices A through F.
我将这些其他顶点标记为A到F。 

324
00:18:35,420 --> 00:18:36,524
And I have a bunch of edges.
而且我有很多优势。 

325
00:18:36,724 --> 00:18:44,779



326
00:18:44,779 --> 00:18:45,279
5.
 5， 

327
00:18:45,279 --> 00:19:06,129



328
00:19:06,130 --> 00:19:07,140
I got one more here.
我又来了一个。 

329
00:19:07,140 --> 00:19:10,230



330
00:19:10,230 --> 00:19:11,640
So that's what's given to me.
这就是给我的。 

331
00:19:11,640 --> 00:19:18,720
And I want to find delta S plugged in for u.
我想找到为您插入的deltaS。 

332
00:19:18,720 --> 00:19:25,390
And A, B, D, et cetera plugged in for V for this graph.
此图的A，B，D等插入了V。 

333
00:19:25,390 --> 00:19:30,649
And let's just do this manually if you will.
如果需要的话，让我们手动进行此操作。 

334
00:19:30,849 --> 00:19:35,110
And just trying to do some kind of breadth first search.
而只是尝试进行某种广度优先搜索。 

335
00:19:35,111 --> 00:19:36,409
And we do know breadth first search.
而且我们知道广度优先搜索。 

336
00:19:36,609 --> 00:19:38,059
We know depth first search.
我们知道深度优先搜索。 

337
00:19:38,059 --> 00:19:45,579
You can imagine trying to use those notions to try and find
您可以想象尝试使用这些概念来尝试找到

338
00:19:45,579 --> 00:19:47,019
the shortest paths here.
最短的路径在这里。 

339
00:19:47,019 --> 00:19:48,828
So now we have to prove afterwards
所以现在我们必须证明

340
00:19:48,828 --> 00:19:51,369
when we are done that these are, in fact, the shortest paths.
当我们完成这些操作时，实际上是最短的路径。 

341
00:19:51,369 --> 00:19:52,719
And that's the hard part of it.
这就是困难的部分。 

342
00:19:52,720 --> 00:19:56,659
But we can certainly try and fill in some numbers associated
但是我们当然可以尝试填写一些相关的数字

343
00:19:56,859 --> 00:19:58,619
with paths that we do know about.
使用我们确实知道的路径。 

344
00:19:58,619 --> 00:20:02,634
So I'm going to say that the numbers that
所以我要说的是

345
00:20:02,634 --> 00:20:08,210
are inside each of these vertices-- d of u
在每个这些顶点内-的d 

346
00:20:08,210 --> 00:20:11,365
is the current weight.
是当前重量。 

347
00:20:11,365 --> 00:20:14,089



348
00:20:14,089 --> 00:20:17,889
And so initially, I'm going to start with D of S being 0,
因此，首先，我将以S的D为0开始， 

349
00:20:17,890 --> 00:20:19,699
because that's a source.
因为那是来源

350
00:20:19,699 --> 00:20:21,240
And all of these other ones are going
所有其他这些都在

351
00:20:21,240 --> 00:20:23,073
to have-- I'm not going to write this down--
有-我不会写下来- 

352
00:20:23,073 --> 00:20:26,940
but they're going to have infinity for their D of Vs.
但他们的D值将无穷大。 

353
00:20:26,940 --> 00:20:28,149
So D of A is infinity.
所以A的D是无穷大。 

354
00:20:28,349 --> 00:20:31,209
Do of B is infinity, et cetera.
 B的Do是无穷大，等等。 

355
00:20:31,210 --> 00:20:34,500
And what I want to do is decrease this D number
我想做的就是减少这个D数

356
00:20:34,500 --> 00:20:38,079
to the point where I'm confident that all of the D numbers
到我有信心所有D数字

357
00:20:38,079 --> 00:20:41,230
that are inside these vertices, these are the current weights,
这些顶点内部的这些是当前的权重， 

358
00:20:41,230 --> 00:20:44,309
or end up being the delta numbers.
或最终成为增量数。 

359
00:20:44,309 --> 00:20:48,519
So my algorithm is done when my d numbers shrink down.
因此，当我的d数减少时，我的算法就完成了。 

360
00:20:48,519 --> 00:20:52,809
And I got the delta values, the correct delta values.
我得到了增量值，正确的增量值。 

361
00:20:52,809 --> 00:20:57,500
But if I wanted to do this, sort of a seat of the pants
但是如果我想这样做，可以坐在裤子上

362
00:20:57,500 --> 00:21:00,920
approach, just go off and try and iteratively
方法，只是去尝试并迭代

363
00:21:00,920 --> 00:21:03,659
reduce these numbers, you say, well, this one was infinity.
减少这些数字，你说，嗯，这是无穷大。 

364
00:21:03,859 --> 00:21:08,689
But clearly, if I start from S and I follow the edges in S,
但是很明显，如果我从S开始并且跟随S的边缘， 

365
00:21:08,690 --> 00:21:11,980
I'm going to be able to mark this as a one.
我将能够将此标记为一个。 

366
00:21:11,980 --> 00:21:15,630
And similarly here, I'm going to be able to mark this as a 2.
同样在这里，我将能够将此标记为2。 

367
00:21:15,630 --> 00:21:19,659
Now, I could arbitrarily pick this one
现在，我可以任意选择

368
00:21:19,859 --> 00:21:23,869
here and this A vertex, and then start
在这里和这个A顶点，然后开始

369
00:21:23,869 --> 00:21:28,089
looking at the edges that emanate from the A vertex.
观察从A顶点发出的边缘。 

370
00:21:28,089 --> 00:21:36,470
And I could go off and mark this as 6, for example.
例如，我可以将其标记为6。 

371
00:21:36,470 --> 00:21:42,380
And if I start from here, I'd mark this as 3.
如果我从这里开始，我将其标记为3。 

372
00:21:42,380 --> 00:21:48,369
Now, is it in fact true that 6 equals
现在，真的等于6 

373
00:21:48,569 --> 00:21:54,669
delta S comma C equals 6?
 delta S逗号C等于6？ 

374
00:21:54,670 --> 00:21:55,899
No.
没有。 

375
00:21:56,099 --> 00:22:00,549
What is in fact-- is there a better way of getting to C?
实际上是什么？有没有更好的方法去C？ 

376
00:22:00,549 --> 00:22:02,779
And what is the weight of that?
重量是多少？ 

377
00:22:02,779 --> 00:22:06,594
What vertex do I have to go through?
我必须经历什么顶点？ 

378
00:22:06,594 --> 00:22:19,180
I mean, one way is to go from S to B to D to C, right?
我的意思是，一种方法是从S到B再到D再到C，对不对？ 

379
00:22:19,180 --> 00:22:21,519
And that would give me 5 right?
那会给我5对吗？ 

380
00:22:21,519 --> 00:22:23,279
So that's 5.
那就是5。 

381
00:22:23,279 --> 00:22:26,529
Can I do better than 5?
我可以做得比5好吗？ 

382
00:22:26,529 --> 00:22:27,769
Not in this graph.
不在此图中。 

383
00:22:27,769 --> 00:22:28,930
OK
好

384
00:22:28,930 --> 00:22:36,680
So it's not the case that the shortest length path gave you
所以不是最短的路径给你

385
00:22:36,680 --> 00:22:40,980
the smallest weight.
最小的重量。 

386
00:22:40,980 --> 00:22:42,599
I mean, that was one example of that.
我的意思是，这就是一个例子。 

387
00:22:42,599 --> 00:22:44,599
And I can go on an and bore you with filling
我可以继续给您带来无聊

388
00:22:44,599 --> 00:22:45,929
in all of these numbers.
在所有这些数字中。 

389
00:22:45,930 --> 00:22:47,980
But you can do that on your own.
但是您可以自己完成。 

390
00:22:47,980 --> 00:22:53,019
And it's really not particularly edifying to do that.
这样做确实没有特别的启发意义。 

391
00:22:53,019 --> 00:22:55,660
But you get a sense of what you need
但是您会了解所需的东西

392
00:22:55,660 --> 00:22:59,430
to be able to do in order to converge on the delta.
为了能够在三角洲上汇合而做。 

393
00:22:59,430 --> 00:23:01,399
And it might take some doing.
这可能需要一些时间。 

394
00:23:01,599 --> 00:23:06,001
Because you have to somehow enumerate in an implicit way--
因为您必须以某种方式隐式枚举- 

395
00:23:06,001 --> 00:23:07,460
you can't do it in an explicit way,
你不能以明确的方式做到这一点， 

396
00:23:07,460 --> 00:23:10,169
because then there'd be an exponential number of paths.
因为那样的话，路径的数量将成倍增长。 

397
00:23:10,369 --> 00:23:12,669
But you'd have to implicitly enumerate
但是您必须隐式枚举

398
00:23:12,670 --> 00:23:16,480
all the different ways that you can possibly get to a vertex
可能到达顶点的所有不同方式

399
00:23:16,480 --> 00:23:21,789
and discover the shortest path through that process,
并找到通过该过程的最短路径， 

400
00:23:21,789 --> 00:23:22,490
all right.
好吧。 

401
00:23:22,490 --> 00:23:25,079
And so we have to be able to do that in these shortest path
因此，我们必须能够在最短的路径上做到这一点

402
00:23:25,079 --> 00:23:26,509
algorithms.
算法。 

403
00:23:26,509 --> 00:23:31,289
And this is a simple graph that has positive weights,
这是一个具有正权重的简单图形， 

404
00:23:31,289 --> 00:23:34,159
non-negative weights with edges.
带边的非负权重。 

405
00:23:34,160 --> 00:23:38,398
It gets more complicated when you have negative weights.
如果负权重会变得更加复杂。 

406
00:23:38,598 --> 00:23:40,639
But before I get to that, there's one other thing
但是在我明白之前，还有另一件事

407
00:23:40,640 --> 00:23:43,490
that I want to talk about here with respect
我想在这里谈论一下

408
00:23:43,490 --> 00:23:46,900
to discovering the actual path.
发现实际路径。 

409
00:23:46,900 --> 00:23:49,734
So what we did here was we had delta u,
所以我们在这里所做的就是我们有了delta u， 

410
00:23:49,934 --> 00:23:55,889
v that corresponded to the weight of the shortest path.
 v对应于最短路径的权重。 

411
00:23:55,890 --> 00:23:59,879
But if you want the path itself, we
但是，如果您想要路径本身，我们

412
00:24:00,079 --> 00:24:04,089
need to have a way of finding the sequence of vertices that
需要有一种方法来找到顶点的序列

413
00:24:04,089 --> 00:24:08,309
corresponds to the minimum weight path.
对应于最小重量路径。 

414
00:24:08,309 --> 00:24:10,240
And in particular, we're going to have
特别是，我们将拥有

415
00:24:10,240 --> 00:24:16,289
to define what we call the predecessor relationship.
定义我们所谓的前身关系。 

416
00:24:16,289 --> 00:24:25,269
And so what I have is d of V is the value
所以我的V的d是值

417
00:24:25,269 --> 00:24:31,230
inside the circle, which is the current weight.
在圆圈内，即当前的重量。 

418
00:24:31,230 --> 00:24:34,890



419
00:24:34,890 --> 00:24:38,400
And as d is something you're very interested in,
由于d是您非常感兴趣的事物， 

420
00:24:38,400 --> 00:24:40,269
eventually you want it to go to delta.
最终，您希望它进入增量。 

421
00:24:40,269 --> 00:24:42,329
The other thing that you're very interested in--
您非常感兴趣的另一件事- 

422
00:24:42,329 --> 00:24:45,949
and this is really a fairly straightforward data structure
这确实是一个相当简单的数据结构

423
00:24:45,950 --> 00:24:50,049
corresponding to just the d number and this predecessor
仅对应于d号和此前任

424
00:24:50,049 --> 00:24:50,909
number.
数。 

425
00:24:50,910 --> 00:25:06,619
And pi of V is the predecessor vertex on the best path to V.
 V的pi是通向V的最佳路径的前任顶点。 

426
00:25:06,819 --> 00:25:10,069
And you said, pi of S equals NIL.
您说过，S的pi等于NIL。 

427
00:25:10,069 --> 00:25:13,490



428
00:25:13,490 --> 00:25:15,950
And then you can think of this as this is eventually
然后您可以考虑一下，因为这最终

429
00:25:15,950 --> 00:25:20,399
what we want, and this gets modified as well.
我们想要的东西，它也会被修改。 

430
00:25:20,599 --> 00:25:24,719
So right now, when you're working and trying
所以现在，当您工作和尝试时

431
00:25:24,720 --> 00:25:27,319
to find the path, you have some particular path
找到路径，您有一些特定的路径

432
00:25:27,319 --> 00:25:29,500
that happens to be the current best path.
恰好是当前的最佳途径。 

433
00:25:29,500 --> 00:25:31,930
And that's a sequence of vertices
那是一系列的顶点

434
00:25:31,930 --> 00:25:34,549
that you can get by following the predecessors.
您可以通过跟随前辈获得。 

435
00:25:34,549 --> 00:25:40,250
So once you're at a particular vertex E, you say all right,
因此，一旦到达特定的顶点E，就可以说了， 

436
00:25:40,250 --> 00:25:46,700
right now I can look at pi of E. And if that points me to C,
现在，我可以查看E的pi。如果这将我指向C， 

437
00:25:46,700 --> 00:25:49,190
then that's good.
那很好。 

438
00:25:49,190 --> 00:25:52,240
I'm going to look at pi of C. And that might point me
我要看C的pi。这可能会指出我

439
00:25:52,240 --> 00:25:54,319
to A, and so on and so forth.
到A，依此类推。 

440
00:25:54,319 --> 00:25:57,559
In this particular instance, pi of E
在此特定情况下，E的pi 

441
00:25:57,559 --> 00:26:02,470
is going to, when you're finally done, is going to point to A.
当您最终完成操作时，将指向A。 

442
00:26:02,470 --> 00:26:06,150
And pi of A is going to point to S, all right, because that's
 A的pi将指向S，好的，因为那是

443
00:26:06,150 --> 00:26:10,009
the path that is the best path is this one.
最好的路径就是这一条。 

444
00:26:10,009 --> 00:26:12,660
Like so and like that.
像这样。 

445
00:26:12,660 --> 00:26:14,380
And so those are the two data structures
这就是两个数据结构

446
00:26:14,380 --> 00:26:18,200
you need to keep in mind that you need to iterate on,
您需要记住，您需要进行迭代， 

447
00:26:18,200 --> 00:26:24,970
this predecessor relationship and the current distance.
这个先前的关系和当前距离。 

448
00:26:24,970 --> 00:26:29,339
And then this ends up being delta.
然后这最终成为增量。 

449
00:26:29,339 --> 00:26:31,369
You're done.
你完成了。 

450
00:26:31,369 --> 00:26:33,400
And at that point, your predecessor relationship
到那时，您的前任关系

451
00:26:33,401 --> 00:26:33,900
is correct.
是正确的。 

452
00:26:33,900 --> 00:26:37,140



453
00:26:37,140 --> 00:26:39,842
So that's the set up.
这就是设置。 

454
00:26:39,842 --> 00:26:41,599
The last complication I want to talk about here
我想在这里谈论的最后一个并发症

455
00:26:41,799 --> 00:26:44,283
is negative weights.
是负重量。 

456
00:26:44,284 --> 00:26:46,450
And it's, I think, appropriate to talk about it when
我认为应该在什么时候谈论它

457
00:26:46,450 --> 00:26:48,169
we have Bellman-Ford up here.
我们在这里有贝尔曼福特。 

458
00:26:48,369 --> 00:26:53,466



459
00:26:53,467 --> 00:26:54,849
Which is really the general algorithm.
这实际上是通用算法。 

460
00:26:55,049 --> 00:27:00,409



461
00:27:00,410 --> 00:27:09,190
So let's talk about-- so the first question is why.
因此，让我们谈谈-所以第一个问题是为什么。 

462
00:27:09,190 --> 00:27:11,779
Why do these things exist, other than making
为什么这些东西存在，除了使

463
00:27:11,779 --> 00:27:14,379
our lives more difficult?
我们的生活更艰难？ 

464
00:27:14,380 --> 00:27:15,579
So give me an example.
所以举个例子。 

465
00:27:15,779 --> 00:27:18,855
What is the motivation for a graph with negative weights?
负权图的动机是什么？ 

466
00:27:18,855 --> 00:27:22,329



467
00:27:22,329 --> 00:27:23,990
I mean, I really would like to know.
我的意思是，我真的很想知道。 

468
00:27:23,990 --> 00:27:26,450
The best motivation is definitely worth recursion.
最好的动机绝对值得递归。 

469
00:27:26,450 --> 00:27:28,980
Then I can use it next time.
那我下次可以用

470
00:27:28,980 --> 00:27:29,863
Yeah, go ahead.
是的，继续。 

471
00:27:29,863 --> 00:27:35,286
AUDIENCE: I'm just thinking like if your goal,
听众：我只是在想，如果你的目标， 

472
00:27:35,286 --> 00:27:37,258
if your goal [INAUDIBLE].
如果您的目标是[听不清]。 

473
00:27:37,258 --> 00:27:40,709



474
00:27:40,709 --> 00:27:42,188
And some of them cost too much.
其中一些成本太高。 

475
00:27:42,188 --> 00:27:45,392
Some of them get you money, and you
他们中有些人赚钱，而你

476
00:27:45,392 --> 00:27:48,889
want to know what-- you're trying to find [INAUDIBLE].
想知道是什么-您正在尝试找到[音频不清晰]。 

477
00:27:49,089 --> 00:27:55,499



478
00:27:55,499 --> 00:27:56,284
PROFESSOR: Sure.
教授：当然可以。 

479
00:27:56,484 --> 00:27:58,464
Yeah, I mean, I think that's a good motivation.
是的，我的意思是，我认为这是一个很好的动机。 

480
00:27:58,464 --> 00:28:02,750



481
00:28:02,750 --> 00:28:04,980
I think driving, when you think about distances
当您考虑距离时，我认为驾驶

482
00:28:04,980 --> 00:28:07,529
and so on, there's no notion of a negative distance,
依此类推，没有负距离的概念， 

483
00:28:07,529 --> 00:28:09,819
at least physically.
至少在身体上。 

484
00:28:09,819 --> 00:28:13,652
But you can imagine that you could have a case where you're
但您可以想象，您可能会遇到

485
00:28:13,652 --> 00:28:14,909
getting paid to drive or something,
得到开车或其他东西的报酬， 

486
00:28:15,109 --> 00:28:18,324
or it costs you to drive, and that would be one.
否则开车就要花钱，那将是一个。 

487
00:28:18,325 --> 00:28:18,950
Yeah, go ahead.
是的，继续。 

488
00:28:18,950 --> 00:28:20,365
AUDIENCE: It sounds like Monopoly.
听众：听起来像是垄断。 

489
00:28:20,365 --> 00:28:24,013
So the vertices are supposed to be [INAUDIBLE].
因此，顶点应该是[听不清]。 

490
00:28:24,013 --> 00:28:25,679
PROFESSOR: Oh, if you land on something,
教授：哦，如果你降落在某个地方， 

491
00:28:25,680 --> 00:28:26,369
you have to pay rent.
你得付房租

492
00:28:26,569 --> 00:28:28,059
Or sometimes you land on something
有时你落在某物上

493
00:28:28,059 --> 00:28:29,009
and you actually get money.
你实际上就赚钱了

494
00:28:29,009 --> 00:28:29,925
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

495
00:28:29,925 --> 00:28:32,791



496
00:28:32,791 --> 00:28:34,750
PROFESSOR: Takes you forward, backwards, right.
教授：带您前进，后退，正确。 

497
00:28:34,750 --> 00:28:35,458
Yeah go ahead.
是的，继续吧。 

498
00:28:35,458 --> 00:28:36,374
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

499
00:28:36,374 --> 00:28:43,710



500
00:28:43,710 --> 00:28:46,670
PROFESSOR: So that is such an interesting notion.
教授：这是一个很有趣的概念。 

501
00:28:46,670 --> 00:28:49,230
Sometimes you may want to go.
有时您可能想去。 

502
00:28:49,230 --> 00:28:52,079
And maybe in this case, you're saying
也许在这种情况下，你是说

503
00:28:52,079 --> 00:28:55,490
it's better to take your distance metric
最好采用距离度量

504
00:28:55,490 --> 00:28:59,940
and go further away in order to get the best way of getting
并走得更远以获得最佳的获取方式

505
00:28:59,940 --> 00:29:01,190
there, or something like that.
在那里，或者类似的东西。 

506
00:29:01,190 --> 00:29:02,105
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

507
00:29:02,105 --> 00:29:08,379



508
00:29:08,380 --> 00:29:09,160
PROFESSOR: Right.
教授：对。 

509
00:29:09,160 --> 00:29:09,659
Sure.
当然。 

510
00:29:09,659 --> 00:29:10,089
That'd be good.
那就好

511
00:29:10,289 --> 00:29:10,819
Right.
对。 

512
00:29:10,819 --> 00:29:12,102
Victor, you had your hand up.
维克多，你举起了手。 

513
00:29:12,103 --> 00:29:12,728
AUDIENCE: Yeah.
听众：是的。 

514
00:29:12,728 --> 00:29:15,222
I'm going to give [INAUDIBLE] on the highway,
我要在高速公路上给[听不清]， 

515
00:29:15,222 --> 00:29:18,216
you can't [INAUDIBLE] distances [INAUDIBLE] negative.
您不能[音频不清晰]的距离[音频不清晰]为负。 

516
00:29:18,217 --> 00:29:22,209
Well, if a government uses [INAUDIBLE] police
好吧，如果政府使用[听不清]警察

517
00:29:22,209 --> 00:29:26,201
to regulate traffic, then you might have a negative distance.
来调节流量，那么您可能会有一个负距离。 

518
00:29:26,201 --> 00:29:28,695
Because obviously, you could go a certain way
因为很明显，您可以采取某种方式

519
00:29:28,695 --> 00:29:31,581
minus the [INAUDIBLE].
减去[听不清]。 

520
00:29:31,582 --> 00:29:32,089
PROFESSOR: Right.
教授：对。 

521
00:29:32,289 --> 00:29:35,119
Yeah, that's a good example.
是的，这是一个很好的例子。 

522
00:29:35,119 --> 00:29:37,049
One of the things that we have to think about
我们必须考虑的事情之一

523
00:29:37,049 --> 00:29:39,309
is-- and this is something that might come up,
是-这可能会出现， 

524
00:29:39,309 --> 00:29:43,619
by the way, in a problem set or a quiz-- which is, is there
顺便说一句，在问题集中或测验中

525
00:29:43,619 --> 00:29:48,539
a way of shifting these weights to make them all positive?
一种转移这些权重以使其全部为正的方法？ 

526
00:29:48,539 --> 00:29:52,250
So the examples we've talked about, not clear to me
所以我们刚才讲的例子对我来说还不清楚

527
00:29:52,250 --> 00:29:56,099
that in the particular settings that we talked about
在我们讨论的特定设置中

528
00:29:56,099 --> 00:29:59,129
that you can somehow create the base
您可以以某种方式创建基础

529
00:29:59,130 --> 00:30:02,919
case to be 0 rather than being negative.
情况是0而不是负数。 

530
00:30:03,119 --> 00:30:07,369
So it may not be possible in a particular scenario.
因此，在特定情况下可能是不可能的。 

531
00:30:07,369 --> 00:30:09,629
But if you can do that-- and the reason
但是，如果可以做到的话-原因

532
00:30:09,630 --> 00:30:12,200
I bring this up is if you can do that, suddenly
我想说的是，如果你能做到，突然

533
00:30:12,200 --> 00:30:14,759
instead of using an order V, E algorithm,
而不是使用V，E阶算法， 

534
00:30:14,759 --> 00:30:18,119
if you can prove correctness of the final solution
如果您可以证明最终解决方案的正确性

535
00:30:18,119 --> 00:30:20,629
is exactly what you'd have gotten for the initial problem
这正是您最初遇到的问题

536
00:30:20,630 --> 00:30:23,159
certification, you've gone from an order V, E algorithm
认证，您已经脱离了V，E阶算法

537
00:30:23,359 --> 00:30:24,894
to an order V log V algorithm.
到V阶V log V算法。 

538
00:30:24,894 --> 00:30:26,309
So that's a wonderful thing to do.
所以这是一件很棒的事情。 

539
00:30:26,309 --> 00:30:28,159
So keep that in mind.
所以记住这一点。 

540
00:30:28,160 --> 00:30:30,720
Try and get rid of negative weight edges if you can
如果可以，请尝试消除负的负边缘

541
00:30:30,720 --> 00:30:32,730
without changing the problem certification.
无需更改问题证明。 

542
00:30:32,730 --> 00:30:34,079
I saw a hand back there.
我看到那里有一只手。 

543
00:30:34,079 --> 00:30:35,056
AUDIENCE: Oh, no.
听众：哦，不。 

544
00:30:35,056 --> 00:30:37,008
I thought you were just asking the question,
我以为你只是在问一个问题， 

545
00:30:37,008 --> 00:30:37,783
if we could do that?
如果可以的话？ 

546
00:30:37,983 --> 00:30:41,399
So I was just gettin ready to answer.
所以我只是准备回答。 

547
00:30:41,400 --> 00:30:47,339
PROFESSOR: OK, yeah, so that's something to keep in mind.
教授：是的，所以要记住这一点。 

548
00:30:47,539 --> 00:30:49,955
One example that I think has come up here, which came up,
我认为这里出现了一个例子， 

549
00:30:49,955 --> 00:30:51,329
I think, the last time I lectured
我想，我上一次讲课

550
00:30:51,329 --> 00:30:54,619
was imagine that you're driving and there
想象你在开车

551
00:30:54,619 --> 00:30:56,239
are all these advertisements.
这些都是广告。 

552
00:30:56,240 --> 00:30:58,750
And you get paid to drive on a freeway.
而且您会获得在高速公路上开车的报酬。 

553
00:30:58,750 --> 00:31:00,196
So the reverse toll.
因此，反向收费。 

554
00:31:00,196 --> 00:31:02,529
I mean, it's a reverse toll, because you get to go there
我的意思是，这是反向收费，因为您可以去那里

555
00:31:02,529 --> 00:31:04,940
and you have to see all these ads.
而且您必须看到所有这些广告。 

556
00:31:04,940 --> 00:31:09,200
And then I guess you drive pretty fast through those ads.
然后，我想您可以通过这些广告快速地进行搜索。 

557
00:31:09,200 --> 00:31:11,380
But you have to go through.
但是你必须经历。 

558
00:31:11,380 --> 00:31:14,690
And so you get paid to go through those particular roads.
这样一来，您就可以获得报酬，可以穿越那些特定的道路。 

559
00:31:14,690 --> 00:31:16,809
And then what about social networks?
然后社交网络呢？ 

560
00:31:16,809 --> 00:31:19,549
I mean, there's liking people and disliking people.
我的意思是，有喜欢的人和讨厌的人。 

561
00:31:19,549 --> 00:31:22,037
I mean, that sounds pretty-- that's negative and positive.
我的意思是，这听起来很不错-既消极又积极。 

562
00:31:22,037 --> 00:31:23,669
One could imagine that social networks would
可以想象，社交网络会

563
00:31:23,869 --> 00:31:26,189
have positive weights and negative weights.
具有正权重和负权重。 

564
00:31:26,190 --> 00:31:27,750
I'm surprised one of you-- I mean,
我很惊讶你们中的一个-我的意思是， 

565
00:31:27,750 --> 00:31:29,250
I don't have an account on Facebook.
我在Facebook上没有帐户。 

566
00:31:29,250 --> 00:31:32,240
But presumably, you guys do.
但是大概，你们会的。 

567
00:31:32,240 --> 00:31:36,153
So think of what's the-- yeah, that's right.
因此，请考虑-是的，没错。 

568
00:31:36,153 --> 00:31:37,569
Well, I'm not sure how this works.
好吧，我不确定这是如何工作的。 

569
00:31:37,569 --> 00:31:40,409
But you guys figure it out.
但是你们弄清楚了。 

570
00:31:40,410 --> 00:31:41,240
So why?
所以为什么？ 

571
00:31:41,240 --> 00:31:43,059
Reverse tolls, social networks.
反向收费，社交网络。 

572
00:31:43,059 --> 00:31:47,079



573
00:31:47,079 --> 00:31:47,769
Lots of things.
很多事情。 

574
00:31:47,769 --> 00:31:51,039



575
00:31:51,039 --> 00:31:53,139
Even if you're not convinced by the motivation,
即使您不相信这种动机， 

576
00:31:53,140 --> 00:31:56,388
I will spend a whole lecture talking about Bellman-Ford.
我将在整个演讲中谈论贝尔曼福特。 

577
00:31:56,588 --> 00:31:57,879
So that's just so that's clear.
这样就很清楚了。 

578
00:31:57,880 --> 00:32:00,819



579
00:32:01,019 --> 00:32:04,470
So the issue with the negative weight cycles
所以负循环的问题

580
00:32:04,470 --> 00:32:07,779
is something that is worth spending a minute on.
值得花一分钟的时间。 

581
00:32:07,779 --> 00:32:09,779
And I talked about the fact that you
我谈到了你

582
00:32:09,779 --> 00:32:13,099
had an exponential number of paths.
路径的数量成倍增加。 

583
00:32:13,099 --> 00:32:15,819
And that causes a bit of a problem,
这会引起一些问题， 

584
00:32:15,819 --> 00:32:18,609
even in the case where you have positive weights.
即使您的体重是正数。 

585
00:32:18,609 --> 00:32:20,419
And I will revisit that example.
我将重温该示例。 

586
00:32:20,420 --> 00:32:22,970
But here's an even worse problem that
但这是一个更严重的问题

587
00:32:22,970 --> 00:32:26,954
corresponds to negative cycles.
对应于负周期。 

588
00:32:26,954 --> 00:32:29,448



589
00:32:29,449 --> 00:32:30,990
So eventually, you want to terminate.
所以最终，您想终止。 

590
00:32:30,990 --> 00:32:32,859
The faster you terminate, and if you
您终止的速度越快，如果您

591
00:32:32,859 --> 00:32:35,849
can talk about asymptotic complexity,
可以谈论渐近复杂性， 

592
00:32:35,849 --> 00:32:38,099
obviously that means that you've terminated
显然，这意味着您已经终止了

593
00:32:38,099 --> 00:32:41,159
within a worst case bound of time.
在最坏的时间范围内。 

594
00:32:41,160 --> 00:32:43,680
And if that's exponential, that's bad.
如果那是指数的，那就不好了。 

595
00:32:43,680 --> 00:32:45,039
You'd want it to be small.
您希望它很小。 

596
00:32:45,039 --> 00:32:47,309
But what if you didn't even terminate?
但是，如果您甚至没有终止怎么办？ 

597
00:32:47,309 --> 00:32:52,609
So suppose you have something like this
所以假设你有这样的事情

598
00:32:52,609 --> 00:33:02,399
where you have a graph that has negative weights on some
您的图上有些负权重

599
00:33:02,400 --> 00:33:04,140
of the edges.
的边缘。 

600
00:33:04,140 --> 00:33:05,639
But others are positive.
但是其他人是积极的。 

601
00:33:05,839 --> 00:33:07,024
So this one has a minus 6.
所以这个数字是负6 

602
00:33:07,025 --> 00:33:17,380



603
00:33:17,380 --> 00:33:19,859
I think I got those right.
我想我没错。 

604
00:33:20,059 --> 00:33:26,519
So 2 for minus 6 over here, 3, 2, 1, and minus 2.
所以2代表这里的负6、3、2、1和负2。 

605
00:33:26,519 --> 00:33:28,500
So one thing that you notice from this graph
您从这张图中注意到的一件事

606
00:33:28,500 --> 00:33:33,700
is that you got this annoying cycle here.
是您在这里遇到了这个烦人的周期。 

607
00:33:33,700 --> 00:33:35,710
That's a negative weight cycle.
那是负的体重循环。 

608
00:33:35,710 --> 00:33:38,130
And that's why I've picked this particular example.
这就是为什么我选择了这个特定示例。 

609
00:33:38,130 --> 00:33:39,659
Minus 6 plus 2 is minus 4.
负6加2为负4。 

610
00:33:39,859 --> 00:33:41,909
Minus 4 plus 3 is minus 1.
负4加3为负1。 

611
00:33:41,910 --> 00:33:45,670
So if you had something where you can't depend on the fact
因此，如果您有某些地方无法依靠事实

612
00:33:45,670 --> 00:33:50,669
that the D's are going to keep reducing.
 D将继续减少。 

613
00:33:50,869 --> 00:33:53,119
And that eventually, they'll stop reducing.
最终，它们将停止减少。 

614
00:33:53,119 --> 00:33:53,869
Well, that's true.
好吧，那是真的。 

615
00:33:53,869 --> 00:33:55,285
Eventually, they'll stop reducing.
最终，它们将停止减少。 

616
00:33:55,286 --> 00:33:57,149
Because they're lower bounded by 0
因为它们的下界是0 

617
00:33:57,349 --> 00:34:00,469
when you have positive weight edges or non-negative weight
当您有正负重边缘或非负重时

618
00:34:00,470 --> 00:34:01,289
edges.
边缘。 

619
00:34:01,289 --> 00:34:05,940
But if you have a graph with a negative cycle-- and I mean,
但是，如果您有一个周期为负的图形-我是说， 

620
00:34:05,940 --> 00:34:08,969
this is a recipe for an infinite loop, right--
这是无限循环的秘诀，对吧- 

621
00:34:08,969 --> 00:34:10,980
in your program, potentially a bug.
在您的程序中，可能是一个错误。 

622
00:34:10,980 --> 00:34:14,380
But maybe not even a bug, not a bug in implementation,
但也许不是错误，也不是实施中的错误， 

623
00:34:14,380 --> 00:34:15,750
but a bug in the algorithm.
而是算法中的错误。 

624
00:34:15,750 --> 00:34:19,414
Because this determination condition isn't set properly.
因为此确定条件设置不正确。 

625
00:34:19,414 --> 00:34:20,789
So you can imagine that you would
所以你可以想象你会

626
00:34:20,789 --> 00:34:24,099
get to B and the first time-- whoops,
第一次去B-哎呀， 

627
00:34:24,099 --> 00:34:26,860
I'm missing a weight here.
我在这里没有重量。 

628
00:34:26,860 --> 00:34:32,909
So you get to B. And you say, well, I'm done.
所以您到了B。您说，好，我完成了。 

629
00:34:32,909 --> 00:34:36,739
Delta of SB is 4.
 SB的Delta为4。 

630
00:34:36,739 --> 00:34:37,576
But that's not true.
但这不是事实。 

631
00:34:37,576 --> 00:34:39,659
Because you could get to B. And then you could get
因为你可以到达B。然后你可以到达

632
00:34:39,659 --> 00:34:41,653
back to B with the weight of 3.
以3的重量回到B 

633
00:34:41,853 --> 00:34:44,019
And then you could do it again with the weight of 2,
然后您可以用2的权重再做一次

634
00:34:44,019 --> 00:34:45,539
and so on and so forth.
等等等等。 

635
00:34:45,539 --> 00:34:46,989
So that's a problem.
所以这是一个问题。 

636
00:34:46,989 --> 00:34:49,050
So what would you like an algorithm to do?
那么，您想让算法做什么？ 

637
00:34:49,050 --> 00:34:52,719
What would you like the Bellman-Ford to do here?
您想要贝尔曼福特在这里做什么？ 

638
00:34:52,719 --> 00:34:56,855
It's not the case that all of the delta values,
并非所有的差值都可以

639
00:34:56,855 --> 00:34:58,230
that is the shortest path values,
那是最短的路径值

640
00:34:58,230 --> 00:35:00,210
are undefined for this graph.
此图未定义。 

641
00:35:00,210 --> 00:35:03,409
Some of them are well defined.
其中一些定义明确。 

642
00:35:03,409 --> 00:35:05,440
This one, you can't ever get back to it.
这个，您再也回不来了。 

643
00:35:05,440 --> 00:35:10,039
So clearly, delta S, S is 0.
很明显，增量S，S为0。 

644
00:35:10,039 --> 00:35:12,150
Everybody buy that?
大家都买吗？ 

645
00:35:12,150 --> 00:35:14,610
What about this one?
这个如何？ 

646
00:35:14,610 --> 00:35:16,440
It's 2, right.
是2，对

647
00:35:16,639 --> 00:35:18,599
Delta S, A is 2.
 Delta S，A为2。 

648
00:35:18,599 --> 00:35:21,132



649
00:35:21,132 --> 00:35:23,340
And everybody buys that, because there's just no way.
每个人都买那个，因为那是没有办法的。 

650
00:35:23,340 --> 00:35:25,559
You can't, you don't touch a negative weight cycle.
您不能，您不会碰负的体重循环。 

651
00:35:25,559 --> 00:35:27,750
You, in fact, don't touch a negative weight edge.
实际上，您不要碰负重边缘。 

652
00:35:27,750 --> 00:35:31,400
But more importantly, you don't touch a negative weight cycle
但更重要的是，您不会碰到负的体重循环

653
00:35:31,400 --> 00:35:32,829
in order to get to A. And there's
为了到达A。 

654
00:35:32,829 --> 00:35:34,960
no way of touching that.
无法触及。 

655
00:35:34,960 --> 00:35:38,769
On the other hand, anything that's in here
另一方面，这里的任何东西

656
00:35:38,969 --> 00:35:40,869
you could run many times.
您可以运行很多次。 

657
00:35:40,869 --> 00:35:44,429
And you could end up with whatever weight you wanted.
您最终可能会承受所需的重量。 

658
00:35:44,429 --> 00:35:46,940
There'd be a minus infinity weight.
负无穷大。 

659
00:35:46,940 --> 00:35:48,679
So what you want an algorithm that
所以你想要一个算法

660
00:35:48,679 --> 00:35:51,769
handles in particular negative cycles,
处理特别不利的周期， 

661
00:35:51,769 --> 00:35:53,400
which are the hard part here.
这是这里的难点。 

662
00:35:53,400 --> 00:35:55,590
Negative weights aren't the hard part
负权重并非难事

663
00:35:55,590 --> 00:35:58,960
if you can't run through these edges more than once.
如果您不能多次穿越这些边缘。 

664
00:35:58,960 --> 00:36:01,449
It's actually the negative cycles that are hard.
实际上，负面循环很难。 

665
00:36:01,449 --> 00:36:03,500
And the negative cycles are going
负面循环正在发生

666
00:36:03,500 --> 00:36:08,329
to make shortest path lengths indeterminate, but not
使最短路径长度不确定，但不是

667
00:36:08,329 --> 00:36:12,940
necessarily for every node in the graph,
对于图中的每个节点， 

668
00:36:12,940 --> 00:36:14,800
like this example shows.
如本例所示。 

669
00:36:14,800 --> 00:36:17,400
So what you want your Bellman-Ford algorithm to do,
因此，您希望您的Bellman-Ford算法能够做到， 

670
00:36:17,599 --> 00:36:20,730
or your shortest path algorithm that
或您的最短路径算法

671
00:36:20,730 --> 00:36:23,389
handles negative cycles to do, is
处理负循环要做的是

672
00:36:23,389 --> 00:36:25,809
to finish in reasonable amounts of time.
在合理的时间内完成。 

673
00:36:25,809 --> 00:36:28,929
Order V, E will take and give you
订单V，E将接送您

674
00:36:28,929 --> 00:36:33,539
the delta numbers for all of the vertices
所有顶点的增量数

675
00:36:33,539 --> 00:36:37,289
that actually have finite numbers
实际上有有限的数

676
00:36:37,289 --> 00:36:39,150
and then mark all of these other vertices
然后标记所有其他这些顶点

677
00:36:39,150 --> 00:36:43,139
as being indeterminate, or essentially minus infinity.
是不确定的，或者本质上是无穷大。 

678
00:36:43,139 --> 00:36:43,719
OK
好

679
00:36:43,719 --> 00:36:45,559
So that's your termination condition.
这就是您的终止条件。 

680
00:36:45,559 --> 00:36:47,769
It's different from the termination condition
与终止条件不同

681
00:36:47,769 --> 00:36:50,920
if you simply had non-negative edge weights.
如果您只是具有非负边缘权重。 

682
00:36:50,920 --> 00:36:51,889
All right.
好吧。 

683
00:36:51,889 --> 00:36:55,750
So remember, it's cycles that cause a problem, not just
所以请记住，导致问题的是周期，而不仅仅是

684
00:36:55,750 --> 00:36:57,230
the edges.
边缘。 

685
00:36:57,230 --> 00:37:00,250
And you have to do something about the cycles.
而且您必须对周期进行一些处理。 

686
00:37:00,250 --> 00:37:03,210
But they may not affect the entire part of the computation.
但是它们可能不会影响整个计算过程。 

687
00:37:03,210 --> 00:37:06,889
So if you don't know that you have a cycle or not,
因此，如果您不知道自己是否有周期， 

688
00:37:06,889 --> 00:37:12,179
then you end up with having to use Bellman-Ford.
然后您最终不得不使用Bellman-Ford。 

689
00:37:12,179 --> 00:37:14,750
And so that also tells you something which is interesting,
这样也可以告诉您一些有趣的事情， 

690
00:37:14,750 --> 00:37:18,400
which is Bellman-Ford has to detect negative cycles.
 Bellman-Ford必须检测到负周期。 

691
00:37:18,400 --> 00:37:20,880
If Bellman-Ford couldn't detect negative cycles,
如果Bellman-Ford无法检测到负周期， 

692
00:37:20,880 --> 00:37:23,309
then how could it possibly be a correct algorithm
那怎么可能是正确的算法

693
00:37:23,309 --> 00:37:25,090
for the arbitrary case?
对于任意情况？ 

694
00:37:25,090 --> 00:37:27,380
So Dijkstra doesn't have to do that.
因此，Dijkstra不必这样做。 

695
00:37:27,380 --> 00:37:29,250
And that's why Dijkstra is simpler.
这就是Dijkstra更简单的原因。 

696
00:37:29,449 --> 00:37:30,719
All right.
好吧。 

697
00:37:30,719 --> 00:37:36,819
So let me talk about the general structure of shortest path
所以让我说说最短路径的一般结构

698
00:37:36,820 --> 00:37:37,400
algorithms.
算法。 

699
00:37:37,599 --> 00:37:42,750
And the 2 important notions that I want to talk about here
我想在这里谈论的两个重要概念

700
00:37:42,750 --> 00:37:49,030
are the notion of relaxation, which we sort of did already
是放松的概念，我们已经做了放松

701
00:37:49,030 --> 00:37:51,590
when we ran through this example.
当我们通过这个例子。 

702
00:37:51,590 --> 00:37:53,460
But I need to formalize that.
但是我需要对此进行形式化。 

703
00:37:53,460 --> 00:37:59,465
And then we'll go back and revisit this exponential graph
然后，我们将返回并重新查看该指数图

704
00:37:59,465 --> 00:37:59,965
example.
例。 

705
00:37:59,965 --> 00:38:03,980



706
00:38:03,980 --> 00:38:06,650
So the general structural of shortest path algorithms
所以最短路径算法的一般结构

707
00:38:06,650 --> 00:38:09,260
are as follows.
如下面所述。 

708
00:38:09,260 --> 00:38:16,269
We're going to initialize for all u belonging to the vertex
我们将初始化所有属于顶点的u 

709
00:38:16,469 --> 00:38:20,379
set, we set d v to be infinity.
设置，我们将dv设置为无穷大。 

710
00:38:20,380 --> 00:38:26,260
And we set the predecessor to be NIL.
我们将前身设置为NIL。 

711
00:38:26,260 --> 00:38:31,650
And then we'll set d of S to be 0.
然后将S的d设置为0。 

712
00:38:31,650 --> 00:38:33,400
We're talking about a single source, here.
我们在这里谈论的是单一来源。 

713
00:38:33,400 --> 00:38:35,800
We'll set that to be 0.
我们将其设置为0。 

714
00:38:35,800 --> 00:38:39,539
And what we're going to do is essentially repeat.
我们要做的基本上是重复。 

715
00:38:39,739 --> 00:38:45,109



716
00:38:45,110 --> 00:38:54,039
Select some edge u comma v. And I'm not specifying how.
选择一些用逗号隔开的边缘。我没有指定具体方法。 

717
00:38:54,239 --> 00:38:56,559
This is going to result in a different algorithm
这将导致不同的算法

718
00:38:56,559 --> 00:38:58,639
depending on the specifics of how.
取决于具体的方式。 

719
00:38:58,639 --> 00:39:07,429
But the important notion is that we're going to relax edge u,
但是重要的一点是，我们将放松您的优势， 

720
00:39:07,429 --> 00:39:11,980
v. And what the notion of relaxation is
 v。放松的概念是什么

721
00:39:11,980 --> 00:39:14,139
is that you're going to look at it.
是你要去看它。 

722
00:39:14,139 --> 00:39:21,879
And you'll say, well, if d of v is greater than d of u
你会说，好吧，如果v的d大于u的d 

723
00:39:21,880 --> 00:39:29,000
plus w u, v, then I've discovered a better
再加上吴，五，然后我发现了一个更好的

724
00:39:29,000 --> 00:39:33,639
way of getting to v then I currently know.
到v的方式，我目前知道。 

725
00:39:33,639 --> 00:39:36,099
So d of v would currently be infinity,
所以v的d当前为无穷大， 

726
00:39:36,099 --> 00:39:39,019
which means I haven't found a way of getting to v yet.
这意味着我还没有找到上v的方法。 

727
00:39:39,019 --> 00:39:43,110
But I know that d of u, for example, is a finite number.
但是我知道u的d是一个有限数。 

728
00:39:43,110 --> 00:39:45,840
And I do know that this edge exists from u to v, which
而且我知道从u到v都存在该边， 

729
00:39:45,840 --> 00:39:48,710
means that I can update the value of d of v.
表示我可以更新v的d值。 

730
00:39:48,909 --> 00:39:53,549
And that's what we call relaxation of the edge u, v.
这就是所谓的边u，v的松弛。 

731
00:39:53,550 --> 00:39:57,710
And so what you do here is if the if is true,
因此，如果if为真，那么您在这里要做的是， 

732
00:39:57,710 --> 00:40:05,769
then you set d, v to be d, u plus w u, v.
然后将d，v设置为d，u加wu，v。 

733
00:40:05,769 --> 00:40:09,570
And you'll also update the predecessor relationship,
而且您还将更新先前的关系， 

734
00:40:09,570 --> 00:40:16,230
because the current best predecessor for v
因为目前v最好的前身

735
00:40:16,429 --> 00:40:17,826
is going to be u.
将会是你。 

736
00:40:17,826 --> 00:40:20,900
So that's the notion of relaxation.
这就是放松的概念。 

737
00:40:20,900 --> 00:40:23,880
And I kind of ran out of room here.
我有点在这里没房间了。 

738
00:40:23,880 --> 00:40:26,730
But you keep doing this.
但是你继续这样做。 

739
00:40:26,929 --> 00:40:28,009
This repeat.
重复一遍。 

740
00:40:28,010 --> 00:40:30,525
So what is the repeat?
那么重复的是什么呢？ 

741
00:40:30,525 --> 00:40:42,110
Well, the repeat is until all edges
好吧，重复直到所有边缘

742
00:40:42,110 --> 00:40:56,860
have d of v less than or equal to d of u plus w u, v.
 v的d小于或等于u加wu的d，v。 

743
00:40:56,860 --> 00:41:01,940
And the assumption here is that you have no negative cycles.
并且这里的假设是您没有负周期。 

744
00:41:01,940 --> 00:41:05,019
We need a different structure.
我们需要一个不同的结构。 

745
00:41:05,019 --> 00:41:07,840
The notion of relaxation is still going to be relevant.
放松的概念仍然有意义。 

746
00:41:07,840 --> 00:41:11,650
But don't think of this structure
但是不要认为这种结构

747
00:41:11,650 --> 00:41:14,940
as being the structure that Bellman-Ford uses,
作为Bellman-Ford使用的结构， 

748
00:41:14,940 --> 00:41:19,579
or algorithms that can handle negative cycles use.
或可以处理负面循环的算法。 

749
00:41:19,579 --> 00:41:23,369
So hopefully, you got the notion of relaxation,
因此，希望您有了放松的想法， 

750
00:41:23,369 --> 00:41:26,579
which is from a pictorial standpoint,
从绘画的角度来看， 

751
00:41:26,579 --> 00:41:29,420
it's simply something that we did
这只是我们所做的

752
00:41:29,420 --> 00:41:35,150
when we looked at updating the value of 6 to 5, for example.
例如，当我们查看将值更新为6时。 

753
00:41:35,150 --> 00:41:39,840
So we said through this process, if I
所以我们说通过这个过程，如果我

754
00:41:39,840 --> 00:41:42,769
relax this particular edge and d was already set up--
放宽这个特定的边缘，并且d已经设置好- 

755
00:41:42,969 --> 00:41:47,230
let's say d, the vertex here had 3.
假设d，此处的顶点为3。 

756
00:41:47,230 --> 00:41:49,449
And this was originally 6.
这原来是6。 

757
00:41:49,449 --> 00:41:53,619
And I look at it and I say, D of C is 6.
我看着它说，C的D是6 

758
00:41:53,619 --> 00:41:58,529
On other hand, 6 is greater than d
另一方面，6大于d 

759
00:41:58,530 --> 00:42:02,860
of the vertex D, which happens to be 3 plus 2.
顶点D的3，恰好是3加2。 

760
00:42:03,059 --> 00:42:06,369
And since 5 is less than 6, I can relax this edge
由于5小于6，所以我可以放宽这个优势

761
00:42:06,369 --> 00:42:09,609
and update the value of 6 to 5.
并将值更新为6。 

762
00:42:09,610 --> 00:42:12,690
And then I update the predecessor relationship
然后我更新前任关系

763
00:42:12,690 --> 00:42:18,300
to have a pi of C to be D. That's
具有C的pi为D。 

764
00:42:18,300 --> 00:42:19,460
the notion of relaxation.
放松的概念。 

765
00:42:19,460 --> 00:42:20,610
Fundamental notion.
基本概念。 

766
00:42:20,610 --> 00:42:24,860
Going to use it in every algorithm that we talk about.
将在我们讨论的每种算法中使用它。 

767
00:42:24,860 --> 00:42:26,530
When do you stop?
你什么时候停下来

768
00:42:26,530 --> 00:42:28,480
Well, when you don't have negative cycles,
好吧，当你没有负面循环时， 

769
00:42:28,480 --> 00:42:32,539
there's a fairly clean termination condition,
有一个相当干净的终止条件， 

770
00:42:32,739 --> 00:42:35,939
which says that you can't relax any of the edges any more.
这表示您无法再放松任何边缘。 

771
00:42:35,940 --> 00:42:39,039
OK You get to the point where you
好吧，你到了你的地步

772
00:42:39,039 --> 00:42:41,429
have values that are associated with each
具有与每个关联的值

773
00:42:41,429 --> 00:42:43,169
of these vertices inside.
里面的这些顶点。 

774
00:42:43,170 --> 00:42:45,150
And it doesn't matter what edge you pick,
无论您选择什么优势， 

775
00:42:45,150 --> 00:42:47,579
you can't improve them.
你无法改善他们。 

776
00:42:47,579 --> 00:42:50,819
So this termination condition, it
所以这个终止条件

777
00:42:50,820 --> 00:42:54,271
could involve an order E check.
可能涉及订单E支票。 

778
00:42:54,271 --> 00:42:55,769
So we're not talking complexity here
所以我们这里不谈论复杂性

779
00:42:55,769 --> 00:42:59,190
yet in terms of being efficient.
但就效率而言。 

780
00:42:59,190 --> 00:43:03,039
But you can imagine when I say until all edges cannot be
但是你可以想象，当我说直到所有边缘都无法

781
00:43:03,039 --> 00:43:05,719
relaxed, that you'd have to look at all the edges.
放松一下，那你就得看所有的边缘。 

782
00:43:05,719 --> 00:43:07,739
And if any one of them can be relaxed,
如果其中任何一个可以放松， 

783
00:43:07,739 --> 00:43:11,479
it's possible that another one can now be relaxed.
现在有可能另一个人可以放松。 

784
00:43:11,480 --> 00:43:13,800
So you've got to keep going until you get to the point
因此，您必须继续前进，直到达到重点为止

785
00:43:13,800 --> 00:43:17,610
where none of the edges can be relaxed.
边缘无法放松的地方。 

786
00:43:17,610 --> 00:43:20,039
So this is a brute force algorithm.
因此，这是一种蛮力算法。 

787
00:43:20,039 --> 00:43:21,420
And it'll work.
而且会起作用。 

788
00:43:21,420 --> 00:43:23,519
It'll just be slow.
只会很慢。 

789
00:43:23,719 --> 00:43:26,109
It'll work for known negative cycles.
它适用于已知的负周期。 

790
00:43:26,110 --> 00:43:29,289
And if you just kind of randomly select these edges
如果您只是随机选择这些边缘

791
00:43:29,289 --> 00:43:31,340
and just keep going, I'll give you
继续前进，我给你

792
00:43:31,340 --> 00:43:36,880
an example where it works pretty badly in a minute.
一个例子，它在一分钟内效果很差。 

793
00:43:36,880 --> 00:43:38,340
But this is an algorithm.
但这是一种算法。 

794
00:43:38,340 --> 00:43:40,030
So I guess I lied when I said we weren't
所以我想我说我们不是在撒谎

795
00:43:40,030 --> 00:43:42,269
going to give you an algorithm.
给你一个算法

796
00:43:42,269 --> 00:43:43,150
It is an algorithm.
这是一种算法。 

797
00:43:43,150 --> 00:43:47,150
It's just an algorithm that you never want to implement.
这只是您永远不想实现的算法。 

798
00:43:47,150 --> 00:43:49,940
You do want to implement the relaxation condition.
您确实要实现松弛条件。 

799
00:43:49,940 --> 00:43:55,130
But not this random way of selecting edges and having
但不是这种随机选择边的方式

800
00:43:55,130 --> 00:43:58,269
this termination condition that, in of itself,
这种终止条件本身就是

801
00:43:58,469 --> 00:44:01,769
is an order E check.
是订单E支票。 

802
00:44:01,769 --> 00:44:03,489
And one of the reasons why you don't
而你不这样做的原因之一

803
00:44:03,489 --> 00:44:06,079
want to implement this algorithm is coming up shortly
要实现此算法不久

804
00:44:06,079 --> 00:44:08,710
in our exponential graph example.
在我们的指数图示例中。 

805
00:44:08,710 --> 00:44:12,530
But let me make sure that people aren't bored.
但是让我确保人们不会感到无聊。 

806
00:44:12,530 --> 00:44:14,840
Any questions about the general structure,
有关总体结构的任何疑问， 

807
00:44:15,039 --> 00:44:18,155
relaxation, anything?
放松，什么？ 

808
00:44:18,155 --> 00:44:19,869
Are we good?
好吗

809
00:44:19,869 --> 00:44:20,549
OK.
好。 

810
00:44:20,550 --> 00:44:24,050
So you guys, I walk away from lecture thinking
你们，我放弃了演讲的思考

811
00:44:24,050 --> 00:44:26,320
I've given this spectacular lecture and everybody
我给了这场壮观的演讲，大家

812
00:44:26,320 --> 00:44:27,170
understands.
了解。 

813
00:44:27,170 --> 00:44:29,320
And then Victor tells me when he shows up
然后维克多告诉我他何时出现

814
00:44:29,320 --> 00:44:32,260
in section in the morning, he says
在早上的部分中，他说

815
00:44:32,260 --> 00:44:34,050
did people understand graphs?
人们了解图表吗？ 

816
00:44:34,050 --> 00:44:36,130
And everyone says no.
每个人都说不。 

817
00:44:36,130 --> 00:44:37,809
Or did people understand x?
还是人们了解x？ 

818
00:44:37,809 --> 00:44:38,849
And people say no.
人们说不。 

819
00:44:38,849 --> 00:44:43,460
So at least tomorrow, tell Victor that you understood.
所以至少到明天，告诉Victor你明白了。 

820
00:44:43,460 --> 00:44:45,840
Whether you did or not.
不管你做与否。 

821
00:44:45,840 --> 00:44:47,090
So then I feel better.
所以我感觉好多了。 

822
00:44:47,090 --> 00:44:49,574
AUDIENCE: That's going to make my life real easy.
听众：这将使我的生活变得轻松。 

823
00:44:49,773 --> 00:44:51,679
PROFESSOR: Yeah, right.
教授：是的，对。 

824
00:44:51,679 --> 00:44:53,029
So good.
这么好。 

825
00:44:53,030 --> 00:44:55,340
Well, you probably like hearing stuff from Victor
好吧，您可能喜欢听Victor讲的东西

826
00:44:55,539 --> 00:44:56,469
better than me anyway.
反正比我更好。 

827
00:44:56,469 --> 00:44:59,099
That's the secret here, right?
这就是这里的秘密吧？ 

828
00:44:59,099 --> 00:45:02,769



829
00:45:02,769 --> 00:45:05,009
All right, so one of the reasons why
好吧，所以原因之一

830
00:45:05,010 --> 00:45:09,380
you don't want to implement this algorithm
你不想实现这个算法

831
00:45:09,380 --> 00:45:12,849
is precisely this example that I put up.
正是我提出的这个例子。 

832
00:45:12,849 --> 00:45:16,119
And this is a really neat example that I like a lot,
这是我非常喜欢的一个很好的例子， 

833
00:45:16,119 --> 00:45:20,539
because it points out two different things.
因为它指出了两个不同的东西。 

834
00:45:20,539 --> 00:45:24,670
It points out that exponential number
指出那个指数数

835
00:45:24,670 --> 00:45:27,840
of paths, an exponential number of paths in a graph,
路径数，图中的指数路径数， 

836
00:45:27,840 --> 00:45:29,864
could cause a problem with this algorithm.
可能会导致此算法出现问题。 

837
00:45:29,864 --> 00:45:31,280
The other thing that it points out
它指出的另一件事

838
00:45:31,280 --> 00:45:35,590
is that we got issues with the weights of edges.
是我们在边缘权重方面遇到了问题。 

839
00:45:35,590 --> 00:45:39,480
One of the nice observations one of you made earlier on
你们中的一个不错的观察之一

840
00:45:39,480 --> 00:45:42,559
is that we had these neat algorithms that did not
是我们有这些整洁的算法

841
00:45:42,559 --> 00:45:45,759
depend on the dynamic range of the weights.
取决于权重的动态范围。 

842
00:45:45,760 --> 00:45:48,480
So let's just say that I in fact had
所以让我们说我实际上有

843
00:45:48,480 --> 00:45:50,969
an exponential range for the weights.
权重的指数范围。 

844
00:45:50,969 --> 00:45:55,219
I know 4 isn't exponential, but at some level,
我知道4不是指数的，但在某种程度上， 

845
00:45:55,219 --> 00:45:57,500
you could imagine that it's exponentially
您可以想象它成指数增长

846
00:45:57,500 --> 00:45:59,980
related to 1 or 2.
与1或2有关。 

847
00:45:59,980 --> 00:46:02,389
And the point here is that if I created
关键是，如果我创建了

848
00:46:02,389 --> 00:46:13,940
a graph that looked like this, where I have V4, V5, V6, V7,
像这样的图，其中有V4，V5，V6，V7， 

849
00:46:13,940 --> 00:46:20,389
V8, and it had this structure, then
 V8，它具有这种结构，然后

850
00:46:20,389 --> 00:46:23,269
I'm going to end up having something
我最终要吃点东西

851
00:46:23,269 --> 00:46:29,000
like 2 raised to n over 2 weight if I
如果我将2提升到2的重量

852
00:46:29,000 --> 00:46:30,699
have n vertices in this graph.
此图中有n个顶点。 

853
00:46:30,699 --> 00:46:33,059
Or at least the dynamic range of these weights
或至少这些权重的动态范围

854
00:46:33,059 --> 00:46:35,730
is going to be 2 raised to n divided by 2.
将2提高到n除以2。 

855
00:46:35,730 --> 00:46:36,639
Everybody buy that?
大家都买吗？ 

856
00:46:36,639 --> 00:46:39,719



857
00:46:39,719 --> 00:46:43,599
So think of this graph as being a fragment of this large graph,
因此，将此图视为该大图的一部分， 

858
00:46:43,599 --> 00:46:46,380
which where n could be 100 and the weights
其中n可以是100和权重

859
00:46:46,380 --> 00:46:48,380
could be 2 raised to 50.
可能是2提高到50。 

860
00:46:48,380 --> 00:46:49,920
And 2 raised to 50 isn't a number
 2加到50不是数字

861
00:46:49,920 --> 00:46:51,780
that we can't handle on a computer, right?
我们无法在计算机上处​​理，对吗？ 

862
00:46:51,780 --> 00:46:53,519
It's still less than 64 bits, right?
它仍然少于64位，对吗？ 

863
00:46:53,719 --> 00:46:56,250
So it's a pretty reasonable example.
因此，这是一个非常合理的示例。 

864
00:46:56,250 --> 00:46:59,190
And we talked about multiple precision arithmetic,
我们讨论了多精度算术， 

865
00:46:59,190 --> 00:47:00,440
infinite precision arithmetic.
无限精度算术。 

866
00:47:00,440 --> 00:47:02,519
So we can handle arbitrary numbers
这样我们就可以处理任意数字

867
00:47:02,519 --> 00:47:05,030
of an arbitrary position.
任意位置。 

868
00:47:05,030 --> 00:47:07,940
So there's nothing that's stopping us
所以没有什么可以阻止我们

869
00:47:07,940 --> 00:47:11,280
from putting square root of 2 and all sorts of things.
取2的平方根和各种各样的东西。 

870
00:47:11,280 --> 00:47:12,789
We won't do imaginary numbers.
我们不会做虚数。 

871
00:47:12,989 --> 00:47:15,789
But you could imagine putting numbers
但是你可以想象把数字

872
00:47:15,789 --> 00:47:20,139
with a high dynamic range as edges in a particular graph
具有高动态范围作为特定图形中的边缘

873
00:47:20,139 --> 00:47:22,869
and expect the Dijkstra, assuming that all of the edges
并期望Dijkstra，假设所有边缘

874
00:47:22,869 --> 00:47:28,089
are non-negative, that Dijkstra should be able to run on it.
是非负的，Dijkstra应该可以在其上运行。 

875
00:47:28,090 --> 00:47:30,760
So what happens with this example?
那么这个例子会怎样？ 

876
00:47:30,760 --> 00:47:33,090
Well, with this example, here's what happens.
好吧，通过此示例，将发生以下情况。 

877
00:47:33,090 --> 00:47:36,340
Let's say that I ran this algorithm.
假设我运行了该算法。 

878
00:47:36,340 --> 00:47:42,210
And initially, I just followed this chain here.
最初，我只是在这里遵循此链条。 

879
00:47:42,210 --> 00:47:45,320
And I get-- this starts with a 0.
我得到-这从0开始。 

880
00:47:45,320 --> 00:47:48,530
And this is a 4, because I get there with 4.
这是4，因为我到了4。 

881
00:47:48,530 --> 00:47:50,280
This one is 8.
这个是8 

882
00:47:50,280 --> 00:47:51,650
And this is 10.
这是10。 

883
00:47:51,650 --> 00:47:55,380
And this is 12, 13, 14.
这是12、13、14 

884
00:47:55,380 --> 00:47:57,730



885
00:47:57,929 --> 00:48:00,739
And that's the initial pass.
那是初始阶段。 

886
00:48:00,739 --> 00:48:02,989
That's the selection.
那就是选择。 

887
00:48:02,989 --> 00:48:10,019
What ends up happening is that you could now relax at this--
最终发生的事情是，您现在可以在此放松一下- 

888
00:48:10,019 --> 00:48:11,429
you see 14.
你看到14。 

889
00:48:11,429 --> 00:48:13,659
And let's say you relax this edge.
假设您放松了这一优势。 

890
00:48:13,659 --> 00:48:18,940
You see that 12 and 14, you've turned that into 13.
您看到12和14，将其变为13。 

891
00:48:18,940 --> 00:48:22,500
And then when you relax this edge, this turns into 12.
然后，当您放松此边缘时，将变为12。 

892
00:48:22,500 --> 00:48:25,019



893
00:48:25,019 --> 00:48:27,639
So you go through that process.
这样您就可以完成该过程。 

894
00:48:27,639 --> 00:48:30,509
Now, this one stays 12.
现在，这个停留12。 

895
00:48:30,510 --> 00:48:32,360
But now you relax this edge.
但是现在您放松了这一优势。 

896
00:48:32,559 --> 00:48:35,349
And so this 12 becomes 10.
因此，这12变成10。 

897
00:48:35,349 --> 00:48:37,309
And then when this changes, you need
然后当这种情况改变时，您需要

898
00:48:37,309 --> 00:48:41,829
to-- if you relax this edge first,
要-如果您先放松这一优势， 

899
00:48:41,829 --> 00:48:45,059
then this 13 is going to become 11.
那么这13将变成11 

900
00:48:45,059 --> 00:48:46,440
It doesn't really matter.
没关系。 

901
00:48:46,440 --> 00:48:49,250
This becomes, I guess, 11.
我猜这就是11。 

902
00:48:49,449 --> 00:48:51,280
And-- is that right?
而且-是吗？ 

903
00:48:51,280 --> 00:48:51,779
Yup.
对。 

904
00:48:51,780 --> 00:48:55,690
This is 11 and that's 11 as well.
这是11，也就是11。 

905
00:48:55,690 --> 00:48:57,440
It might start out being 12 if you
如果您可能开始是12 

906
00:48:57,440 --> 00:48:59,250
relax this edge and that edge.
放松这个边缘和那个边缘。 

907
00:48:59,250 --> 00:49:02,920
So you might go to 12 to 11, and so on and so forth.
因此，您可能会转到12到11，依此类推。 

908
00:49:02,920 --> 00:49:07,250
So for a pathological ordering, I won't belabor the point.
因此，对于病理性排序，我不会感到惊讶。 

909
00:49:07,449 --> 00:49:09,699
But you see that you're going 14, 13, 12,
但是您会看到要走14、13、12 

910
00:49:09,699 --> 00:49:14,480
11 with a bad ordering that corresponds
 11对应的错误顺序

911
00:49:14,480 --> 00:49:16,789
to the selection of the edges.
到边缘的选择。 

912
00:49:16,989 --> 00:49:21,265
And so if the overall weight here and overall weight here,
因此，如果此处的总重量和此处的总重量， 

913
00:49:21,266 --> 00:49:22,639
when you start out with, is going
当你开始的时候

914
00:49:22,639 --> 00:49:25,389
to be order 2 raised to n over 2.
将订单2的n提升为2。 

915
00:49:25,389 --> 00:49:29,159
OK And you could be, in this particular graph,
好，在这个特定的图中， 

916
00:49:29,159 --> 00:49:32,639
relaxing edges an exponential number of times
松弛边缘成指数倍的次数

917
00:49:32,639 --> 00:49:36,940
in order to finish.
为了完成。 

918
00:49:36,940 --> 00:49:39,840
And so the number of times you relax an edge
因此，您放松边缘的次数

919
00:49:39,840 --> 00:49:42,440
could be of the order of the weights
可能是权重的数量级

920
00:49:42,440 --> 00:49:43,820
that you start out with.
一开始就是

921
00:49:43,820 --> 00:49:47,019
And that makes this algorithm an exponential time algorithm.
这使该算法成为指数时间算法。 

922
00:49:47,219 --> 00:49:49,049
So clearly, we have to do better than that
很明显，我们必须做得更好

923
00:49:49,050 --> 00:49:52,539
when it comes to Dijkstra or Bellman-Ford.
谈到Dijkstra或Bellman-Ford。 

924
00:49:52,539 --> 00:49:54,840
So how are we going to do better than that?
那么我们将如何做得更好呢？ 

925
00:49:54,840 --> 00:49:56,260
Yeah, question back there.
是的，再问那里。 

926
00:49:56,260 --> 00:49:57,518
AUDIENCE: Is it an issue that we're
观众：这是我们的问题吗

927
00:49:57,717 --> 00:49:59,175
starting at the [INAUDIBLE]?
从[听不清]开始？ 

928
00:49:59,175 --> 00:50:02,806



929
00:50:02,806 --> 00:50:04,139
PROFESSOR: You're exactly right.
教授：您说得很对。 

930
00:50:04,139 --> 00:50:07,409
There's an issue with the ordering that we've chosen.
我们选择的顺序存在问题。 

931
00:50:07,409 --> 00:50:10,920
But what you have to show is that for any graph,
但是您要显示的是对于任何图形， 

932
00:50:10,920 --> 00:50:12,789
the particular ordering that you choose
您选择的特定顺序

933
00:50:12,789 --> 00:50:16,909
will result in V log V plus E and so on and so forth.
将导致V log V加E等，依此类推。 

934
00:50:16,909 --> 00:50:17,909
So you're exactly right.
所以你说的很对。 

935
00:50:17,909 --> 00:50:20,117
I mean, it's an issue with the ordering we've chosen.
我的意思是，这与我们选择的订单有关。 

936
00:50:20,117 --> 00:50:22,049
This is a pathological ordering.
这是病理排序。 

937
00:50:22,050 --> 00:50:23,650
It's just meaning to say that we have
只是说我们有

938
00:50:23,849 --> 00:50:27,079
to be careful about how we select.
要谨慎选择。 

939
00:50:27,079 --> 00:50:30,039
If you selected wrong, you've got problems.
如果选择错误，则说明您遇到了问题。 

940
00:50:30,039 --> 00:50:32,110
And so the purpose of next week is
所以下周的目的是

941
00:50:32,110 --> 00:50:35,360
going to be how do we select these edges properly.
我们将如何正确选择这些边缘。 

942
00:50:35,360 --> 00:50:40,070
And so I leave you with this notion of,
所以我给你留下这样的观念， 

943
00:50:40,070 --> 00:50:44,000
very simple notion of, optimal substructure using
非常简单的概念，使用

944
00:50:44,199 --> 00:50:46,429
two very simple terms that you can
您可以使用两个非常简单的术语

945
00:50:46,429 --> 00:50:50,199
prove in literally a line of text.
用一行文字证明。 

946
00:50:50,199 --> 00:50:59,409
And the first one says as subpaths of a shortest path
第一个说作为最短路径的子路径

947
00:50:59,409 --> 00:51:00,579
are shortest paths.
是最短的路径。 

948
00:51:00,579 --> 00:51:05,519



949
00:51:05,519 --> 00:51:11,920
And all that means is if I had V0, and I went to V1,
这就是说如果我有V0，然后我转到V1， 

950
00:51:11,920 --> 00:51:15,500
and I went to V2, and these are paths here.
我去了V2，这些是这里的路径。 

951
00:51:15,500 --> 00:51:22,929
So this could be p01, p02, p03.
因此可能是p01，p02，p03。 

952
00:51:22,929 --> 00:51:26,239
And so there are many vertices potentially between V0 and V1.
因此，V0和V1之间可能有许多顶点。 

953
00:51:26,239 --> 00:51:30,009
And if you tell me that V0 through V3,
如果您告诉我V0至V3， 

954
00:51:30,010 --> 00:51:34,460
the concatenation of p01, p02, and, sorry, p03
 p01，p02和对不起p03的串联

955
00:51:34,460 --> 00:51:35,485
are a shortest path.
是最短的路径。 

956
00:51:35,485 --> 00:51:40,539



957
00:51:40,739 --> 00:51:44,109
If this is an SP, shortest path, then that
如果这是SP，最短路径，则

958
00:51:44,110 --> 00:51:50,030
implies that each of these are shortest paths as well.
意味着这些都是最短的路径。 

959
00:51:50,030 --> 00:51:52,650
And that makes sense, because if in fact there
这是有道理的，因为如果实际上

960
00:51:52,650 --> 00:51:55,539
was a better way of getting from V0 to V1
是从V0转到V1的更好方法

961
00:51:55,739 --> 00:52:00,199
that was better than p01, why would you ever put p01 in here?
那比p01好，为什么还要把p01放在这里呢？ 

962
00:52:00,199 --> 00:52:02,389
You would use that better way.
您将使用更好的方法。 

963
00:52:02,389 --> 00:52:03,579
So very simple.
非常简单。 

964
00:52:03,579 --> 00:52:06,809
That's what's called the optimum substructure property.
这就是所谓的最佳子结构属性。 

965
00:52:06,809 --> 00:52:12,190
And this notion of the triangle inequality
这个三角形不等式的概念

966
00:52:12,190 --> 00:52:14,440
is also related to that.
也与此有关。 

967
00:52:14,440 --> 00:52:21,500
And that simply says that if I have something like this,
这只是说，如果我有这样的事情， 

968
00:52:21,699 --> 00:52:28,109
that I have V0, V1, and V2, then when
我有V0，V1和V2，那么当

969
00:52:28,110 --> 00:52:32,809
I look at the delta value of V0, V1,
我看一下V0，V1的增量值

970
00:52:32,809 --> 00:52:38,500
and I compare that with the delta values of V0, V2, and V2,
我将其与V0，V2和V2的增量值进行比较， 

971
00:52:38,500 --> 00:52:46,289
V1, then this has got to be smaller than or equal to this
 V1，则此值必须小于或等于此值

972
00:52:46,289 --> 00:52:48,096
plus that.
再加上。 

973
00:52:48,096 --> 00:52:49,219
And that again makes sense.
这又是有道理的。 

974
00:52:49,219 --> 00:52:54,089
Because if this plus this was smaller than that,
因为如果加上这个比那个小， 

975
00:52:54,090 --> 00:52:59,030
well remember I'm talking about paths here, not edges.
记住，我在这里谈论的是路径，而不是边缘。 

976
00:52:59,030 --> 00:53:00,690
And the better way of getting to V1
以及进入V1的更好方法

977
00:53:00,889 --> 00:53:03,139
would be to follow-- go through V2 rather
将会遵循-而是通过V2 

978
00:53:03,139 --> 00:53:05,639
than following this path up on top.
而不是遵循这条道路。 

979
00:53:05,639 --> 00:53:07,480
Amazingly, these two notions are going
令人惊讶的是，这两个概念正在

980
00:53:07,480 --> 00:53:09,670
to be enough to take this algorithm
足以采用此算法

981
00:53:09,670 --> 00:53:12,980
and turn it into essentially a linear time algorithm.
并将其转化为实质上的线性时间算法。 

982
00:53:12,980 --> 00:53:17,980
And we'll do that next time.
我们下次再做。 

