1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:02,489
The following content is provided under a Creative
广告素材下提供了以下内容

3
00:00:02,490 --> 00:00:04,009
Commons license.
普通许可。 

4
00:00:04,009 --> 00:00:06,349
Your support will help MIT OpenCourseWare
您的支持将帮助MIT OpenCourseWare 

5
00:00:06,349 --> 00:00:10,719
continue to offer high quality educational resources for free.
继续免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,225
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,225 --> 00:00:17,850
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,850 --> 00:00:21,730



10
00:00:21,730 --> 00:00:23,980
PROFESSOR: Today we're going to introduce graph search
教授：今天我们将介绍图形搜索

11
00:00:23,980 --> 00:00:25,896
in general and talk about one algorithm, which
一般来说，谈论一种算法， 

12
00:00:25,896 --> 00:00:29,339
is breadth-first search, and understand how in principle you
是广度优先的搜索，并了解原则上

13
00:00:29,339 --> 00:00:33,179
can solve a puzzle like the Rubik's Cube.
可以解决魔方之类的难题。 

14
00:00:33,179 --> 00:00:36,189
So before I get to Rubik's Cubes let
所以在我进入魔方之前

15
00:00:36,189 --> 00:00:41,942
me remind you of some basic stuff about graphs.
我提醒您一些有关图的基本知识。 

16
00:00:41,942 --> 00:00:50,380
Or I can tell you to start out with, graph search is
或者我可以告诉您开始时，图形搜索是

17
00:00:50,380 --> 00:00:52,905
about exploring a graph.
关于探索图。 

18
00:00:52,905 --> 00:00:55,890



19
00:00:55,890 --> 00:00:58,779
And there's many different notions of exploring a graph.
探索图有许多不同的概念。 

20
00:00:58,979 --> 00:01:01,949
Maybe I give you some node in a graph, s,
也许我给你图中的某个节点s 

21
00:01:01,950 --> 00:01:03,589
and some other node in a graph, t,
图中的其他节点t 

22
00:01:03,789 --> 00:01:06,939
and I'd like to find a path that's
我想找到一条

23
00:01:06,939 --> 00:01:09,390
going to represent a problem like I give you
代表我给你的问题

24
00:01:09,390 --> 00:01:13,140
a particular state of a Rubik's Cube and I want to know
魔方的特定状态，我想知道

25
00:01:13,140 --> 00:01:16,534
is there some path that gets me into a solved state?
有什么方法可以使我进入已解决状态？ 

26
00:01:16,534 --> 00:01:18,200
Do I really want to solve this on stage?
我真的要在舞台上解决这个问题吗？ 

27
00:01:18,200 --> 00:01:19,230
What the hell?
我勒个去？ 

28
00:01:19,230 --> 00:01:21,650
We started.
我们开始了。 

29
00:01:21,650 --> 00:01:24,209
So this is a particularly easy state to solve,
因此，这是一种特别容易解决的状态， 

30
00:01:24,409 --> 00:01:26,816
which is why I set up this way.
这就是为什么我这样设置的原因。 

31
00:01:26,816 --> 00:01:27,939
All right, so there you go.
好吧，那您就去了。 

32
00:01:27,939 --> 00:01:31,509
Seven by seven by seven Rubik's Cube solved in 10 seconds.
七乘七乘七的魔方在10秒内解决。 

33
00:01:31,510 --> 00:01:33,650
Amazing.
惊人。 

34
00:01:33,650 --> 00:01:36,030
New world record.
新的世界纪录。 

35
00:01:36,030 --> 00:01:39,326
So you're given some initial state of the Rubik's Cube.
因此，您已经获得了魔方的一些初始状态。 

36
00:01:39,326 --> 00:01:40,701
You're given the targets that you
您得到的目标是

37
00:01:40,701 --> 00:01:42,159
know what solved looks like.
知道解决的方式。 

38
00:01:42,159 --> 00:01:45,000
You want to find this path.
您想找到此路径。 

39
00:01:45,000 --> 00:01:47,887
Maybe you want to find all paths from s.
也许您想找到s的所有路径。 

40
00:01:47,887 --> 00:01:49,719
Maybe you just want to explore all the nodes
也许您只想探索所有节点

41
00:01:49,719 --> 00:01:51,159
in a graph you can reach from s.
在图中可以从s到达。 

42
00:01:51,159 --> 00:01:53,459
Maybe you want to explore all the nodes in a graph or maybe
也许您想探索图中的所有节点，或者

43
00:01:53,459 --> 00:01:54,500
all the edges in a graph.
图中的所有边。 

44
00:01:54,501 --> 00:01:56,076
These are all exploration problems.
这些都是探索问题。 

45
00:01:56,076 --> 00:01:57,909
They're all going to be solved by algorithms
它们都将由算法解决

46
00:01:57,909 --> 00:02:01,640
from this class and next class.
从这个班和下一个班

47
00:02:01,640 --> 00:02:04,349
So before we go further though, I
所以在继续之前，我

48
00:02:04,349 --> 00:02:07,329
should remind you what a graph is
应该提醒您什么是图形

49
00:02:07,329 --> 00:02:10,169
and sort of basic features of graphs
图的基本特征

50
00:02:10,169 --> 00:02:12,030
that we're going to be using.
我们将要使用的。 

51
00:02:12,229 --> 00:02:15,389
This is also 6042 material so you should know it very well.
这也是6042的材料，因此您应该非常了解它。 

52
00:02:15,389 --> 00:02:17,119
If you don't, there's an appendix
如果没有，则有一个附录

53
00:02:17,120 --> 00:02:18,819
in the textbook about it.
在有关它的教科书中。 

54
00:02:18,819 --> 00:02:20,096
We have a set of vertices.
我们有一组顶点。 

55
00:02:20,097 --> 00:02:21,055
We have a set of edges.
我们有一组优势。 

56
00:02:21,055 --> 00:02:33,360



57
00:02:33,360 --> 00:02:38,655
Edges are either unordered pairs--
边要么是无序对- 

58
00:02:38,655 --> 00:02:41,460



59
00:02:41,460 --> 00:02:44,240
some sets of two items--
一些两件套

60
00:02:44,240 --> 00:02:46,939



61
00:02:47,139 --> 00:02:50,629
or ordered pairs.
或有序对。 

62
00:02:50,629 --> 00:02:58,229



63
00:02:58,229 --> 00:03:02,269
In this case, we call the graph undirected.
在这种情况下，我们称该图为无向图。 

64
00:03:02,270 --> 00:03:04,719
In this case, we call the graph directed.
在这种情况下，我们称其为有向图。 

65
00:03:04,919 --> 00:03:07,629
Usually, there's only one type.
通常，只有一种类型。 

66
00:03:07,629 --> 00:03:09,030
Either all the edges are directed
所有边缘都指向

67
00:03:09,030 --> 00:03:11,689
or all the edges are undirected.
或所有边缘都是无向的。 

68
00:03:11,689 --> 00:03:13,439
There is a study of graphs that have both,
有一项对图的研究， 

69
00:03:13,439 --> 00:03:15,396
but we are not doing that here.
但是我们不在这里做。 

70
00:03:15,396 --> 00:03:18,719



71
00:03:18,719 --> 00:03:20,430
Some simple examples.
一些简单的例子。 

72
00:03:20,430 --> 00:03:23,343



73
00:03:23,343 --> 00:03:24,009
Here is a graph.
这是一张图。 

74
00:03:24,009 --> 00:03:29,569



75
00:03:29,569 --> 00:03:30,794
This is an undirected graph.
这是无向图。 

76
00:03:30,794 --> 00:03:42,819



77
00:03:42,819 --> 00:03:44,069
This is a directed graph.
这是有向图。 

78
00:03:44,069 --> 00:03:48,489



79
00:03:48,490 --> 00:03:50,115
The set of vertices here is a, b, c, d.
这里的一组顶点是a，b，c，d。 

80
00:03:50,115 --> 00:03:52,525
The set of vertices here is a, b, c.
这里的一组顶点是a，b，c。 

81
00:03:52,525 --> 00:03:55,180
The set of edges here is--
这里的边集是- 

82
00:03:55,180 --> 00:04:04,250
E is going to be things like a, b; b, c; c, d--
 E将会是a，b之类的东西； b，c； c，d-- 

83
00:04:04,250 --> 00:04:05,550
I think you get the idea.
我想你应该已经明白了。 

84
00:04:05,550 --> 00:04:09,780



85
00:04:09,780 --> 00:04:12,750
Just for completeness, V is a, b, c, d.
仅出于完整性考虑，V是a，b，c，d。 

86
00:04:12,750 --> 00:04:14,639
Just so you remember notations and so on.
只是您要记住符号等等。 

87
00:04:14,639 --> 00:04:17,213



88
00:04:17,213 --> 00:04:19,588
One of the issues we're going to talk about in this class
我们将在本课程中讨论的问题之一

89
00:04:19,588 --> 00:04:23,562
is how do you represent a graph like this for an algorithm?
怎样表示这样的图用于算法？ 

90
00:04:23,562 --> 00:04:25,569
So it's all fine to say, oh, this is a set of things.
所以可以说，这是一堆事情。 

91
00:04:25,769 --> 00:04:27,069
This is a set of things.
这是一组事情。 

92
00:04:27,069 --> 00:04:28,709
An obvious representation is, you have
一个明显的表示是， 

93
00:04:28,709 --> 00:04:31,120
a list or an array of vertices.
列表或顶点数组。 

94
00:04:31,120 --> 00:04:32,519
You have an array of edges.
您有一组边线。 

95
00:04:32,519 --> 00:04:34,319
Each edge knows its two end points.
每个边都知道其两个端点。 

96
00:04:34,319 --> 00:04:37,649
That would be a horrible representation for a graph
这将是一个可怕的图形表示

97
00:04:37,649 --> 00:04:39,919
because if you're, I don't know, at vertex, a,
因为如果你在顶点，我不知道

98
00:04:39,920 --> 00:04:42,139
and you want to know, well what are the neighbors of a?
并且您想知道，a的邻居是什么？ 

99
00:04:42,339 --> 00:04:43,259
b and c.
 b和c。 

100
00:04:43,259 --> 00:04:45,289
You'd have to go through the entire edge list
您必须浏览整个边缘列表

101
00:04:45,290 --> 00:04:47,379
to figure out the neighbors of a.
找出a的邻居。 

102
00:04:47,379 --> 00:04:50,423
So it's been linear time just to know where you can go from a.
所以这是线性的时间，只是要知道您可以从哪里去。 

103
00:04:50,423 --> 00:04:52,339
So we're not going to use that representation.
因此，我们将不使用该表示形式。 

104
00:04:52,339 --> 00:04:55,429
We're going to use some better representations.
我们将使用一些更好的表示形式。 

105
00:04:55,430 --> 00:04:57,160
Something called an adjacency list.
称为邻接表的东西。 

106
00:04:57,160 --> 00:05:01,560



107
00:05:01,560 --> 00:05:07,970
Over here, you've got things like a, c; b, c; and c, b.
在这里，您会看到a，c之类的东西； b，c；和c，b。 

108
00:05:07,970 --> 00:05:10,716
So you can have edges in both directions.
因此，您可以在两个方向上都具有边缘。 

109
00:05:10,716 --> 00:05:11,620
What am I missing?
我想念什么？ 

110
00:05:11,620 --> 00:05:12,120
b, a.
 b，a 

111
00:05:12,120 --> 00:05:14,891



112
00:05:14,891 --> 00:05:17,480
So that's E, in that case.
在这种情况下，那就是E。 

113
00:05:17,480 --> 00:05:22,180



114
00:05:22,180 --> 00:05:25,483
There are a whole lot of applications of graph search.
图搜索有很多应用。 

115
00:05:25,483 --> 00:05:28,430
I'll make you a little list to talk about few of them.
我会列出一些清单，以供您讨论。 

116
00:05:28,430 --> 00:05:32,269



117
00:05:32,269 --> 00:05:35,094
So we've got web crawling.
这样我们就可以进行网络爬网了。 

118
00:05:35,095 --> 00:05:38,810



119
00:05:39,009 --> 00:05:39,605
You're Google.
您是Google。 

120
00:05:39,605 --> 00:05:42,100
You want to find all the pages on the web.
您要查找网络上的所有页面。 

121
00:05:42,100 --> 00:05:45,050
Most people don't just tell you, hey, I've got a new page,
大多数人不只是告诉你，嘿，我有一个新页面， 

122
00:05:45,050 --> 00:05:46,449
please index it.
请索引它。 

123
00:05:46,449 --> 00:05:48,519
You have to just keep following links--
您只需要保持以下链接- 

124
00:05:48,519 --> 00:05:50,709
in the early days of the web, this was a big deal--
在网络初期，这很重要- 

125
00:05:50,709 --> 00:05:53,658
following links finding everything that's out there.
以下链接可查找所有内容。 

126
00:05:53,658 --> 00:05:56,199
It's a little bit of an issue because if you define it wrong,
这是一个小问题，因为如果定义错误， 

127
00:05:56,199 --> 00:05:59,689
the internet is infinite because of all those dynamically
互联网是无限的，因为所有这些都是动态的

128
00:05:59,689 --> 00:06:00,600
generated pages.
生成的页面。 

129
00:06:00,600 --> 00:06:03,129
But to deal with that, Google goes
但是为了解决这个问题，谷歌

130
00:06:03,329 --> 00:06:05,349
sort of breadth-first for the most part.
大多数情况下，宽度优先。 

131
00:06:05,350 --> 00:06:09,509
It's prioritized You want to see all the things you
它是优先的您想看所有的东西

132
00:06:09,709 --> 00:06:15,439
can reach from pages you already have and keep going.
可以从您已有的页面访问并继续前进。 

133
00:06:15,439 --> 00:06:19,129
At some point, you give up when you run out of time.
在某个时候，您会在时间用完时放弃。 

134
00:06:19,129 --> 00:06:21,129
Social networking.
社交网络。 

135
00:06:21,129 --> 00:06:22,000
You're on Facebook.
您正在使用Facebook。 

136
00:06:22,000 --> 00:06:23,500
You use Friend Finder.
您使用朋友查找器。 

137
00:06:23,500 --> 00:06:26,259
It tries to find the friends that are nearest to you.
它试图找到离您最近的朋友。 

138
00:06:26,259 --> 00:06:31,139
Or friends of friends is sort of a level to search.
或朋友的朋友是要搜索的级别。 

139
00:06:31,139 --> 00:06:33,339
That's essentially a graph search problem.
从本质上讲，这是一个图搜索问题。 

140
00:06:33,339 --> 00:06:37,129
You want to know what's two levels or three
您想知道两个或三个级别

141
00:06:37,129 --> 00:06:39,180
levels of separation from you.
与您的分离水平。 

142
00:06:39,180 --> 00:06:43,528
And then you loop over those and look for other signs
然后遍历那些并寻找其他迹象

143
00:06:43,528 --> 00:06:44,819
that you might be good friends.
你可能是好朋友。 

144
00:06:44,819 --> 00:06:49,560



145
00:06:49,560 --> 00:06:54,459
You are on a network like the internet or some intranet.
您正在使用Internet或某些Intranet之类的网络。 

146
00:06:54,459 --> 00:06:56,109
You want to broadcast a message.
您要广播一条消息。 

147
00:06:56,110 --> 00:06:57,139
So here's you.
所以这是你。 

148
00:06:57,339 --> 00:06:59,349
You want to send data out.
您要发送数据。 

149
00:06:59,350 --> 00:07:01,629
That's essentially a graph exploration problem.
从本质上讲，这是一个图形探索问题。 

150
00:07:01,829 --> 00:07:04,849
That message, that packet, is going to explore the graph.
那个消息，那个数据包，将探索图。 

151
00:07:04,850 --> 00:07:09,259



152
00:07:09,459 --> 00:07:10,324
Garbage collection.
垃圾收集。 

153
00:07:10,324 --> 00:07:14,339



154
00:07:14,339 --> 00:07:17,368
I hope you all know that modern languages have
我希望大家都知道现代语言有

155
00:07:17,369 --> 00:07:18,160
garbage collection.
垃圾收集。 

156
00:07:18,160 --> 00:07:21,740
This is why you don't have to worry about freeing things.
这就是为什么您不必担心释放东西的原因。 

157
00:07:21,740 --> 00:07:23,800
Even in Python-- even in CPython,
即使在Python中-甚至在CPython中， 

158
00:07:23,800 --> 00:07:27,600
I learned-- there is a garbage collector as of version two.
我了解到-从第二版开始就有一个垃圾收集器。 

159
00:07:27,600 --> 00:07:31,389
But also in PyPy, and JPython and in Java--
而且在PyPy，JPython和Java中- 

160
00:07:31,589 --> 00:07:35,563
pretty much every fairly modern language
几乎每种相当现代的语言

161
00:07:35,564 --> 00:07:36,730
you have garbage collection.
你有垃圾收集。 

162
00:07:36,730 --> 00:07:40,579
Meaning, if there's some data that's unreachable from--
意思是，如果某些数据无法通过以下方式访问- 

163
00:07:40,779 --> 00:07:43,819
So you have your variables.
所以你有自己的变量。 

164
00:07:43,819 --> 00:07:45,889
Variables that can be accessed by the program.
程序可以访问的变量。 

165
00:07:45,889 --> 00:07:48,409
Everything that's reachable from there you have to keep.
从那里可以到达的一切都必须保留。 

166
00:07:48,410 --> 00:07:51,819
But if some data structure becomes no longer reachable,
但是，如果某些数据结构不再可访问， 

167
00:07:52,019 --> 00:07:57,894
you can throw it away and regain memory.
您可以扔掉它并重新获得记忆。 

168
00:07:57,894 --> 00:08:00,019
So that's happening behind the scenes all the time,
所以这一直在幕后发生， 

169
00:08:00,019 --> 00:08:01,750
and the way it's being done is with
它的完成方式是

170
00:08:01,750 --> 00:08:03,170
their breadth-first search, which
他们的广度优先搜索

171
00:08:03,170 --> 00:08:04,990
is what we're going to talk about today.
这就是我们今天要谈论的。 

172
00:08:04,990 --> 00:08:07,620



173
00:08:07,620 --> 00:08:08,449
Another one.
另一个。 

174
00:08:08,449 --> 00:08:09,094
Model checking.
模型检查。 

175
00:08:09,095 --> 00:08:14,689



176
00:08:14,889 --> 00:08:21,250
Model checking is-- you have some finite model of either
模型检查是-您可以选择其中一个的有限模型

177
00:08:21,250 --> 00:08:24,204
a piece of code, or a circuit, or chip, whatever,
一段代码，电路，芯片等等

178
00:08:24,204 --> 00:08:26,219
and you want to prove that it actually
你想证明它实际上

179
00:08:26,220 --> 00:08:27,620
does what you think it does.
按照您的想法去做。 

180
00:08:27,620 --> 00:08:29,329
And so you've drawn a graph.
因此，您绘制了一个图形。 

181
00:08:29,529 --> 00:08:31,789
The graph is all the possible states
该图是所有可能的状态

182
00:08:31,790 --> 00:08:36,000
that your circuit or your computer program could reach,
您的电路或计算机程序可以达到的目标

183
00:08:36,000 --> 00:08:38,393
or that it could possibly have.
或者它可能有。 

184
00:08:38,393 --> 00:08:39,858
You start in some initial state, and you
您从某种初始状态开始，然后

185
00:08:40,058 --> 00:08:42,266
want to know among all the states that you can reach,
想知道您可以达到的所有状态， 

186
00:08:42,267 --> 00:08:43,199
does it have some property.
它有一些属性吗？ 

187
00:08:43,399 --> 00:08:46,049
And so you need to visit all the vertices that
因此，您需要访问所有的顶点

188
00:08:46,049 --> 00:08:48,500
are reachable from a particular place.
可以从特定位置到达。 

189
00:08:48,500 --> 00:08:53,720
And usually people do that using breadth-first search.
通常人们使用广度优先搜索来做到这一点。 

190
00:08:53,720 --> 00:08:55,389
I use breadth-first search a lot,
我经常使用广度优先搜索， 

191
00:08:55,389 --> 00:08:59,860
myself, to check mathematical conjectures.
我自己，检查数学猜想。 

192
00:08:59,860 --> 00:09:06,269
So if you're a mathematician, and you think something
因此，如果您是数学家，并且您认为

193
00:09:06,269 --> 00:09:07,721
is true.
是真的。 

194
00:09:07,721 --> 00:09:11,600
Like maybe-- It's hard to give an example of that.
也许-很难举一个例子。 

195
00:09:11,600 --> 00:09:15,690
But you can imagine some graph of all the possible inputs
但是您可以想象所有可能输入的一些图形

196
00:09:15,690 --> 00:09:18,330
to that theorem, and you need to check them
那个定理，你需要检查一下

197
00:09:18,330 --> 00:09:19,600
for every possible input--
对于每种可能的输入- 

198
00:09:19,600 --> 00:09:21,450
If this is true-- the typical way to do that
如果这是真的-这样做的典型方法

199
00:09:21,450 --> 00:09:24,480
is breadth-first searching through that entire graph
在整个图上进行广度优先搜索

200
00:09:24,480 --> 00:09:27,100
of states.
状态。 

201
00:09:27,100 --> 00:09:29,493
Usually, we're testing finite, special cases
通常，我们正在测试有限的特殊情况

202
00:09:29,693 --> 00:09:32,110
of a general conjecture, but if we find a counter-example,
一般猜想，但是如果我们找到反例， 

203
00:09:32,110 --> 00:09:32,899
we're done.
我们完成了。 

204
00:09:32,899 --> 00:09:34,591
Don't have to work on it anymore.
不必再努力了。 

205
00:09:34,591 --> 00:09:36,590
If we don't find a counter-example, usually then
如果我们找不到反例，通常

206
00:09:36,590 --> 00:09:38,269
we have to do the mathematics.
我们必须做数学。 

207
00:09:38,269 --> 00:09:42,694
It doesn't solve everything, but it's helpful.
它并不能解决所有问题，但很有帮助。 

208
00:09:42,695 --> 00:09:47,600



209
00:09:47,600 --> 00:09:52,229
And then, the fun thing we're going
然后，我们要做的有趣的事情

210
00:09:52,429 --> 00:09:54,069
to talk about a little bit today,
今天要谈一点

211
00:09:54,070 --> 00:09:55,903
is if you want to solve something like a two
如果你想解决两个问题

212
00:09:55,903 --> 00:09:57,938
by two by two Rubik's Cube optimally,
最佳地乘以二乘两的魔方， 

213
00:09:57,938 --> 00:09:59,730
you can do that using breadth-first search.
您可以使用广度优先搜索来做到这一点。 

214
00:09:59,730 --> 00:10:02,734
And you're going to do that on your problem set.
您将在问题集上进行此操作。 

215
00:10:02,934 --> 00:10:05,339
To do it solving this one optimally using breadth-first
要做到这一点，最好使用广度优先

216
00:10:05,340 --> 00:10:08,599
search would probably--
搜索可能- 

217
00:10:08,799 --> 00:10:11,139
would definitely-- take more than the lifetime
肯定会-花一生以上的时间

218
00:10:11,139 --> 00:10:12,330
of the universe.
宇宙

219
00:10:12,330 --> 00:10:14,579
So don't try seven by seven by seven.
所以不要尝试七乘七乘七。 

220
00:10:14,779 --> 00:10:17,610



221
00:10:17,610 --> 00:10:20,979
Leave that to the cubing experts, I guess.
我猜这要留给相关专家。 

222
00:10:21,179 --> 00:10:23,609
I think no one will ever solve a seven by seven by seven
我认为没人会以七乘七的比例解决问题

223
00:10:23,610 --> 00:10:26,149
Rubik's Cube optimally.
魔方最佳。 

224
00:10:26,149 --> 00:10:30,189
There are ways to find a solution just not the best one.
有很多方法不能找到最佳解决方案。 

225
00:10:30,190 --> 00:10:33,194
So let me tell you just for fun, as an example.
因此，让我告诉您一个很好的例子。 

226
00:10:33,394 --> 00:10:36,929



227
00:10:36,929 --> 00:10:41,529
This Pocket Cube, which is a two by two by two Rubik's Cube.
这个袖珍立方体，是一个两乘两乘的魔方。 

228
00:10:41,529 --> 00:10:45,779
What we have in mind is called the configuration graph
我们想到的就是配置图

229
00:10:45,779 --> 00:10:48,480
or sometimes configuration space.
或有时配置空间。 

230
00:10:48,480 --> 00:10:50,701
But it's a graph, so we'll call it a graph.
但这是一个图形，因此我们将其称为图形。 

231
00:10:50,701 --> 00:10:53,839



232
00:10:54,039 --> 00:11:01,464
This graph has a vertex for each possible state of the cube.
该图为多维数据集的每个可能状态都有一个顶点。 

233
00:11:01,465 --> 00:11:10,340



234
00:11:10,340 --> 00:11:12,334
So this is a state.
所以这是一个状态。 

235
00:11:12,534 --> 00:11:15,139



236
00:11:15,139 --> 00:11:16,819
This is a state.
这是一种状态。 

237
00:11:16,820 --> 00:11:17,439
This is a state.
这是一种状态。 

238
00:11:17,639 --> 00:11:19,240
This is a state.
这是一种状态。 

239
00:11:19,240 --> 00:11:21,789
Now I'm hopelessly lost.
现在我无可救药地迷路了。 

240
00:11:21,789 --> 00:11:23,539
Anyone want to work on this?
有人要为此工作吗？ 

241
00:11:23,539 --> 00:11:25,801
Bored?
无聊？ 

242
00:11:25,802 --> 00:11:26,359
No one?
没有人？ 

243
00:11:26,559 --> 00:11:28,509
Alright, I'll leave it unsolved then.
好吧，那我就把它解决掉。 

244
00:11:28,509 --> 00:11:31,039



245
00:11:31,039 --> 00:11:32,521
So all those are vertices.
所以所有这些都是顶点。 

246
00:11:32,522 --> 00:11:33,980
There's actually a lot of vertices.
实际上有很多顶点。 

247
00:11:33,980 --> 00:11:38,690
There are 264 million vertices or so.
大约有2.64亿个顶点。 

248
00:11:38,690 --> 00:11:39,109
If you want.
如果你想。 

249
00:11:39,309 --> 00:11:41,559
To the side here.
在这边

250
00:11:41,559 --> 00:11:49,299
Number of vertices is something like 8 factorial times 3
顶点数大约是8阶乘3 

251
00:11:49,299 --> 00:11:51,949
to the 8.
到8。 

252
00:11:51,950 --> 00:11:57,436
And one way to see that is to draw a two by two
看到它的一种方法是画一个二乘二

253
00:11:57,636 --> 00:11:58,469
by two Rubik's Cube.
由两个魔方。 

254
00:11:58,470 --> 00:12:01,257



255
00:12:01,457 --> 00:12:12,889
So these are what you might call cubelets,
这些就是您可能称为的多维数据集， 

256
00:12:12,889 --> 00:12:16,370
or cubies I think is the standard term in Rubik's Cube
我认为这是Rubik's Cube中的标准术语

257
00:12:16,370 --> 00:12:16,870
land.
土地。 

258
00:12:16,870 --> 00:12:21,220



259
00:12:21,220 --> 00:12:23,125
There's eight of them in a two by two by two.
一共有八乘二乘二乘。 

260
00:12:23,125 --> 00:12:24,750
Two cubed.
两个立方体。 

261
00:12:24,750 --> 00:12:28,451
You can essentially permute those cubies within the cube
您基本上可以在多维数据集中置换这些立方

262
00:12:28,451 --> 00:12:29,159
however you like.
但是你喜欢。 

263
00:12:29,159 --> 00:12:31,019
That's 8 factorial.
那是8阶乘。 

264
00:12:31,019 --> 00:12:33,234
And then each of them has three possible twists.
然后它们每个都有三个可能的转折。 

265
00:12:33,234 --> 00:12:33,949
It could be like this.
可能是这样。 

266
00:12:34,149 --> 00:12:35,179
It could be like this.
可能是这样。 

267
00:12:35,179 --> 00:12:37,699
Or it could be like this.
或者可能是这样。 

268
00:12:37,700 --> 00:12:39,355
So you've got three for each.
因此，每个都有三个。 

269
00:12:39,355 --> 00:12:40,980
And this is actually an accurate count.
这实际上是一个准确的计数。 

270
00:12:40,980 --> 00:12:43,229
You're not over-counting the number of configurations.
您并没有过多地考虑配置数量。 

271
00:12:43,229 --> 00:12:45,759
All of those are, at least in principle, conceivable.
所有这些，至少在原则上都是可以想到的。 

272
00:12:45,759 --> 00:12:48,059
If you take apart the cube, you can reassemble it
如果拆开立方体，可以重新组装

273
00:12:48,059 --> 00:12:49,589
in each of those states.
在每个州中。 

274
00:12:49,590 --> 00:12:53,729
And that number is about 264 million.
这个数字约为2.64亿。 

275
00:12:53,929 --> 00:12:57,719



276
00:12:57,720 --> 00:13:00,000
Which is not so bad for computers.
这对于计算机来说还不错。 

277
00:13:00,000 --> 00:13:01,764
You could search that.
您可以搜索。 

278
00:13:01,764 --> 00:13:02,729
Life is a little bit easier.
生活要轻松一些。 

279
00:13:02,929 --> 00:13:04,939
You get to divide by 24 because there's
你除以24是因为

280
00:13:04,940 --> 00:13:06,599
24 symmetries of the cube.
立方体的24个对称。 

281
00:13:06,799 --> 00:13:08,189
Eight times three.
八乘三。 

282
00:13:08,190 --> 00:13:12,128
You can divide by three, also, because only a third
您也可以除以三，因为只有三分之一

283
00:13:12,328 --> 00:13:14,370
of the configuration space is actually reachable.
配置空间实际上是可以到达的。 

284
00:13:14,370 --> 00:13:16,070
If you're not allowed to take the parts apart,
如果您不允许拆开零件， 

285
00:13:16,070 --> 00:13:17,720
if you have to get there by a motion,
如果您必须动身到达那儿， 

286
00:13:17,720 --> 00:13:21,096
you can only get to 1/3 of the two by two by two.
您只能乘以2乘以2乘以1/3。 

287
00:13:21,096 --> 00:13:22,720
So it's a little bit smaller than that,
所以比这小一点

288
00:13:22,720 --> 00:13:24,349
if you're actually doing a breadth-first search, which
如果您实际上是在进行广度优先搜索， 

289
00:13:24,549 --> 00:13:26,757
is what you're going to be doing on your problem set.
这就是您要解决的问题所在。 

290
00:13:26,758 --> 00:13:29,350
But in any case, it's feasible.
但是无论如何，这都是可行的。 

291
00:13:29,350 --> 00:13:30,370
That was vertices.
那是顶点。 

292
00:13:30,370 --> 00:13:31,575
We should talk about edges.
我们应该谈论边缘。 

293
00:13:31,575 --> 00:13:42,240



294
00:13:42,240 --> 00:13:47,570
For every move-- every move takes you
每一步-每一步都需要您

295
00:13:47,570 --> 00:13:49,870
from one configuration to another.
从一种配置到另一种。 

296
00:13:49,870 --> 00:13:52,960
You could traverse it in one direction and make that move.
您可以朝一个方向移动它并进行移动。 

297
00:13:52,960 --> 00:13:54,210
You could also undo that move.
您也可以撤消该动作。 

298
00:13:54,210 --> 00:13:57,230
Because every move is undoable in a Rubik's Cube,
因为在魔方中每一步都是不可挽回的， 

299
00:13:57,230 --> 00:13:58,940
this graph is undirected.
该图是无向的。 

300
00:13:58,940 --> 00:14:02,570
Or you can think of it as every edge works in both directions.
或者，您可以考虑一下它，因为每个边缘都在两个方向上起作用。 

301
00:14:02,570 --> 00:14:03,610
So this is a move.
所以这是一个举动。 

302
00:14:03,610 --> 00:14:05,830
It's called a quarter twist.
这叫做四分之一转。 

303
00:14:05,830 --> 00:14:07,639
This is a controversy if you will.
如果您愿意，这是一个争议。 

304
00:14:07,639 --> 00:14:10,429
Some people allow a whole half twist as a single move.
有些人只允许单步移动一半。 

305
00:14:10,429 --> 00:14:13,029
Whether you define that as a single move or a double move
您将其定义为单举还是双举

306
00:14:13,029 --> 00:14:14,379
is not that big a deal.
没什么大不了的。 

307
00:14:14,379 --> 00:14:17,919
It just changes some of the answers.
它只是改变了一些答案。 

308
00:14:17,919 --> 00:14:20,969
But you're still exploring essentially the same graph.
但是您仍在探索基本相同的图。 

309
00:14:20,970 --> 00:14:23,253



310
00:14:23,453 --> 00:14:24,870
So that's the graph and you'd like
这就是图表，您想要

311
00:14:24,870 --> 00:14:26,244
to know some properties about it.
了解它的一些属性。 

312
00:14:26,244 --> 00:14:28,580
So let me draw a picture of the graph.
因此，让我画一幅图。 

313
00:14:28,580 --> 00:14:31,359
I'm not going to draw all 264 million vertices.
我不会绘制所有2.64亿个顶点。 

314
00:14:31,559 --> 00:14:34,959
But in particular, there's the solved state--
但特别是有一个已解决的状态- 

315
00:14:34,960 --> 00:14:37,090
we kind of care about that one, where
我们有点在意那个

316
00:14:37,090 --> 00:14:40,070
all the colors are aligned--
所有颜色都对齐了

317
00:14:40,070 --> 00:14:44,100
then there's all of the configurations
然后有所有的配置

318
00:14:44,100 --> 00:14:45,839
you could reach by one move.
一口气就能到达。 

319
00:14:46,039 --> 00:14:49,949
So these are the possible moves from the solved state.
因此，这是从已解决状态可能采取的行动。 

320
00:14:49,950 --> 00:14:52,950



321
00:14:52,950 --> 00:14:55,199
And then from those configurations,
然后从这些配置中

322
00:14:55,399 --> 00:14:57,970
there's more places you can go.
还有更多可以去的地方。 

323
00:14:57,970 --> 00:15:00,447
Maybe there's multiple ways to get to the same node.
也许有多种方法可以到达同一个节点。 

324
00:15:00,447 --> 00:15:03,319



325
00:15:03,320 --> 00:15:05,250
But these would be all the configurations
但是这些就是所有的配置

326
00:15:05,250 --> 00:15:07,190
you can reach in two moves.
您可以分两步到达。 

327
00:15:07,190 --> 00:15:14,969



328
00:15:15,169 --> 00:15:16,939
And so on.
等等。 

329
00:15:16,940 --> 00:15:19,100
And at some point, you run out of graph.
在某些时候，您用光了图表。 

330
00:15:19,100 --> 00:15:26,250
So there might be a few nodes out here.
因此，这里可能有几个节点。 

331
00:15:26,250 --> 00:15:28,580
The way I'm drawing this, this is everything
我画这个的方式，这就是一切

332
00:15:28,580 --> 00:15:31,240
you can reach in one move, in two movies, in three moves.
您可以一招，两部电影，三招。 

333
00:15:31,240 --> 00:15:35,009
At the end, this would be 11 moves,
最后，这将是11个动作

334
00:15:35,009 --> 00:15:37,759
if you allow half twists.
如果允许半曲。 

335
00:15:37,759 --> 00:15:41,470
And as puzzlers, we're particularly
作为困惑者，我们特别

336
00:15:41,470 --> 00:15:44,740
interested in this number, which you
对这个号码感兴趣，你

337
00:15:44,740 --> 00:15:50,759
would call, as a graph theorist, the diameter of the graph.
作为图论者，将称为图的直径。 

338
00:15:50,759 --> 00:15:53,200
Puzzlers call it God's number.
困惑者称其为上帝的数字。 

339
00:15:53,200 --> 00:15:57,110
If you were God or some omni--
如果您是上帝或一些全能的人， 

340
00:15:57,110 --> 00:15:59,019
something being.
某事。 

341
00:15:59,019 --> 00:16:01,860
You have the optimal algorithm for solving the Rubik's Cube.
您拥有解决魔方的最佳算法。 

342
00:16:01,860 --> 00:16:04,220
How many moves do you need If you always
您需要多少步，如果您总是

343
00:16:04,220 --> 00:16:06,100
follow the best path?
走最好的路？ 

344
00:16:06,100 --> 00:16:08,649
And the answer is, in the worst case, 11.
答案是在最坏的情况下为11。 

345
00:16:08,649 --> 00:16:14,129
So we're interested in the worst case of the best algorithm.
因此，我们对最佳算法的最坏情况感兴趣。 

346
00:16:14,129 --> 00:16:16,879
For two by two by two, the answer is 11.
对于二乘二乘二，答案是11。 

347
00:16:16,879 --> 00:16:20,049
For three by three by three, the answer is 20.
对于三乘三乘三，答案是20。 

348
00:16:20,049 --> 00:16:23,069
That was just proved last summer with a couple
去年夏天，一对夫妇证明了这一点

349
00:16:23,070 --> 00:16:24,449
years of computer time.
年的计算机时间。 

350
00:16:24,649 --> 00:16:25,799
For four by four by four--
四乘四乘四

351
00:16:25,799 --> 00:16:26,758
I don't have one here--
我这里没有一个

352
00:16:26,759 --> 00:16:28,258
I think we'll never know the answer.
我想我们永远不会知道答案。 

353
00:16:28,258 --> 00:16:30,324
For five by five by five, we'll never know the answer.
对于五乘五乘五，我们永远不会知道答案。 

354
00:16:30,524 --> 00:16:33,819
For six, for seven, same deal.
六个，七个，同样的交易。 

355
00:16:33,820 --> 00:16:36,330
But for two by two by two, you can compute it.
但是对于二乘二乘二，您可以计算出来。 

356
00:16:36,330 --> 00:16:37,979
You will compute it on your problem set.
您将根据自己的问题集进行计算。 

357
00:16:38,179 --> 00:16:40,399
And it's kind of nice to know because it
很高兴知道

358
00:16:40,399 --> 00:16:46,799
says whatever configuration I'm in, I can solve it in 11 moves.
说我所使用的任何配置，我都可以在11个步骤中解决。 

359
00:16:46,799 --> 00:16:49,439
But the best known way to compute it,
但是最著名的计算方法

360
00:16:49,440 --> 00:16:54,220
is basically to construct this graph one layer at a time
基本上是一次构造该图

361
00:16:54,220 --> 00:16:55,470
until you're done.
直到完成。 

362
00:16:55,470 --> 00:16:57,109
And then you know what the diameter is.
然后您知道直径是多少。 

363
00:16:57,309 --> 00:17:00,909
The trouble is, in between here this grows exponentially.
问题是，在这之间，它成倍增长。 

364
00:17:00,909 --> 00:17:03,179
At some point, it decreases a little bit.
在某些时候，它会减少一点。 

365
00:17:03,179 --> 00:17:04,970
But getting over that exponential hump
但是克服那指数的驼峰

366
00:17:04,970 --> 00:17:06,564
is really hard.
真的很难

367
00:17:06,564 --> 00:17:08,980
And for three by three by three, they used a lot of tricks
而三乘三乘三，他们使用了很多技巧

368
00:17:08,980 --> 00:17:13,490
to speed up the algorithm, but in the end
加快算法，但最终

369
00:17:13,490 --> 00:17:15,759
it's essentially a breadth-first search.
这本质上是广度优先的搜索。 

370
00:17:15,759 --> 00:17:17,358
What's a breadth-first search?
什么是广度优先搜索？ 

371
00:17:17,358 --> 00:17:19,059
This going layer by layer.
这层层走。 

372
00:17:19,059 --> 00:17:22,429
So we're going to formalize that in a moment.
因此，我们暂时将其正式化。 

373
00:17:22,430 --> 00:17:24,888
But that is the problem.
但这就是问题所在。 

374
00:17:25,088 --> 00:17:37,319
So just for fun, any guesses what
所以只是为了好玩，任何猜测

375
00:17:37,319 --> 00:17:40,019
the right answer is for an n by n by n Rubik's cube?
正确的答案是对于一个n×n×n的Rubik立方体？ 

376
00:17:40,019 --> 00:17:41,721
What's the diameter?
直径是多少？ 

377
00:17:41,721 --> 00:17:43,720
Not an exact answer, because I think we'll never
没有确切的答案，因为我认为我们永远不会

378
00:17:43,720 --> 00:17:44,649
know the exact answer.
知道确切的答案。 

379
00:17:44,849 --> 00:17:48,557
But if I want theta something, what
但是如果我想要theta，那

380
00:17:48,557 --> 00:17:50,279
do you think the something is?
你认为这是什么吗？ 

381
00:17:50,279 --> 00:17:54,648



382
00:17:54,648 --> 00:17:56,731
How many people here have solved the Rubik's Cube?
这里有多少人解决了魔方魔方？ 

383
00:17:56,731 --> 00:17:58,129
Ever?
曾经吗

384
00:17:58,130 --> 00:18:00,309
So you know what we're talking about here.
所以您知道我们在这里谈论什么。 

385
00:18:00,509 --> 00:18:04,390
Most people have worked on it.
大多数人都在为此工作。 

386
00:18:04,390 --> 00:18:08,079
To think about an n by n by n Rubik's Cube,
想一想n by n Rubik's Cube， 

387
00:18:08,279 --> 00:18:11,420
each side has area n squared.
每边的面积为n平方。 

388
00:18:11,420 --> 00:18:14,210
So total surface area is 6 n squared.
因此，总表面积为6 n平方。 

389
00:18:14,210 --> 00:18:18,718
So there's, roughly, stata n squared little cubies here.
因此，这里大约有方形的小立方体。 

390
00:18:18,718 --> 00:18:21,100
So what do you think the right [INAUDIBLE] is for n by n by n?
那么您认为正确的[音频不清晰]是n×n×n的呢？ 

391
00:18:21,300 --> 00:18:26,701



392
00:18:26,701 --> 00:18:27,480
No guesses?
没猜到吗？ 

393
00:18:27,480 --> 00:18:32,095



394
00:18:32,095 --> 00:18:33,450
AUDIENCE: n cubed?
听众：n立方？ 

395
00:18:33,450 --> 00:18:34,900
PROFESSOR: n cubed?
教授：n立方？ 

396
00:18:34,900 --> 00:18:36,339
Reasonable guess.
合理的猜测。 

397
00:18:36,539 --> 00:18:38,045
But wrong.
但是错了。 

398
00:18:38,045 --> 00:18:39,690
It's an upper bounds.
这是一个上限。 

399
00:18:39,690 --> 00:18:40,890
Why n cubed?
为什么n立方？ 

400
00:18:40,890 --> 00:18:43,432



401
00:18:43,432 --> 00:18:44,347
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

402
00:18:44,347 --> 00:18:48,834



403
00:18:48,834 --> 00:18:51,000
PROFESSOR: Oh, you're guessing based on the numbers.
教授：哦，您是根据数字猜测的。 

404
00:18:51,000 --> 00:18:51,499
Yeah.
是的

405
00:18:51,499 --> 00:18:53,500
The numbers are misleading, unfortunately.
不幸的是，数字令人误解。 

406
00:18:53,500 --> 00:18:56,465
It's the law of small numbers I guess.
我猜这是小数定律。 

407
00:18:56,465 --> 00:18:59,299
It doesn't really look right.
看起来并不正确。 

408
00:18:59,299 --> 00:19:00,635
I know the answer.
我知道答案。 

409
00:19:00,635 --> 00:19:02,009
I know the answer because we just
我知道答案，因为我们只是

410
00:19:02,009 --> 00:19:03,259
wrote a paper with the answer.
用答案写了一篇论文。 

411
00:19:03,259 --> 00:19:05,940
This is a new result. From this summer.
这是一个新结果。从今年夏天开始。 

412
00:19:05,940 --> 00:19:08,129
But I'm curious.
但是我很好奇。 

413
00:19:08,329 --> 00:19:11,049
To me the obvious answer is n squared because there's
对我来说，显而易见的答案是n平方，因为

414
00:19:11,049 --> 00:19:12,700
about n squared cubies.
大约n个平方的立方。 

415
00:19:12,700 --> 00:19:15,139
And it's not so hard to show in a constant number moves
而且显示恒定数量的移动并不难

416
00:19:15,339 --> 00:19:19,010
you can solve a constant number of cubies.
您可以解决恒定数量的Cubis。 

417
00:19:19,010 --> 00:19:20,759
If you think about the general algorithms,
如果您考虑一般算法， 

418
00:19:20,759 --> 00:19:22,675
like if you've ever looked up professor's cube
就像你曾经看过教授的立方体

419
00:19:22,675 --> 00:19:25,199
and how to solve it, you're doing like 10 moves,
以及解决方法，您正在做10招， 

420
00:19:25,200 --> 00:19:27,720
and then maybe you swap two cubies
然后也许您交换了两个cubics 

421
00:19:27,720 --> 00:19:30,529
which you can use to solve a couple of cubies
您可以用来解决几个问题

422
00:19:30,529 --> 00:19:31,910
in a constant number of moves.
以恒定的步伐移动。 

423
00:19:31,910 --> 00:19:36,400
So n squared would be the standard answer
所以n平方将是标准答案

424
00:19:36,400 --> 00:19:38,399
if you're following standard algorithms.
如果您遵循标准算法。 

425
00:19:38,599 --> 00:19:41,224
But it turns out, you can do a little bit better.
但事实证明，您可以做得更好。 

426
00:19:41,224 --> 00:19:43,349
And the right answer is n squared divided by log n.
正确的答案是n平方除以log n。 

427
00:19:43,349 --> 00:19:45,049
I think it's cool.
我觉得很酷。 

428
00:19:45,049 --> 00:19:46,813
Hopefully, you guys can appreciate that.
希望你们能体会到这一点。 

429
00:19:46,814 --> 00:19:48,980
Not a lot of people can appreciate n squared divided
没有多少人可以欣赏n平方除法

430
00:19:48,980 --> 00:19:52,365
by log n, but here in algorithms, we're all about n
通过log n，但是在算法中，我们都是关于n 

431
00:19:52,365 --> 00:19:53,289
squared over log n.
平方对数n。 

432
00:19:53,289 --> 00:19:57,769



433
00:19:57,769 --> 00:20:00,420
If you're interested, the paper's on my website.
如果您有兴趣，可以在我的网站上找到该论文。 

434
00:20:00,420 --> 00:20:03,389
I think its called, Algorithms For Solving Rubik's Cubes.
我认为它的名字叫“解决魔方的算法”。 

435
00:20:03,589 --> 00:20:05,109
There's a constant there.
那里有一个常数。 

436
00:20:05,109 --> 00:20:06,979
Current constant is not so good.
电流常数不是很好。 

437
00:20:06,980 --> 00:20:08,319
Let's say it's in the millions.
假设它以百万计。 

438
00:20:08,319 --> 00:20:11,759
[LAUGHTER]
 [笑声] 

439
00:20:11,759 --> 00:20:13,009
You've got to start somewhere.
您必须从某个地方开始。 

440
00:20:13,009 --> 00:20:15,753



441
00:20:15,753 --> 00:20:17,419
The next open problem will be to improve
下一个开放的问题将是改善

442
00:20:17,420 --> 00:20:19,170
that constant to something reasonable that
恒定的东西

443
00:20:19,170 --> 00:20:20,720
maybe is close to 20.
也许接近20。 

444
00:20:20,720 --> 00:20:25,250
But we're far from that.
但是，我们远非如此。 

445
00:20:25,250 --> 00:20:27,144
Let's talk about graph representation.
让我们谈谈图形表示。 

446
00:20:27,144 --> 00:20:31,288



447
00:20:31,288 --> 00:20:33,079
Before we can talk about exporting a graph,
在我们讨论导出图形之前， 

448
00:20:33,079 --> 00:20:36,679
we need to know what we're given as input.
我们需要知道输入的内容。 

449
00:20:36,680 --> 00:20:39,950
And there's basically one standard representation
基本上有一个标准表示

450
00:20:39,950 --> 00:20:43,509
and a bunch of variations of it.
和它的许多变化。 

451
00:20:43,509 --> 00:20:45,125
And they're called adjacency lists.
它们被称为邻接表。 

452
00:20:45,125 --> 00:20:48,089



453
00:20:48,089 --> 00:20:49,720
So the idea with an adjacency list,
所以有一个邻接表的想法， 

454
00:20:49,720 --> 00:20:58,435
is you have an array called Adj, for adjacency
您是否有一个名为Adj的数组，用于邻接

455
00:20:58,435 --> 00:21:02,289
of size V. Each element in the array
大小为V。数组中的每个元素

456
00:21:02,289 --> 00:21:03,734
is a pointer to a linked list.
是指向链表的指针。 

457
00:21:03,734 --> 00:21:07,609



458
00:21:07,609 --> 00:21:12,259
And the idea is that this array is indexed by a vertex.
想法是该数组由顶点索引。 

459
00:21:12,259 --> 00:21:18,960



460
00:21:18,960 --> 00:21:21,170
So we're imagining a world where we
所以我们正在想象一个世界

461
00:21:21,170 --> 00:21:23,500
can index arrays by vertices.
可以按顶点索引数组。 

462
00:21:23,500 --> 00:21:25,960
So maybe, you just label your vertices
所以也许，您只标记顶点

463
00:21:25,960 --> 00:21:27,730
zero through v minus 1.
零到v减去1。 

464
00:21:27,730 --> 00:21:29,759
Then that's a regular array.
那是一个常规数组。 

465
00:21:29,759 --> 00:21:31,801
Or, if you want to get fancy, you
或者，如果您想花哨， 

466
00:21:31,801 --> 00:21:35,199
can think of a vertex as an arbitrary hashable thing,
可以将顶点视为任意可哈希的事物， 

467
00:21:35,200 --> 00:21:37,700
and Adj is actually a hash table.
而Adj实际上是一个哈希表。 

468
00:21:37,700 --> 00:21:39,809
And that's how you probably do it in Python.
这就是您可能在Python中执行的方式。 

469
00:21:39,809 --> 00:21:42,909
Maybe your vertices are objects, and this is just
也许您的顶点是对象，这仅仅是

470
00:21:42,910 --> 00:21:44,563
hashing based on the address of the object.
根据对象的地址进行哈希处理。 

471
00:21:44,763 --> 00:21:46,429
But we're not going to worry about that.
但是我们不会为此担心。 

472
00:21:46,430 --> 00:21:48,169
We're just going to write Adj of u.
我们将要写您的Adj。 

473
00:21:48,369 --> 00:21:50,559
Assume that somehow you can get to the linked list
假设您可以通过某种方式进入链接列表

474
00:21:50,559 --> 00:21:51,768
corresponding to that vertex.
对应于该顶点。 

475
00:21:51,768 --> 00:22:00,680



476
00:22:00,680 --> 00:22:02,420
And the idea is, for every vertex
想法是，对于每个顶点

477
00:22:02,420 --> 00:22:06,259
we just store its neighbors, namely
我们只是存储它的邻居，即

478
00:22:06,259 --> 00:22:10,220
the vertices you can reach by one step from u.
您可以从u一步到达的顶点。 

479
00:22:10,220 --> 00:22:13,150
So I'm going to define that a little more formally.
因此，我将对此进行更正式的定义。 

480
00:22:13,150 --> 00:22:16,879
Adj of u is going to be the set of all vertices,
 u的调整将是所有顶点的集合， 

481
00:22:17,079 --> 00:22:22,429
V, such that u, v is an edge.
 V，这样u，v是边。 

482
00:22:22,430 --> 00:22:31,119



483
00:22:31,319 --> 00:22:35,990
So if I have a vertex like b, Adj of b
所以如果我有一个像b这样的顶点

484
00:22:35,990 --> 00:22:38,684
is going to be both a and c because in one step
将同时是a和c，因为一步

485
00:22:38,684 --> 00:22:42,009
there are outgoing edges from b to a and b to c.
从b到a以及b到c有出射边。 

486
00:22:42,009 --> 00:22:44,730
So Adj of b is a, c.
所以b的Adj是a，c。 

487
00:22:44,730 --> 00:22:52,259



488
00:22:52,259 --> 00:22:53,529
In that graph.
在那个图中。 

489
00:22:53,529 --> 00:22:56,619
I should have labeled the vertices something different.
我应该给顶点标注一些不同的东西。 

490
00:22:56,619 --> 00:23:02,669
Adj of a is going to be just c because you can't
 A的调整将只是c，因为您不能

491
00:23:02,670 --> 00:23:05,144
get with one step from a to b.
从a到b迈出一步。 

492
00:23:05,144 --> 00:23:08,079
The edge is in the wrong direction.
边缘方向错误。 

493
00:23:08,079 --> 00:23:13,240
And Adj of c is b.
 c的调整是b。 

494
00:23:13,240 --> 00:23:17,480



495
00:23:17,480 --> 00:23:19,259
I think that definition's pretty clear.
我认为这个定义很明确。 

496
00:23:19,259 --> 00:23:23,289
For undirected graphs, you just put braces here.
对于无向图，您只需在此处放括号。 

497
00:23:23,289 --> 00:23:24,710
Which means you store--
这意味着您存储- 

498
00:23:24,710 --> 00:23:25,980
I mean, it's the same thing.
我的意思是，这是同一回事。 

499
00:23:25,980 --> 00:23:29,180
Here Adj of c is going to be a, b, and d, as you
这里的c的调整将是a，b和d 

500
00:23:29,180 --> 00:23:33,200
can get in one step from c to a, from c to b, from c to d.
从c到a，从c到b，从c到d可以一步到位。 

501
00:23:33,200 --> 00:23:34,519
For pretty much every--
几乎每个

502
00:23:34,519 --> 00:23:36,700
At least for graph exploration problems,
至少对于图探索问题， 

503
00:23:36,700 --> 00:23:38,379
this is the representation you want.
这是您想要的表示形式。 

504
00:23:38,579 --> 00:23:39,849
Because you're at some vertex, and you want to know,
因为您在某个顶点，并且您想知道， 

505
00:23:39,849 --> 00:23:40,929
where can I go next.
我下一步可以去哪里。 

506
00:23:40,930 --> 00:23:44,359
And Adj of that vertex tells you exactly where you can go next.
该顶点的Adj会告诉您确切的下一步。 

507
00:23:44,559 --> 00:23:45,829
So this is what you want.
这就是您想要的。 

508
00:23:45,829 --> 00:23:50,029



509
00:23:50,029 --> 00:23:53,039
There's a lot of different ways to actually implement
实际上有很多不同的方法

510
00:23:53,039 --> 00:23:56,539
adjacency lists.
邻接表。 

511
00:23:56,539 --> 00:23:59,440
I've talked about two of them.
我已经讨论了其中两个。 

512
00:23:59,440 --> 00:24:02,720
You could have the vertices labeled zero to v minus 1,
您可以将顶点标记为0到v减去1， 

513
00:24:02,720 --> 00:24:05,019
and then this is, literally, an array.
然后，这实际上是一个数组。 

514
00:24:05,019 --> 00:24:06,119
And you have--
你有 - 

515
00:24:06,119 --> 00:24:08,459
I guess I should draw.
我想我应该画画。 

516
00:24:08,460 --> 00:24:13,730
In this picture, Adj is an array.
在这张照片中，Adj是一个数组。 

517
00:24:13,730 --> 00:24:17,079
So you've got a, b, and c.
这样您就有了a，b和c。 

518
00:24:17,079 --> 00:24:20,490
Each one of them is a pointer to a linked list.
它们每个都是指向链接列表的指针。 

519
00:24:20,490 --> 00:24:27,509
This one's actually going to be a, c, and we're done.
这个实际上是a，c，我们完成了。 

520
00:24:27,509 --> 00:24:30,819
Sorry, that was b.
抱歉，那是b。 

521
00:24:30,819 --> 00:24:33,519
Who said it had to be alphabetical order?
谁说这必须是字母顺序？ 

522
00:24:33,519 --> 00:24:38,109
A is a pointer to c, c is a pointer to b.
 A是指向c的指针，c是指向b的指针。 

523
00:24:38,109 --> 00:24:40,569
That's explicitly how you might represent it.
这就是您可能如何表示的方式。 

524
00:24:40,569 --> 00:24:43,349
This might be a hash table instead of an array,
这可能是哈希表而不是数组， 

525
00:24:43,349 --> 00:24:45,869
if you have weirder vertices.
如果您有怪异的顶点。 

526
00:24:45,869 --> 00:24:48,369
You can also do it in a more object-oriented fashion.
您也可以以更面向对象的方式进行操作。 

527
00:24:48,369 --> 00:24:55,589



528
00:24:55,589 --> 00:24:59,089
For every vertex, v, you can make the vertices objects,
对于每个顶点v，您都可以创建顶点对象， 

529
00:24:59,089 --> 00:25:05,929
and v dot neighbors could store what
 V点邻居可以存储什么

530
00:25:05,930 --> 00:25:08,460
we're defining over there to be Adj
我们在那边定义为Adj 

531
00:25:08,460 --> 00:25:13,630
of v. This would be the more object-oriented way to do it
 v。这将是更面向对象的方法

532
00:25:13,630 --> 00:25:15,839
I've thought a lot about this, and I like this,
我已经考虑了很多，我喜欢

533
00:25:16,039 --> 00:25:19,009
and usually when I implement graphs this is what I do.
通常，当我实现图形时，这就是我要做的。 

534
00:25:19,009 --> 00:25:23,200
But it is actually convenient to have this representation.
但是实际上有这种表示很方便。 

535
00:25:23,200 --> 00:25:25,664
There's a reason the textbook uses this representation.
教科书使用这种表示形式是有原因的。 

536
00:25:25,664 --> 00:25:28,039
Because, if you've already got some vertices lying around
因为，如果您已经有一些顶点在附近

537
00:25:28,039 --> 00:25:31,149
and you want to have multiple graphs on those vertices,
并且您想要在这些顶点上有多个图， 

538
00:25:31,150 --> 00:25:33,710
this lets you do that.
这可以让您做到这一点。 

539
00:25:33,710 --> 00:25:37,933
You can define multiple Adj arrays, one for graph one, one
您可以定义多个Adj数组，一个用于图一，一个

540
00:25:37,933 --> 00:25:39,349
for graph two, one for graph three
对于图二，对于图三

541
00:25:39,349 --> 00:25:41,789
but they can all talk about the same vertices.
但是他们都可以谈论相同的顶点。 

542
00:25:41,789 --> 00:25:45,409
Whereas here, vertex can only belong to one graph.
而在这里，顶点只能属于一个图形。 

543
00:25:45,410 --> 00:25:48,259
It can only have one neighbor structure
它只能有一个邻居结构

544
00:25:48,259 --> 00:25:49,390
that says what happens.
那说明发生了什么。 

545
00:25:49,390 --> 00:25:51,000
If you're only dealing with one graph,
如果您只处理一张图， 

546
00:25:51,000 --> 00:25:52,849
this is probably cleaner.
这可能更干净。 

547
00:25:52,849 --> 00:25:56,219
But with multiple graphs, which will happen even in this class,
但是有了多个图，即使在此类中也会发生这种情况， 

548
00:25:56,220 --> 00:26:00,534
adjacency lists are kind of the way to go.
邻接表是一种处理方式。 

549
00:26:00,534 --> 00:26:02,450
You can also do implicitly-represented graphs.
您也可以做隐式表示的图。 

550
00:26:02,450 --> 00:26:13,379



551
00:26:13,579 --> 00:26:20,595
Which would be to say, Adj of u is a function.
也就是说，u的Adj是一个函数。 

552
00:26:20,595 --> 00:26:23,960



553
00:26:23,960 --> 00:26:36,660
Or v dot neighbors is a method of the vertex class.
或v点邻居是顶点类的一种方法。 

554
00:26:36,660 --> 00:26:39,210
Meaning, it's not just stored there explicitly.
意思是，它不只是显式地存储在那里。 

555
00:26:39,210 --> 00:26:41,269
Whenever you need it, you call this function
无论何时需要，都可以调用此函数

556
00:26:41,269 --> 00:26:45,500
and it computes what you want.
并计算出您想要的

557
00:26:45,500 --> 00:26:47,420
This is useful because it uses less space.
这很有用，因为它使用的空间更少。 

558
00:26:47,420 --> 00:26:52,029
You could say this uses zero space or maybe v space.
您可以说这使用零空间或v空间。 

559
00:26:52,029 --> 00:26:53,470
One for each vertex.
每个顶点一个。 

560
00:26:53,470 --> 00:26:53,938
It depends.
这取决于。 

561
00:26:54,138 --> 00:26:56,179
Maybe you don't even need to explicitly represent
也许您甚至不需要明确表示

562
00:26:56,180 --> 00:26:57,879
all the vertices.
所有的顶点。 

563
00:26:58,079 --> 00:27:03,500
You start with some vertex, and given a vertex, somehow
您从某个顶点开始，然后以某种方式给定一个顶点

564
00:27:03,500 --> 00:27:06,609
you know how to compute, let's say in constant time or linear
您知道如何进行计算，例如恒定时间或线性

565
00:27:06,609 --> 00:27:10,269
time or something, the neighbors of that vertex.
时间或某物，那个顶点的邻居。 

566
00:27:10,269 --> 00:27:11,839
And then from there, you can keep
然后从那里开始

567
00:27:11,839 --> 00:27:13,339
searching, keep computing neighbors,
搜索，保持计算邻居， 

568
00:27:13,339 --> 00:27:14,589
until you find what you want.
直到找到想要的东西。 

569
00:27:14,589 --> 00:27:16,505
Maybe you don't have to build the whole graph,
也许您不必构建整个图形， 

570
00:27:16,506 --> 00:27:19,573
you just need to build enough of it until you find your answer.
您只需要构建足够的内容，直到找到答案。 

571
00:27:19,773 --> 00:27:21,314
Whatever answer you're searching for.
无论您要寻找什么答案。 

572
00:27:21,315 --> 00:27:23,649
Can you think of a situation where that might be the case?
您能想到这种情况吗？ 

573
00:27:23,849 --> 00:27:27,204



574
00:27:27,204 --> 00:27:29,329
Where implicit representation would be a good idea?
隐式表示哪里是个好主意？ 

575
00:27:29,329 --> 00:27:29,829
Yes.
是。 

576
00:27:29,829 --> 00:27:30,710
Rubik's Cubes.
魔方。 

577
00:27:30,710 --> 00:27:31,342
They're really good.
他们真的很好。 

578
00:27:31,542 --> 00:27:33,169
I never want to build this space.
我永远不想建立这个空间。 

579
00:27:33,170 --> 00:27:35,859
It has a bajillion states.
它有一个十亿个州。 

580
00:27:36,059 --> 00:27:37,169
A bajillion vertices.
数以万计的顶点。 

581
00:27:37,170 --> 00:27:38,779
It would take forever.
这将永远。 

582
00:27:38,779 --> 00:27:41,579
There's more configurations of this cube
此多维数据集还有更多配置

583
00:27:41,579 --> 00:27:45,589
than there are particles in the known universe.
比已知宇宙中的粒子还要多。 

584
00:27:45,589 --> 00:27:47,701
I just computed that in my head.
我只是在脑子里计算了一下。 

585
00:27:47,701 --> 00:27:49,919
[LAUGHTER]
 [笑声] 

586
00:27:50,119 --> 00:27:52,129
I have done this computation recently,
我最近进行了此计算， 

587
00:27:52,130 --> 00:27:55,419
and for five by five by five it's like 10 to the 40 states.
五到五乘五代表40个州中的10个。 

588
00:27:55,619 --> 00:27:58,358
Or 10 to the 40, 10 to the 60.
或10到40，10到60。 

589
00:27:58,358 --> 00:28:00,399
There's about 10 to the 80 particles in the known
在已知的粒子中，大约有10到80个粒子

590
00:28:00,400 --> 00:28:00,940
universe.
宇宙。 

591
00:28:00,940 --> 00:28:02,240
10 to the 83 or something.
 10到83左右。 

592
00:28:02,240 --> 00:28:06,750
So this is probably 10 to the 200 or so.
因此，这大概是10到200左右。 

593
00:28:06,750 --> 00:28:07,862
It's a lot.
好多

594
00:28:07,862 --> 00:28:08,869
You never want to build that.
您永远不需要构建它。 

595
00:28:09,069 --> 00:28:11,819
But, it's very easy to represent this state.
但是，很容易表示这种状态。 

596
00:28:11,819 --> 00:28:13,519
Just store where all the cubies are.
只需存储所有cubices所在的位置即可。 

597
00:28:13,519 --> 00:28:16,410
And it's very easy to see what are all the configurations you
而且很容易看到您的所有配置

598
00:28:16,410 --> 00:28:17,640
can reach in one move.
一手就能达成。 

599
00:28:17,640 --> 00:28:20,630
Just try this move, try this move, try this move.
只需尝试此举，尝试此举，再尝试此举即可。 

600
00:28:20,630 --> 00:28:22,371
Put it back and try the next move.
放回去并尝试下一步。 

601
00:28:22,371 --> 00:28:22,669
And so on.
等等。 

602
00:28:22,869 --> 00:28:25,659



603
00:28:25,660 --> 00:28:27,399
For an m by n by n cube in order n
对于m×n×n立方体，顺序为n 

604
00:28:27,599 --> 00:28:30,209
time, you can list all the order n next states.
时间，您可以列出所有n个下一个状态的命令。 

605
00:28:30,210 --> 00:28:32,049
You can list all the order n neighbors.
您可以列出所有n个邻居。 

606
00:28:32,049 --> 00:28:35,223
And so you can keep exploring, searching for your state.
因此，您可以继续探索，搜索状态。 

607
00:28:35,223 --> 00:28:37,389
Now you don't want to explore too far for that cube,
现在，您不想为那个立方体探索太多， 

608
00:28:37,390 --> 00:28:40,819
but at least you're not hosed just
但至少你不只是用软管

609
00:28:41,019 --> 00:28:44,190
from the problem of representing the graph.
从表示图形的问题出发。 

610
00:28:44,190 --> 00:28:46,029
So even for two by two by two, it's
所以即使是二乘二乘

611
00:28:46,029 --> 00:28:48,164
useful to do this mostly to save space.
这样做主要是为了节省空间。 

612
00:28:48,164 --> 00:28:50,309
You're not really saving time.
您并没有真正节省时间。 

613
00:28:50,309 --> 00:28:54,960
But you'd like to not have to store all 264 million states
但是您不必存储所有2.64亿个州

614
00:28:54,960 --> 00:29:01,649
because it's going to be several gigabytes and it's annoying.
因为它将达到数GB，这很烦人。 

615
00:29:01,849 --> 00:29:05,649
Speaking of space-- ignoring the implicit representation--
说到空间-忽略隐式表示- 

616
00:29:05,650 --> 00:29:08,755
how much space does this representation require?
此表示需要多少空间？ 

617
00:29:08,755 --> 00:29:19,619



618
00:29:19,819 --> 00:29:23,089
V plus E. This Is going to be the bread and butter
 V加E。这将成为面包和黄油

619
00:29:23,089 --> 00:29:24,608
of our graph algorithms.
我们的图算法。 

620
00:29:24,608 --> 00:29:27,149
Most of the things we're going to talk about achieve V plus E
我们要谈论的大多数事情都达到V加E 

621
00:29:27,150 --> 00:29:27,650
time.
时间。 

622
00:29:27,650 --> 00:29:28,889
This is essentially optimal.
这本质上是最佳的。 

623
00:29:29,089 --> 00:29:32,161
It's linear in the size of your graph.
它在图形大小上是线性的。 

624
00:29:32,162 --> 00:29:34,700
You've got V vertices, E edges.
您有V个顶点，E个边。 

625
00:29:34,700 --> 00:29:37,160
Technically, in case you're curious,
从技术上讲，如果您感到好奇， 

626
00:29:37,160 --> 00:29:40,359
this is really the size of V plus the size of E.
这实际上是V的大小加上E的大小。 

627
00:29:40,559 --> 00:29:44,688
But in the textbook, and I guess in the world,
但是在教科书中，我想全世界

628
00:29:44,689 --> 00:29:46,980
we just omit those sizes of whenever they're in a theta
我们只是忽略了它们在theta中的大小

629
00:29:46,980 --> 00:29:49,180
notation or Big O notation.
标记或Big O标记。 

630
00:29:49,180 --> 00:29:50,930
So number vertices plus number of edges.
因此，顶点数加上边数。 

631
00:29:50,930 --> 00:29:52,304
that sort of the bare minimum you
那种最低限度的最低要求

632
00:29:52,304 --> 00:29:55,255
need if you want an explicit representation of the graph.
如果需要图形的显式表示，则需要。 

633
00:29:55,455 --> 00:29:56,829
And we achieve that because we've
我们实现这一目标是因为我们已经

634
00:29:56,829 --> 00:30:00,879
got we've got v space just to store the vertices in an array.
我们有v空间仅用于将顶点存储在数组中。 

635
00:30:00,880 --> 00:30:03,619
And then if you add up--
然后，如果您加起来- 

636
00:30:03,819 --> 00:30:06,676
Each of these is an edge.
这些都是优势。 

637
00:30:06,676 --> 00:30:08,009
You have to be a little careful.
你要小心点

638
00:30:08,009 --> 00:30:11,569
In undirected graphs, each of these is a half edge.
在无向图中，每一个都是半边。 

639
00:30:11,569 --> 00:30:15,339
So there's actually two times e nodes over here.
因此，实际上这里有两个e节点。 

640
00:30:15,339 --> 00:30:19,389
But it's theta E. So theta V plus E
但这是thetaE。所以theta V加E 

641
00:30:19,390 --> 00:30:22,140
is the amount of space we need.
是我们需要的空间量。 

642
00:30:22,140 --> 00:30:24,889
And ideally, all our algorithms will run in this much time.
理想情况下，我们所有的算法都将在这么长时间内运行。 

643
00:30:25,089 --> 00:30:28,549
Because that's what you need just to look at the graph.
因为这就是您只需要查看图表所需要的。 

644
00:30:28,549 --> 00:31:06,710



645
00:31:06,710 --> 00:31:11,389
So let's do an actual algorithm, which is breadth-first search.
因此，让我们做一个实际的算法，即广度优先搜索。 

646
00:31:11,589 --> 00:31:14,919



647
00:31:14,920 --> 00:31:18,420
So to the simplest algorithm you can think of in graphs.
因此，对于最简单的算法，您可以在图形中想到。 

648
00:31:18,420 --> 00:31:20,889
I've already outlined it several times.
我已经概述了好几次了。 

649
00:31:21,089 --> 00:31:22,639
You start at some node.
您从某个节点开始。 

650
00:31:22,640 --> 00:31:24,609
You look at all the nodes you can get to from there.
您查看从那里可以到达的所有节点。 

651
00:31:24,809 --> 00:31:26,975
You look at all the nodes you can get to from there.
您查看从那里可以到达的所有节点。 

652
00:31:26,976 --> 00:31:29,099
Keep going until you're done.
继续直到完成。 

653
00:31:29,299 --> 00:31:32,109
So this is going to explore all of the vertices that
因此，这将探索所有的顶点

654
00:31:32,109 --> 00:31:34,029
are reachable from a node.
从一个节点可达。 

655
00:31:34,029 --> 00:31:36,720



656
00:31:36,720 --> 00:31:39,269
The challenge-- The one annoying thing
挑战-一件事烦人

657
00:31:39,269 --> 00:31:41,519
about breadth-first search and why this is not trivial
关于广度优先搜索的原因，以及为什么这样做并不简单

658
00:31:41,519 --> 00:31:44,279
is that there can be some edges that
可能会有一些边缘

659
00:31:44,279 --> 00:31:52,339
go sort of backwards, like that, to some previous layer.
像这样倒退到上一层。 

660
00:31:52,339 --> 00:31:54,241
Actually, that's not true, is it?
其实不是这样，是吗？ 

661
00:31:54,241 --> 00:31:58,089



662
00:31:58,089 --> 00:31:59,274
This can't happen.
这不可能发生。 

663
00:31:59,275 --> 00:32:02,220
You see why?
你明白为什么吗？ 

664
00:32:02,220 --> 00:32:06,279
Because if that edge existed, then from this node
因为如果存在该边缘，则从该节点开始

665
00:32:06,279 --> 00:32:08,204
you'd be able to get here.
您将能够到达这里。 

666
00:32:08,204 --> 00:32:10,179
So in an undirected graph, that can't happen.
因此，在无向图中不会发生这种情况。 

667
00:32:10,180 --> 00:32:12,519
In a directed graph, you could conceivably
在有向图中，可以想象

668
00:32:12,519 --> 00:32:13,660
have a back edge like that.
有这样的后缘。 

669
00:32:13,660 --> 00:32:16,269
You'd have to realize, oh, that's a vertex I've already
您必须意识到，哦，这是我已经拥有的一个顶点

670
00:32:16,269 --> 00:32:19,450
seen, I don't want to put it here, even though it's
看到了，即使它是

671
00:32:19,450 --> 00:32:21,269
something I can reach from this node,
我可以从这个节点到达的东西

672
00:32:21,269 --> 00:32:22,961
because I've already been there.
因为我已经去过那里。 

673
00:32:22,961 --> 00:32:24,710
We've got to worry about things like that.
我们必须担心这样的事情。 

674
00:32:24,710 --> 00:32:27,259



675
00:32:27,259 --> 00:32:29,970
That's, I guess, the main thing to worry about.
我想这就是主要要担心的事情。 

676
00:32:29,970 --> 00:32:34,419



677
00:32:34,619 --> 00:32:36,614
So our goal is to visit all the nodes--
所以我们的目标是访问所有节点

678
00:32:36,615 --> 00:32:40,950



679
00:32:40,950 --> 00:32:47,555
the vertices-- reachable from given node, s.
顶点-可从给定节点s到达。 

680
00:32:47,555 --> 00:32:51,470



681
00:32:51,470 --> 00:32:54,720
We want to achieve V plus E time.
我们要达到V加E的时间。 

682
00:32:54,720 --> 00:33:00,190



683
00:33:00,190 --> 00:33:10,529
And the idea is to look at the nodes that are
想法是看一下

684
00:33:10,529 --> 00:33:15,779
reachable first in zero moves.
零移动中首先到达。 

685
00:33:15,779 --> 00:33:17,039
Zero moves.
零动。 

686
00:33:17,039 --> 00:33:17,819
That's s.
是的。 

687
00:33:17,819 --> 00:33:20,389



688
00:33:20,390 --> 00:33:23,480
Then in one move.
然后一招。 

689
00:33:23,480 --> 00:33:27,650
Well that's everything you can reach from s in one step.
好了，一步就可以达到s的一切。 

690
00:33:27,650 --> 00:33:29,430
That's adjacency of s.
那是s的邻接。 

691
00:33:29,430 --> 00:33:32,609
And then two moves, and three moves, and so
然后是两个动作，三个动作，依此类推

692
00:33:32,809 --> 00:33:36,909
on until we run out of graph.
直到我们用完图表。 

693
00:33:36,910 --> 00:33:47,599
But we need to be careful to avoid duplicates.
但是我们需要注意避免重复。 

694
00:33:47,799 --> 00:33:51,089
We want to avoid revisiting vertices
我们要避免重新访问顶点

695
00:33:51,089 --> 00:33:52,089
for a couple of reasons.
有几个原因。 

696
00:33:52,089 --> 00:33:55,109
One is if we didn't, we would spend infinite time.
一是如果我们不这样做，我们将花费无限的时间。 

697
00:33:55,109 --> 00:33:56,944
Because we'd just go there and come back,
因为我们只是去那里再回来， 

698
00:33:56,944 --> 00:33:58,069
and go there and come back.
然后去那里再回来

699
00:33:58,069 --> 00:33:59,740
As long as there's at least one cycle,
只要至少有一个周期， 

700
00:33:59,740 --> 00:34:00,920
you're going to keep going around the cycle
您将继续循环

701
00:34:00,920 --> 00:34:03,279
forever and ever if you don't try to avoid duplicates.
如果您不尝试避免重复，那就永远。 

702
00:34:03,279 --> 00:34:05,706



703
00:34:05,707 --> 00:34:07,589
So let me write down some code for this algorithm.
因此，让我为该算法写下一些代码。 

704
00:34:07,789 --> 00:34:09,579
It's pretty straightforward.
这很简单。 

705
00:34:09,579 --> 00:34:12,190
So straightforward, we can be completely explicit
非常简单，我们可以完全明确

706
00:34:12,190 --> 00:34:13,829
and write pseudocode.
并编写伪代码。 

707
00:34:13,829 --> 00:34:18,824



708
00:34:18,824 --> 00:34:21,199
There's a few different ways to implement this algorithm.
有几种不同的方法可以实现此算法。 

709
00:34:21,199 --> 00:34:23,780
I'll show you my favorite.
我会告诉你我的最爱。 

710
00:34:23,780 --> 00:34:25,659
The textbook has a different favorite.
教科书有不同的喜好。 

711
00:34:25,659 --> 00:34:42,039



712
00:34:42,039 --> 00:34:44,739
I'm going to write in pure Python, I believe.
我相信，我将用纯Python编写。 

713
00:34:44,739 --> 00:35:57,369



714
00:35:57,369 --> 00:35:58,099
Almost done.
快完成了

715
00:35:58,099 --> 00:36:30,650



716
00:36:30,650 --> 00:36:32,960
I think I got that right.
我想我没错。 

717
00:36:33,159 --> 00:36:36,594
So this is at the end of the while-loop.
因此，这是在while循环的结尾。 

718
00:36:36,594 --> 00:36:39,271
And at that point we should be done.
在这一点上，我们应该完成。 

719
00:36:39,271 --> 00:36:40,730
We can do an actual example, maybe.
我们可以做一个实际的例子。 

720
00:36:40,730 --> 00:37:16,610



721
00:37:16,610 --> 00:37:19,559
I'm going to do it on an undirected graph,
我将在无向图上执行该操作

722
00:37:19,559 --> 00:37:22,469
but this algorithm works just as well on directed and undirected
但是该算法在定向和无定向上同样有效

723
00:37:22,469 --> 00:37:22,969
graphs.
图。 

724
00:37:22,969 --> 00:37:28,329



725
00:37:28,329 --> 00:37:30,949
There's an undirected graph.
有一个无向图。 

726
00:37:30,949 --> 00:37:34,889
We're given some start vertex, s,
我们得到了一些起始顶点s 

727
00:37:34,889 --> 00:37:37,429
and we're given the graph by being
我们得到的图形是

728
00:37:37,429 --> 00:37:39,849
given the adjacency lists.
给定邻接表。 

729
00:37:39,849 --> 00:37:42,599
So you could iterate over the vertices of that thing.
因此，您可以遍历该对象的顶点。 

730
00:37:42,599 --> 00:37:44,420
Given a vertex, you can list all the edges
给定一个顶点，您可以列出所有边缘

731
00:37:44,420 --> 00:37:47,112
you can reach in one step.
您可以一步一步到达。 

732
00:37:47,112 --> 00:37:48,570
And then the top of the algorithm's
然后是算法的顶部

733
00:37:48,570 --> 00:37:50,400
just some initialization.
只是一些初始化。 

734
00:37:50,400 --> 00:37:51,980
The basic structure--
基本结构

735
00:37:51,980 --> 00:37:55,889
We have this thing called the frontier, which is what we just
我们有一个叫做边境的东西，这就是

736
00:37:55,889 --> 00:37:58,920
reached on the previous level.
达到上一个级别。 

737
00:37:58,920 --> 00:38:04,480
I think that's going to be level i minus one.
我认为这将是我的水平减去一。 

738
00:38:04,480 --> 00:38:06,224
Just don't want to make an index error.
只是不想使索引错误。 

739
00:38:06,224 --> 00:38:08,929



740
00:38:08,929 --> 00:38:11,919
These are going to be all the things you can reach using
这些将是您可以使用的所有东西

741
00:38:11,920 --> 00:38:14,769
exactly i minus one moves.
我恰好减去一招。 

742
00:38:14,969 --> 00:38:17,019
And then next is going to be all the things
接下来就是所有的东西

743
00:38:17,019 --> 00:38:18,559
you can reach in i moves.
你可以达到我的举动。 

744
00:38:18,559 --> 00:38:21,309



745
00:38:21,309 --> 00:38:24,976
So to get started, what we know is s.
因此，开始之前，我们知道的是s。 

746
00:38:24,976 --> 00:38:28,579
s is what you can reach in zero moves.
 s是您零移动即可达到的目标。 

747
00:38:28,579 --> 00:38:31,539
So we set the level of s to be zero.
因此，我们将s的级别设置为零。 

748
00:38:31,539 --> 00:38:33,219
That's the first line of the code.
那是代码的第一行。 

749
00:38:33,219 --> 00:38:35,010
There's this other thing called the parent.
还有另一件事叫父母。 

750
00:38:35,010 --> 00:38:36,650
We'll worry about that later.
我们稍后会担心。 

751
00:38:36,650 --> 00:38:37,519
It's optional.
它是可选的。 

752
00:38:37,719 --> 00:38:40,699
It gives us some other fun structure.
它为我们提供了其他有趣的结构。 

753
00:38:40,699 --> 00:38:44,949
We set i to be one because we just finished level zero.
我们将i设为1，因为我们刚完成零级。 

754
00:38:44,949 --> 00:38:49,599
Frontier of what you can reach in level zero is just s itself.
您可以在零级达到的范围的边界本身就是s。 

755
00:38:49,599 --> 00:38:51,559
So we're going to put that on the list.
因此，我们将其列入清单。 

756
00:38:51,559 --> 00:38:54,869
That is level zero. i equals one So one minus one is zero.
那是零级。我等于一，所以一减一等于零。 

757
00:38:54,869 --> 00:38:56,359
All good.
都好。 

758
00:38:56,360 --> 00:38:57,809
And then we're going to iterate.
然后我们要进行迭代。 

759
00:38:57,809 --> 00:38:59,539
And this is going to be looking at--
而这将会是

760
00:38:59,539 --> 00:39:02,346
The end of the iteration is to increment i.
迭代的结尾是增加i。 

761
00:39:02,347 --> 00:39:03,730
So you could also call this a for-loop
因此，您也可以将其称为for循环

762
00:39:03,929 --> 00:39:05,762
except we don't know when it's going to end.
除了我们不知道什么时候结束。 

763
00:39:05,762 --> 00:39:09,019
So it's easier to think of i incrementing
因此，考虑到我增加时会更容易

764
00:39:09,019 --> 00:39:11,150
each step not knowing when we're going to stop.
每个步骤都不知道我们何时要停止。 

765
00:39:11,150 --> 00:39:12,990
We're going to stop whenever we run out of nodes.
每当节点用完时，我们都将停止。 

766
00:39:13,190 --> 00:39:16,786
So whenever frontier is a non-empty list.
因此，只要边界是一个非空列表。 

767
00:39:16,786 --> 00:39:18,369
the bulk of the work here is computing
这里的大部分工作是计算

768
00:39:18,369 --> 00:39:19,519
what the next level is.
下一个级别是什么。 

769
00:39:19,519 --> 00:39:20,860
That's called next.
那就是下一个。 

770
00:39:20,860 --> 00:39:22,329
It's going to be level i.
这将是我的水平。 

771
00:39:22,329 --> 00:39:23,309
We do some computation.
我们进行一些计算。 

772
00:39:23,309 --> 00:39:26,019
Eventually we have what's on the next level.
最终，我们有了下一个层次。 

773
00:39:26,019 --> 00:39:28,172
Then we set frontier next.
然后我们接下来设置边界。 

774
00:39:28,172 --> 00:39:29,380
Because that's our new level.
因为那是我们的新水平。 

775
00:39:29,380 --> 00:39:32,730
We increment i, and then invariant of frontier being
我们递增i，然后边界一直不变

776
00:39:32,929 --> 00:39:35,641
level i minus 1 is preserved.
级别i减去1被保留。 

777
00:39:35,641 --> 00:39:36,349
Right after here.
就在这里。 

778
00:39:36,349 --> 00:39:40,099
And then we just keep going till we run out of nodes.
然后，我们一直继续直到节点用尽。 

779
00:39:40,099 --> 00:39:42,230
How do we compute next?
接下来如何计算？ 

780
00:39:42,230 --> 00:39:44,210
Well, we look at every node in the frontier,
好吧，我们看一下边界中的每个节点， 

781
00:39:44,210 --> 00:39:47,659
and we look at all the nodes you can reach from those nodes.
然后我们查看您可以从这些节点到达的所有节点。 

782
00:39:47,659 --> 00:39:50,730
So every node, u, in the frontier and then we look at--
因此，您在边界中的每个节点，然后我们来看…… 

783
00:39:50,730 --> 00:39:53,110
So this means there is an edge from u
所以这意味着你有优势

784
00:39:53,110 --> 00:39:55,460
to v through the picture.
穿过图片。 

785
00:39:55,659 --> 00:39:58,519
We look at all the edges from all the frontier nodes
我们查看所有边界节点的所有边缘

786
00:39:58,519 --> 00:39:59,869
where you can go.
你可以去哪里。 

787
00:39:59,869 --> 00:40:02,329
And then the key thing is we check for duplicates.
然后关键是我们要检查重复项。 

788
00:40:02,329 --> 00:40:04,829
We see, have we seen this node before?
我们知道，我们以前见过这个节点吗？ 

789
00:40:04,829 --> 00:40:08,269
If we have, we would have set it's level to be something.
如果有的话，我们应该将它的级别设置为某种程度。 

790
00:40:08,269 --> 00:40:09,869
If we haven't seen it, it will not
如果我们没有看到它，它将不会

791
00:40:09,869 --> 00:40:14,159
be in the level hash table or the level dictionary.
在级别哈希表或级别字典中。 

792
00:40:14,159 --> 00:40:18,349
And so if it's not in there, we'll put it in there
因此，如果它不在其中，我们将其放入其中

793
00:40:18,349 --> 00:40:20,639
and add it to the next layer.
并将其添加到下一层。 

794
00:40:20,639 --> 00:40:22,859
So that's how you avoid duplicates.
这样便可以避免重复。 

795
00:40:22,860 --> 00:40:25,690
You set its level to make sure you will never visit it again,
您设置其级别以确保您再也不会访问它， 

796
00:40:25,889 --> 00:40:28,869
you add it to the next frontier, you iterate, you're done.
您将其添加到下一个边界，进行迭代，就完成了。 

797
00:40:28,869 --> 00:40:31,358



798
00:40:31,358 --> 00:40:32,900
This is one version of what you might
这是您可能会遇到的一个版本

799
00:40:32,900 --> 00:40:34,039
call a breadth-first search.
进行广度优先搜索。 

800
00:40:34,239 --> 00:40:36,269
And it achieves this goal, visiting
它实现了这一目标， 

801
00:40:36,269 --> 00:40:39,219
all the nodes reachable from s, in linear time.
所有节点从s到线性时间。 

802
00:40:39,219 --> 00:40:41,639
Let's see how it works on a real example.
让我们看看它是如何在一个真实示例中工作的。 

803
00:40:41,639 --> 00:40:43,739
So first frontier is this thing.
所以这是最前沿的事情。 

804
00:40:43,739 --> 00:40:46,669



805
00:40:46,670 --> 00:40:49,119
Frontier just has the node s, so we just look at s,
边境只有节点s，所以我们只看s， 

806
00:40:49,119 --> 00:40:50,929
and we look at all the edges from s.
然后我们查看s的所有边。 

807
00:40:50,929 --> 00:40:52,440
We get a and x.
我们得到a和x。 

808
00:40:52,440 --> 00:40:56,460
So those get added to the next frontier.
因此，这些将被添加到下一个领域。 

809
00:40:56,460 --> 00:41:01,039
Maybe before I go too far, let me switch colors.
也许在我走得太远之前，让我切换颜色。 

810
00:41:01,039 --> 00:41:05,699



811
00:41:05,699 --> 00:41:08,079
Multimedia here.
多媒体在这里。 

812
00:41:08,079 --> 00:41:12,576
So here's level one.
所以这是第一层。 

813
00:41:12,576 --> 00:41:17,269
All of these guys, we're going to set their level to one.
所有这些人，我们将其级别设置为1。 

814
00:41:17,269 --> 00:41:18,876
They can be reached in one step.
一步就可以达到。 

815
00:41:18,876 --> 00:41:19,710
That's pretty clear.
很清楚

816
00:41:19,710 --> 00:41:22,570
So now frontier is a and x.
所以现在边界是a和x。 

817
00:41:22,570 --> 00:41:24,380
That's what next becomes.
这就是接下来的事情。 

818
00:41:24,380 --> 00:41:26,039
Then frontier becomes next.
然后边界成为下一个。 

819
00:41:26,239 --> 00:41:28,509
And so we look at all the edges from a.
因此，我们从a看所有边缘。 

820
00:41:28,510 --> 00:41:31,110
That's going to be s and z.
那将是s和z。 

821
00:41:31,110 --> 00:41:33,730
s, we've already looked at, it already has a level set,
 s，我们已经看过了，已经设置了一个级别， 

822
00:41:33,730 --> 00:41:35,199
so we ignore that.
所以我们忽略了这一点。 

823
00:41:35,199 --> 00:41:35,879
So we look at z.
因此，我们看z。 

824
00:41:35,880 --> 00:41:38,000
Z does not have a level indicated here,
 Z没有此处指示的水平， 

825
00:41:38,199 --> 00:41:40,299
so we're going to set it to i which happens
所以我们将其设置为i 

826
00:41:40,300 --> 00:41:42,340
to be two at this point.
在这一点上要成为两个。 

827
00:41:42,340 --> 00:41:43,000
And we look at x.
我们看x。 

828
00:41:43,199 --> 00:41:45,159
It has neighbors s, d, and c.
它具有邻居s，d和c。 

829
00:41:45,159 --> 00:41:46,329
We look at s again.
我们再次看s。 

830
00:41:46,329 --> 00:41:48,679
We say, oh, we've already seen that yet again.
我们说，哦，我们已经再次看到了。 

831
00:41:48,679 --> 00:41:50,799
So we're worried about this taking a lot of time
所以我们担心这会花费很多时间

832
00:41:50,800 --> 00:41:54,090
because we look at s three times in total.
因为我们总共看了s三次。 

833
00:41:54,090 --> 00:41:56,289
Then we look at d.
然后我们看d。 

834
00:41:56,289 --> 00:41:59,239
d hasn't been set, so we set it to two. c hasn't been set,
 d尚未设置，因此我们将其设置为2。尚未设置c 

835
00:41:59,239 --> 00:42:00,219
so we set it to two.
所以我们将其设置为两个。 

836
00:42:00,219 --> 00:42:05,944
So the frontier at level two is that.
因此，在第二级的前沿是。 

837
00:42:05,945 --> 00:42:07,570
Then we look at all the neighbors of z.
然后我们看z的所有邻居。 

838
00:42:07,570 --> 00:42:09,489
There's a. a's already been set.
有个。已经设置好了。 

839
00:42:09,489 --> 00:42:10,780
Look at all the neighbors of d.
看看d的所有邻居。 

840
00:42:10,780 --> 00:42:11,170
There's x.
有x。 

841
00:42:11,369 --> 00:42:11,869
There's c.
有c。 

842
00:42:11,869 --> 00:42:12,702
Those have been set.
那些已经设置好了。 

843
00:42:12,702 --> 00:42:13,849
There's f.
有f。 

844
00:42:13,849 --> 00:42:16,440
This one gets added.
这被添加。 

845
00:42:16,440 --> 00:42:17,480
Then we look at c.
然后我们看c。 

846
00:42:17,480 --> 00:42:18,019
There's x.
有x。 

847
00:42:18,019 --> 00:42:19,769
That's been done. d's been done.
已经做完了。 d完成了。 

848
00:42:19,769 --> 00:42:20,690
f's been done.
 f已经完成。 

849
00:42:20,690 --> 00:42:23,369
v has not been done.
 v尚未完成。 

850
00:42:23,369 --> 00:42:27,299
So this becomes a frontier at level three.
因此，这成为第三级的前沿。 

851
00:42:27,300 --> 00:42:28,730
Then we look at level three.
然后我们看三级。 

852
00:42:28,929 --> 00:42:29,576
There's f.
有f。 

853
00:42:29,577 --> 00:42:31,210
D's been done, c's been done, b's been done.
 D已经完成，c已经完成，b已经完成。 

854
00:42:31,409 --> 00:42:34,529
We look at v. c's been done. f's been done.
我们来看v。c已经完成了。 f已经完成。 

855
00:42:34,530 --> 00:42:35,710
Nothing to add to next.
没有要添加的内容。 

856
00:42:35,710 --> 00:42:36,780
Next becomes empty.
下一步变为空。 

857
00:42:36,780 --> 00:42:38,039
Frontier becomes empty.
边界变空了。 

858
00:42:38,239 --> 00:42:39,529
The while-loop finishes.
 while循环结束。 

859
00:42:39,530 --> 00:42:40,760
TA DA!
塔达！ 

860
00:42:40,760 --> 00:42:43,510
We've computed-- we've visited all the vertices.
我们已经计算-我们已经访问了所有顶点。 

861
00:42:43,510 --> 00:42:44,253
Question.
题。 

862
00:42:44,452 --> 00:42:45,369
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

863
00:42:45,369 --> 00:42:51,125



864
00:42:51,324 --> 00:42:52,909
What notation?
什么符号？ 

865
00:42:52,909 --> 00:42:54,460
PROFESSOR: This is Python notation.
教授：这是Python表示法。 

866
00:42:54,460 --> 00:42:56,860
You may have heard of Python.
您可能听说过Python。 

867
00:42:56,860 --> 00:43:01,519
This is a dictionary which has one key value,
这是一本字典，只有一个键值， 

868
00:43:01,719 --> 00:43:03,719
s, and has one value, zero.
 s，并且有一个值，零。 

869
00:43:03,719 --> 00:43:06,109
So you could--
所以你可以- 

870
00:43:06,110 --> 00:43:08,300
That's shorthand in Python for--
这是Python的简写- 

871
00:43:08,300 --> 00:43:10,440
Usually you have a comma separated list.
通常，您有一个用逗号分隔的列表。 

872
00:43:10,440 --> 00:43:14,309
The colon is specifying key value pairs.
冒号指定键值对。 

873
00:43:14,309 --> 00:43:17,299



874
00:43:17,300 --> 00:43:19,760
I didn't talk about parent.
我没有谈论父母。 

875
00:43:19,760 --> 00:43:23,110
We can do that for a little bit.
我们可以做一点。 

876
00:43:23,309 --> 00:43:28,279
So parent we're initializing to say, the parent of s is nobody,
所以我们要初始化为parent，s的父母是没人， 

877
00:43:28,280 --> 00:43:30,690
and then whenever we visit a new vertex,
然后每当我们访问一个新顶点时， 

878
00:43:30,889 --> 00:43:34,900
v, we set its parent to be the vertex that we came from.
 v，我们将其父级设为我们来自的顶点。 

879
00:43:34,900 --> 00:43:36,650
So we had this vertex, v. We had an edge
所以我们有这个顶点v。我们有一个优势

880
00:43:36,650 --> 00:43:38,559
to v from some vertex, u.
从某个顶点到v 

881
00:43:38,559 --> 00:43:40,719
We set the parent of v to be u.
我们将v的父级设置为u。 

882
00:43:40,719 --> 00:43:44,139
So let me add in what that becomes.
因此，让我补充一下。 

883
00:43:44,139 --> 00:43:47,299
I'll change colors yet again.
我将再次更改颜色。 

884
00:43:47,300 --> 00:43:51,820
Although it gets hard to see any color but red.
虽然很难看到红色以外的任何颜色。 

885
00:43:51,820 --> 00:43:55,340
So we have s.
所以我们有。 

886
00:43:55,340 --> 00:44:00,809
When we visited a, then the parent of a would become s.
当我们访问a时，a的父代将变为s。 

887
00:44:00,809 --> 00:44:05,150
When we visited z, the parent of z would be a.
当我们访问z时，z的父代将是a。 

888
00:44:05,150 --> 00:44:07,639
Parent of x is going to be s.
 x的父级将是s。 

889
00:44:07,639 --> 00:44:09,924
Parent of d is going to be x.
 d的父级将是x。 

890
00:44:09,925 --> 00:44:12,565
The parent of c is going to be x.
 c的父级将是x。 

891
00:44:12,764 --> 00:44:14,364
The parent of f--
 f的父

892
00:44:14,364 --> 00:44:16,530
it could have been either way, but the way I did it,
可以是任何一种方式，但是我这样做的方式， 

893
00:44:16,530 --> 00:44:21,000
d went first, and so that became its parent.
 d首先进入，因此成为其父项。 

894
00:44:21,199 --> 00:44:25,326
And I think for v, c was its parent.
我认为对于v，c是其父代。 

895
00:44:25,327 --> 00:44:27,210
So that's what the parent pointers will look like.
这就是父指针的样子。 

896
00:44:27,409 --> 00:44:28,819
They always follow edges.
他们总是跟随边缘。 

897
00:44:28,820 --> 00:44:30,760
They actually follow edges backwards.
他们实际上向后跟随边缘。 

898
00:44:30,760 --> 00:44:32,420
If this was a directed graph, the graph
如果这是有向图，则该图

899
00:44:32,619 --> 00:44:35,420
might be directed that way but the parent pointers
可能以这种方式指向，但父指针

900
00:44:35,420 --> 00:44:37,269
go back along the edges.
沿着边缘往回走。 

901
00:44:37,269 --> 00:44:38,389
So it's a way to return.
因此，这是一种返回的方式。 

902
00:44:38,389 --> 00:44:41,710
It's a way to return to s.
这是返回s的一种方式。 

903
00:44:41,710 --> 00:44:44,579
If you follow these pointers, all roads lead to s.
如果遵循这些指针，则所有道路均通向s。 

904
00:44:44,579 --> 00:44:48,139



905
00:44:48,139 --> 00:44:50,549
Because we started at s, that's the property we have.
因为我们从s开始，所以这就是我们的财产。 

906
00:44:50,550 --> 00:44:53,980
In fact, these pointers always form a tree,
实际上，这些指针总是形成一棵树， 

907
00:44:54,179 --> 00:44:56,279
and the root of the tree is s.
树的根是s。 

908
00:44:56,280 --> 00:44:59,860
In fact, these pointers form what are called shortest paths.
实际上，这些指针形成了所谓的最短路径。 

909
00:44:59,860 --> 00:45:05,730
Let me write down a little bit about this.
让我写下一点。 

910
00:45:05,730 --> 00:45:19,969



911
00:45:19,969 --> 00:45:21,284
Shortest path properties.
最短路径属性。 

912
00:45:21,284 --> 00:45:45,909



913
00:45:45,909 --> 00:45:51,399
If you take a node, and you take its parent,
如果您采用一个节点，并且采用其父节点， 

914
00:45:51,400 --> 00:45:53,170
and you take the parent of the parent,
然后您选择父母的父母， 

915
00:45:53,170 --> 00:45:56,599
and so on, eventually you get to s.
依此类推，最终您到达s。 

916
00:45:56,599 --> 00:45:59,539
And if you read it backwards, that will actually
如果您向后阅读，实际上

917
00:45:59,539 --> 00:46:01,880
be a path in the graph.
是图中的路径。 

918
00:46:01,880 --> 00:46:09,420
And it will be a shortest path, in the graph,
在图中，这将是一条最短的路径， 

919
00:46:09,420 --> 00:46:14,610
from s to v. Meaning, if you look
从s到v。含义，如果您看

920
00:46:14,610 --> 00:46:16,980
at all paths in the graph that go from s to v--
在图中从s到v的所有路径上- 

921
00:46:17,179 --> 00:46:21,460
So say we're going from s to v, how about that,
所以说我们要从s转到v，那怎么样， 

922
00:46:21,460 --> 00:46:23,230
we compute this path out of BFS.
我们从BFS中计算出该路径。 

923
00:46:23,230 --> 00:46:25,449
Which is, follow a parent of v is c, parent
就是说，跟随父的v是c，父

924
00:46:25,449 --> 00:46:27,669
of c is x, parent of x is s.
 c的x是x，x的父元素是s。 

925
00:46:27,670 --> 00:46:28,599
Read it backwards.
向后阅读。 

926
00:46:28,599 --> 00:46:30,589
That gives us a path from s to v.
这给了我们从s到v的路径。 

927
00:46:30,590 --> 00:46:31,940
The claim is, that is the shortest
索赔是，这是最短的

928
00:46:32,139 --> 00:46:35,420
way to get from s to v. It might not be the only one.
从s到v的方法。它可能不是唯一的一种。 

929
00:46:35,420 --> 00:46:38,329
Like if you're going from s to f, there's two short paths.
就像您要从s转到f一样，这里有两条短路。 

930
00:46:38,329 --> 00:46:40,329
There's this one of length three.
这是长度三的之一。 

931
00:46:40,329 --> 00:46:42,159
There's this one of length three..
这是长度三的之一。 

932
00:46:42,159 --> 00:46:43,389
Uses three edges.
使用三个边缘。 

933
00:46:43,389 --> 00:46:45,299
Same length.
长度相同。 

934
00:46:45,300 --> 00:46:47,110
And in the parent pointers, we can only
在父指针中，我们只能

935
00:46:47,110 --> 00:46:48,440
afford to encode one of those paths
能够编码其中一条路径

936
00:46:48,639 --> 00:46:51,014
because in general there might be exponentially many ways
因为一般来说，可能有成倍的方式

937
00:46:51,014 --> 00:46:52,690
to get from one node to another.
从一个节点到达另一个节点。 

938
00:46:52,690 --> 00:46:56,940
We find a shortest path, not necessarily the only one.
我们找到一条最短的路径，不一定是唯一的一条。 

939
00:46:56,940 --> 00:47:00,599
And the length of that path--
那条路的长度

940
00:47:00,599 --> 00:47:03,750
So shortest here means that you use the fewest edges.
因此，这里最短意味着您使用的边最少。 

941
00:47:03,750 --> 00:47:07,909
And the length will be level of v. That's
长度将为v级。 

942
00:47:07,909 --> 00:47:10,728
what we're keeping track of.
我们正在跟踪的内容。 

943
00:47:10,728 --> 00:47:13,019
If the level's zero, you can get there with zero steps.
如果级别为零，则可以零级到达那里。 

944
00:47:13,019 --> 00:47:15,059
If the level's one, you get there with one steps.
如果是关卡，则只需一步即可到达。 

945
00:47:15,059 --> 00:47:17,143
Because we're visiting everything you can possibly
因为我们正在尽一切可能

946
00:47:17,143 --> 00:47:19,829
get in k steps, the level is telling you what
进入k步，水平告诉您什么

947
00:47:19,829 --> 00:47:21,411
that shortest path distance is.
最短的路径距离是。 

948
00:47:21,411 --> 00:47:22,909
And the parent pointers are actually
父指针实际上是

949
00:47:22,909 --> 00:47:25,029
giving you the shortest path.
为您提供最短的路径。 

950
00:47:25,030 --> 00:47:27,090
That's the cool thing about BFS.
这就是BFS的酷之处。 

951
00:47:27,090 --> 00:47:28,420
Yeah, BFS explores the vertices.
是的，BFS探索顶点。 

952
00:47:28,619 --> 00:47:30,415
Sometimes, that's all you care about.
有时候，这就是您所关心的。 

953
00:47:30,416 --> 00:47:32,039
But in some sense, what really matters,
但是从某种意义上说，真正重要的是， 

954
00:47:32,039 --> 00:47:36,199
is it finds the shortest way to get from anywhere to anywhere.
它找到了从任何地方到任何地方的最快捷方法。 

955
00:47:36,199 --> 00:47:40,199
For a Rubik's Cube, that's nice because you
对于魔方来说，这很好，因为您

956
00:47:40,199 --> 00:47:43,259
run BFS from the start state of the Rubik's Cube.
从魔方的开始状态运行BFS。 

957
00:47:43,260 --> 00:47:45,190
Then you say, oh, I'm in this state.
然后您说，哦，我处于这种状态。 

958
00:47:45,190 --> 00:47:46,724
You look up this state.
您查找此状态。 

959
00:47:46,724 --> 00:47:47,440
You look at its level.
您看一下它的水平。 

960
00:47:47,639 --> 00:47:50,589
It says, oh, you can get there in nine steps.
它说，哦，您可以按照以下九个步骤到达那里。 

961
00:47:50,590 --> 00:47:52,260
That's, I think, the average.
我认为这是平均值。 

962
00:47:52,260 --> 00:47:53,501
So I'm guessing.
所以我猜。 

963
00:47:53,501 --> 00:47:55,250
I don't know how to do this in nine steps.
我不知道如何通过九个步骤来执行此操作。 

964
00:47:55,250 --> 00:47:58,469



965
00:47:58,469 --> 00:48:00,219
Great, so now you know how to solve it.
太好了，所以您现在知道如何解决它。 

966
00:48:00,219 --> 00:48:01,719
You just look at the parent pointer.
您只需查看父指针。 

967
00:48:01,719 --> 00:48:03,094
The parent pointer gives you another configuration.
父指针为您提供了另一种配置。 

968
00:48:03,094 --> 00:48:05,029
You say, oh, what move was that?
你说，哦，那是什么动作？ 

969
00:48:05,030 --> 00:48:06,480
And then you do that move.
然后您执行此操作。 

970
00:48:06,480 --> 00:48:07,940
I'm not going to solve it.
我不会解决它。 

971
00:48:07,940 --> 00:48:09,360
Then you look at the parent pointer of that.
然后，您查看其父指针。 

972
00:48:09,360 --> 00:48:10,045
You do that move.
你这样做。 

973
00:48:10,045 --> 00:48:11,510
You look at the parent pointer of that.
您看一下它的父指针。 

974
00:48:11,510 --> 00:48:11,880
You do that move.
你这样做。 

975
00:48:12,079 --> 00:48:13,871
Eventually, you'll get to the solved state,
最终，您将达到解决状态， 

976
00:48:13,871 --> 00:48:16,230
and you will do it using the fewest possible moves.
并且您将使用最少的动作来完成。 

977
00:48:16,429 --> 00:48:20,589
So if you can afford to put the whole graph in memory, which
因此，如果您有能力将整个图形存储在内存中， 

978
00:48:20,590 --> 00:48:23,250
you can't for a big Rubik's Cube but you can for a small one,
您不能购买大型魔方，但可以购买小型魔方， 

979
00:48:23,449 --> 00:48:27,559
then this will give you a strategy, the optimal strategy,
那么这将为您提供一种策略，最佳策略， 

980
00:48:27,559 --> 00:48:32,400
God's algorithm if you will, for every configuration.
如果您愿意的话，可以针对每种配置使用上帝的算法。 

981
00:48:32,400 --> 00:48:34,000
It solves all of them.
它解决了所有这些问题。 

982
00:48:34,199 --> 00:48:36,198
Which is great.
太好了

983
00:48:36,199 --> 00:48:37,789
What is the running time of this algorithm?
该算法的运行时间是多少？ 

984
00:48:37,989 --> 00:48:41,869
I claim it's order V plus E. But it looked a little wasteful
我声称这是V加上E的订单。但是看起来有点浪费

985
00:48:41,869 --> 00:48:45,299
because it was checking vertices over and over and over.
因为它一遍又一遍地检查顶点。 

986
00:48:45,300 --> 00:48:47,260
But if you think about it carefully,
但是如果仔细考虑一下

987
00:48:47,260 --> 00:48:49,246
you're only looking--
你只是在看- 

988
00:48:49,246 --> 00:48:51,269
what's the right way to say this--
这样说的正确方法是- 

989
00:48:51,269 --> 00:48:55,583
you only check every edge once.
您只需检查每个边缘一次。 

990
00:48:55,583 --> 00:48:57,500
Or in undirected graphs, you check them twice,
或在无向图中，将它们检查两次， 

991
00:48:57,500 --> 00:49:00,820
once from each side.
每边一次。 

992
00:49:00,820 --> 00:49:04,289
A vertex enters the frontier only once.
顶点仅进入边界一次。 

993
00:49:04,289 --> 00:49:07,610
Because once it's in the frontier, it gets a level set.
因为一旦进入边界，就会获得一个等级集。 

994
00:49:07,610 --> 00:49:11,250
And once it has a level set, it'll never go in again.
设置了级别后，就再也不会进入了。 

995
00:49:11,449 --> 00:49:14,449
It'll never get added to next.
它永远不会添加到下一个。 

996
00:49:14,449 --> 00:49:17,439
So s gets added once then we check all the neighbors of s.
所以s被添加一次，然后我们检查s的所有邻居。 

997
00:49:17,440 --> 00:49:19,909
a gets added once, then we check all the neighbors of a.
将a添加一次，然后检查a的所有邻居。 

998
00:49:19,909 --> 00:49:21,519
Each of these guys gets added once.
这些家伙每个都被添加一次。 

999
00:49:21,519 --> 00:49:22,949
We check all the neighbors.
我们检查所有邻居。 

1000
00:49:22,949 --> 00:49:24,409
So the total running time is going
所以总的运行时间在

1001
00:49:24,409 --> 00:49:27,489
to be the sum over all vertices of the size
是该大小的所有顶点的总和

1002
00:49:27,489 --> 00:49:33,529
of the adjacency list of v. So this is the number of neighbors
 v的邻接列表。所以这是邻居的数量

1003
00:49:33,530 --> 00:49:35,019
that v has.
 v有。 

1004
00:49:35,219 --> 00:49:37,578
And this is going to be?
这将是？ 

1005
00:49:37,579 --> 00:49:38,079
Answer?
回答？ 

1006
00:49:38,079 --> 00:49:42,135



1007
00:49:42,335 --> 00:49:44,003
AUDIENCE: Two times the number of edges.
听众：边缘数量的两倍。 

1008
00:49:44,003 --> 00:49:44,670
PROFESSOR: Sorry
教授：对不起

1009
00:49:44,670 --> 00:49:46,010
AUDIENCE: Double the number of edges.
听众：边缘数量加倍。 

1010
00:49:46,210 --> 00:49:48,929
PROFESSOR: Twice the number of edges for undirected graphs.
教授：无向图的边数是原来的两倍。 

1011
00:49:48,929 --> 00:49:51,329
It's going to be the number of edges for directed graphs.
这将是有向图的边数。 

1012
00:49:51,329 --> 00:49:52,769
This is the Handshaking Lemma.
这就是握手引理。 

1013
00:49:52,769 --> 00:49:54,670
If you don't remember the Handshaking Lemma,
如果您不记得握手引理， 

1014
00:49:54,670 --> 00:49:57,329
you should read the textbook.
您应该阅读教科书。 

1015
00:49:57,329 --> 00:49:59,115
Six o four two stuff.
六点四两的东西。 

1016
00:49:59,115 --> 00:50:03,300



1017
00:50:03,300 --> 00:50:06,780
Basically you visit every edge twice.
基本上，您访问每个边缘两次。 

1018
00:50:06,780 --> 00:50:10,670
For directed graphs, you visit every edge once.
对于有向图，您需要访问每个边一次。 

1019
00:50:10,869 --> 00:50:13,589
But it's order E. We also spend order V
但这是订单E。我们也花了订单V 

1020
00:50:13,590 --> 00:50:15,789
because we touch every vertex.
因为我们触摸每个顶点。 

1021
00:50:15,789 --> 00:50:18,769
So the total running time is order V plus E.
因此，总运行时间为订单V加E。 

1022
00:50:18,769 --> 00:50:23,239
In fact, the way this is going, you can be a little tighter
实际上，这样可以使您更加紧凑

1023
00:50:23,239 --> 00:50:26,826
and say it's order E. I just want to mention in reality--
并说它是E阶。我只想在现实中提到- 

1024
00:50:26,827 --> 00:50:29,210
Sometimes you don't care about just what you can reach from s,
有时候，您并不只是在乎从s可以获得什么， 

1025
00:50:29,409 --> 00:50:31,409
you really want to visit every vertex.
您真的想访问每个顶点。 

1026
00:50:31,409 --> 00:50:33,710
Then you need another outer loop that's
然后您需要另一个外部循环

1027
00:50:33,710 --> 00:50:38,170
iterating over all the vertices as potential choices for s.
迭代所有顶点作为s的潜在选择。 

1028
00:50:38,170 --> 00:50:41,159
And you then can visit all the vertices in the entire graph
然后，您可以访问整个图中的所有顶点

1029
00:50:41,159 --> 00:50:42,929
even if it's disconnected.
即使已断开连接。 

1030
00:50:42,929 --> 00:50:45,039
We'll talk more about that next class.
我们将在下一堂课中进一步讨论。 

1031
00:50:45,039 --> 00:50:46,606
That's it for BFS.
 BFS就是这样。 

1032
00:50:46,606 --> 00:50:51,606



