1
00:00:00,000 --> 00:00:00,090



2
00:00:00,090 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,000
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,000 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,320
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,320 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:21,742



10
00:00:21,742 --> 00:00:23,449
PROFESSOR: Are people understanding AVLs?
教授：人们了解AVL吗？ 

11
00:00:23,449 --> 00:00:27,600



12
00:00:27,600 --> 00:00:29,960
That's good, because if everyone raised their hands,
很好，因为如果每个人都举手， 

13
00:00:29,960 --> 00:00:31,690
we'd be done and out of here.
我们会做完的，然后离开这里。 

14
00:00:31,690 --> 00:00:34,270
So we're not covering new material in this recitation.
因此，本次朗诵不涉及新材料。 

15
00:00:34,270 --> 00:00:37,320
We're talking about AVLs again, except this time
除了这次，我们再次谈论AVL 

16
00:00:37,320 --> 00:00:39,210
you'll tell me how we'll do them,
你会告诉我我们将如何做， 

17
00:00:39,210 --> 00:00:42,140
and we'll look at the code and see
然后我们看一下代码，看看

18
00:00:42,140 --> 00:00:44,780
how the theory matches the code.
理论如何与代码匹配。 

19
00:00:44,780 --> 00:00:47,149
And I need one of these.
我需要其中之一。 

20
00:00:47,149 --> 00:00:47,799
Thank you.
谢谢。 

21
00:00:47,799 --> 00:00:52,343



22
00:00:52,344 --> 00:00:53,259
So let's start simple.
让我们开始吧。 

23
00:00:53,259 --> 00:00:55,609
What's a BST?
什么是BST？ 

24
00:00:55,609 --> 00:00:57,109
AUDIENCE: Binary search tree.
受众：二进制搜索树。 

25
00:00:57,109 --> 00:01:00,109



26
00:01:00,109 --> 00:01:02,929
PROFESSOR: OK, binary search tree.
教授：好的，二进制搜索树。 

27
00:01:02,929 --> 00:01:06,079
It's binary because every node has at most two children.
它是二进制的，因为每个节点最多有两个孩子。 

28
00:01:06,079 --> 00:01:07,685
Why is it a search tree?
为什么是搜索树？ 

29
00:01:07,686 --> 00:01:09,426
AUDIENCE: It's easy to search.
听众：很容易搜索。 

30
00:01:09,626 --> 00:01:10,209
PROFESSOR: OK.
教授：好的。 

31
00:01:10,209 --> 00:01:11,278
Why is it easy to search?
为什么搜索容易？ 

32
00:01:11,278 --> 00:01:12,944
AUDIENCE: Because you start [INAUDIBLE],
听众：因为您开始[听不清]， 

33
00:01:12,944 --> 00:01:15,194
is my number greater than this key or is it less than,
我的数字大于此键还是小于， 

34
00:01:15,194 --> 00:01:16,409
and then you go from there.
然后你从那里去。 

35
00:01:16,409 --> 00:01:16,992
PROFESSOR: OK.
教授：好的。 

36
00:01:16,992 --> 00:01:20,599
So if I would have to state this as a formal rep invariant
因此，如果我不得不将其声明为正式代表不变式

37
00:01:20,599 --> 00:01:24,015
thing, what would I say it is so that I can do that operation?
事情，我要说的是什么以便我可以执行该操作？ 

38
00:01:24,016 --> 00:01:26,268
AUDIENCE: Node at right is greater than
听众：右侧的节点大于

39
00:01:26,268 --> 00:01:30,909
node at key, which is greater than node at left.
关键点处的节点，大于左边的节点。 

40
00:01:30,909 --> 00:01:32,140
PROFESSOR: OK, excellent.
教授：好的，很好。 

41
00:01:32,140 --> 00:01:36,189
So it turns out I can use this argument recursively
所以事实证明我可以递归使用这个参数

42
00:01:36,189 --> 00:01:40,829
to say that for a given node, everything that
表示对于给定的节点， 

43
00:01:40,829 --> 00:01:44,739
is to the right of that node is greater,
在那个节点的右边更大

44
00:01:44,739 --> 00:01:48,709
and everything that is to the left is smaller.
左侧的所有内容都较小。 

45
00:01:48,709 --> 00:01:52,449



46
00:01:52,450 --> 00:01:54,480
And this allows us to do search quickly
这使我们可以快速进行搜索

47
00:01:54,480 --> 00:01:57,180
because if you're looking for a key,
因为如果您正在寻找钥匙， 

48
00:01:57,180 --> 00:02:00,480
say you have numbers in your tree and you're looking for 5.
说您的树上有数字，并且正在寻找5。 

49
00:02:00,480 --> 00:02:03,569
If you arrive at a node whose value is 4, you go right.
如果到达值为4的节点，则继续进行。 

50
00:02:03,769 --> 00:02:07,819
If you arrive at a node whose value is 7, you go left.
如果到达值为7的节点，则向左走。 

51
00:02:07,819 --> 00:02:11,419
OK So what do we know how to do on BSTs?
好，那么我们知道如何在BST上做什么？ 

52
00:02:11,419 --> 00:02:14,324
What are the operations that we know?
我们知道什么操作？ 

53
00:02:14,324 --> 00:02:17,579
AUDIENCE: Minimum, maximum.
听众：最小，最大。 

54
00:02:17,580 --> 00:02:18,965
PROFESSOR: Min, max.
教授：最小，最大

55
00:02:18,965 --> 00:02:22,099



56
00:02:22,099 --> 00:02:24,210
AUDIENCE: Left, right, parent.
听众：左，右，父母。 

57
00:02:24,210 --> 00:02:26,439
PROFESSOR: So those are for the node.
教授：这些是用于节点的。 

58
00:02:26,639 --> 00:02:30,299
I want the queries and the updates for the BST type.
我想要查询和BST类型的更新。 

59
00:02:30,300 --> 00:02:31,717
AUDIENCE: Insert and delete.
听众：插入和删除。 

60
00:02:31,717 --> 00:02:32,300
PROFESSOR: OK.
教授：好的。 

61
00:02:32,300 --> 00:02:35,030



62
00:02:35,030 --> 00:02:39,051
Insert, Delete.
插入，删除。 

63
00:02:39,051 --> 00:02:40,036
AUDIENCE: Next larger.
听众：接下来更大。 

64
00:02:40,036 --> 00:02:42,896



65
00:02:42,896 --> 00:02:43,479
PROFESSOR: OK.
教授：好的。 

66
00:02:43,479 --> 00:02:52,339



67
00:02:52,340 --> 00:02:55,026
And then in here, the S in BST.
然后是BST中的S 

68
00:02:55,026 --> 00:02:57,626
Someone give me the S so we can move on.
有人给我S，以便我们继续前进。 

69
00:02:57,626 --> 00:02:58,800
AUDIENCE: Find.
听众：找到。 

70
00:02:58,800 --> 00:03:03,054
PROFESSOR: Find, search, depending
教授：根据需要查找，搜索

71
00:03:03,253 --> 00:03:04,419
on what code you're reading.
您正在阅读的代码。 

72
00:03:04,419 --> 00:03:07,069



73
00:03:07,069 --> 00:03:11,259
What's the running time for these guys?
这些家伙的跑步时间是多少？ 

74
00:03:11,259 --> 00:03:12,549
AUDIENCE: Order h.
听众：订单h。 

75
00:03:12,550 --> 00:03:14,219
PROFESSOR: Excellent.
教授：非常好。 

76
00:03:14,219 --> 00:03:16,349
So everything has the same running time.
因此，所有内容都具有相同的运行时间。 

77
00:03:16,349 --> 00:03:19,030
Nice and easy to remember.
很容易记住。 

78
00:03:19,030 --> 00:03:19,900
Order h.
订单h。 

79
00:03:19,900 --> 00:03:21,635
What's h?
什么啊

80
00:03:21,635 --> 00:03:23,930
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

81
00:03:23,930 --> 00:03:25,189
PROFESSOR: OK.
教授：好的。 

82
00:03:25,189 --> 00:03:27,120
How do we define this height?
我们如何定义这个高度？ 

83
00:03:27,120 --> 00:03:31,269
What's the height for this tree?
这棵树的高度是多少？ 

84
00:03:31,269 --> 00:03:32,185
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

85
00:03:32,185 --> 00:03:35,460



86
00:03:35,460 --> 00:03:36,719
PROFESSOR: Good.
教授：很好。 

87
00:03:36,719 --> 00:03:38,879
What's the height for this tree?
这棵树的高度是多少？ 

88
00:03:38,879 --> 00:03:43,460



89
00:03:43,460 --> 00:03:48,883
What's the height for this tree?
这棵树的高度是多少？ 

90
00:03:48,883 --> 00:03:49,466
AUDIENCE: Two.
听众：两个。 

91
00:03:49,466 --> 00:03:52,599



92
00:03:52,599 --> 00:03:55,019
PROFESSOR: So now for a more general case,
教授：所以现在来看一个更一般的情况， 

93
00:03:55,020 --> 00:04:00,120
where this is the height, and the height of my left subtree
这是我的左子树的高度和高度

94
00:04:00,319 --> 00:04:00,879
is hl.
是hl。 

95
00:04:00,879 --> 00:04:04,939
The height of my right subtree is hr.
我右边的子树的高度是hr。 

96
00:04:04,939 --> 00:04:06,671
What's h?
什么啊

97
00:04:06,671 --> 00:04:11,001
AUDIENCE: It's the maximum of hr times hl plus 1.
听众：这是hr乘以hl加上1的最大值。 

98
00:04:11,001 --> 00:04:16,785



99
00:04:16,785 --> 00:04:17,660
PROFESSOR: Nice save.
教授：很好。 

100
00:04:17,660 --> 00:04:18,918
I heard a "plus 1" somewhere there.
我在那里听到“加1”。 

101
00:04:19,117 --> 00:04:22,290



102
00:04:22,290 --> 00:04:24,480
Very good.
很好。 

103
00:04:24,480 --> 00:04:25,069
This is r.
这是r。 

104
00:04:25,069 --> 00:04:28,870



105
00:04:28,870 --> 00:04:31,060
So if we look at the first part of the code,
因此，如果我们看一下代码的第一部分， 

106
00:04:31,060 --> 00:04:35,839
lines one through eight, lines seven and eight
第一到第八行，第七和第八行

107
00:04:35,839 --> 00:04:39,279
implement the definition that we talked about here.
实现我们在这里讨论的定义。 

108
00:04:39,279 --> 00:04:41,439
So in our Python implementation, each node
因此，在我们的Python实现中，每个节点

109
00:04:41,439 --> 00:04:44,550
knows the height of the tree that he's the root of.
知道他是根的那棵树的高度。 

110
00:04:44,550 --> 00:04:47,639



111
00:04:47,639 --> 00:04:49,899
And since we're storing that, we need
既然我们要存储它，我们需要

112
00:04:49,899 --> 00:04:52,149
to update it every once in awhile when we make changes
在进行更改时每隔一段时间进行更新

113
00:04:52,149 --> 00:04:54,870
to the tree, like when we insert nodes.
就像我们插入节点时一样。 

114
00:04:54,870 --> 00:04:56,810
And the way we do that is update height, which
我们这样做的方法是更新高度

115
00:04:56,810 --> 00:04:59,970
uses the formula that we came up with here.
使用我们在这里想到的公式。 

116
00:04:59,970 --> 00:05:04,120
Now, there is a hack on lines two, three, four, five.
现在，在第二，第三，第四，第五行有一个破解。 

117
00:05:04,120 --> 00:05:06,750
Can anyone tell me what the hack is?
谁能告诉我骇客是什么？ 

118
00:05:06,750 --> 00:05:20,988



119
00:05:20,988 --> 00:05:22,469
AUDIENCE: The negative 1.
听众：负面1。 

120
00:05:22,470 --> 00:05:23,240
PROFESSOR: OK.
教授：好的。 

121
00:05:23,240 --> 00:05:24,139
How does that work?
这是如何运作的？ 

122
00:05:24,139 --> 00:05:24,979
Why do I need it?
我为什么需要它？ 

123
00:05:24,980 --> 00:05:27,579



124
00:05:27,779 --> 00:05:30,169
AUDIENCE: That's so if you're at the root node,
听众：就是这样，如果您在根节点上， 

125
00:05:30,170 --> 00:05:33,509
you can still calculate the height.
您仍然可以计算高度。 

126
00:05:33,509 --> 00:05:37,819
PROFESSOR: Depends on how the root node looks like.
教授：取决于根节点的外观。 

127
00:05:37,819 --> 00:05:40,038
AUDIENCE: If it has no children.
听众：如果没有孩子。 

128
00:05:40,038 --> 00:05:41,079
PROFESSOR: That's a leaf.
教授：那是一片叶子。 

129
00:05:41,079 --> 00:05:41,879
AUDIENCE: Yes.
听众：是的。 

130
00:05:41,879 --> 00:05:43,670
PROFESSOR: OK.
教授：好的。 

131
00:05:43,670 --> 00:05:47,189
So if I'm in this case or in this case, what's hl,
因此，如果我在这种情况下还是在这种情况下，hl是什么， 

132
00:05:47,389 --> 00:05:49,139
what's hr?
什么时间？ 

133
00:05:49,139 --> 00:05:52,129
In this case, I have this node of height zero,
在这种情况下，我有这个高度为零的节点， 

134
00:05:52,129 --> 00:05:55,399
so I can make a small mistake here and it'll save me,
所以我可以在这里犯一个小错误，这样可以救我， 

135
00:05:55,399 --> 00:05:59,989
but here, I have no children, so hl and hr have
但是在这里，我没有孩子，所以hl和hr有

136
00:05:59,990 --> 00:06:04,560
to be set in such a way that this formula evaluates to 0.
设置为使该公式的值为0。 

137
00:06:04,560 --> 00:06:07,889
If I set them to minus 1, I'll have minus 1, minus 1.
如果将它们设置为负1，我将具有负1，负1。 

138
00:06:07,889 --> 00:06:11,755
The maximum is minus 1 plus 1 equals 0.
最大值为负1加1等于0。 

139
00:06:11,755 --> 00:06:15,649
AUDIENCE: It's just to check the nodes for AVLs.
听众：只是检查节点的AVL。 

140
00:06:15,649 --> 00:06:18,089
PROFESSOR: We use that to update the height.
教授：我们用它来更新高度。 

141
00:06:18,089 --> 00:06:19,949
For AVLs, we need to know the height
对于AVL，我们需要知道高度

142
00:06:19,949 --> 00:06:21,649
of a node instantaneously.
瞬间

143
00:06:21,649 --> 00:06:23,199
We can't afford to go down the tree
我们买不起那棵树

144
00:06:23,199 --> 00:06:25,589
and compute the height every time we need it,
并在每次需要时计算高度

145
00:06:25,589 --> 00:06:29,750
so every node gets to store its height.
这样每个节点都可以存储其高度。 

146
00:06:29,750 --> 00:06:32,884
There's a small field in each node that has the height.
每个节点中都有一个高度小的字段。 

147
00:06:32,884 --> 00:06:35,009
So we need to update that every once in awhile when
因此，我们需要每隔一段时间更新一次

148
00:06:35,009 --> 00:06:36,769
we do insertions and deletions.
我们进行插入和删除。 

149
00:06:36,769 --> 00:06:38,589
This is how we update it, and in order
这就是我们如何更新它，并按顺序

150
00:06:38,589 --> 00:06:42,319
to update it for this case, where we're at a leaf,
为这种情况更新它，我们在一片叶子上， 

151
00:06:42,319 --> 00:06:45,230
we have to say that the height of a non-existing tree
我们必须说一棵不存在的树的高度

152
00:06:45,230 --> 00:06:47,516
is minus 1.
为负1。 

153
00:06:47,516 --> 00:06:49,810
Of course, in theory and in real life,
当然，在理论上和现实生活中， 

154
00:06:49,810 --> 00:06:52,540
there are no non-existing trees, so this is a clever hack
没有不存在的树，所以这是一个聪明的技巧

155
00:06:52,540 --> 00:06:56,470
to reduce code size.
减少代码大小。 

156
00:06:56,470 --> 00:07:00,220
So we said binary search trees would look something like this.
所以我们说二进制搜索树看起来像这样。 

157
00:07:00,220 --> 00:07:16,408



158
00:07:16,408 --> 00:07:17,430
Is this guy an AVL?
这个人是AVL吗？ 

159
00:07:17,430 --> 00:07:24,050



160
00:07:24,050 --> 00:07:26,696
Does anyone think it's an a AVL?
有人认为这是AVL吗？ 

161
00:07:26,696 --> 00:07:31,660
Does anyone think it's not an AVL?
有人认为这不是AVL吗？ 

162
00:07:31,660 --> 00:07:35,004
Can one of you tell me why?
谁能告诉我为什么？ 

163
00:07:35,204 --> 00:07:39,300
AUDIENCE: The tree with 5 as its root is not balanced.
听众：以5为根的树是不平衡的。 

164
00:07:39,300 --> 00:07:43,862



165
00:07:43,862 --> 00:07:45,495
PROFESSOR: So this guy here is not balanced.
教授：所以这个人不平衡。 

166
00:07:45,694 --> 00:07:48,670
Why is it not balanced?
为什么不平衡？ 

167
00:07:48,670 --> 00:07:53,790
AUDIENCE: Because it has two on its right and zero on its left,
听众：因为它的右边有两个，左边有零， 

168
00:07:53,790 --> 00:07:55,290
so the difference is greater than 1.
所以差异大于1。 

169
00:07:55,290 --> 00:08:00,213



170
00:08:00,213 --> 00:08:02,379
PROFESSOR: You're saying that there's something here
教授：您是说这里有些事

171
00:08:02,379 --> 00:08:08,100
that's two, and something here that's-- OK, so height.
那是两个，这里的东西是-好，那么高。 

172
00:08:08,100 --> 00:08:11,689
So then it's almost like that.
这样就差不多了。 

173
00:08:11,889 --> 00:08:17,769
It's 1 here and minus 1 here.
这里是1，这里是1。 

174
00:08:17,769 --> 00:08:19,469
So the reason I asked you to clarify
所以我要求你澄清的原因

175
00:08:19,470 --> 00:08:21,300
is that first you said two and zero,
首先是你说二和零， 

176
00:08:21,300 --> 00:08:23,939
and that's the node count, and AVL
这是节点数和AVL 

177
00:08:23,939 --> 00:08:25,660
doesn't care about node count.
不在乎节点数。 

178
00:08:25,660 --> 00:08:27,449
AVL cares about height.
 AVL关心身高。 

179
00:08:27,649 --> 00:08:35,948
So for example, if I have something like this,
例如，如果我有这样的事情， 

180
00:08:35,948 --> 00:08:37,618
this is a happy AVL.
这是一个快乐的AVL。 

181
00:08:37,619 --> 00:08:39,608
Three nodes, here one node here.
三个节点，这里一个节点。 

182
00:08:39,808 --> 00:08:42,459
The difference in node count is greater than 1,
节点数之差大于1， 

183
00:08:42,460 --> 00:08:44,200
but the difference in height is 1.
但高度差为1。 

184
00:08:44,200 --> 00:08:47,360
Therefore, this is a good AVL.
因此，这是一个很好的AVL。 

185
00:08:47,360 --> 00:08:49,360
So what's a rep invariant for an AVL?
那么，AVL的代表不变性是什么？ 

186
00:08:49,360 --> 00:08:56,024



187
00:08:56,024 --> 00:08:58,972
AUDIENCE: The height of the left subtree for every node
听众：每个节点的左子树的高度

188
00:08:58,972 --> 00:09:02,949
is within 1 of the height of the right subtree.
在右子树的高度的1之内。 

189
00:09:02,950 --> 00:09:03,825
PROFESSOR: Excellent.
教授：非常好。 

190
00:09:03,825 --> 00:09:06,219



191
00:09:06,419 --> 00:09:07,029
AVL.
 AVL。 

192
00:09:07,029 --> 00:09:15,049
The core property is that for every node,
核心属性是每个节点

193
00:09:15,049 --> 00:09:20,849
the left height and the right height differ by at most 1.
左高度和右高度最多相差1。 

194
00:09:20,850 --> 00:09:22,099
What else?
还有什么？ 

195
00:09:22,299 --> 00:09:24,559
If we want to be completely rigorous,
如果我们要严格一点

196
00:09:24,559 --> 00:09:26,139
what else do we have to say?
我们还要说什么？ 

197
00:09:26,139 --> 00:09:28,789



198
00:09:28,789 --> 00:09:29,529
It's a BST.
这是BST。 

199
00:09:29,529 --> 00:09:34,169



200
00:09:34,169 --> 00:09:36,144
So an AVL is a special kind of BST,
因此，AVL是一种特殊的BST， 

201
00:09:36,144 --> 00:09:38,470
and that's why when we write the AVL code,
这就是为什么当我们编写AVL代码时， 

202
00:09:38,470 --> 00:09:43,029
we inherit from the BST and we use some of its methods
我们从BST继承而来，并使用了一些方法

203
00:09:43,029 --> 00:09:43,529
heavily.
沉重。 

204
00:09:43,529 --> 00:09:47,659



205
00:09:47,659 --> 00:09:48,759
Why do we like AVLs?
为什么我们喜欢AVL？ 

206
00:09:48,759 --> 00:09:52,139
What's so good about them?
他们有什么好处？ 

207
00:09:52,139 --> 00:09:56,139
AUDIENCE: It's faster because it ensures the minimal height
观众：速度更快，因为它可以确保最小的高度

208
00:09:56,139 --> 00:10:00,639
of the entire tree because most of our complexities are o of h,
因为我们大多数的复杂性都是h的o， 

209
00:10:00,639 --> 00:10:02,669
so it would have to be smaller.
因此它必须更小。 

210
00:10:02,669 --> 00:10:05,110
PROFESSOR: So we care about this.
教授：因此，我们对此表示关注。 

211
00:10:05,110 --> 00:10:07,659
In a regular binary tree, the worst case that you have
在常规的二叉树中，最糟糕的情况是

212
00:10:07,659 --> 00:10:12,559
is this.
这是。 

213
00:10:12,559 --> 00:10:15,739
Ignoring this part, this is a worst case binary search tree
忽略这部分，这是最坏情况的二进制搜索树

214
00:10:15,740 --> 00:10:19,879
where it's basically a list, so height is order n.
它基本上是一个列表，因此高度为n阶。 

215
00:10:19,879 --> 00:10:24,509
In an AVL, you're saying it's better.
在AVL中，您说的更好。 

216
00:10:24,509 --> 00:10:29,480
So the reason why we care about AVLs is
因此，我们关心AVL的原因是

217
00:10:29,480 --> 00:10:36,570
that height is order of log n.
该高度是对数n的顺序。 

218
00:10:36,570 --> 00:10:39,064
Now, did people understand from lecture why that's the case?
现在，人们从演讲中了解为什么会这样吗？ 

219
00:10:39,264 --> 00:10:42,840



220
00:10:42,840 --> 00:10:47,459
Can anyone tell me why that's the case?
谁能告诉我为什么会这样吗？ 

221
00:10:47,659 --> 00:10:49,587
AUDIENCE: Well, it's just like every level
听众：好吧，就像每个级别

222
00:10:49,587 --> 00:10:55,714
you go down, if you split off that many times, of course
你走下去，如果你分裂了那么多次，当然

223
00:10:55,715 --> 00:10:58,259
it's log n.
它是日志n。 

224
00:10:58,259 --> 00:11:03,689
If you have n nodes and they're filled up to the edge,
如果您有n个节点并且它们已被填满， 

225
00:11:03,690 --> 00:11:05,939
there's going to be log n of them.
他们将要登录n。 

226
00:11:06,139 --> 00:11:09,230
AUDIENCE: It's close to a full binary tree, right?
听众：它接近完整的二叉树，对吗？ 

227
00:11:09,230 --> 00:11:12,259
PROFESSOR: For some definition of "close."
教授：关于“关闭”的定义。 

228
00:11:12,259 --> 00:11:14,009
So here's what I use to remember,
所以这就是我要记住的

229
00:11:14,009 --> 00:11:18,809
and I think I can persuade you that the height is log n using
我想我可以说服您使用

230
00:11:18,809 --> 00:11:21,948
the argument that I'll show you here.
我将在这里向您展示的论点。 

231
00:11:21,948 --> 00:11:23,490
Let's start building a tree this way.
让我们以这种方式开始构建树。 

232
00:11:23,490 --> 00:11:25,750
Let's say I have a fixed height, and I
假设我有固定的身高，而我

233
00:11:25,750 --> 00:11:28,620
want to have as few nodes as possible.
希望拥有尽可能少的节点。 

234
00:11:28,620 --> 00:11:33,279
If I have a tree with a big height and very few nodes,
如果我有一棵高大的树，只有很少的节点， 

235
00:11:33,279 --> 00:11:38,740
h is going to be bad when you write it as a function of n.
当您将其写为n的函数时，h将是不好的。 

236
00:11:38,740 --> 00:11:40,669
So those trees are unbalanced.
所以那些树是不平衡的。 

237
00:11:40,669 --> 00:11:43,000
Big height, small number of nodes.
高度大，节点数少。 

238
00:11:43,000 --> 00:11:46,000
So say we're trying to build an AVL with the smallest
所以说我们正在尝试用最小的AVL 

239
00:11:46,000 --> 00:11:48,720
number of nodes and a fixed height.
节点数和固定高度。 

240
00:11:48,720 --> 00:11:49,860
What if the height is 0?
如果高度为0怎么办？ 

241
00:11:49,860 --> 00:11:52,659
What does that tree look like?
那棵树是什么样的？ 

242
00:11:52,659 --> 00:11:56,929
It's not too complicated, right?
不太复杂吧？ 

243
00:11:56,929 --> 00:11:58,609
This is an AVL of height 0.
这是高度为0的AVL。 

244
00:11:58,610 --> 00:12:01,740
It's the only possible AVL of height 0.
这是高度0的唯一可能的AVL。 

245
00:12:01,740 --> 00:12:04,259
Now, what if we're trying to build an AVL of height 1
现在，如果我们要构建高度为1的AVL怎么办

246
00:12:04,259 --> 00:12:05,855
that has as few nodes as possible?
有尽可能少的节点？ 

247
00:12:05,855 --> 00:12:10,349



248
00:12:10,549 --> 00:12:12,889
This is what it looks like, right?
看起来像这样吧？ 

249
00:12:12,889 --> 00:12:16,509
Height 0, height 1.
高度0，高度1。 

250
00:12:16,509 --> 00:12:18,080
I could add another node here, but I
我可以在这里添加另一个节点，但是我

251
00:12:18,080 --> 00:12:21,370
don't want to because I want as few nodes as possible.
不想，因为我想要尽可能少的节点。 

252
00:12:21,370 --> 00:12:23,720
Now, what if I tried to build an AVL of height 2
现在，如果我尝试构建高度为2的AVL怎么办

253
00:12:23,720 --> 00:12:25,094
that has as few nodes as possible?
有尽可能少的节点？ 

254
00:12:25,294 --> 00:12:28,339



255
00:12:28,340 --> 00:12:29,009
Can I do this?
我可以这样做吗？ 

256
00:12:29,009 --> 00:12:31,735



257
00:12:31,735 --> 00:12:34,152
AUDIENCE: So at the worst case, you have h minus 1
听众：所以在最坏的情况下，你的h减1 

258
00:12:34,352 --> 00:12:36,159
and then h minus 2 there.
然后h减2。 

259
00:12:36,159 --> 00:12:38,889
PROFESSOR: OK.
教授：好的。 

260
00:12:38,889 --> 00:12:39,840
You're moving ahead.
您正在前进。 

261
00:12:39,840 --> 00:12:42,079
You're forcing me to move faster, but you're right.
您逼我加快步伐，但您是对的。 

262
00:12:42,279 --> 00:12:45,319
And the reason is this is unbalanced.
原因是这是不平衡的。 

263
00:12:45,320 --> 00:12:48,590
The height at the left has to be the height of the right
左边的高度必须是右边的高度

264
00:12:48,590 --> 00:12:49,609
plus or minus 1.
正负1。 

265
00:12:49,809 --> 00:12:51,679
Can't be anything else.
别无其他。 

266
00:12:51,679 --> 00:12:54,979
So at the very least, I have to build a tree of height 0 here,
因此，至少我必须在此处建造一棵高度为0的树， 

267
00:12:54,980 --> 00:12:57,240
and I know that the best tree of height
我知道最好的树高

268
00:12:57,240 --> 00:12:59,000
0 that I have is this guy.
我有0是这个人。 

269
00:12:59,000 --> 00:13:03,769



270
00:13:03,769 --> 00:13:04,539
Cool.
凉。 

271
00:13:04,539 --> 00:13:07,939
So for height 3, I would have to do this.
因此，对于高度3，我将必须执行此操作。 

272
00:13:07,940 --> 00:13:11,168
And then you're saying, what would I use at the left?
然后您说的是，我将在左侧使用什么？ 

273
00:13:11,168 --> 00:13:16,148
AUDIENCE: You'd use whatever height's on the right minus 2.
听众：您可以使用右侧减去2的任何高度。 

274
00:13:16,148 --> 00:13:18,243
The height on the right minus 1 per side.
右侧的高度每侧减去1。 

275
00:13:18,443 --> 00:13:20,360
PROFESSOR: So on the right, I have a height 2.
教授：所以在右边，我的身高是2。 

276
00:13:20,360 --> 00:13:23,000
On the left, I have a height 1.
在左边，我的身高是1。 

277
00:13:23,000 --> 00:13:26,360



278
00:13:26,360 --> 00:13:29,940
If I want to go up to height 4, I do the same thing.
如果我想上升到4号高度，我会做同样的事情。 

279
00:13:29,940 --> 00:13:33,470
So if I want to build an AVL tree
所以如果我想建立一个AVL树

280
00:13:33,470 --> 00:13:36,889
with as few nodes as possible and height h,
尽可能少的节点和高度h 

281
00:13:36,889 --> 00:13:38,960
I start with the root, then at the right,
我从根开始，然后在右边， 

282
00:13:38,960 --> 00:13:43,350
I build an AVL tree of height h minus 1, and at the left,
我建立了高度为h减去1的AVL树，在左侧， 

283
00:13:43,350 --> 00:13:45,970
an AVL tree of height h minus 2.
高度为h减去2.的AVL树。 

284
00:13:45,970 --> 00:13:48,219
And if these have the minimum number of nodes,
如果这些节点的数量最少， 

285
00:13:48,419 --> 00:13:51,039
then it turns out that the whole thing
然后事实证明整个事情

286
00:13:51,039 --> 00:13:52,486
has the minimum number of nodes.
节点数最少。 

287
00:13:52,486 --> 00:13:54,569
I don't want to build a tree where the heights are
我不想在高处建一棵树

288
00:13:54,570 --> 00:13:57,500
equal because that would mean more nodes here,
相等，因为这意味着此处有更多节点， 

289
00:13:57,500 --> 00:13:59,039
so this is the best I can do.
所以这是我所能做的最好的。 

290
00:13:59,039 --> 00:14:02,094
This is the best way I can build a tall tree
这是我建高大树的最好方法

291
00:14:02,095 --> 00:14:03,345
with as few nodes as possible.
节点越少越好。 

292
00:14:03,345 --> 00:14:10,450



293
00:14:10,450 --> 00:14:12,949
Suppose I want to write the number of nodes
假设我要写节点数

294
00:14:13,149 --> 00:14:14,269
as a function of height.
作为高度的函数。 

295
00:14:14,269 --> 00:14:16,970
You're telling me what it is.
你是在告诉我这是什么。 

296
00:14:16,970 --> 00:14:21,219
When I was here, you were giving me the answer for this.
当我在这里时，您正在给我答案。 

297
00:14:21,419 --> 00:14:22,939
So suppose I have a height, and I
所以假设我有个身高

298
00:14:22,940 --> 00:14:25,090
want to know how many nodes I have in my tree that
想知道我的树上有多少个节点

299
00:14:25,090 --> 00:14:26,370
has a minimum number of nodes.
节点数最少。 

300
00:14:26,370 --> 00:14:28,657
What is it?
它是什么？ 

301
00:14:28,657 --> 00:14:39,634
AUDIENCE: It's N h minus 1, and then plus N h minus 2.
听众：是N h减去1，然后加上N h减去2。 

302
00:14:39,634 --> 00:14:44,125



303
00:14:44,125 --> 00:14:45,649
There might be a constant.
可能有一个常数。 

304
00:14:45,649 --> 00:14:47,190
PROFESSOR: There might be a constant.
教授：可能有一个常数。 

305
00:14:47,190 --> 00:14:50,950



306
00:14:50,950 --> 00:14:54,840
N h minus 1 is this tree, N h minus 2 is this tree,
 N h减1是这棵树，N h减2是这棵树， 

307
00:14:54,840 --> 00:14:56,399
so what's the constant?
那么什么是常数？ 

308
00:14:56,399 --> 00:14:57,315
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

309
00:14:57,315 --> 00:14:57,940
PROFESSOR: Yep.
教授：是的。 

310
00:14:57,940 --> 00:15:01,195
This guy.
这家伙。 

311
00:15:01,195 --> 00:15:04,355
AUDIENCE: Doesn't he have height 0, though?
听众：不过他不是有0身高吗？ 

312
00:15:04,355 --> 00:15:06,119
AUDIENCE: We're talking number of nodes.
听众：我们在谈论节点数。 

313
00:15:06,119 --> 00:15:06,459
AUDIENCE: Oh.
听众：哦。 

314
00:15:06,659 --> 00:15:07,887
Number of nodes, yeah.
节点数，是的。 

315
00:15:07,888 --> 00:15:10,918



316
00:15:10,918 --> 00:15:12,710
PROFESSOR: I'm not going to solve this now.
教授：我现在不打算解决这个问题。 

317
00:15:12,710 --> 00:15:14,675
We learned how to solve recurrences a long time ago,
我们很久以前就学会了如何解决复发问题， 

318
00:15:14,875 --> 00:15:16,879
so I'll pretend I still remember how to do that,
所以我假装我仍然记得该怎么做， 

319
00:15:16,879 --> 00:15:18,469
and I will tell you that the solution looks
我会告诉你解决方案看起来

320
00:15:18,669 --> 00:15:20,479
something like this.
这样的事情。 

321
00:15:20,480 --> 00:15:25,080
N of h is roughly 5, which is the magic number that we talked
 h的N大约为5，这是我们所说的幻数

322
00:15:25,080 --> 00:15:27,759
about in lecture-- roughly, which
大概在演讲中

323
00:15:27,759 --> 00:15:34,879
means there might be some things there that I forgot-- to the h.
意味着可能有一些我忘了的东西-h。 

324
00:15:34,879 --> 00:15:38,279
What really matters is that it's an exponential in h.
真正重要的是，它是h的指数。 

325
00:15:38,279 --> 00:15:40,829
If you look at these guys, this is close to the Fibonacci
如果你看这些家伙，这跟斐波那契很接近

326
00:15:40,830 --> 00:15:44,720
number formula except there's a plus 1 here.
数字公式，除了这里有一个加号1。 

327
00:15:44,720 --> 00:15:48,350
So these guys are bigger than the Fibonacci numbers.
因此，这些人比斐波那契数更大。 

328
00:15:48,350 --> 00:15:50,469
This is definitely bigger than whatever
绝对比什么都大

329
00:15:50,669 --> 00:15:52,044
the formula for Fibonacci numbers
斐波那契数的公式

330
00:15:52,044 --> 00:15:58,159
is, which is 5 to the h minus something over something.
是，即5减去h减去某物。 

331
00:15:58,159 --> 00:16:01,699
What really matters is the minimum number of nodes
真正重要的是最小节点数

332
00:16:01,700 --> 00:16:06,240
in an AVL of height h is an exponential as a function of h.
在高度AVL中，h是h的指数。 

333
00:16:06,240 --> 00:16:10,110
If you invert that, you get that the maximum height
如果将其反转，则得到最大高度

334
00:16:10,110 --> 00:16:20,159
for a tree with N nodes is log N. This is a way
对于具有N个节点的树，则为logN。这是一种方法

335
00:16:20,159 --> 00:16:24,269
to construct an AVL that shows you that the height has
构造一个AVL，向您显示高度

336
00:16:24,269 --> 00:16:27,399
to be logarithmic as long as we can keep this rep
只要我们能保持这个代表就可以对数

337
00:16:27,399 --> 00:16:29,656
invariant true.
不变的。 

338
00:16:29,657 --> 00:16:31,094
AUDIENCE: I have a question.
听众：我有一个问题。 

339
00:16:31,094 --> 00:16:35,884
I didn't quite follow how you got h minus 2 and h minus 1
我不太了解你如何得到h减2和h减1 

340
00:16:35,884 --> 00:16:37,330
there.
那里。 

341
00:16:37,330 --> 00:16:38,819
PROFESSOR: Here, here, here?
教授：在这里，在这里？ 

342
00:16:39,019 --> 00:16:40,836
AUDIENCE: There.
听众：在那里。 

343
00:16:40,836 --> 00:16:43,110
The tree down.
树倒了。 

344
00:16:43,110 --> 00:16:43,729
This one?
这个？ 

345
00:16:43,929 --> 00:16:44,629
This one?
这个？ 

346
00:16:44,629 --> 00:16:45,779
AUDIENCE: This one, yeah.
听众：是的。 

347
00:16:45,779 --> 00:16:46,362
PROFESSOR: OK.
教授：好的。 

348
00:16:46,363 --> 00:16:48,829
So suppose I'm at height 4 here.
因此，假设我的身高为4。 

349
00:16:49,029 --> 00:16:53,779



350
00:16:53,779 --> 00:16:56,789
What's the best way to construct an AVL that
构造AVL的最佳方法是什么

351
00:16:56,789 --> 00:16:59,719
has as few nodes as possible but height 4?
有尽可能少的节点，但高度为4？ 

352
00:16:59,720 --> 00:17:01,990
If this guy has to be at height 4,
如果这个家伙必须身高4， 

353
00:17:01,990 --> 00:17:06,180
then it has to have a child at height 3, at least one child.
那么它必须有一个3岁高的孩子，至少一个孩子。 

354
00:17:06,180 --> 00:17:08,880
Otherwise, it's not going to be height 4.
否则，它将不会达到高度4。 

355
00:17:08,880 --> 00:17:12,408
Now, I need to build something here that has height 3.
现在，我需要在此处构建高度为3的东西。 

356
00:17:12,608 --> 00:17:14,000
What should I build?
我应该建造什么？ 

357
00:17:14,000 --> 00:17:17,430
The best AVL tree that I know that has height 3, right?
我知道的最好的AVL树的高度为3，对吗？ 

358
00:17:17,430 --> 00:17:20,940
I have to get to height 3 using as few nodes as possible,
我必须使用尽可能少的节点来达到高度3， 

359
00:17:20,940 --> 00:17:23,490
so I'm going to use this guy because it has as few nodes as
所以我要使用这个人，因为它的节点数尽可能少

360
00:17:23,490 --> 00:17:26,230
possible and it has height 3.
可能的，它的高度为3。 

361
00:17:26,230 --> 00:17:29,990
So this covers my right side.
所以这涵盖了我的右边。 

362
00:17:29,990 --> 00:17:35,430
Now, for my left side, what am I going to use here?
现在，对于我的左侧，我将在这里使用什么？ 

363
00:17:35,430 --> 00:17:38,990
Another AVL tree that has as few nodes as possible, right?
另一个具有尽可能少的节点的AVL树，对不对？ 

364
00:17:38,990 --> 00:17:41,809
So I'm definitely keeping that.
所以我绝对会保留。 

365
00:17:41,809 --> 00:17:45,627
But what's going to be the height of that?
但是，高度将是什么？ 

366
00:17:45,627 --> 00:17:47,752
AUDIENCE: So we want the difference to be less than
听众：所以我们希望差异小于

367
00:17:47,752 --> 00:17:48,384
or equal to 1?
或等于1？ 

368
00:17:48,384 --> 00:17:49,049
PROFESSOR: Yeah.
教授：是的。 

369
00:17:49,049 --> 00:17:50,819
Otherwise, it's not an AVL.
否则，它不是AVL。 

370
00:17:50,819 --> 00:17:55,329
AUDIENCE: So it would be of height 4.
听众：高度为4。 

371
00:17:55,329 --> 00:17:58,689
PROFESSOR: So I know for sure that this guy has height 4.
教授：所以我确定这家伙的身高是4。 

372
00:17:58,690 --> 00:18:00,245
The difference has to be plus, minus 1.
差值必须为正负1。 

373
00:18:00,445 --> 00:18:01,569
AUDIENCE: So it would be 2.
听众：所以应该是2。 

374
00:18:01,569 --> 00:18:03,589
PROFESSOR: 2, 3, 4.
教授：2、3、4 

375
00:18:03,589 --> 00:18:06,361
I know for sure I don't want it to be 4,
我知道我不希望它是4 

376
00:18:06,362 --> 00:18:07,869
and now I have to choose between 2 and 3.
现在我必须在2到3之间进行选择

377
00:18:08,069 --> 00:18:10,354
A tree of height 2 will have fewer nodes
高度为2的树的节点更少

378
00:18:10,354 --> 00:18:11,769
than a tree of height 3, so that's
比一棵高3的树，所以

379
00:18:11,769 --> 00:18:14,139
why we're doing it this way.
为什么我们要这样做

380
00:18:14,140 --> 00:18:17,669
So to build a tree of height 4, build a tree of height 3,
因此，要建造一棵高4的树，建造一棵高3的树， 

381
00:18:17,869 --> 00:18:20,279
build a tree of height 2, connect them together.
建一棵高2的树，将它们连接在一起。 

382
00:18:20,279 --> 00:18:24,000
That's how we get to this, and then this.
这就是我们要达到的目标，然后是目标。 

383
00:18:24,000 --> 00:18:24,500
Cool.
凉。 

384
00:18:24,500 --> 00:18:27,220



385
00:18:27,220 --> 00:18:29,660
Do people remember how to do insertions and deletions
人们是否记得如何进行插入和删除

386
00:18:29,660 --> 00:18:30,920
in a regular binary tree?
在常规的二叉树中？ 

387
00:18:30,920 --> 00:18:34,879



388
00:18:35,079 --> 00:18:35,579
Yes?
是？ 

389
00:18:35,579 --> 00:18:40,419



390
00:18:40,420 --> 00:18:43,539
How do I insert 6.5 here in this one?
我要如何在这里插入6.5？ 

391
00:18:43,539 --> 00:18:47,359



392
00:18:47,359 --> 00:18:49,909
AUDIENCE: You take 6.5, you're like, oh, it's greater than 4,
听众：您拿6.5，就像，哦，大于4， 

393
00:18:49,910 --> 00:18:51,410
then you move to 5.
然后转到5。 

394
00:18:51,410 --> 00:18:53,410
Then you're like, oh, it's greater than 5.
然后，您就像哦，大于5。 

395
00:18:53,410 --> 00:18:53,920
Go to 6.
转到6。 

396
00:18:53,920 --> 00:18:58,230
Oh, it's less than 6, and then it goes to the left of 6.
哦，它小于6，然后到6的左边。 

397
00:18:58,230 --> 00:18:59,586
I mean-- sorry.
我的意思是-抱歉。 

398
00:18:59,586 --> 00:19:02,460
I meant left of 7.
我的意思是离开7。 

399
00:19:02,460 --> 00:19:02,909
PROFESSOR: OK.
教授：好的。 

400
00:19:03,109 --> 00:19:04,788
So it's bigger than--
因此，它比- 

401
00:19:04,788 --> 00:19:06,500
AUDIENCE: Testing you all, guys.
观众：大家都在测试。 

402
00:19:06,500 --> 00:19:08,920
Oh yeah.
哦耶。 

403
00:19:08,920 --> 00:19:11,967
6.5 is bigger than 6, so then it goes to the left of 7
 6.5大于6，因此它位于7的左侧

404
00:19:12,167 --> 00:19:13,580
because it's less than 7.
因为小于7 

405
00:19:13,580 --> 00:19:18,000



406
00:19:18,000 --> 00:19:21,898
PROFESSOR: I thought I had my example wrong for a second.
教授：我以为我的例子错了一秒钟。 

407
00:19:21,898 --> 00:19:22,939
AUDIENCE: I'm just tired.
听众：我很累。 

408
00:19:22,940 --> 00:19:27,059
PROFESSOR: Me too, so don't scare me.
教授：我也是，所以不要吓我。 

409
00:19:27,059 --> 00:19:29,389
All right.
好吧。 

410
00:19:29,390 --> 00:19:32,740
So suppose we have heights stored in the nodes here,
因此，假设我们在此处的节点中存储了高度， 

411
00:19:32,740 --> 00:19:35,480
because we want to do that for AVLs.
因为我们要为AVL做到这一点。 

412
00:19:35,480 --> 00:19:39,960
We'll figure out why in a bit.
我们稍后会找出原因。 

413
00:19:39,960 --> 00:19:45,519
The height of this guy used to be 0, 1, 2, 3, right?
这个家伙的身高曾经是0、1、2、3，对吧？ 

414
00:19:45,519 --> 00:19:50,648
0, 1, 2, 3.
 0、1、2、3。 

415
00:19:50,648 --> 00:19:52,189
What happened when I added this node?
添加此节点时发生了什么？ 

416
00:19:52,190 --> 00:19:54,619



417
00:19:54,819 --> 00:19:57,923
AUDIENCE: You added 1 to everything [INAUDIBLE].
听众：您对所有[听不清]加了1。 

418
00:19:57,923 --> 00:19:58,589
PROFESSOR: Yeah.
教授：是的。 

419
00:19:58,589 --> 00:20:01,339
So I went down on my insertion path
所以我沿着插入路径走了

420
00:20:01,339 --> 00:20:04,959
to find out where to insert a node, and then I added it.
找出要插入节点的位置，然后将其添加。 

421
00:20:04,960 --> 00:20:07,480



422
00:20:07,480 --> 00:20:09,079
I just chose my case conveniently,
我只是方便地选择了我的箱子， 

423
00:20:09,079 --> 00:20:11,809
but in some cases, all the heights
但在某些情况下，所有高度

424
00:20:11,809 --> 00:20:14,990
of the nodes on that path have changed.
该路径上的节点数已更改。 

425
00:20:14,990 --> 00:20:18,089
So in an AVL, after we insert, we
因此，在AVL中，插入后

426
00:20:18,089 --> 00:20:19,720
have to make sure that the height
必须确保高度

427
00:20:19,720 --> 00:20:23,000
of every node on the path is updated.
路径上每个节点的更新。 

428
00:20:23,000 --> 00:20:24,599
Does this make sense?
这有意义吗？ 

429
00:20:24,599 --> 00:20:30,500
So the heights will be 1, 2, 3, 4.
因此，高度将为1、2、3、4。 

430
00:20:30,500 --> 00:20:33,539



431
00:20:33,539 --> 00:20:35,440
So the way we implemented the AVLs is
因此，我们实施AVL的方式是

432
00:20:35,440 --> 00:20:38,690
that we do regular insertions and deletions,
我们会定期进行插入和删除操作， 

433
00:20:38,690 --> 00:20:42,159
and then at the end, we say, well it used to be an AVL.
最后，我们说它曾经是AVL。 

434
00:20:42,359 --> 00:20:43,859
Now we added or removed the node,
现在我们添加或删除了该节点， 

435
00:20:43,859 --> 00:20:46,359
so it might be a slightly unbalanced AVL,
因此它可能是略微不平衡的AVL， 

436
00:20:46,359 --> 00:20:49,339
which means it's not an AVL.
这意味着它不是AVL。 

437
00:20:49,339 --> 00:20:51,319
And we have the rebalance procedure.
我们有重新平衡程序。 

438
00:20:51,319 --> 00:20:56,041
So if you look at on the second page of the code,
因此，如果您查看代码的第二页， 

439
00:20:56,041 --> 00:20:59,619
insert and delete are really tiny, lines 20 to 22
插入和删除的确很小，第20至22行

440
00:20:59,619 --> 00:21:01,379
and 24 to 28.
和24至28。 

441
00:21:01,380 --> 00:21:03,980
And they're really tiny because they call the old code
而且它们真的很小，因为它们调用了旧代码

442
00:21:03,980 --> 00:21:06,500
and then they call Rebalance.
然后他们称重新平衡。 

443
00:21:06,500 --> 00:21:11,200
So all the magic in an AVL is in Rebalance.
因此，AVL中的所有魔力都在重新平衡中。 

444
00:21:11,200 --> 00:21:13,650
The first thing that Rebalance does, if you see,
如果您看到，Rebalance要做的第一件事就是， 

445
00:21:13,650 --> 00:21:16,410
it has a while loop there, and the first thing that it does
它在那里有一个while循环，它做的第一件事

446
00:21:16,410 --> 00:21:20,150
in the while loop is it updates the height, and this is why.
在while循环中它会更新高度，这就是原因。 

447
00:21:20,150 --> 00:21:22,339
The height might have changed after the insert,
插入后，高度可能已更改， 

448
00:21:22,539 --> 00:21:25,210
so any decision based on the old height is bad.
因此任何基于旧高度的决定都是不好的。 

449
00:21:25,210 --> 00:21:28,391



450
00:21:28,391 --> 00:21:29,640
That's why we have that there.
这就是为什么我们在那里。 

451
00:21:29,640 --> 00:21:32,900



452
00:21:32,900 --> 00:21:33,579
Make sense so far?
到目前为止有意义吗？ 

453
00:21:33,779 --> 00:21:38,609



454
00:21:38,609 --> 00:21:42,439
So if you look at rebalance, don't try to understand it
因此，如果您考虑重新平衡，请不要试图理解它

455
00:21:42,440 --> 00:21:44,529
quite yet, but what it does is it
还没有，但是它的作用是

456
00:21:44,529 --> 00:21:47,307
calls Rotate Left and Rotate Right.
调用“向左旋转”和“向右旋转”。 

457
00:21:47,307 --> 00:21:48,640
Well, Left Rotate, Right Rotate.
好吧，向左旋转，向右旋转。 

458
00:21:48,640 --> 00:21:51,190



459
00:21:51,190 --> 00:21:53,980
All the magic is in Rebalance, and the tools that it uses
所有的魔力都在重新平衡中，以及它所使用的工具

460
00:21:53,980 --> 00:21:56,930
are Left Rotate and Right Rotate.
是“向左旋转”和“向右旋转”。 

461
00:21:56,930 --> 00:21:59,799
Now, I'm going to show you what a rotation is supposed
现在，我将向您展示应该进行的轮换

462
00:21:59,799 --> 00:22:16,950
to do in-- and the children of these nodes are a, b, c, d.
要做-这些节点的子节点是a，b，c，d。 

463
00:22:16,950 --> 00:22:23,659
Also, this node is hanging off of something here, e.
同样，此节点在这里悬挂着某些东西。 

464
00:22:23,859 --> 00:22:26,629
If I want to do a Right Rotate here,
如果我想在这里进行右旋转， 

465
00:22:26,630 --> 00:22:33,159
so if I want to rotate the tree like this, then after rotating,
所以如果我想像这样旋转树，那么旋转后

466
00:22:33,359 --> 00:22:34,805
it's going to look like this.
它看起来像这样。 

467
00:22:34,806 --> 00:22:51,659



468
00:22:51,859 --> 00:22:57,240
So notice that c got moved from B to A, but it got
所以请注意c从B移到A，但是

469
00:22:57,240 --> 00:23:00,319
moved in such a way that the whole thing is still a BST.
整个过程仍然是BST。 

470
00:23:00,319 --> 00:23:03,049
These guys show up in the same order as children,
这些人的出现顺序与孩子相同， 

471
00:23:03,049 --> 00:23:05,700
and these guys show up in the same order,
这些家伙以相同的顺序出现， 

472
00:23:05,700 --> 00:23:08,403
so search will still work.
因此搜索仍然有效。 

473
00:23:08,403 --> 00:23:10,569
This is how it's supposed to look like as a picture.
这就是它看起来像图片的样子。 

474
00:23:10,569 --> 00:23:13,829
Let's try to write the pseudocode for achieving this.
让我们尝试编写用于实现此目的的伪代码。 

475
00:23:13,829 --> 00:23:17,449



476
00:23:17,450 --> 00:23:21,160
AUDIENCE: First, you identify the parent node.
听众：首先，您确定父节点。 

477
00:23:21,160 --> 00:23:23,734
Step one.
第一步。 

478
00:23:23,934 --> 00:23:26,319
PROFESSOR: Well, let's say we have it.
教授：好吧，我们可以拥有它。 

479
00:23:26,319 --> 00:23:29,789
AUDIENCE: I mean from B. You say, A is my parent.
听众：我的意思是从B。你说，A是我的父母。 

480
00:23:29,789 --> 00:23:32,476
That's now going to become my right child.
现在这将成为我的正确孩子。 

481
00:23:32,477 --> 00:23:32,859
PROFESSOR: OK.
教授：好的。 

482
00:23:33,059 --> 00:23:38,059



483
00:23:38,059 --> 00:23:40,740
So what do you want to change?
那你想改变什么？ 

484
00:23:40,740 --> 00:23:44,400
By the way, this whole thing has to happen in constant time,
顺便说一句，这整个事情必须在恒定的时间内发生， 

485
00:23:44,400 --> 00:23:47,150
so we're not allowed to go anywhere inside here, here,
所以我们不允许在这里，这里， 

486
00:23:47,150 --> 00:23:48,169
here, or here.
在这里或这里。 

487
00:23:48,369 --> 00:23:49,869
We're allowed to change these links,
我们可以更改这些链接， 

488
00:23:49,869 --> 00:23:51,509
but if you go inside and try to do
但是如果你进去尝试

489
00:23:51,509 --> 00:23:53,500
more complicated restructuring, that's
更复杂的重组，那就是

490
00:23:53,500 --> 00:23:55,297
going to block the running time.
会阻塞运行时间。 

491
00:23:55,297 --> 00:23:56,880
We're only allowed to change the links
我们只允许更改链接

492
00:23:56,880 --> 00:23:58,369
that you see on the board.
您在黑板上看到的。 

493
00:23:58,569 --> 00:24:04,149
AUDIENCE: I know in the BST, not BST node but BST, the delete,
听众：我知道在BST中，不是BST节点，而是BST，删除， 

494
00:24:04,150 --> 00:24:07,849
if you're deleting the root, they make up the pseudoroot.
如果要删除根，则它们将构成伪根。 

495
00:24:08,049 --> 00:24:10,440
PROFESSOR: Let's not worry about it.
教授：我们不用担心。 

496
00:24:10,440 --> 00:24:12,970
So Delete already did that magic for you, right?
所以Delete已经为您做到了，对吗？ 

497
00:24:12,970 --> 00:24:16,221
So the pseudoroot would be here, so this node has a root.
因此伪根将在此处，因此该节点具有根。 

498
00:24:16,221 --> 00:24:16,720
We're happy.
很高兴。 

499
00:24:16,720 --> 00:24:18,553
AUDIENCE: That's not what I'm talking about.
听众：我不是在说这个。 

500
00:24:18,553 --> 00:24:21,720
I'm saying that you could do the same with B because you're
我是说你可以对B做同样的事情，因为你

501
00:24:21,720 --> 00:24:24,899
going to have to break a link with lowercase c onto B
将不得不断开小写字母c到B的链接

502
00:24:25,099 --> 00:24:28,519
in order to flip it.
为了翻转它。 

503
00:24:28,519 --> 00:24:32,509
So I'm saying you could have a placer, some sort of place
所以我说你可以有一个放置器

504
00:24:32,509 --> 00:24:35,606
to put it so you don't lose it.
放它，这样您就不会丢失它。 

505
00:24:35,606 --> 00:24:36,190
PROFESSOR: OK.
教授：好的。 

506
00:24:36,190 --> 00:24:40,129
Let's see if we do that.
让我们看看我们是否这样做。 

507
00:24:40,329 --> 00:24:44,649
AUDIENCE: The new right child of B will be A,
听众：B的新右子将是A， 

508
00:24:44,650 --> 00:24:50,639
and the new left child of A will be C, and the new parent of c
 A的新左子将是C，c的新父

509
00:24:50,839 --> 00:24:51,750
is A.
是A。 

510
00:24:51,750 --> 00:24:54,144
PROFESSOR: OK, let's move slower.
教授：好的，我们走慢一些。 

511
00:24:54,144 --> 00:24:55,660
I have to write them down.
我要写下来

512
00:24:55,660 --> 00:24:59,131
So the new right child of B is?
那么B的新右子是？ 

513
00:24:59,131 --> 00:25:03,690
AUDIENCE: Is A. Also, you probably
听众：是A。另外，你可能

514
00:25:03,690 --> 00:25:05,601
should do temp variables to store them.
应该做临时变量来存储它们。 

515
00:25:05,601 --> 00:25:06,899
AUDIENCE: I don't think you have to.
听众：我认为你不必这样做。 

516
00:25:07,099 --> 00:25:12,432
You can just swap the one connection and swap the other.
您可以交换一个连接而交换另一个连接。 

517
00:25:12,432 --> 00:25:15,064



518
00:25:15,064 --> 00:25:17,230
PROFESSOR: Let's do it without worrying about temps,
教授：我们不用担心临时工， 

519
00:25:17,230 --> 00:25:19,150
and then we can figure out temps later.
然后我们可以找出临时的

520
00:25:19,150 --> 00:25:26,000
So B's right becomes A. So it's going to be like this.
这样B的权利就变成了A。所以它将像这样。 

521
00:25:26,000 --> 00:25:30,673



522
00:25:30,673 --> 00:25:32,089
Let me erase this confusing error.
让我消除这个令人困惑的错误。 

523
00:25:32,089 --> 00:25:36,559



524
00:25:36,559 --> 00:25:38,784
AUDIENCE: And A's left child is c.
听众：A的左孩子是c。 

525
00:25:38,785 --> 00:25:45,420



526
00:25:45,420 --> 00:25:52,250
PROFESSOR: A's left child is c.
教授：A的左孩子是c。 

527
00:25:52,250 --> 00:25:54,150
OK.
好。 

528
00:25:54,150 --> 00:25:56,589
AUDIENCE: C's parent is A.
听众：C的父母是A。 

529
00:25:56,789 --> 00:26:02,980
PROFESSOR: C's parent is A. OK, very good.
教授：C的父母是A。好的，很好。 

530
00:26:02,980 --> 00:26:05,104
So I changed the child, then I changed the parent
所以我改变了孩子，然后我改变了父母

531
00:26:05,104 --> 00:26:06,269
so that they would match up.
这样他们才能配对。 

532
00:26:06,269 --> 00:26:10,160



533
00:26:10,160 --> 00:26:13,285
So if B's right is A, then what should I do with--
因此，如果B的权利是A，那我该怎么做- 

534
00:26:13,285 --> 00:26:19,063
AUDIENCE: A's parent is B.
听众：A的父母是B。 

535
00:26:19,263 --> 00:26:20,679
PROFESSOR: Always do them in pairs
教授：总是成对做

536
00:26:20,680 --> 00:26:23,789
so you don't lose track of them.
这样您就不会失去对它们的了解。 

537
00:26:23,789 --> 00:26:24,516
And?
和？ 

538
00:26:24,516 --> 00:26:29,592
AUDIENCE: B's parent is e and e's subchild is B.
听众：B的父母是e，e的子孩子是B。 

539
00:26:29,592 --> 00:26:30,099
PROFESSOR: Sorry.
教授：对不起。 

540
00:26:30,299 --> 00:26:32,605
B's parent is e, right?
 B的父母是e，对吗？ 

541
00:26:32,605 --> 00:26:33,230
AUDIENCE: Yeah.
听众：是的。 

542
00:26:33,230 --> 00:26:36,491



543
00:26:36,491 --> 00:26:40,170
PROFESSOR: So B's parent is e, and--
教授：那么B的父母是e，并且- 

544
00:26:40,170 --> 00:26:41,889
AUDIENCE: e's left.
听众：e离开了。 

545
00:26:42,089 --> 00:26:43,470
PROFESSOR: Child is--
教授：孩子是- 

546
00:26:43,470 --> 00:26:44,390
AUDIENCE: B.
听众：B. 

547
00:26:44,390 --> 00:26:46,796
PROFESSOR: Because I drew it like this, right?
教授：因为我是这样画的，对吗？ 

548
00:26:46,796 --> 00:26:49,940
But if I drew it like this?
但是如果我这样画的话？ 

549
00:26:49,940 --> 00:26:52,150
AUDIENCE: e's--
听众：e是

550
00:26:52,150 --> 00:26:54,129
PROFESSOR: It would have to be the right child,
教授：那一定是合适的孩子， 

551
00:26:54,329 --> 00:26:57,931
so we have to look at both cases.
所以我们必须看两种情况。 

552
00:26:57,931 --> 00:26:59,678
AUDIENCE: If B is greater than e,
听众：如果B大于e， 

553
00:26:59,878 --> 00:27:04,748
then it would be right child, and if B is less than e,
那将是正确的孩子，如果B小于e， 

554
00:27:04,749 --> 00:27:05,977
it would be left child.
那将是孩子。 

555
00:27:05,977 --> 00:27:06,359
PROFESSOR: OK.
教授：好的。 

556
00:27:06,559 --> 00:27:18,539
So if B is greater than e, then e's right is B.
因此，如果B大于e，那么e的权利就是B。 

557
00:27:18,539 --> 00:27:23,680
Otherwise, e's left is B, right?
否则，e的左边是B，对吗？ 

558
00:27:23,680 --> 00:27:25,539
Now, suppose comparisons are expensive
现在，假设比较昂贵

559
00:27:25,539 --> 00:27:27,874
and they don't want to do a comparison to find this out.
他们不想进行比较以找出答案。 

560
00:27:27,874 --> 00:27:29,414
I want to play with the tree instead.
我想和树一起玩。 

561
00:27:29,414 --> 00:27:29,990
What do I do?
我该怎么办？ 

562
00:27:29,990 --> 00:27:37,372



563
00:27:37,372 --> 00:27:41,880
AUDIENCE: Can you see which one A was before that?
听众：你能看到之前的那个A吗？ 

564
00:27:41,880 --> 00:27:43,670
PROFESSOR: Yep.
教授：是的。 

565
00:27:43,670 --> 00:27:45,884
AUDIENCE: If A used to be the right child,
听众：如果A曾经是合适的孩子， 

566
00:27:45,884 --> 00:27:47,099
now B is the right child.
现在B是合适的孩子。 

567
00:27:47,099 --> 00:27:47,765
PROFESSOR: Yeah.
教授：是的。 

568
00:27:47,766 --> 00:27:51,150
I haven't changed the child yet, so I can do that.
我还没有改变孩子，所以我可以做到。 

569
00:27:51,150 --> 00:27:54,355
AUDIENCE: That's still a comparison though, right?
听众：但这仍然是一个比较，对吗？ 

570
00:27:54,355 --> 00:27:56,730
PROFESSOR: But now I'm doing a pointer comparison and not
教授：但是现在我在做指针比较，而不是

571
00:27:56,730 --> 00:27:59,509
a key comparison.
关键比较。 

572
00:27:59,509 --> 00:28:02,269
AUDIENCE: If e.r is A, then--
听众：如果er是A，则- 

573
00:28:02,269 --> 00:28:08,269
PROFESSOR: If e.right is A, then it becomes B. Otherwise.
教授：如果e.right是A，则它成为B。否则。 

574
00:28:08,269 --> 00:28:11,059



575
00:28:11,059 --> 00:28:13,706
OK, this looks good.
好，看起来不错

576
00:28:13,707 --> 00:28:15,089
So there's the issue of temp variables
因此存在临时变量的问题

577
00:28:15,289 --> 00:28:16,969
and assigning these in the right order
并按正确的顺序分配它们

578
00:28:16,969 --> 00:28:19,009
so you don't have too many temp variables and too
所以你没有太多的临时变量

579
00:28:19,009 --> 00:28:22,309
many lines of code, and the Python code in the handout
多行代码，以及讲义中的Python代码

580
00:28:22,309 --> 00:28:23,649
takes care of that.
照顾那个。 

581
00:28:23,650 --> 00:28:25,380
But this is the logic that you want.
但这是您想要的逻辑。 

582
00:28:25,380 --> 00:28:28,890
So if you have to write it from scratch,
因此，如果您必须从头开始编写， 

583
00:28:28,890 --> 00:28:30,069
you don't have to memorize that.
您不必记住这一点。 

584
00:28:30,269 --> 00:28:32,759
Remember that you want to get from here to here,
请记住，您想从这里到达这里， 

585
00:28:32,759 --> 00:28:37,210
and do exactly the thought process that we have here.
并精确地进行我们在这里的思考过程。 

586
00:28:37,210 --> 00:28:42,059
What if I want to do a left rotation instead
如果我想做左旋转怎么办

587
00:28:42,059 --> 00:28:45,450
of a right rotation?
右旋转？ 

588
00:28:45,450 --> 00:28:49,135
AUDIENCE: You just have to change the r's to l's.
听众：您只需要将r更改为l。 

589
00:28:49,135 --> 00:28:50,009
PROFESSOR: Very good.
教授：非常好。 

590
00:28:50,009 --> 00:28:51,089
Copy, paste.
复制粘贴。 

591
00:28:51,089 --> 00:28:52,769
Swap l's and r's and we're done.
交换l和r，我们就完成了。 

592
00:28:52,769 --> 00:28:57,059



593
00:28:57,059 --> 00:28:58,119
Why do we need rotations?
为什么我们需要轮换？ 

594
00:28:58,119 --> 00:29:02,901



595
00:29:02,902 --> 00:29:03,909
AUDIENCE: To rebalance stuff.
听众：重新平衡事物。 

596
00:29:04,109 --> 00:29:05,199
PROFESSOR: To rebalance stuff.
教授：重新平衡东西。 

597
00:29:05,200 --> 00:29:05,700
OK.
好。 

598
00:29:05,700 --> 00:29:08,068
Why do we rebalance stuff?
为什么我们要重新平衡东西？ 

599
00:29:08,068 --> 00:29:10,000
AUDIENCE: Because you don't want your code
听众：因为你不想要你的代码

600
00:29:10,000 --> 00:29:12,634
to crash when you add nodes that are sequentially larger,
当添加顺序更大的节点时崩溃， 

601
00:29:12,634 --> 00:29:16,041
and then you try to find something, and then it crashes.
然后尝试找到某些东西，然后崩溃。 

602
00:29:16,041 --> 00:29:16,625
PROFESSOR: OK.
教授：好的。 

603
00:29:16,625 --> 00:29:17,741
Why would it crash?
为什么会崩溃？ 

604
00:29:17,741 --> 00:29:19,282
AUDIENCE: Because the recursion depth
听众：因为递归深度

605
00:29:19,282 --> 00:29:21,601
is exceeded because you're going down
被超越，因为你要下去

606
00:29:21,602 --> 00:29:22,839
the line trying to find something,
线试图找到一些东西， 

607
00:29:23,039 --> 00:29:24,517
and you go down too far.
而且你走得太远了。 

608
00:29:24,517 --> 00:29:24,899
PROFESSOR: OK.
教授：好的。 

609
00:29:25,099 --> 00:29:27,649
So pretending we don't have a recursion depth issue,
因此，假装我们没有递归深度问题， 

610
00:29:27,650 --> 00:29:30,670
then it's going to be slow.
那就慢了

611
00:29:30,670 --> 00:29:33,990
So you start from a nice AVL, and if you don't rebalance,
因此，您从一个不错的AVL开始，如果您不重新平衡， 

612
00:29:33,990 --> 00:29:37,430
you get to a BST that's slow, slow, slow,
您会遇到缓慢，缓慢，缓慢的BST， 

613
00:29:37,430 --> 00:29:40,240
and then you'll fail our tests and still get a 0.
然后您将无法通过我们的测试，但仍然得到0。 

614
00:29:40,240 --> 00:29:40,740
Yes?
是？ 

615
00:29:40,740 --> 00:29:47,559
AUDIENCE: But if you just had a carrot-like tree,
观众：但是如果你有一棵胡萝卜状的树， 

616
00:29:47,559 --> 00:29:50,470
or if you added, for instance, 4, and then you added in 5,
或者您添加了例如4，然后添加了5 

617
00:29:50,470 --> 00:29:52,960
and then you added in 3, and then you added in 6,
然后添加3，然后添加6， 

618
00:29:52,960 --> 00:29:57,299
and then you added in 2, you'd just get a carrot.
然后添加2，就可以得到胡萝卜。 

619
00:29:57,299 --> 00:30:02,930
So then I feel like AVL wouldn't cover that case.
因此，我觉得AVL无法解决这种情况。 

620
00:30:02,930 --> 00:30:04,970
PROFESSOR: Let's do them in sequence.
教授：让我们按顺序进行。 

621
00:30:04,970 --> 00:30:09,500



622
00:30:09,500 --> 00:30:12,047
So what are we inserting?
那么我们要插入什么？ 

623
00:30:12,047 --> 00:30:12,630
So you said 4.
所以你说4。 

624
00:30:12,630 --> 00:30:15,450
AUDIENCE: So you start with 4, and then you insert 5,
听众：因此，您从4开始，然后插入5， 

625
00:30:15,450 --> 00:30:18,759
then you insert 3.
然后插入3。 

626
00:30:18,759 --> 00:30:19,700
PROFESSOR: Let's see.
教授：让我们看看。 

627
00:30:19,700 --> 00:30:21,402
4, 3.
 4、3 

628
00:30:21,402 --> 00:30:28,529
AUDIENCE: Then you insert 6, then you insert 2,
听众：然后插入6，然后插入2， 

629
00:30:28,529 --> 00:30:34,149
then you insert 7, and then 1.
然后输入7，然后输入1。 

630
00:30:34,150 --> 00:30:35,650
AUDIENCE: You've got to rotate that.
听众：您必须旋转它。 

631
00:30:35,650 --> 00:30:36,970
AUDIENCE: Well, the thing is--
听众：好吧，事情是- 

632
00:30:36,970 --> 00:30:38,515
PROFESSOR: Well, is this an AVL?
教授：嗯，这是AVL吗？ 

633
00:30:38,515 --> 00:30:39,831
PROFESSOR: Well, it's balanced.
教授：好吧，这很均衡。 

634
00:30:40,031 --> 00:30:40,740
PROFESSOR: Is it?
教授：是吗？ 

635
00:30:40,740 --> 00:30:42,453
AUDIENCE: No, it's not.
听众：不，不是。 

636
00:30:42,453 --> 00:30:43,389
5 is unhappy.
 5不开心。 

637
00:30:43,390 --> 00:30:46,200



638
00:30:46,200 --> 00:30:49,140
AUDIENCE: That height of the tree is only one
听众：那棵树的高度只有一

639
00:30:49,140 --> 00:30:51,069
greater than the other height.
大于其他高度。 

640
00:30:51,269 --> 00:30:53,014
PROFESSOR: So the height here is 1.
教授：所以这里的高度是1。 

641
00:30:53,015 --> 00:30:56,442
What's the height here?
这里的高度是多少？ 

642
00:30:56,442 --> 00:30:58,400
There's nothing here, so the height is minus 1.
这里什么都没有，所以高度是负1。 

643
00:30:58,400 --> 00:31:02,200



644
00:31:02,200 --> 00:31:06,059
AUDIENCE: I mean, but the other side of the tree.
听众：我的意思是，但那棵树的另一边。 

645
00:31:06,059 --> 00:31:08,819
PROFESSOR: So if you're looking at this guy,
教授：所以，如果您正在寻找这个人， 

646
00:31:08,819 --> 00:31:11,509
things look balanced, but in an AVL,
情况看起来很平衡，但是在AVL中， 

647
00:31:11,509 --> 00:31:14,571
this has to hold for every node.
这必须适用于每个节点。 

648
00:31:14,571 --> 00:31:16,779
If there's one node where the heights are unbalanced,
如果有一个节点的高度不平衡， 

649
00:31:16,779 --> 00:31:18,433
the whole thing is unbalanced.
整个事情是不平衡的。 

650
00:31:18,433 --> 00:31:20,349
Otherwise, the construction that we did before
否则，我们之前所做的构造

651
00:31:20,349 --> 00:31:22,069
wouldn't make sense.
没道理

652
00:31:22,069 --> 00:31:24,319
AUDIENCE: It's all [INAUDIBLE] within the [INAUDIBLE].
听众：[音频不清晰]中的所有[音频不清晰]。 

653
00:31:24,319 --> 00:31:25,220
PROFESSOR: Yep.
教授：是的。 

654
00:31:25,220 --> 00:31:27,819
So now that we're going to look at rebalancing, which
所以现在我们要考虑重新平衡， 

655
00:31:27,819 --> 00:31:29,349
is the magic behind AVLs, we have
是AVL背后的魔力，我们有

656
00:31:29,349 --> 00:31:32,919
to make sure that after we start with something that's
确保在我们开始时

657
00:31:32,920 --> 00:31:35,128
slightly imbalanced, when we rotate things around,
稍微不平衡，当我们旋转事物时， 

658
00:31:35,328 --> 00:31:37,412
we have to make sure that everything gets balanced
我们必须确保一切都平衡

659
00:31:37,412 --> 00:31:42,319
at the end and happy, so that's a good thing to keep in mind.
最后要开心，所以要牢记这是一件好事。 

660
00:31:42,319 --> 00:31:42,819
Good.
好。 

661
00:31:42,819 --> 00:31:43,730
Any other questions?
还有其他问题吗？ 

662
00:31:43,730 --> 00:31:47,880



663
00:31:47,880 --> 00:31:50,053
AUDIENCE: Is it obvious that you can
听众：很明显，你可以

664
00:31:50,253 --> 00:31:53,039
put any number of nodes in an AVL tree?
在AVL树中放置任意数量的节点？ 

665
00:31:53,039 --> 00:31:54,700
PROFESSOR: Point any number of nodes?
教授：指向多少个节点？ 

666
00:31:54,700 --> 00:31:56,159
AUDIENCE: Yeah.
听众：是的。 

667
00:31:56,359 --> 00:31:59,512
It's obvious that you can do one node, or two nodes or three
很明显，您可以做一个节点，或者两个或三个节点

668
00:31:59,512 --> 00:32:05,019
nodes, but is it true that for any number of nodes,
节点，但是对于任何数量的节点， 

669
00:32:05,019 --> 00:32:07,029
you can arrange into an AVL tree?
你可以安排成AVL树吗？ 

670
00:32:07,029 --> 00:32:08,644
Does that make sense?
那有意义吗？ 

671
00:32:08,644 --> 00:32:09,309
PROFESSOR: Yeah.
教授：是的。 

672
00:32:09,309 --> 00:32:13,029
So if you want to have any number of nodes,
因此，如果您想拥有任意数量的节点， 

673
00:32:13,029 --> 00:32:16,142
you call Insert, AVL Insert, and then you'll get an AVL.
依次调用“插入”，“ AVL插入”，然后您将获得一个AVL。 

674
00:32:16,142 --> 00:32:16,807
AUDIENCE: Right.
听众：对。 

675
00:32:16,807 --> 00:32:19,099
But what I'm trying to say is, is it
但是我想说的是

676
00:32:19,099 --> 00:32:23,230
possible to construct an AVL tree out of 13 nodes?
可以从13个节点中构建AVL树？ 

677
00:32:23,230 --> 00:32:24,230
PROFESSOR: Sure.
教授：当然可以。 

678
00:32:24,230 --> 00:32:25,957
AUDIENCE: Or 17 nodes?
听众：还是17个节点？ 

679
00:32:26,157 --> 00:32:28,615
AUDIENCE: Is there a limit for where that property will not
听众：该财产不会受到限制的地方

680
00:32:28,615 --> 00:32:29,115
fit?
适合？ 

681
00:32:29,115 --> 00:32:29,829
AUDIENCE: Right.
听众：对。 

682
00:32:29,829 --> 00:32:31,586
Is there some set of nodes--
是否有一些节点集- 

683
00:32:31,586 --> 00:32:32,920
PROFESSOR: I like this question.
教授：我喜欢这个问题。 

684
00:32:32,920 --> 00:32:34,160
I like this question.
我喜欢这个问题。 

685
00:32:34,160 --> 00:32:39,720
So what would be the perfect binary search tree?
那么什么是完美的二叉搜索树？ 

686
00:32:39,720 --> 00:32:42,683



687
00:32:42,683 --> 00:32:44,999
AUDIENCE: An element of log N height.
听众：高度为N的元素。 

688
00:32:44,999 --> 00:32:46,539
PROFESSOR: An element of log N height
教授：高度为N的元素

689
00:32:46,539 --> 00:32:54,200
and the complete tree, so something that looks like this.
和完整的树，看起来像这样

690
00:32:54,200 --> 00:33:00,640



691
00:33:00,640 --> 00:33:04,464
Where did we see this thing before?
我们以前在哪里看过这个东西？ 

692
00:33:04,664 --> 00:33:05,595
AUDIENCE: In the heap.
听众：在堆里​​。 

693
00:33:05,595 --> 00:33:06,470
PROFESSOR: All right.
教授：好的。 

694
00:33:06,470 --> 00:33:08,650
So a heap looks exactly like this,
所以堆看起来像这样

695
00:33:08,650 --> 00:33:13,419
except the values inside don't fulfill the BST requirement.
除了其中的值不满足BST要求。 

696
00:33:13,619 --> 00:33:15,674
Otherwise, we'd know how to build perfect BSTs.
否则，我们将知道如何构建完善的BST。 

697
00:33:15,674 --> 00:33:17,779
It so happens that we don't.
碰巧我们没有。 

698
00:33:17,779 --> 00:33:19,349
But is this an AVL?
但这是AVL吗？ 

699
00:33:19,349 --> 00:33:25,894



700
00:33:25,894 --> 00:33:26,478
AUDIENCE: Yes.
听众：是的。 

701
00:33:26,478 --> 00:33:31,835



702
00:33:31,835 --> 00:33:34,082
AUDIENCE: That example or in general?
听众：那个例子还是一般来说？ 

703
00:33:34,082 --> 00:33:35,589
PROFESSOR: Let's start with that example.
教授：让我们从该示例开始。 

704
00:33:35,789 --> 00:33:36,414
Is this an AVL?
这是AVL吗？ 

705
00:33:36,414 --> 00:33:41,289



706
00:33:41,289 --> 00:33:42,359
AUDIENCE: No.
听众：不。 

707
00:33:42,359 --> 00:33:45,599
The node just to the left of the root--
根节点左侧的节点- 

708
00:33:45,599 --> 00:33:47,250
PROFESSOR: This guy?
教授：这个家伙？ 

709
00:33:47,250 --> 00:33:49,130
AUDIENCE: No.
听众：不。 

710
00:33:49,130 --> 00:33:51,831
That one's of height two, so it has height one.
这个人的身高是2，所以它的身高是1。 

711
00:33:52,031 --> 00:33:53,240
PROFESSOR: This is beautiful.
教授：这很漂亮。 

712
00:33:53,240 --> 00:33:54,890
This is as good as it could get.
这是可以得到的。 

713
00:33:54,890 --> 00:33:56,740
This is an optimal binary search tree.
这是最佳的二叉搜索树。 

714
00:33:56,740 --> 00:33:59,190
This is perfect.
太棒了。 

715
00:33:59,190 --> 00:34:00,899
It better match the definition of AVL,
它更符合AVL的定义， 

716
00:34:01,099 --> 00:34:04,269
because otherwise, it would mean AVL doesn't like perfect trees.
因为否则，这将意味着AVL不喜欢完美的树木。 

717
00:34:04,269 --> 00:34:06,829
So the good news is that any complete tree
好消息是，任何一棵完整的树

718
00:34:06,829 --> 00:34:10,159
is going to be an AVL because everything
将成为一个AVL，因为一切

719
00:34:10,159 --> 00:34:14,989
is perfectly balanced or almost perfectly balanced.
完全平衡或几乎完全平衡。 

720
00:34:14,989 --> 00:34:18,690
The only thing that's not complete is the last level.
唯一不完整的是最后一个级别。 

721
00:34:18,690 --> 00:34:21,789
So all the paths from the roots to the last level
因此，从根到最后一层的所有路径

722
00:34:21,789 --> 00:34:25,809
are either height log N or height log N minus 1.
是高度对数N或高度对数N减去1。 

723
00:34:25,809 --> 00:34:28,809
So wherever you do the height comparison,
因此，无论您在哪里进行高度比较， 

724
00:34:28,809 --> 00:34:31,219
you're going to get a difference of 1,
您将得到1， 

725
00:34:31,219 --> 00:34:35,739
and we can keep adding nodes to this.
并且我们可以继续向其添加节点。 

726
00:34:35,739 --> 00:34:39,179
This is how I'd build a BST of as many nodes as we want.
这就是我要构建尽可能多的节点的BST的方式。 

727
00:34:39,179 --> 00:34:41,489
AUDIENCE: I have a question.
听众：我有一个问题。 

728
00:34:41,489 --> 00:34:46,599
For the fixed heights, why we try to minimize the nodes?
对于固定的高度，为什么我们尝试最小化节点？ 

729
00:34:46,599 --> 00:34:51,078
Wouldn't a better way to build a more efficient tree
没有更好的方法来构建更有效率的树

730
00:34:51,079 --> 00:34:54,920
is to try to minimize the height?
是要尽量减小高度？ 

731
00:34:55,119 --> 00:35:00,204
So instead of adding nodes up, just fill in the tree?
因此，无需添加节点，只需填充树即可？ 

732
00:35:00,204 --> 00:35:01,079
PROFESSOR: Very good.
教授：非常好。 

733
00:35:01,079 --> 00:35:04,079
So you're thinking of how to build an efficient tree, how
因此，您正在考虑如何构建高效的树， 

734
00:35:04,079 --> 00:35:05,869
to build a good tree.
建一棵好树。 

735
00:35:05,869 --> 00:35:08,759
Here, I'm trying to prove the property
在这里，我试图证明财产

736
00:35:08,760 --> 00:35:11,480
about the maximum height of a tree.
大约一棵树的最大高度。 

737
00:35:11,480 --> 00:35:13,519
So here I'm playing devil's advocate.
所以我在这里扮演恶魔的拥护者。 

738
00:35:13,519 --> 00:35:15,980
I'm thinking, what is the worst case for AVLs?
我在想，AVL最坏的情况是什么？ 

739
00:35:15,980 --> 00:35:18,719
How do I make AVLs look as bad as possible?
如何使AVL看起来越差越好？ 

740
00:35:18,719 --> 00:35:20,839
That's why I started this way.
这就是为什么我以这种方式开始。 

741
00:35:20,840 --> 00:35:22,641
So usually, we're the good guy coding,
通常，我们是编码的好人， 

742
00:35:22,641 --> 00:35:24,139
but after you're done coding and you
但是在完成编码之后

743
00:35:24,139 --> 00:35:27,049
know how your algorithm runs, if you want to have peace of mind
如果您想放心，知道算法的运行方式

744
00:35:27,050 --> 00:35:30,000
and go to sleep well and get full points afterwards,
睡个好觉，然后得到满分， 

745
00:35:30,199 --> 00:35:32,299
it sometimes helps to think as devil's advocate.
有时有助于将其视为恶魔的拥护者。 

746
00:35:32,300 --> 00:35:34,000
How would I break this algorithm?
我将如何打破这种算法？ 

747
00:35:34,199 --> 00:35:36,409
What's the worst thing that I could do to it?
我能做的最坏的事情是什么？ 

748
00:35:36,409 --> 00:35:38,679
And if you can find something that breaks it,
如果您能找到破坏它的东西， 

749
00:35:38,679 --> 00:35:41,559
well, you probably know how to fix it.
好吧，您可能知道如何解决它。 

750
00:35:41,559 --> 00:35:43,889
If not, you can sleep well at night
如果没有的话，晚上可以睡个好觉

751
00:35:43,889 --> 00:35:45,775
and know that your algorithm is sound.
并且知道您的算法是正确的。 

752
00:35:45,775 --> 00:35:49,349



753
00:35:49,349 --> 00:35:55,215
AUDIENCE: In that example on the board, where we said
观众：在董事会的那个例子中，我们说

754
00:35:55,215 --> 00:36:00,250
the height of the tree on the left side was h minus 1,
左侧树的高度为h减去1， 

755
00:36:00,250 --> 00:36:03,219
and then the other side had the h minus 2.
然后另一边的h减2。 

756
00:36:03,219 --> 00:36:05,989



757
00:36:05,989 --> 00:36:11,919
For that h minus 2 tree, every node in that
对于那个h减去2树，那个树中的每个节点

758
00:36:11,920 --> 00:36:16,106
has to be h minus 2 height, every leaf.
每片叶子必须为h减去2高度。 

759
00:36:16,106 --> 00:36:17,190
Is that what we're saying?
这就是我们要说的吗？ 

760
00:36:17,190 --> 00:36:19,809
Otherwise, it falls apart because there would be one
否则，它会崩溃，因为会有一个

761
00:36:19,809 --> 00:36:20,309
that's--
那是 - 

762
00:36:20,309 --> 00:36:22,518
PROFESSOR: So we're saying that the root of this tree
教授：所以我们说这棵树的根

763
00:36:22,518 --> 00:36:24,900
has to be h minus 2.
必须为h减2。 

764
00:36:24,900 --> 00:36:27,769
And the way we do this is we copy this guy over,
我们这样做的方法是将这个人复制过来， 

765
00:36:27,969 --> 00:36:30,739
so this guy's lopsided, too.
所以这家伙也变了

766
00:36:30,739 --> 00:36:34,104
So it's not every path to the bottom, just one path.
因此，并不是每条到达底部的路径，而是一条路径。 

767
00:36:34,105 --> 00:36:34,646
AUDIENCE: OK.
听众：好的。 

768
00:36:34,646 --> 00:36:37,001
So it could be an incomplete.
因此可能是不完整的。 

769
00:36:37,001 --> 00:36:37,960
PROFESSOR: Yep.
教授：是的。 

770
00:36:37,960 --> 00:36:43,019
In that case, is that balanced?
在那种情况下，那是平衡的吗？ 

771
00:36:43,019 --> 00:36:48,309
PROFESSOR: So this was an AVL of height 2, right?
教授：所以这是2号高度的AVL，对吗？ 

772
00:36:48,309 --> 00:36:51,529
If I stick it here, it's still going to be an AVL of height 2.
如果我把它贴在这里，它仍将是高度2的AVL。 

773
00:36:51,530 --> 00:36:53,231
AUDIENCE: Right.
听众：对。 

774
00:36:53,431 --> 00:36:55,139
PROFESSOR: This thing will have height 2.
教授：这东西的高度为2。 

775
00:36:55,139 --> 00:36:58,518
This thing will have height 3.
这东西的高度为3。 

776
00:36:58,518 --> 00:37:00,445
AUDIENCE: OK.
听众：好的。 

777
00:37:00,445 --> 00:37:02,742
So it's not everything on the same level,
因此，并非所有事物都处于同一水平， 

778
00:37:02,742 --> 00:37:04,784
necessarily, that needs to be of the same height.
当然，它必须具有相同的高度。 

779
00:37:04,784 --> 00:37:06,230
It's only the children.
只有孩子们。 

780
00:37:06,230 --> 00:37:07,210
PROFESSOR: Yep.
教授：是的。 

781
00:37:07,210 --> 00:37:10,340
So the two children, so two nodes on the same level,
所以两个孩子，所以两个节点在同一水平上

782
00:37:10,340 --> 00:37:14,137
might have their heights differ by one, but not more than one.
高度可能相差一，但不能超过一。 

783
00:37:14,137 --> 00:37:15,519
If they could differ by more than one,
如果它们相差一个以上， 

784
00:37:15,719 --> 00:37:17,480
you could have a link list.
您可能会有一个链接列表。 

785
00:37:17,480 --> 00:37:20,539
Because they differ by one, then it's sort of sane.
因为它们相差一个，所以有点理智。 

786
00:37:20,739 --> 00:37:24,189
It's almost balanced.
它几乎是平衡的。 

787
00:37:24,190 --> 00:37:25,110
Good.
好。 

788
00:37:25,110 --> 00:37:26,130
I like the questions.
我喜欢这些问题。 

789
00:37:26,130 --> 00:37:27,820
It means you guys are thinking.
这意味着你们正在思考。 

790
00:37:27,820 --> 00:37:28,702
I really like it.
我很喜欢。 

791
00:37:28,902 --> 00:37:30,044
Yeah?
是啊

792
00:37:30,045 --> 00:37:31,550
AUDIENCE: If they differ by one.
听众：如果两者相差一。 

793
00:37:31,550 --> 00:37:34,280
So you have an ideal tree up there,
所以你在那里有一棵理想的树， 

794
00:37:34,280 --> 00:37:36,000
and then you have the worst case possible.
然后您可能会遇到最坏的情况。 

795
00:37:36,199 --> 00:37:39,079
That wouldn't affect performance at all, right,
完全不会影响性能，对， 

796
00:37:39,079 --> 00:37:40,519
if you have the worst case?
如果你有最坏的情况？ 

797
00:37:40,519 --> 00:37:42,599
PROFESSOR: So what we know what performance is we
教授：所以我们知道我们的表现是什么

798
00:37:42,599 --> 00:37:45,089
have this guarantee.
有这个保证。 

799
00:37:45,090 --> 00:37:48,440
It's at worst a constant times log n.
最坏的情况是常数n为log。 

800
00:37:48,639 --> 00:37:50,239
This is constant times log n.
这是常数乘以log n。 

801
00:37:50,239 --> 00:37:52,529
The constant happens to be 1.
该常数恰好是1。 

802
00:37:52,530 --> 00:37:54,690
This is a constant times log n.
这是常数乘以log n。 

803
00:37:54,889 --> 00:37:58,514
The constant happens to be something bigger than 1.
该常数恰好大于1。 

804
00:37:58,514 --> 00:38:00,692
I think it's somewhere between 2 and 3.
我认为它介于2到3之间。 

805
00:38:00,692 --> 00:38:02,952
AUDIENCE: That just varies by the constant.
听众：只是随常数而变化。 

806
00:38:02,952 --> 00:38:03,856
PROFESSOR: Yeah.
教授：是的。 

807
00:38:03,856 --> 00:38:06,525
And since we only care about asymptotics in this class,
而且由于我们只关心此类的无症状性， 

808
00:38:06,525 --> 00:38:08,019
we're happy.
很高兴。 

809
00:38:08,019 --> 00:38:10,759
But we don't know how to build this.
但是我们不知道该如何构建。 

810
00:38:10,760 --> 00:38:13,210
This is just something pretty that we draw on a board,
这只是我们在板上画的东西， 

811
00:38:13,210 --> 00:38:15,940
but we don't have an algorithm that efficiency builds
但是我们没有一个可以提高效率的算法

812
00:38:15,940 --> 00:38:21,380
this out of a random series of insertions and deletions.
这是一系列随机的插入和删除操作。 

813
00:38:21,380 --> 00:38:23,539
I hope we don't.
我希望我们不要。 

814
00:38:23,739 --> 00:38:26,089
Otherwise, I look bad.
否则，我看起来不好。 

815
00:38:26,090 --> 00:38:27,360
What do I want to delete?
我要删除什么？ 

816
00:38:27,360 --> 00:38:32,019



817
00:38:32,219 --> 00:38:34,163
AUDIENCE: Instead of a binary search
听众：而不是二进制搜索

818
00:38:34,164 --> 00:38:35,670
tree as the base of the AVL, if you
如果树是AVL的基础

819
00:38:35,869 --> 00:38:39,784
wanted to have four children per node,
希望每个节点有四个孩子， 

820
00:38:39,784 --> 00:38:42,469
would this change that much except you'd
除了你会改变很多吗

821
00:38:42,469 --> 00:38:46,605
just have twice as many variables?
仅有两倍的变量？ 

822
00:38:46,606 --> 00:38:48,230
PROFESSOR: That's a good exam question.
教授：这是一个很好的考试问题。 

823
00:38:48,230 --> 00:38:53,510



824
00:38:53,510 --> 00:38:56,070
So it turns out that there's this tree called
结果发现这棵树叫做

825
00:38:56,269 --> 00:39:01,489
a B tree, which has 1,000 or more nodes.
 B树，具有1,000或更多的节点。 

826
00:39:01,489 --> 00:39:02,485
AUDIENCE: B tree?
听众：B树？ 

827
00:39:02,485 --> 00:39:03,896
Doesn't that stand for binary?
那不是二进制吗？ 

828
00:39:03,896 --> 00:39:04,480
PROFESSOR: No.
教授：不。 

829
00:39:04,480 --> 00:39:10,972
It's B. Just B. That's used for databases on disk.
是B。只是B。用于磁盘上的数据库。 

830
00:39:10,972 --> 00:39:13,230
So there, you want to make the height as small as possible,
因此，您要使高度尽可能小， 

831
00:39:13,429 --> 00:39:15,762
because every time you get a node, you do a disk access,
因为每次获得节点时，您都​​需要进行磁盘访问， 

832
00:39:15,762 --> 00:39:17,139
and that's expensive.
那很贵。 

833
00:39:17,139 --> 00:39:18,969
But once you do a disk access, the nodes
但是一旦完成磁盘访问，节点

834
00:39:18,969 --> 00:39:22,429
can be as big as you want.
可以随心所欲。 

835
00:39:22,429 --> 00:39:25,730
You can read a few bytes off the disk at roughly the same cost
您可以以大致相同的成本从磁盘读取几个字节

836
00:39:25,730 --> 00:39:27,869
as you can read a megabyte, so you're better off
因为您可以读取1兆字节，所以最好

837
00:39:27,869 --> 00:39:28,858
reading a megabyte.
读取一个兆字节。 

838
00:39:28,858 --> 00:39:31,150
I might be exaggerating a bit, but for a few kilobytes,
我可能会有点夸张，但是对于几千字节， 

839
00:39:31,150 --> 00:39:32,090
that's true.
确实如此。 

840
00:39:32,090 --> 00:39:34,559
So B trees have thousands of children,
所以B树有成千上万的孩子， 

841
00:39:34,559 --> 00:39:35,880
and they keep them sorted.
他们保持排序。 

842
00:39:35,880 --> 00:39:39,630
It's sort of like that, but the fan out is huge.
有点像，但是扇出的扇子很大。 

843
00:39:39,630 --> 00:39:41,570
And it turns out everything is still log n
事实证明一切仍然在记录

844
00:39:41,570 --> 00:39:44,056
as long as the number of children you have is constant.
只要您的孩子数量是恒定的。 

845
00:39:44,255 --> 00:39:46,433
AUDIENCE: But for this rotation thing, though.
听众：但是，对于这种轮换来说。 

846
00:39:46,434 --> 00:39:47,150
PROFESSOR: Oh god, no.
教授：哦，天哪。 

847
00:39:47,349 --> 00:39:48,819
We don't have to rotate.
我们不必旋转。 

848
00:39:48,820 --> 00:39:51,440
It gets a lot more complicated.
它变得更加复杂。 

849
00:39:51,639 --> 00:39:54,474
We haven't gotten to rebalancing yet, right?
我们还没有重新平衡，对吗？ 

850
00:39:54,474 --> 00:39:56,349
Wait until you see how rebalancing looks like
等到看到重新平衡的样子

851
00:39:56,349 --> 00:39:57,920
with two children, and then imagine
有两个孩子，然后想象

852
00:39:57,920 --> 00:40:01,920
trying to figure out the cases for 1,000 children.
试图找出1000名儿童的情况。 

853
00:40:01,920 --> 00:40:03,559
That's not sane.
那不是理智

854
00:40:03,559 --> 00:40:05,449
In B trees, they use something else
在B树中，他们使用其他东西

855
00:40:05,449 --> 00:40:07,799
to make them balance the right way.
使他们平衡正确的方法。 

856
00:40:07,800 --> 00:40:11,710
And of course, they're harder than this.
当然，它们比这更难。 

857
00:40:11,710 --> 00:40:15,909
So let me try to get through rebalancing somewhat quickly.
因此，让我尝试快速完成重新平衡。 

858
00:40:15,909 --> 00:40:25,609



859
00:40:25,610 --> 00:40:29,079
This is where I forget what I need to do.
这是我忘记要做的事情的地方。 

860
00:40:29,079 --> 00:40:29,579
Rebalancing.
重新平衡。 

861
00:40:29,579 --> 00:41:12,980



862
00:41:12,980 --> 00:41:27,449
So suppose we call Rebalance on this guy,
因此，假设我们称这个人为Rebalance， 

863
00:41:27,449 --> 00:41:30,929
and we know that the nodes here have heights k minus 1,
我们知道这里的节点的高度为k减去1 

864
00:41:30,929 --> 00:41:33,599
this is k minus 1 or k, and this is k,
这是k减去1或k，这是k， 

865
00:41:33,599 --> 00:41:36,730
and I want to call Rebalance here.
我想在这里打电话给Rebalance。 

866
00:41:36,730 --> 00:41:39,039
Let's first figure out if it's an AVL tree
首先让我们弄清楚它是否是AVL树

867
00:41:39,039 --> 00:41:41,029
or if there's something wrong with it.
或者它有什么问题。 

868
00:41:41,030 --> 00:41:44,675
What's the height here?
这里的高度是多少？ 

869
00:41:44,675 --> 00:41:47,221
AUDIENCE: k plus 1.
听众：k加1。 

870
00:41:47,221 --> 00:41:49,219
PROFESSOR: So no matter what the height is here,
教授：所以无论这里的高度

871
00:41:49,219 --> 00:41:51,399
the height here has to be k plus 1.
这里的高度必须是k加1。 

872
00:41:51,400 --> 00:41:53,735
What's the height here?
这里的高度是多少？ 

873
00:41:53,735 --> 00:41:56,569
AUDIENCE: k plus 2.
听众：k加2。 

874
00:41:56,570 --> 00:41:57,610
PROFESSOR: OK.
教授：好的。 

875
00:41:57,610 --> 00:41:59,780
What else can you tell me about this node?
关于这个节点，您还能告诉我什么？ 

876
00:41:59,780 --> 00:42:04,960



877
00:42:05,159 --> 00:42:06,980
If I call Check RI on it, it's going
如果我打电话给Check RI，它会

878
00:42:06,980 --> 00:42:10,440
to crash because the rep invariant for AVLs
崩溃，因为AVL的rep不变

879
00:42:10,440 --> 00:42:11,769
does not hold here.
在这里不举行。 

880
00:42:11,969 --> 00:42:13,899
This child at the top of this tree
这个孩子在这棵树的顶端

881
00:42:13,900 --> 00:42:15,230
will have height k minus 1.
高度k减去1。 

882
00:42:15,429 --> 00:42:17,250
This will have height k plus 1.
这将具有高度k加1。 

883
00:42:17,250 --> 00:42:18,980
The difference is more than 1.
差异大于1。 

884
00:42:18,980 --> 00:42:21,650
Not good.
不好。 

885
00:42:21,650 --> 00:42:22,543
So this is unhappy.
所以这很不高兴。 

886
00:42:22,543 --> 00:42:23,710
How do we fix the situation?
我们如何解决这种情况？ 

887
00:42:23,710 --> 00:42:26,380



888
00:42:26,380 --> 00:42:29,000
AUDIENCE: Rotate left around k plus 1.
观众：向左旋转k加1。 

889
00:42:29,199 --> 00:42:30,254
PROFESSOR: All right.
教授：好的。 

890
00:42:30,255 --> 00:42:33,519
So it better be a rotation, because we spent so much
最好是轮换，因为我们花了很多钱

891
00:42:33,519 --> 00:42:36,016
figuring out how to rotate.
弄清楚如何旋转。 

892
00:42:36,016 --> 00:42:37,889
Let's see what happens if we rotate this way,
让我们看看如果我们这样旋转，会发生什么， 

893
00:42:37,889 --> 00:42:39,369
and the way to keep track of this
以及保持追踪的方式

894
00:42:39,369 --> 00:42:41,556
is I'm going to label my nodes.
我要标记我的节点。 

895
00:42:41,556 --> 00:42:45,010



896
00:42:45,010 --> 00:42:53,090
B, A, left child of A has height k minus 1.
 B，A，A的左孩子的身高k减去1。 

897
00:42:53,090 --> 00:42:55,115
This guy is k minus 1.
这个人是k减1。 

898
00:42:55,315 --> 00:43:00,759



899
00:43:00,760 --> 00:43:04,480
So what's the height of A now?
那么，A的高度是多少？ 

900
00:43:04,480 --> 00:43:06,231
AUDIENCE: k.
观众：k。 

901
00:43:06,431 --> 00:43:07,895
Oh wait, that's not a node.
哦，等等，这不是节点。 

902
00:43:07,896 --> 00:43:10,840
Just k minus 1 or k.
只需k减去1或k。 

903
00:43:10,840 --> 00:43:13,420
PROFESSOR: So this is a tree of height k minus 1.
教授：这是一棵树，高k减1。 

904
00:43:13,420 --> 00:43:15,309
This is a height of tree k minus 1 or k.
这是树的高度k减去1或k。 

905
00:43:15,309 --> 00:43:18,639
The height of this guy is?
这个家伙的身高是多少？ 

906
00:43:18,639 --> 00:43:19,139
AUDIENCE: k.
观众：k。 

907
00:43:19,139 --> 00:43:22,485



908
00:43:22,485 --> 00:43:23,920
AUDIENCE: k plus 1.
听众：k加1。 

909
00:43:23,920 --> 00:43:26,519
PROFESSOR: Or k plus 1.
教授：或k加1。 

910
00:43:26,519 --> 00:43:28,300
The height of this guy is definitely k.
这个家伙的身高绝对是k。 

911
00:43:28,300 --> 00:43:30,664
The height of this guys is k or k plus 1.
这些人的身高是k或k加1。 

912
00:43:30,664 --> 00:43:31,289
Is that an AVL?
那是AVL吗？ 

913
00:43:31,289 --> 00:43:32,509
Is it happy now?
现在幸福吗？ 

914
00:43:32,510 --> 00:43:36,900



915
00:43:37,099 --> 00:43:40,429
So this is the easy kind of rebalancing, one rotation
所以这是一种简单的重新平衡操作

916
00:43:40,429 --> 00:43:41,417
and you're done.
到此为止。 

917
00:43:41,418 --> 00:43:43,134
AUDIENCE: [INAUDIBLE] the difference between k
听众：[听不清] k之间的差

918
00:43:43,333 --> 00:43:44,748
minus 1 and k minus 1 over k?
减1和k减去k减1？ 

919
00:43:44,748 --> 00:43:46,289
PROFESSOR: It's not k minus 1 over k.
教授：不是k减去k减去1。 

920
00:43:46,289 --> 00:43:47,820
It's either k minus 1 or k.
它是k减去1或k。 

921
00:43:47,820 --> 00:43:50,610



922
00:43:50,610 --> 00:43:51,186
Bad notation.
错误的符号。 

923
00:43:51,186 --> 00:43:54,050



924
00:43:54,050 --> 00:43:55,110
Thank you for the question.
感谢你的提问。 

925
00:43:55,309 --> 00:43:57,219
You saved everyone from confusion.
您使所有人免于混乱。 

926
00:43:57,219 --> 00:44:00,027



927
00:44:00,027 --> 00:44:02,369
No, there's no fractional heights.
不，没有分数高度。 

928
00:44:02,369 --> 00:44:03,389
Anything else?
还要别的吗？ 

929
00:44:03,389 --> 00:44:03,889
Thank you.
谢谢。 

930
00:44:03,889 --> 00:44:04,489
That was good.
那很好。 

931
00:44:04,489 --> 00:44:09,460



932
00:44:09,460 --> 00:44:09,959
All right.
好吧。 

933
00:44:09,960 --> 00:44:11,030
So this is easy, right?
所以这很容易，对吗？ 

934
00:44:11,030 --> 00:44:12,269
This is the easy rotation.
这是容易的旋转。 

935
00:44:12,269 --> 00:44:13,559
Let's do the hard one now.
现在让我们努力吧。 

936
00:44:13,559 --> 00:44:37,670



937
00:44:37,670 --> 00:44:40,664
What's the height here?
这里的高度是多少？ 

938
00:44:40,664 --> 00:44:42,152
AUDIENCE: k plus 1.
听众：k加1。 

939
00:44:42,152 --> 00:44:47,112



940
00:44:47,112 --> 00:44:50,384
PROFESSOR: What's the height here?
教授：这里的高度是多少？ 

941
00:44:50,583 --> 00:44:53,579
AUDIENCE: Plus 2.
观众：加2。 

942
00:44:53,579 --> 00:44:56,549
PROFESSOR: AVL, not AVL?
教授：AVL，不是AVL？ 

943
00:44:56,550 --> 00:44:58,110
AUDIENCE: No.
听众：不。 

944
00:44:58,309 --> 00:45:00,809
PROFESSOR: k minus 1 on the left child,
教授：左侧孩子的k减去1， 

945
00:45:00,809 --> 00:45:02,650
k plus 1 on the right child.
 k在正确的孩子上加1。 

946
00:45:02,650 --> 00:45:04,349
The difference is more than one.
差异不止一个。 

947
00:45:04,349 --> 00:45:06,119
Not an AVL.
不是AVL。 

948
00:45:06,119 --> 00:45:07,159
How do we fix this?
我们该如何解决？ 

949
00:45:07,159 --> 00:45:14,132



950
00:45:14,132 --> 00:45:17,619
AUDIENCE: Make a right rotation [INAUDIBLE].
听众：右旋转[听不清]。 

951
00:45:17,619 --> 00:45:18,559
PROFESSOR: Sorry?
教授：对不起？ 

952
00:45:18,559 --> 00:45:21,559
AUDIENCE: Make a right rotation on k first.
听众：首先在k上右旋转。 

953
00:45:21,559 --> 00:45:23,378
PROFESSOR: So make a right rotation where?
教授：那么，在哪里进行正确的轮换？ 

954
00:45:23,378 --> 00:45:25,242
AUDIENCE: On k [INAUDIBLE] plus 1.
受众群体：在k [听不清]上加1。 

955
00:45:25,242 --> 00:45:30,289



956
00:45:30,289 --> 00:45:32,664
PROFESSOR: Let me break this up so we
教授：让我分解一下，所以我们

957
00:45:32,664 --> 00:45:34,869
could see how that would work out.
可以看到如何解决。 

958
00:45:34,869 --> 00:45:39,279



959
00:45:39,280 --> 00:45:42,519
So these two are k minus 1 and k minus 1,
所以这两个是k减1和k减1 

960
00:45:42,719 --> 00:45:48,139
and these nodes are A, B, and C. So you're
这些节点是A，B和C。 

961
00:45:48,139 --> 00:45:52,449
saying do a right rotation here, right?
说在这里右转吧？ 

962
00:45:52,449 --> 00:45:54,939
Let's see what that gets us to.
让我们看看能带给我们什么。 

963
00:45:54,940 --> 00:45:58,360
So A is the same, and then here I'm
所以A是一样的，然后我在这里

964
00:45:58,360 --> 00:46:03,940
going to have C instead of B, and B. The right child of B
将拥有C而不是B和B。B的正确子代

965
00:46:04,139 --> 00:46:06,699
is the same as it was before.
和以前一样。 

966
00:46:06,699 --> 00:46:14,919
The left child of B is k minus 1.
 B的左孩子是k减1。 

967
00:46:14,920 --> 00:46:19,170
Then the left child of C is another k minus 1,
那么C的左孩子又是k减1， 

968
00:46:19,170 --> 00:46:21,510
and this guy is k minus 1.
这个家伙是k减1。 

969
00:46:21,510 --> 00:46:23,992
OK, what's the height at B now?
好，现在B的高度是多少？ 

970
00:46:23,992 --> 00:46:25,920
AUDIENCE: k.
观众：k。 

971
00:46:25,920 --> 00:46:27,320
PROFESSOR: OK.
教授：好的。 

972
00:46:27,320 --> 00:46:29,759
What's the height here?
这里的高度是多少？ 

973
00:46:29,759 --> 00:46:33,139
AUDIENCE: k plus 1.
听众：k加1。 

974
00:46:33,139 --> 00:46:35,021
PROFESSOR: And the height here?
教授：这里的高度是多少？ 

975
00:46:35,021 --> 00:46:37,759
AUDIENCE: k plus 2.
听众：k加2。 

976
00:46:37,760 --> 00:46:40,110
PROFESSOR: Is this an AVL?
教授：这是AVL吗？ 

977
00:46:40,110 --> 00:46:43,936
So we're not done, but what's the good news about this?
因此，我们还没有完成，但是这有什么好消息呢？ 

978
00:46:43,936 --> 00:46:47,664
AUDIENCE: Now you can rotate it left around C.
听众：现在您可以将其向C左旋转。 

979
00:46:47,664 --> 00:46:48,596
PROFESSOR: Yep.
教授：是的。 

980
00:46:48,596 --> 00:46:49,530
Exactly.
究竟。 

981
00:46:49,530 --> 00:46:55,980
That is this, and we know how to fix this in one step.
就是这样，我们知道如何一步解决。 

982
00:46:55,980 --> 00:46:57,630
You said exactly the right thing.
你说的完全正确。 

983
00:46:57,630 --> 00:46:59,710
This is exactly what we do.
这正是我们所做的。 

984
00:46:59,909 --> 00:47:03,639
First, rotate here so that we get to that,
首先，在这里旋转，以便我们可以做到这一点， 

985
00:47:03,639 --> 00:47:06,389
and then we're in the happy case.
然后我们就很高兴了。 

986
00:47:06,389 --> 00:47:08,989
So intuitively, the difference between the happy case
如此直观地讲，幸福案例之间的区别

987
00:47:08,989 --> 00:47:13,329
and the harder case that's going to be happy eventually
最终将变得更加艰难的情况

988
00:47:13,329 --> 00:47:16,860
is where the heavy path is, so where
是重路在哪里，所以在哪里

989
00:47:16,860 --> 00:47:19,170
you have the bigger height.
你的身高更大。 

990
00:47:19,369 --> 00:47:24,500
In this case, k plus 2, k plus 1, k.
在这种情况下，k加2，k加1，k。 

991
00:47:24,500 --> 00:47:29,230
So the heavy path is this thing here.
所以这条路很重。 

992
00:47:29,230 --> 00:47:30,159
It's a straight line.
这是一条直线。 

993
00:47:30,159 --> 00:47:33,399
Because of that, we can rotate here and then
因此，我们可以在这里旋转

994
00:47:33,400 --> 00:47:36,289
redistribute the weights uniformly.
重新分配权重。 

995
00:47:36,289 --> 00:47:39,409
In this case, the heavy path is this.
在这种情况下，繁重的道路就是这样。 

996
00:47:39,409 --> 00:47:44,920
It's a zigzag, so one rotation won't fix it.
这是锯齿形的，因此旋转一圈将无法解决。 

997
00:47:44,920 --> 00:47:46,570
Instead, we do one rotation here so
相反，我们在这里旋转一圈

998
00:47:46,570 --> 00:47:50,570
that we make the weights be distributed
我们使权重分布

999
00:47:50,570 --> 00:47:52,610
in a straight line, and then one rotation here,
在一条直线上，然后在这里旋转一圈， 

1000
00:47:52,610 --> 00:47:55,230
which makes everything look good.
这使一切看起来都不错。 

1001
00:47:55,230 --> 00:47:55,978
Yes?
是？ 

1002
00:47:55,978 --> 00:47:57,769
AUDIENCE: So that's just a general pattern.
听众：这只是一般模式。 

1003
00:47:57,769 --> 00:47:59,693
And you redistribute [INAUDIBLE]?
然后您重新分配[音频不清晰]？ 

1004
00:47:59,693 --> 00:48:02,411



1005
00:48:02,411 --> 00:48:04,869
PROFESSOR: So the first thing we do is say you're at a node
教授：所以我们要做的第一件事就是说你在一个节点上

1006
00:48:04,869 --> 00:48:05,963
and you need to rebalance.
您需要重新平衡。 

1007
00:48:05,963 --> 00:48:07,380
First thing, you check the heights
首先，您检查身高

1008
00:48:07,380 --> 00:48:09,980
and see if it's already balanced.
看看它是否已经平衡。 

1009
00:48:09,980 --> 00:48:13,119
If it's not balanced, suppose your heavier node
如果不平衡，请假设您的节点较重

1010
00:48:13,119 --> 00:48:14,699
is on the right.
在右边。 

1011
00:48:14,699 --> 00:48:19,259
Then you go and see if the right child is heavier
然后你去看看合适的孩子是否较重

1012
00:48:19,260 --> 00:48:20,610
or the left child is heavier.
或左孩子较重。 

1013
00:48:20,809 --> 00:48:24,659
So you see if the height distribution is a straight line
所以你看高度分布是否是一条直线

1014
00:48:24,659 --> 00:48:26,679
or is exact, and then you decide whether you're
或确切，然后您决定是否

1015
00:48:26,679 --> 00:48:28,428
going to do one rotation or two rotations.
将要旋转一圈或两圈。 

1016
00:48:28,429 --> 00:48:31,769



1017
00:48:31,969 --> 00:48:35,049
So this is all nice and good except for one thing.
因此，除了一件事情之外，一切都很好。 

1018
00:48:35,050 --> 00:48:39,105
The heights keep changing here, and we're
高度在这里不断变化，我们

1019
00:48:39,105 --> 00:48:42,250
storing the heights in each node.
在每个节点中存储高度。 

1020
00:48:42,250 --> 00:48:44,150
So if we're doing all this rotating
因此，如果我们要进行所有这些旋转

1021
00:48:44,150 --> 00:48:47,829
without updating the heights, then we're
没有更新高度，那么我们

1022
00:48:47,829 --> 00:48:49,923
going to have something that looks like an AVL
会有看起来像AVL的东西

1023
00:48:49,923 --> 00:48:51,840
but doesn't keep track of the heights anymore,
但不再追踪高度

1024
00:48:51,840 --> 00:48:54,980
so eventually, we're going to make bad decisions.
所以最终，我们将做出错误的决定。 

1025
00:48:54,980 --> 00:48:57,440
So we need to update the heights.
因此，我们需要更新高度。 

1026
00:48:57,440 --> 00:49:00,253
Where do we update the heights?
我们在哪里更新高度？ 

1027
00:49:00,253 --> 00:49:01,670
You can look at the code and cheat
你可以看一下代码并作弊

1028
00:49:01,670 --> 00:49:05,456
or you can try to think and tell me the answer, either way.
或者您可以尝试以任何一种方式思考并告诉我答案。 

1029
00:49:05,456 --> 00:49:13,569



1030
00:49:13,570 --> 00:49:17,630
So this only does rotates, right?
所以这只会旋转，对吧？ 

1031
00:49:17,630 --> 00:49:20,648
If rotates would be able to update the heights,
如果旋转可以更新高度， 

1032
00:49:20,648 --> 00:49:21,690
everything would be good.
一切都会很好。 

1033
00:49:21,690 --> 00:49:23,519
I wouldn't have to worry about this.
我不必为此担心。 

1034
00:49:23,519 --> 00:49:26,349



1035
00:49:26,349 --> 00:49:29,519
Pretend I hadn't deleted the original case here,
假装我没有删除原始案例， 

1036
00:49:29,519 --> 00:49:38,050
which I think was A, B, C, and then some children.
我认为是A，B，C，然后是一些孩子。 

1037
00:49:38,050 --> 00:49:39,519
What heights changed here?
这里的高度有什么变化？ 

1038
00:49:39,719 --> 00:49:45,949



1039
00:49:45,949 --> 00:49:50,639
When I did this rotation, what heights changed?
当我旋转时，什么高度发生变化？ 

1040
00:49:50,639 --> 00:49:53,039
AUDIENCE: B's height changed.
听众：B的身高改变了。 

1041
00:49:53,039 --> 00:49:58,320
AUDIENCE: B, A, and C is greater than B.
听众：B，A和C大于B。 

1042
00:49:58,320 --> 00:50:02,039
PROFESSOR: B and potentially A. If I'm not sure,
教授：B，可能还有A。如果不确定， 

1043
00:50:02,239 --> 00:50:04,299
then I'm going to try to update the height anyway
那我还是要尝试更新高度

1044
00:50:04,300 --> 00:50:06,630
to make sure that I have the right height.
确保我的身高合适。 

1045
00:50:06,630 --> 00:50:10,789
After I do this, I have to update the height on B
完成此操作后，我必须更新B的高度

1046
00:50:10,789 --> 00:50:15,224
and update the heights on A. Is this correct?
并更新A的高度。这是正确的吗？ 

1047
00:50:15,224 --> 00:50:21,471



1048
00:50:21,472 --> 00:50:22,960
AUDIENCE: And B.
听众：和B。 

1049
00:50:22,960 --> 00:50:24,210
PROFESSOR: And all the way up.
教授：一直以来。 

1050
00:50:24,210 --> 00:50:26,039
Let's assume that happens.
假设发生这种情况。 

1051
00:50:26,239 --> 00:50:28,241
Does this look right?
这看起来正确吗？ 

1052
00:50:28,242 --> 00:50:31,019
AUDIENCE: Don't you also have to update for C?
听众：您是否也不必为C更新？ 

1053
00:50:31,219 --> 00:50:31,939
PROFESSOR: For c.
教授：对于c。 

1054
00:50:31,940 --> 00:50:34,885



1055
00:50:34,885 --> 00:50:37,840
Did I change anything under c?
我在c下更改了什么吗？ 

1056
00:50:37,840 --> 00:50:40,289
AUDIENCE: I think he's talking about capital C.
听众：我认为他是在谈论大写C。 

1057
00:50:40,289 --> 00:50:42,980
PROFESSOR: Oh, capital C. Yeah, OK.
教授：哦，大写C.是的，好的。 

1058
00:50:42,980 --> 00:50:48,800



1059
00:50:48,800 --> 00:50:49,985
So the children are the same.
所以孩子们是一样的。 

1060
00:50:50,184 --> 00:50:53,900
They were a and b before, they're a and b afterwards,
他们之前是a和b，之后是a和b， 

1061
00:50:53,900 --> 00:50:55,385
so I don't have to worry about this guy.
所以我不必担心这个家伙。 

1062
00:50:55,585 --> 00:50:56,959
The heights here haven't changed,
这里的高度没有改变， 

1063
00:50:56,960 --> 00:50:59,704
so the height here hasn't changed.
所以这里的高度没有改变。 

1064
00:50:59,704 --> 00:51:01,079
But you're thinking of a problem,
但是你在想一个问题， 

1065
00:51:01,079 --> 00:51:03,121
and that is good because there is a problem here.
那很好，因为这里有问题。 

1066
00:51:03,121 --> 00:51:06,251



1067
00:51:06,251 --> 00:51:09,632
AUDIENCE: What if there's a subtree instead of small c?
听众：如果有一个子树而不是小c怎么办？ 

1068
00:51:09,632 --> 00:51:13,019
PROFESSOR: A subtree instead of small c?
教授：是子树而不是小c？ 

1069
00:51:13,219 --> 00:51:14,609
OK, so yeah, this is a subtree.
好的，是的，这是一个子树。 

1070
00:51:14,610 --> 00:51:16,940



1071
00:51:17,139 --> 00:51:19,960
After rotating, this subtree moves over here.
旋转后，此子树将移至此处。 

1072
00:51:19,960 --> 00:51:22,612



1073
00:51:22,612 --> 00:51:23,235
AUDIENCE: Wait.
听众：等等。 

1074
00:51:23,235 --> 00:51:25,579
You have to update A first, and then update B.
您必须先更新A，然后再更新B。 

1075
00:51:25,579 --> 00:51:27,299
PROFESSOR: OK.
教授：好的。 

1076
00:51:27,300 --> 00:51:29,510
So the height starts from the bottom.
因此，高度从底部开始。 

1077
00:51:29,510 --> 00:51:31,260
The bottom height zero, the next one
底部高度为零，下一个为

1078
00:51:31,260 --> 00:51:33,400
up, the next one up, the next one up.
起来，下一个上升，下一个上升。 

1079
00:51:33,400 --> 00:51:34,920
Keep that in mind.
记住这一点。 

1080
00:51:34,920 --> 00:51:37,639
Nothing changed below this guy, nothing changed below this guy,
这个家伙下面什么都没改变，这个家伙下面什么都没改变， 

1081
00:51:37,639 --> 00:51:42,089
nothing changed here, so I don't have to update these.
这里没有任何变化，因此我不必更新这些。 

1082
00:51:42,090 --> 00:51:44,539
But when I compute the height, update height
但是当我计算高度时，更新高度

1083
00:51:44,539 --> 00:51:47,489
at the beginning of the listing assumes
在列表的开头假设

1084
00:51:47,489 --> 00:51:49,449
that the height of the children is correct.
孩子的身高是正确的。 

1085
00:51:49,449 --> 00:51:51,115
So when I compute the height of my mode,
因此，当我计算模式高度时， 

1086
00:51:51,115 --> 00:51:53,000
the height of the children has to be updated.
孩子们的身高必须更新。 

1087
00:51:53,000 --> 00:51:55,117
So if I call Update Height of B first,
因此，如果我先调用B的更新高度， 

1088
00:51:55,117 --> 00:51:56,750
I already know that this might have changed,
我已经知道这可能已经改变， 

1089
00:51:56,949 --> 00:51:59,419
so whatever answer I get is bogus.
所以我得到的答案都是假的。 

1090
00:51:59,420 --> 00:52:03,375
So this doesn't work and I have to do this.
所以这行不通，我必须这样做。 

1091
00:52:03,574 --> 00:52:13,289



1092
00:52:13,289 --> 00:52:14,480
This is rotation.
这是旋转。 

1093
00:52:14,480 --> 00:52:16,380
That's rebalancing.
那是重新平衡。 

1094
00:52:16,380 --> 00:52:18,039
One more trick to rebalancing.
再平衡的另一招。 

1095
00:52:18,239 --> 00:52:23,199
So we talked about rebalancing the subtree at one node.
因此，我们讨论了在一个节点上重新平衡子树的问题。 

1096
00:52:23,199 --> 00:52:24,659
What's missing from this picture?
该图片缺少什么？ 

1097
00:52:24,659 --> 00:52:29,559



1098
00:52:29,559 --> 00:52:32,009
AUDIENCE: So you check it on all levels?
听众：那么您在所有级别上都进行检查吗？ 

1099
00:52:32,010 --> 00:52:32,920
PROFESSOR: Yeah.
教授：是的。 

1100
00:52:32,920 --> 00:52:34,559
So I made some changes here.
所以我在这里做了一些更改。 

1101
00:52:34,559 --> 00:52:38,829
My tree might look happy starting from here on,
从这里开始，我的树可能看起来很幸福， 

1102
00:52:38,829 --> 00:52:41,090
but if I did an insertion or a deletion,
但是如果我进行了插入或删除， 

1103
00:52:41,090 --> 00:52:43,570
heights changed all the way up, so I
高度一路上升，所以我

1104
00:52:43,570 --> 00:52:46,635
have to go all the way up and do more rebalancings potentially.
必须全力以赴，并可能进行更多的重新平衡。 

1105
00:52:46,635 --> 00:52:50,460



1106
00:52:50,460 --> 00:52:51,599
And that's it.
就是这样。 

1107
00:52:51,599 --> 00:52:52,786
These are AVLs.
这些是AVL。 

1108
00:52:52,786 --> 00:52:53,619
Any other questions?
还有其他问题吗？ 

1109
00:52:53,619 --> 00:52:58,574



1110
00:52:58,574 --> 00:52:59,289
Did you guys get them?
你们得到了吗？ 

1111
00:52:59,489 --> 00:53:00,992
Do they make more sense now?
他们现在更有意义吗？ 

1112
00:53:00,992 --> 00:53:01,820
AUDIENCE: Yes.
听众：是的。 

1113
00:53:01,820 --> 00:53:03,030
PROFESSOR: OK.
教授：好的。 

1114
00:53:03,030 --> 00:53:04,300
Good.
好。 

1115
00:53:04,300 --> 00:53:08,134
You'll have to play with them on the next Pset.
您必须在下一个Pset上与它们一起玩。 

1116
00:53:08,134 --> 00:53:10,003
AUDIENCE: By "play," what do you mean?
听众：“玩”是什么意思？ 

1117
00:53:10,003 --> 00:53:12,170
PROFESSOR: Well, you're not writing it from scratch.
教授：嗯，您不是从头开始编写的。 

1118
00:53:12,170 --> 00:53:13,914
You have to modify existing code.
您必须修改现有代码。 

1119
00:53:13,914 --> 00:53:17,614
AUDIENCE: What are we going to make it do?
听众：我们要怎么做？ 

1120
00:53:17,614 --> 00:53:20,030
PROFESSOR: So you'll have to keep track of something other
教授：所以您必须跟踪其他内容

1121
00:53:20,030 --> 00:53:20,650
than heights.
比高度。 

1122
00:53:20,849 --> 00:53:22,670
You'll have to keep track of a new value.
您必须跟踪新值。 

1123
00:53:22,670 --> 00:53:24,503
AUDIENCE: Oh, like the minimum or something?
听众：哦，像最低价一样吗？ 

1124
00:53:24,503 --> 00:53:26,019
PROFESSOR: Or something, yeah.
教授：是的，是的。 

1125
00:53:26,019 --> 00:53:31,019



