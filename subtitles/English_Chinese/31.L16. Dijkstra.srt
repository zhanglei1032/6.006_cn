1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,800
The following content is provided
提供以下内容

3
00:00:01,800 --> 00:00:04,040
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,040 --> 00:00:06,879
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,879 --> 00:00:10,740
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,740 --> 00:00:13,349
To make a donation, or view additional materials
捐款或查看其他材料

7
00:00:13,349 --> 00:00:17,236
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,236 --> 00:00:17,861
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,861 --> 00:00:22,459



10
00:00:22,460 --> 00:00:24,510
PROFESSOR: Good morning, everyone.
教授：大家早上好。 

11
00:00:24,510 --> 00:00:26,539
Let's get started on lecture number
让我们开始讲课

12
00:00:26,739 --> 00:00:30,579
two of four lecture sequences of shortest paths.
最短路径的四个讲座序列中的两个。 

13
00:00:30,579 --> 00:00:34,219
So, last time, we talked about a general structure
所以，上次我们讨论了一个通用结构

14
00:00:34,219 --> 00:00:37,159
for a shortest path algorithm.
最短路径算法。 

15
00:00:37,159 --> 00:00:40,021
Today, we'll actually look at a concrete algorithm
今天，我们实际上将看一个具体的算法

16
00:00:40,021 --> 00:00:40,979
that's due to Dijkstra.
那是由于Dijkstra。 

17
00:00:40,979 --> 00:00:43,989



18
00:00:43,990 --> 00:00:45,960
Before we get to that, I want to do
在此之前，我想做

19
00:00:45,960 --> 00:00:49,609
a little bit of a review of the concepts
回顾一下概念

20
00:00:49,609 --> 00:00:54,450
that we covered in the lecture last week.
这是我们上周在讲座中介绍的内容。 

21
00:00:54,450 --> 00:00:56,590
In particular, we talked about this notion
特别是我们谈到了这个概念

22
00:00:56,590 --> 00:00:59,224
of relaxation, which is a fundamental operation
放松，这是一项基本操作

23
00:00:59,424 --> 00:01:01,629
in all shortest path algorithms.
在所有最短路径算法中。 

24
00:01:01,630 --> 00:01:03,679
And I want to go over that again.
我想再谈一遍。 

25
00:01:03,679 --> 00:01:06,019
We look at a couple of special cases
我们来看几个特殊情况

26
00:01:06,019 --> 00:01:10,079
today, with respect to algorithms for shortest paths.
今天，关于最短路径的算法。 

27
00:01:10,079 --> 00:01:13,439
We look at a Directed Acyclic Graph.
我们看一个有向无环图。 

28
00:01:13,439 --> 00:01:17,429
Then your graph has no cycles in it.
那么您的图形中就没有循环。 

29
00:01:17,430 --> 00:01:22,569
Regardless of whether you have negative edges or not,
不管您是否有负面优势， 

30
00:01:22,769 --> 00:01:24,439
there's a straightforward algorithm
有一个简单的算法

31
00:01:24,439 --> 00:01:28,759
that we look at to find shortest paths and DAGs.
我们将寻找最短的路径和DAG。 

32
00:01:28,760 --> 00:01:30,569
And then, we'll focus in on the case
然后，我们将专注于案例

33
00:01:30,769 --> 00:01:32,659
where there are no negative edges.
没有消极的地方。 

34
00:01:32,659 --> 00:01:35,969
And talk about Dijkstra's algorithm.
并讨论Dijkstra的算法。 

35
00:01:35,969 --> 00:01:43,189
So, to start with the review, here's,
所以，从评论开始，这里是

36
00:01:43,189 --> 00:01:46,329
really, a trivial example of a graph
确实，一个简单的图形示例

37
00:01:46,329 --> 00:01:50,000
that we want to compute the shortest paths on.
我们要计算最短路径的路径。 

38
00:01:50,000 --> 00:01:56,780
And the numbers that are inside these vertices
这些顶点内的数字

39
00:01:56,780 --> 00:01:58,119
are our priority values.
是我们的优先值。 

40
00:01:58,319 --> 00:02:09,719
So, think of d of v as the length of the current shortest
因此，将v的d视为当前最短的长度

41
00:02:09,719 --> 00:02:16,250
path from the source, s, to v.
从源s到v的路径。 

42
00:02:16,250 --> 00:02:22,900
And, given the source, s, the length to the source is 0.
并且，在给定源s的情况下，到源的长度为0。 

43
00:02:22,900 --> 00:02:24,129
So d of s is 0.
因此s的d为0。 

44
00:02:24,129 --> 00:02:26,590
It starts at 0 and ends at 0.
它从0开始，到0结束。 

45
00:02:26,590 --> 00:02:29,939
And other ones, I initialized to infinity.
和其他的一样，我初始化为无穷大。 

46
00:02:29,939 --> 00:02:35,180
And through this process that we call relaxation,
通过这个我们称为放松的过程， 

47
00:02:35,180 --> 00:02:40,770
we can generally reduce these d values,
我们通常可以减少这些d值， 

48
00:02:40,770 --> 00:02:42,930
that are the lengths of the current shortest paths,
这是当前最短路径的长度， 

49
00:02:42,930 --> 00:02:47,025
down to what we call the delta values.
直到我们所说的增量值。 

50
00:02:47,025 --> 00:02:49,610



51
00:02:49,610 --> 00:02:53,590
Which is the length of our shortest path.
这是我们最短路径的长度。 

52
00:02:53,789 --> 00:02:57,030



53
00:02:57,030 --> 00:02:57,944
It may be unique.
它可能是唯一的。 

54
00:02:57,944 --> 00:02:59,750
It may not be unique.
它可能不是唯一的。 

55
00:02:59,750 --> 00:03:02,280
But you have to get the minimum value.
但是您必须获得最小值。 

56
00:03:02,280 --> 00:03:09,330
And then, all of the vertices have convergent values
然后，所有顶点都具有收敛值

57
00:03:09,330 --> 00:03:11,710
of d that converge to delta.
的d收敛到delta。 

58
00:03:11,710 --> 00:03:14,120
Then, your algorithm is done.
然后，算法完成。 

59
00:03:14,120 --> 00:03:19,490
And one last thing that is important to reconstruct
最后一件对重建很重要的事情

60
00:03:19,490 --> 00:03:26,900
the path is the notion of a predecessor and pi v
路径是前辈和pi v的概念

61
00:03:26,900 --> 00:03:36,530
is the predecessor of v in the shortest path from s
在距离s最短的路径中是v的前身

62
00:03:36,530 --> 00:03:44,180
to v. And you can follow this predecessor
诉v。您可以追随此前任

63
00:03:44,180 --> 00:03:46,810
chain to reconstruct the shortest path,
链以重建最短路径， 

64
00:03:46,810 --> 00:03:51,560
once you've converged, and all of the values
一旦融合，所有的价值

65
00:03:51,560 --> 00:03:56,939
are down to the delta s comma v. So, in this trivial example,
归结于delta s逗号v。因此，在这个琐碎的示例中， 

66
00:03:57,139 --> 00:04:04,579
you start with d of s being 0, d of a and d of b being infinity.
您以s的d为0，a的d和b的d为无穷大开始。 

67
00:04:04,580 --> 00:04:10,560
Let's put on it a few weights here.
让我们在这里加一些权重。 

68
00:04:10,560 --> 00:04:13,520
And what you do is potentially relax
而你要做的就是放松

69
00:04:13,520 --> 00:04:16,509
the edges that go out of s.
 s的边缘。 

70
00:04:16,509 --> 00:04:19,488
And this notion of relaxation, that I'll write out formally
这个放松的概念，我会正式写出来

71
00:04:19,488 --> 00:04:21,939
in a minute-- we looked at it last time,
一分钟后-我们上次看了一下， 

72
00:04:21,939 --> 00:04:24,180
is a process of following this edge,
是遵循这一优势的过程， 

73
00:04:24,180 --> 00:04:26,709
and updating the d of a value.
并更新值的d。 

74
00:04:26,709 --> 00:04:30,139
And this infinity becomes 1 because you say, well,
这个无穷大变为1，因为你说， 

75
00:04:30,139 --> 00:04:33,589
if I start here with 0 and I add 1 to it, I get 1 here.
如果我从0开始并加1，则得到1。 

76
00:04:33,589 --> 00:04:35,829
Similarly, this infinity becomes 3.
同样，此无穷大为3。 

77
00:04:35,829 --> 00:04:38,099
And, at this point, you've relaxed the edges
并且，此时，您已经放松了边缘

78
00:04:38,100 --> 00:04:43,040
that go out of s two these other two nodes, a and b.
从其他两个另外两个节点a和b中得出。 

79
00:04:43,040 --> 00:04:45,331
You're not quite done yet.
您尚未完成。 

80
00:04:45,531 --> 00:04:49,769
At this point, you could imagine that, at least in this example,
此时，您可以想象，至少在此示例中， 

81
00:04:49,769 --> 00:04:52,349
you found the shortest path to the vertex a.
您找到了到达顶点a的最短路径。 

82
00:04:52,350 --> 00:04:57,939
But it is, in fact, a path of length, 2, to vertex b.
但这实际上是到顶点b的长度为2的路径。 

83
00:04:57,939 --> 00:05:01,540
Right now, we think that the the current shortest path to b,
现在，我们认为当前通往b的最短路径是

84
00:05:01,540 --> 00:05:05,500
after the first step of relaxing the edges from s,
在从s放松边缘的第一步之后， 

85
00:05:05,500 --> 00:05:06,720
happens to be 3.
碰巧是3。 

86
00:05:06,720 --> 00:05:13,360
But if you go like so, then you end up with the 2.
但是，如果您这样做，则最终得到的是2。 

87
00:05:13,360 --> 00:05:15,790
And, at this point, you're done.
至此，您已经完成。 

88
00:05:15,790 --> 00:05:20,379
Now we have to prove that any particular algorithm we put up
现在我们必须证明我们提出的任何特定算法

89
00:05:20,379 --> 00:05:24,759
is going to converge to the delta values, and the algorithm
将收敛到增量值，并且算法

90
00:05:24,759 --> 00:05:25,373
to terminate.
终止。 

91
00:05:25,374 --> 00:05:27,790
And then, we have to worry about the asymptotic complexity
然后，我们必须担心渐近复杂性

92
00:05:27,790 --> 00:05:28,930
of the algorithm.
算法的

93
00:05:28,930 --> 00:05:31,060
But that's the general overall flow.
但这就是总体流程。 

94
00:05:31,060 --> 00:05:34,060
And we look at, as I said, two algorithms today.
正如我说的，我们今天讨论两种算法。 

95
00:05:34,060 --> 00:05:35,519
Both special cases.
两种特殊情况。 

96
00:05:35,519 --> 00:05:38,379
One for DAGs and one for non-negative edges.
一种用于DAG，另一种用于非负边缘。 

97
00:05:38,379 --> 00:05:41,430
And we'll go through, and maybe not do a formal proof,
我们会仔细研究，也许不会做正式的证明， 

98
00:05:41,430 --> 00:05:44,319
but suddenly give you a strong intuition
但是突然间给你强烈的直觉

99
00:05:44,319 --> 00:05:46,990
as to why these algorithms work.
这些算法为何起作用。 

100
00:05:46,990 --> 00:05:52,750
Any questions about this material?
对这个材料有任何疑问吗？ 

101
00:05:52,750 --> 00:05:54,920
OK.
好。 

102
00:05:54,920 --> 00:05:58,220
So, what I want to do is give you
所以，我要做的就是给你

103
00:05:58,220 --> 00:06:04,569
a sense for why this relaxation step is useful.
这种放松步骤为何有用的感觉。 

104
00:06:04,769 --> 00:06:08,469
But also, importantly, safe, or correct.
但同样重要的是，安全或正确的。 

105
00:06:08,470 --> 00:06:15,220
And recall that our basic relaxation operation, which
回想一下我们基本的放松操作

106
00:06:15,220 --> 00:06:19,740
we did over here, as we updated the infinity value to 1
我们在这里做了，因为我们将无穷大值更新为1 

107
00:06:19,740 --> 00:06:24,100
and the 3 value to 2, et cetera, looks like this.
值3等于2，等等。 

108
00:06:24,100 --> 00:06:33,310
It says, if d of v is greater than d of u plus w u,v. Then,
它说，如果v的d大于u的d加wu，v。然后， 

109
00:06:33,509 --> 00:06:40,099
I'm going to update d of v to be d of u plus w u, v.
我将把v的d更新为u加wu，v的d。 

110
00:06:40,100 --> 00:06:43,870
You found a better way of reaching vertex v.
您找到了到达顶点v的更好方法。 

111
00:06:44,069 --> 00:06:44,894
A shorter way.
一种较短的方法。 

112
00:06:44,894 --> 00:06:48,560



113
00:06:48,560 --> 00:06:51,920
And this way happens to be going through the vertex, u.
而且这种方式恰好通过了顶点u。 

114
00:06:51,920 --> 00:06:55,129
So you update not only the priority value, but also
因此，您不仅可以更新优先级值，还可以更新

115
00:06:55,329 --> 00:06:57,449
the predecessor relationship.
前辈关系。 

116
00:06:57,449 --> 00:06:57,949
All right?
好吧？ 

117
00:06:57,949 --> 00:06:59,939
That's the relaxation step.
那是放松的步骤。 

118
00:06:59,939 --> 00:07:04,805
Now, I want to be able to show that relaxation is safe.
现在，我希望能够证明放松是安全的。 

119
00:07:04,805 --> 00:07:10,199



120
00:07:10,199 --> 00:07:11,759
What do I mean by that?
那是什么意思

121
00:07:11,759 --> 00:07:16,469
Well, I want to make sure that I never relax an edge
好吧，我想确保自己永远不会放松

122
00:07:16,470 --> 00:07:18,490
and somehow do something wrong, which
并以某种方式做错了

123
00:07:18,490 --> 00:07:23,319
gets me a value that's less than delta s v.
给我的值小于delta s v。 

124
00:07:23,319 --> 00:07:25,879
I want to be able to converge from the top.
我希望能够从顶部收敛。 

125
00:07:25,879 --> 00:07:28,839
I want to be able to start with these infinity values
我希望能够从这些无限值开始

126
00:07:28,839 --> 00:07:31,659
because I don't have a path to this particular vertex,
因为我没有通往这个特定顶点的路径， 

127
00:07:31,660 --> 00:07:35,500
and continually reduce the values of the priorities.
并不断降低优先级的价值。 

128
00:07:35,699 --> 00:07:39,459
And then get down to delta, the correct values, and don't go,
然后求出正确的增量值，别走了， 

129
00:07:39,459 --> 00:07:40,750
I don't want to go any further.
我不想再走了。 

130
00:07:40,750 --> 00:07:41,470
All right?
好吧？ 

131
00:07:41,470 --> 00:07:43,930
Because, if I get below, then you're talking about,
因为，如果我跌倒了，那么您在谈论， 

132
00:07:44,129 --> 00:07:46,170
essentially, you may be able to get back up,
从本质上讲，您也许可以复活， 

133
00:07:46,170 --> 00:07:49,629
but that is not the kind of algorithm that we want.
但这不是我们想要的那种算法。 

134
00:07:49,629 --> 00:07:51,959
At least, algorithms we look at here.
至少，我们在这里查看算法。 

135
00:07:51,959 --> 00:07:53,930
And that is dangerous.
那很危险。 

136
00:07:53,930 --> 00:07:56,850
So we want relaxation to be safe.
因此，我们希望放松是安全的。 

137
00:07:56,850 --> 00:08:02,310
And we can fairly easily prove a simple lemma,
我们可以很容易地证明一个简单的引理， 

138
00:08:02,509 --> 00:08:10,279
using induction, that says that the relaxation
使用归纳法，即放松

139
00:08:10,279 --> 00:08:13,689
operation-- and it doesn't matter
操作-没关系

140
00:08:13,689 --> 00:08:15,689
what sequence you relax things.
你放松什么顺序。 

141
00:08:15,689 --> 00:08:17,594
This is a fairly powerful lemma that
这是一个相当强大的引理

142
00:08:17,595 --> 00:08:20,850
says that if you have an algorithm that uses relaxation,
说如果您有使用松弛的算法， 

143
00:08:20,850 --> 00:08:25,850
and that's the only way of updating these d values,
这是更新这些d值的唯一方法， 

144
00:08:25,850 --> 00:08:27,560
then it's safe.
那很安全

145
00:08:27,560 --> 00:08:30,934
You're not going to get a wrong, shortest path value.
您不会得到错误的最短路径值。 

146
00:08:30,934 --> 00:08:32,350
Either at the end of the algorithm
在算法末尾

147
00:08:32,350 --> 00:08:35,298
or at any time during the running, or the execution,
或在跑步或执行期间的任何时候， 

148
00:08:35,298 --> 00:08:36,409
of this algorithm.
该算法。 

149
00:08:36,409 --> 00:08:36,908
OK?
好？ 

150
00:08:36,908 --> 00:08:39,889
So the relaxation operation algorithm
所以松弛运算算法

151
00:08:39,889 --> 00:08:53,159
maintains the invariant that d of v
维持v的d不变

152
00:08:53,159 --> 00:09:02,309
is greater than or equal to delta s, v for all vertices.
对于所有顶点，均大于或等于delta s，v。 

153
00:09:02,309 --> 00:09:03,229
OK?
好？ 

154
00:09:03,230 --> 00:09:05,375
So that's a powerful lemma.
所以这是一个强大的引理。 

155
00:09:05,375 --> 00:09:07,250
It's a fairly straightforward lemma to prove.
这是一个相当简单的引理可以证明。 

156
00:09:07,250 --> 00:09:09,750
But it's an important lemma.
但这是一个重要的引理。 

157
00:09:09,750 --> 00:09:13,330
It tells us that we can create the generic structure
它告诉我们可以创建通用结构

158
00:09:13,330 --> 00:09:16,480
of the shortest path algorithm that I talked about last week.
我上周讨论的最短路径算法。 

159
00:09:16,480 --> 00:09:19,370
It says, pick an edge.
它说，挑一个边缘。 

160
00:09:19,370 --> 00:09:20,311
Relax it.
放轻松

161
00:09:20,311 --> 00:09:20,859
Pick another edge.
选择另一个优势。 

162
00:09:21,059 --> 00:09:21,996
Relax it.
放轻松

163
00:09:21,996 --> 00:09:23,579
And hopefully everything will work out
希望一切都会解决

164
00:09:23,580 --> 00:09:25,480
and you'll get your delta values.
然后您将获得增量值。 

165
00:09:25,480 --> 00:09:28,927
And what this lemma says is, you'll
这个引理说的是，你会

166
00:09:28,927 --> 00:09:30,509
never get something in the middle that
永远不会在中间得到任何东西

167
00:09:30,509 --> 00:09:32,500
is less than your shortest path value.
小于最短路径值。 

168
00:09:32,500 --> 00:09:35,779
And if you keep running over for long enough time,
如果你继续跑了足够长的时间， 

169
00:09:35,779 --> 00:09:37,439
depending on the particular heuristic
取决于特定的启发式

170
00:09:37,440 --> 00:09:39,359
that you use for selecting the edges,
用于选择边缘的

171
00:09:39,559 --> 00:09:41,569
your algorithm will eventually terminate.
您的算法最终将终止。 

172
00:09:41,570 --> 00:09:46,740
And, hopefully, it'll run in polynomial time.
而且，希望它将在多项式时间内运行。 

173
00:09:46,740 --> 00:09:50,500
So, how do we prove this?
那么，我们如何证明这一点呢？ 

174
00:09:50,500 --> 00:09:52,620
I'm going to do about half of it,
我要做大约一半

175
00:09:52,620 --> 00:09:56,159
then try and get you to finish it.
然后尝试让您完成它。 

176
00:09:56,159 --> 00:10:04,639
So it's by induction on the number of steps,
所以是归纳为步骤数， 

177
00:10:04,639 --> 00:10:14,919
in the sense that we are going to essentially assume that d
在某种意义上，我们将基本上假设d 

178
00:10:14,919 --> 00:10:23,949
of u is greater than or equal to delta s,u.
 u的值大于或等于delta s，u。 

179
00:10:23,950 --> 00:10:28,850
And we're going to do this relaxation operation.
我们将执行此放松操作。 

180
00:10:28,850 --> 00:10:33,235
So it's like a base case is that this is correct.
因此，这就像一个基本情况，是正确的。 

181
00:10:33,235 --> 00:10:36,479



182
00:10:36,679 --> 00:10:43,449
And now we want to show that the relaxation operation doesn't
现在我们想证明松弛操作不会

183
00:10:43,450 --> 00:10:47,090
make d of v incorrect.
使v的d不正确。 

184
00:10:47,090 --> 00:10:52,024
So, that's the inductive hypothesis.
因此，这就是归纳假设。 

185
00:10:52,024 --> 00:10:54,659



186
00:10:54,659 --> 00:11:00,679
Now, we can say by the triangle inequality
现在，我们可以通过三角不等式说

187
00:11:00,679 --> 00:11:05,589
that I talked about late in last week's lecture,
在上周的演讲中我谈到的是

188
00:11:05,590 --> 00:11:11,849
you have delta s, v less than or equal to delta s comma
您有delta s，v小于或等于delta s逗号

189
00:11:12,049 --> 00:11:17,659
u plus delta u comma v. And what is that?
你加上三角洲逗号，那是什么？ 

190
00:11:17,659 --> 00:11:26,669
Well, that just says, if I have something like this,
好吧，这就是说，如果我有这样的事情， 

191
00:11:26,669 --> 00:11:30,339
that I have s.
我有。 

192
00:11:30,340 --> 00:11:35,570
Let's call this u and v.
我们称这个为u和v。 

193
00:11:35,570 --> 00:11:38,970
This is not an edge between s and v. It's a path.
这不是s和v之间的边，而是一条路径。 

194
00:11:38,970 --> 00:11:40,340
It could be a single edge.
它可以是单个边缘。 

195
00:11:40,340 --> 00:11:42,600
But we think of this as a path between s
但是我们认为这是s之间的一条路径

196
00:11:42,600 --> 00:11:47,029
and v. This is a path between s and u.
和v。这是s和u之间的路径。 

197
00:11:47,029 --> 00:11:50,889
This is a path between u and v.
这是u和v之间的路径。 

198
00:11:50,889 --> 00:11:57,779
And, in particular, if there's a way
特别是如果有办法

199
00:11:57,779 --> 00:12:08,639
of getting from s to u and u to v that happens to be shorter
从s到u和从u到v的过程恰好较短

200
00:12:08,639 --> 00:12:12,980
then the best way of getting from s to v,
那么从s到v的最佳方法， 

201
00:12:12,980 --> 00:12:14,831
well, that's a contradiction.
好吧，这是一个矛盾。 

202
00:12:14,831 --> 00:12:15,330
OK?
好？ 

203
00:12:15,330 --> 00:12:21,069
Because this is the shortest way of getting from s to v.
因为这是从s到v的最短方法。 

204
00:12:21,269 --> 00:12:23,600
And it has no constraints over the number of edges
而且它对边的数量没有限制

205
00:12:23,600 --> 00:12:26,750
that it incorporates.
它纳入。 

206
00:12:26,750 --> 00:12:28,730
And so, by definition, the shortest way
因此，按照定义，最短的方法

207
00:12:28,730 --> 00:12:31,139
of getting from s to v is either some direct way.
从s到v的一种直接方法。 

208
00:12:31,139 --> 00:12:32,460
Maybe there's a single edge.
也许只有一个优势。 

209
00:12:32,460 --> 00:12:36,610
Or it may go through this vertex, u.
否则它可能会穿过此顶点u。 

210
00:12:36,610 --> 00:12:37,110
All right?
好吧？ 

211
00:12:37,110 --> 00:12:39,889
So that's the triangle inequality.
这就是三角形不等式。 

212
00:12:39,889 --> 00:12:44,159
Notice that, what I have here, is something
注意，我在这里有一些东西

213
00:12:44,159 --> 00:12:50,669
where going from s, to a, to b is actually
从s到a到b的位置实际上是

214
00:12:50,669 --> 00:12:53,062
shorter than going from s to b.
比从s到b短。 

215
00:12:53,062 --> 00:12:55,019
But these are single edges we're talking about.
但是这些都是我们正在谈论的单一方面。 

216
00:12:55,019 --> 00:12:56,220
These are weights we're talking about.
这些是我们正在谈论的权重。 

217
00:12:56,220 --> 00:12:57,879
And there's no contradiction here
这里没有矛盾

218
00:12:57,879 --> 00:13:01,929
because all this says is that, what I want to see here
因为这就是我想在这里看到的

219
00:13:01,929 --> 00:13:07,469
is delta s comma b is going to be 2.
是delta s逗号b将为2。 

220
00:13:07,470 --> 00:13:08,840
OK?
好？ 

221
00:13:08,840 --> 00:13:11,109
Initially, I may be starting out with infinity and 3
最初，我可能会以无穷大和3开始

222
00:13:11,309 --> 00:13:12,899
for the d values.
对于d值。 

223
00:13:12,899 --> 00:13:15,159
But the delta value, which is the shortest way
但是增量值，这是最短的方法

224
00:13:15,159 --> 00:13:17,509
of getting to b, happens to go through a.
到达b的过程，碰巧经历了a。 

225
00:13:17,509 --> 00:13:20,149
And so, if you use that, then the triangle inequality
因此，如果使用它，那么三角形不等式

226
00:13:20,149 --> 00:13:21,059
makes sense.
说得通。 

227
00:13:21,059 --> 00:13:23,939
So don't get confused when you see pictures
所以看图片时不要困惑

228
00:13:23,940 --> 00:13:28,819
like this, where the weights don't obey the triangle
这样，权重不服从三角形

229
00:13:29,019 --> 00:13:30,039
inequality.
不等式。 

230
00:13:30,039 --> 00:13:33,679
The triangle inequality has to do with the shortest paths, not
三角不等式与最短路径有关，而不是

231
00:13:33,679 --> 00:13:35,100
the single edge ways.
单边方式。 

232
00:13:35,100 --> 00:13:35,600
OK?
好？ 

233
00:13:35,600 --> 00:13:38,409



234
00:13:38,409 --> 00:13:42,319
So, that's half the proof here.
所以，这是这里的一半证明。 

235
00:13:42,320 --> 00:13:46,589
What I've done is assumed that d of u is correct.
我所做的假设是假设d是正确的。 

236
00:13:46,789 --> 00:13:50,059
And I've used the triangle inequality.
而且我使用了三角形不等式。 

237
00:13:50,059 --> 00:13:51,679
And I've just written this down.
我刚刚写下来。 

238
00:13:51,679 --> 00:13:58,199
Now, someone do the last step, or the second to last step,
现在，有人进行了最后一步，或者倒数第二步， 

239
00:13:58,200 --> 00:13:59,730
of this proof.
这个证明。 

240
00:13:59,730 --> 00:14:00,230
Anybody?
有人吗

241
00:14:00,230 --> 00:14:03,100



242
00:14:03,100 --> 00:14:05,599
What can I say now, given that what I have here.
鉴于我在这里拥有什么，我现在能说什么。 

243
00:14:05,799 --> 00:14:09,079
Look at these two values.
看这两个值。 

244
00:14:09,080 --> 00:14:12,620
What can I say about these values?
我能说些什么？ 

245
00:14:12,620 --> 00:14:14,519
How can I prove what I want to prove,
我该如何证明我想证明的东西， 

246
00:14:14,519 --> 00:14:19,750
which is, basically, delta of s comma v should be less than
基本上，s的差值v应该小于

247
00:14:19,750 --> 00:14:21,559
or equal to d of v?
等于v的d？ 

248
00:14:21,559 --> 00:14:22,189
OK.
好。 

249
00:14:22,190 --> 00:14:24,479
That's what I want to show.
那就是我想展示的。 

250
00:14:24,679 --> 00:14:26,779
I've just written another way here.
我在这里写了另一种方式。 

251
00:14:26,779 --> 00:14:27,509
How do I do that?
我怎么做？ 

252
00:14:27,509 --> 00:14:30,946



253
00:14:30,946 --> 00:14:31,446
Anyone?
任何人？ 

254
00:14:31,446 --> 00:14:36,379



255
00:14:36,379 --> 00:14:45,809
What can I substitute for-- there's a less than operator,
我可以替代什么-少于运算符， 

256
00:14:45,809 --> 00:14:48,829
which means that I can replace things over here.
这意味着我可以替换这里的东西。 

257
00:14:48,830 --> 00:14:49,634
Yeah.
是的

258
00:14:49,634 --> 00:14:53,016
AUDIENCE: If you, like, you have a [INAUDIBLE]?
听众：如果您喜欢，您有[听不清]吗？ 

259
00:14:53,017 --> 00:14:53,600
PROFESSOR: Ah.
教授：嗯。 

260
00:14:53,600 --> 00:14:54,100
Excellent.
优秀的。 

261
00:14:54,100 --> 00:14:59,259
So the first thing is, I could put d of u over here, right?
所以第一件事是，我可以把你放在这里，对吗？ 

262
00:14:59,259 --> 00:15:04,149
Less than or equal to d of u.
小于或等于u的d。 

263
00:15:04,149 --> 00:15:06,769
And the reason I can do that is because d of u
我之所以能够做到这一点，是因为你的d 

264
00:15:06,769 --> 00:15:09,539
is greater then delta s comma u.
大于delta逗号。 

265
00:15:09,539 --> 00:15:13,069
So that's cool, right?
太酷了吧？ 

266
00:15:13,070 --> 00:15:13,690
Sorry, delta.
抱歉，三角洲。 

267
00:15:13,690 --> 00:15:14,479
Thank you.
谢谢。 

268
00:15:14,679 --> 00:15:15,899
Delta s comma u.
三角洲逗号

269
00:15:15,899 --> 00:15:16,959
Thank you.
谢谢。 

270
00:15:16,960 --> 00:15:18,629
And so, that's what I got here.
所以，这就是我在这里得到的。 

271
00:15:18,629 --> 00:15:20,039
What else?
还有什么？ 

272
00:15:20,039 --> 00:15:20,539
Yeah?
是啊

273
00:15:20,539 --> 00:15:24,073
AUDIENCE: You replace delta u, v with w u, v.
受众：您将u，v替换为wu，v。 

274
00:15:24,073 --> 00:15:25,990
PROFESSOR: I can replace delta u, v with w, u,
教授：我可以用w，u代替u，v 

275
00:15:25,990 --> 00:15:28,710
v. Exactly right.
 v。完全正确。 

276
00:15:28,710 --> 00:15:29,720
Exactly right.
非常正确。 

277
00:15:29,720 --> 00:15:30,320
Great.
大。 

278
00:15:30,320 --> 00:15:31,359
That deserves a cushion.
那值得缓冲。 

279
00:15:31,559 --> 00:15:33,419
I think you already have one.
我想你已经有一个。 

280
00:15:33,419 --> 00:15:35,040
Yep.
是的

281
00:15:35,041 --> 00:15:35,339
Oh, man.
天啊。 

282
00:15:35,539 --> 00:15:39,029
I should have not-- so you get that because I messed up.
我不应该-因为我搞砸了，所以您明白了。 

283
00:15:39,029 --> 00:15:40,929
Seems like you need to get-- whoa.
似乎您需要获取-哇。 

284
00:15:40,929 --> 00:15:41,509
Hey.
嘿。 

285
00:15:41,509 --> 00:15:42,519
OK.
好。 

286
00:15:42,519 --> 00:15:44,269
You get one because I hit you on the head.
你得到一个，因为我打你的头。 

287
00:15:44,269 --> 00:15:45,189
All right.
好吧。 

288
00:15:45,190 --> 00:15:46,440
And this time, I'll just save.
而这次，我将保存。 

289
00:15:46,440 --> 00:15:47,613
I'm running out of cushions here.
我的座垫不多了。 

290
00:15:47,813 --> 00:15:51,889
But I've got some in my office.
但是我办公室里有一些。 

291
00:15:51,889 --> 00:15:52,710
All right.
好吧。 

292
00:15:52,710 --> 00:15:53,269
So that's it.
就是这样了。 

293
00:15:53,269 --> 00:15:54,860
That's the proof.
那就是证明。 

294
00:15:54,860 --> 00:15:56,032
OK?
好？ 

295
00:15:56,032 --> 00:15:56,990
Fairly straightforward.
非常坦率的。 

296
00:15:56,990 --> 00:15:59,860



297
00:15:59,860 --> 00:16:04,289
You get to the point where you want
您到达想要的地步

298
00:16:04,289 --> 00:16:07,000
to apply the triangle inequality.
应用三角形不等式。 

299
00:16:07,000 --> 00:16:12,990
You simply look at each of these terms and, by induction
您只需看一下每个术语，并通过归纳法

300
00:16:12,990 --> 00:16:16,350
hypothesis, you could put d,u here.
假设，您可以将d，u放在这里。 

301
00:16:16,350 --> 00:16:18,500
And, I just talked about the weights,
而且，我刚刚谈到了重量， 

302
00:16:18,500 --> 00:16:20,480
and so on, and so forth.
等等等等。 

303
00:16:20,480 --> 00:16:23,629
And you know that w u,v, which is a direct way,
而且您知道wu，v是直接的方法， 

304
00:16:23,629 --> 00:16:29,639
a single edge way, of getting to a node,
到达节点的单边方法

305
00:16:29,639 --> 00:16:33,549
has to be greater than the shortest path.
必须大于最短路径。 

306
00:16:33,549 --> 00:16:36,289
Like here, this 3 value is a direct way
像这里一样，这3个值是直接的方法

307
00:16:36,289 --> 00:16:38,519
of getting from s to b.
从s到b的关系。 

308
00:16:38,519 --> 00:16:41,210
And, in this case, it's greater than the shortest
而且，在这种情况下，它大于最短的

309
00:16:41,210 --> 00:16:42,769
path, which is of length 2.
路径，长度为2。 

310
00:16:42,769 --> 00:16:45,710
But it can never be smaller than the shortest path.
但是它永远不能小于最短路径。 

311
00:16:45,710 --> 00:16:51,250
And so, once we have that here, we can essentially say,
因此，一旦我们在这里有了，我们就可以说， 

312
00:16:51,250 --> 00:16:55,009
we know that delta s, v is less than or equal to d u plus d v.
我们知道delta s，v小于或等于du plus d v。 

313
00:16:55,009 --> 00:16:57,529
Which implies, of course, that this is simply--
当然，这意味着，这仅仅是- 

314
00:16:57,529 --> 00:17:00,039
once we are done with the relaxation step-- that
一旦我们完成放松步骤- 

315
00:17:00,039 --> 00:17:07,629
equals d v. This part here equals d v. OK?
等于d v。这部分等于d v。好吗？ 

316
00:17:07,630 --> 00:17:09,440
That's how that works.
就是这样。 

317
00:17:09,440 --> 00:17:11,150
So that's good news.
这是个好消息。 

318
00:17:11,150 --> 00:17:15,276
We have a relaxation algorithm that is safe.
我们有一个安全的松弛算法。 

319
00:17:15,276 --> 00:17:16,650
We can now arbitrarily, and we'll
现在，我们可以任意选择， 

320
00:17:16,650 --> 00:17:21,519
do this for all of algorithms we look at, really.
确实针对我们研究的所有算法执行此操作。 

321
00:17:21,519 --> 00:17:23,980
At least in 006, for shortest paths.
至少在006中，用于最短路径。 

322
00:17:23,980 --> 00:17:27,559
Which applies some sequence of relaxations.
其中应用了一些松弛顺序。 

323
00:17:27,559 --> 00:17:31,515
And, depending on the special case of the problem,
并且，根据问题的特殊情况， 

324
00:17:31,516 --> 00:17:33,640
we're going to apply these things in different ways
我们将以不同的方式应用这些东西

325
00:17:33,640 --> 00:17:36,109
to get the most efficient algorithm.
以获得最有效的算法。 

326
00:17:36,309 --> 00:17:37,200
All right?
好吧？ 

327
00:17:37,200 --> 00:17:40,890
So, we can now do algorithms.
因此，我们现在可以执行算法。 

328
00:17:40,890 --> 00:17:43,514
Let's look at DAGs first.
首先让我们看一下DAG。 

329
00:17:43,714 --> 00:17:53,669



330
00:17:53,670 --> 00:17:58,390
So, DAG stands for Directed Acyclic Graphs.
因此，DAG代表有向无环图。 

331
00:17:58,390 --> 00:18:08,430
So that means we can't have cycles.
所以这意味着我们不能有循环。 

332
00:18:08,430 --> 00:18:10,109
So we can't have negative cycles.
所以我们不能有负周期。 

333
00:18:10,309 --> 00:18:13,409
So that's why this is an interesting special case.
这就是为什么这是一个有趣的特殊情况。 

334
00:18:13,410 --> 00:18:15,470
It makes things a little bit easier for us
它使我们的工作更轻松

335
00:18:15,470 --> 00:18:18,390
because we don't have to worry about negative cycles.
因为我们不必担心负周期。 

336
00:18:18,390 --> 00:18:20,079
We're actually going to look at DAGs
我们实际上将研究DAG 

337
00:18:20,279 --> 00:18:22,274
that have negative edges in them.
里面有消极的边缘。 

338
00:18:22,275 --> 00:18:22,619
All right?
好吧？ 

339
00:18:22,819 --> 00:18:26,089
So, we're allowed to have negative edges in these DAGs.
因此，允许我们在这些DAG中使用负边缘。 

340
00:18:26,089 --> 00:18:27,730
But we don't have negative cycles.
但是我们没有负周期。 

341
00:18:27,730 --> 00:18:29,284
And, as I said last time, it's not
而且，正如我上次说的， 

342
00:18:29,284 --> 00:18:30,950
the negative edges that cause a problem.
引起问题的负边缘。 

343
00:18:30,950 --> 00:18:34,266
If you only go through at negative edge once,
如果只在负边缘经历一次， 

344
00:18:34,266 --> 00:18:35,640
you can just subtract that value.
您可以减去该值。 

345
00:18:35,640 --> 00:18:36,910
And it's cool.
而且很酷。 

346
00:18:36,910 --> 00:18:38,960
It's only when you get into a situation
只有当你陷入困境时

347
00:18:38,960 --> 00:18:41,169
where you're going through a negative edge,
你正在经历一个消极的边缘， 

348
00:18:41,369 --> 00:18:42,359
a negative cycle.
负循环。 

349
00:18:42,359 --> 00:18:45,959
And you can just iterate through them to get to minus infinity.
您可以遍历它们以达到负无穷大。 

350
00:18:45,960 --> 00:18:49,639
And you have an indeterminate shortest path value.
并且您有不确定的最短路径值。 

351
00:18:49,839 --> 00:18:54,319
So the way this is going to work-- if you ever
所以这将是可行的-如果您愿意

352
00:18:54,319 --> 00:18:56,819
have a DAG, by the way, the first thing you want to try--
顺便说一句，有一个DAG，您想尝试的第一件事- 

353
00:18:56,819 --> 00:18:58,819
and this is certainly true in your problem set--
在您的问题集中肯定是这样- 

354
00:18:58,819 --> 00:19:01,839
when there's a question, try to topologically sort it.
遇到问题时，请尝试对其进行拓扑排序。 

355
00:19:01,839 --> 00:19:02,429
OK?
好？ 

356
00:19:02,430 --> 00:19:05,549
It's a fine hammer to use, when you have a DAG.
装有DAG时，可以使用这把锤子。 

357
00:19:05,549 --> 00:19:11,690
And it's not an exception here.
在这里也不例外。 

358
00:19:11,690 --> 00:19:13,500
To do shortest paths, we're going
要走最短的路，我们要

359
00:19:13,500 --> 00:19:17,759
to topologically sort the DAG.
对DAG进行拓扑排序。 

360
00:19:17,759 --> 00:19:32,769
And the path from u to v implies that u
从u到v的路径意味着u 

361
00:19:32,769 --> 00:19:37,500
is before v in the ordering.
在排序中位于v之前。 

362
00:19:37,500 --> 00:19:41,819



363
00:19:41,819 --> 00:19:43,692
And, once you do that, you have this linear.
而且，一旦执行此操作，就具有线性关系。 

364
00:19:43,692 --> 00:19:44,900
And I'll show you an example.
我会给你看一个例子。 

365
00:19:44,900 --> 00:19:46,509
You have this linear ordering.
您具有此线性顺序。 

366
00:19:46,509 --> 00:19:49,079
And we're just going to go through, in order,
我们将按顺序进行

367
00:19:49,079 --> 00:19:51,162
from left to right, relaxing these edges.
从左到右，放松这些边缘。 

368
00:19:51,162 --> 00:19:52,419
And we're going to get our shortest
而且我们要做到最短

369
00:19:52,619 --> 00:19:55,239
paths for all the vertices.
所有顶点的路径。 

370
00:19:55,240 --> 00:20:01,079
So, the second and last step is, one pass, left to right,
因此，第二个也是最后一个步骤，从左到右， 

371
00:20:01,079 --> 00:20:07,460
over the vertices, in topologically sorted order.
在顶点上，按照拓扑排序的顺序排列。 

372
00:20:07,460 --> 00:20:17,000



373
00:20:17,000 --> 00:20:20,569
And we're going to relax each edge that
我们将放松每个方面

374
00:20:20,569 --> 00:20:22,124
leaves the particular vertex we are
离开特定的顶点

375
00:20:22,124 --> 00:20:23,289
trying to process right now.
现在尝试进行处理。 

376
00:20:23,289 --> 00:20:32,940



377
00:20:32,940 --> 00:20:36,990
And so, we know topological sorting is order v plus e,
因此，我们知道拓扑排序是v加上e， 

378
00:20:36,990 --> 00:20:38,660
includes depth-first search.
包括深度优先搜索。 

379
00:20:38,660 --> 00:20:41,460
And this pass over the vertices, you're touching each vertex.
而这越过了顶点，您正在触摸每个顶点。 

380
00:20:41,460 --> 00:20:44,490
And you're touching every edge a constant number of times.
而您触摸每个边缘的次数是固定的。 

381
00:20:44,490 --> 00:20:45,970
In this case, once.
在这种情况下，一次。 

382
00:20:45,970 --> 00:20:53,180
So this is our first special case shortest path algorithm.
因此，这是我们的第一个特例最短路径算法。 

383
00:20:53,180 --> 00:20:55,920
And that takes order v plus e time.
这需要订单v加上e的时间。 

384
00:20:55,920 --> 00:20:57,009
All right?
好吧？ 

385
00:20:57,009 --> 00:20:58,569
Why does this work?
为什么这样做？ 

386
00:20:58,569 --> 00:21:06,149
And just one little interesting aspect
还有一个有趣的方面

387
00:21:06,150 --> 00:21:09,369
of this, which is related to a DAG.
这与DAG有关。 

388
00:21:09,569 --> 00:21:14,809
And the relationship between the DAG and the particular starting
以及DAG与特定起点之间的关系

389
00:21:14,809 --> 00:21:17,230
vertex that we're going to be looking at.
我们要关注的顶点。 

390
00:21:17,230 --> 00:21:20,500
So, this is an example.
因此，这是一个示例。 

391
00:21:20,500 --> 00:21:23,569
Suppose I have a DAG like this.
假设我有一个像这样的DAG。 

392
00:21:23,569 --> 00:21:26,720
And I marked this vertex as s.
我将此顶点标记为s。 

393
00:21:26,720 --> 00:21:30,019
And I want to find the shortest path from s
我想找到s的最短路径

394
00:21:30,019 --> 00:21:33,329
to these other nodes that are a and b.
到这些其他节点a和b。 

395
00:21:33,329 --> 00:21:36,279
Well, they don't exist, right?
好吧，它们不存在，对不对？ 

396
00:21:36,279 --> 00:21:40,170
So, in this case, I'm going to have a shortest
所以，在这种情况下，我将最短

397
00:21:40,170 --> 00:21:42,410
path to a being infinity and shortest path to b
通往无穷大的路径和通往b的最短路径

398
00:21:42,410 --> 00:21:43,710
being infinity.
无限

399
00:21:43,710 --> 00:21:46,079
And this is a trivial example.
这是一个简单的例子。 

400
00:21:46,079 --> 00:21:48,329
So, this algorithm is general.
因此，该算法是通用的。 

401
00:21:48,329 --> 00:21:51,730
It doesn't say anything about what the starting vertex is.
它没有说明起始顶点是什么。 

402
00:21:51,730 --> 00:21:52,230
Right?
对？ 

403
00:21:52,230 --> 00:21:55,299
It should work for any choice of starting vertex.
它应该适用于任何起始顶点选择。 

404
00:21:55,299 --> 00:22:00,529
The nice thing is that you can do the topological sort.
令人高兴的是，您可以进行拓扑排序。 

405
00:22:00,529 --> 00:22:05,460
And then you can commit to what the starting vertex is.
然后，您可以承诺起始顶点是什么。 

406
00:22:05,460 --> 00:22:08,890
And you can go off, and you can say, from this starting vertex,
然后，您可以从这个起始顶点出发， 

407
00:22:08,890 --> 00:22:11,399
I'm going to go and compute the shortest paths
我要去计算最短的路径

408
00:22:11,599 --> 00:22:15,339
to the other vertices that I can actually reach.
到我实际可以到达的其他顶点。 

409
00:22:15,339 --> 00:22:16,049
OK?
好？ 

410
00:22:16,049 --> 00:22:19,639
So let's say that you had a DAG that looks like this.
假设您有一个看起来像这样的DAG。 

411
00:22:19,640 --> 00:22:21,640
All right, once you've topologically sorted it,
好吧，一旦您对它进行了拓扑排序， 

412
00:22:21,640 --> 00:22:27,086
you can always draw a DAG in linear form.
您可以始终以线性形式绘制DAG。 

413
00:22:27,086 --> 00:22:27,920
That's a nice thing.
很好

414
00:22:27,920 --> 00:22:37,912



415
00:22:37,912 --> 00:22:39,669
I'm going to put edge weights down in a minute.
我将在一分钟内降低边缘权重。 

416
00:22:39,869 --> 00:22:48,149



417
00:22:48,150 --> 00:22:48,650
All right.
好吧。 

418
00:22:48,650 --> 00:22:49,419
So that's my DAG.
这就是我的DAG。 

419
00:22:49,619 --> 00:22:52,879



420
00:22:52,880 --> 00:22:53,380
Let's see.
让我们来看看。 

421
00:22:53,380 --> 00:23:04,160
5, 3, 2, 6, 7, 4, 2, minus 1, minus 2.
 5，3，2，6，7，4，4，负1，负2。 

422
00:23:04,160 --> 00:23:07,970



423
00:23:07,970 --> 00:23:09,240
So that's my DAG.
这就是我的DAG。 

424
00:23:09,240 --> 00:23:12,839
And I've drawn it in topologically sorted form.
我已经按照拓扑排序的形式绘制了它。 

425
00:23:12,839 --> 00:23:14,299
And I go left to right.
我从左到右。 

426
00:23:14,299 --> 00:23:19,079
Now, let's say that, at this point, I get to step two.
现在，让我们说到这一步，我进入第二步。 

427
00:23:19,079 --> 00:23:20,809
And I want to find shortest paths.
我想找到最短的路径。 

428
00:23:20,809 --> 00:23:23,490
Now, I have to say, what is my source?
现在，我不得不说，我的来源是什么？ 

429
00:23:23,490 --> 00:23:28,849
And, if I just happen to have this as my source,
而且，如果我只是碰巧以此为来源， 

430
00:23:28,849 --> 00:23:31,159
well, there's nothing to do here.
好吧，这里无事可做。 

431
00:23:31,160 --> 00:23:33,440
There's no edges that go out of this.
没有任何余地。 

432
00:23:33,440 --> 00:23:36,509
And so that means that everything to the left of me
所以这意味着我左边的一切

433
00:23:36,509 --> 00:23:37,930
is infinity.
是无穷大。 

434
00:23:37,930 --> 00:23:38,740
OK?
好？ 

435
00:23:38,740 --> 00:23:40,589
So the first thing that you do is,
因此，您要做的第一件事是， 

436
00:23:40,589 --> 00:23:44,179
you say, find the source that corresponds
你说，找到对应的来源

437
00:23:44,180 --> 00:23:46,789
to the starting vertex.
到起始顶点。 

438
00:23:46,789 --> 00:23:50,210
And let's say, this is the starting vertex, in this case.
假设在这种情况下，这是起始顶点。 

439
00:23:50,210 --> 00:23:53,900
Which I'll mark in bold.
我将以粗体标记。 

440
00:23:53,900 --> 00:23:54,919
So that's my starting vertex.
这就是我的起点。 

441
00:23:55,119 --> 00:23:57,059
I'll take a nontrivial case.
我将处理一个不平凡的案件。 

442
00:23:57,059 --> 00:23:59,569
And everything to the left is going
左边的一切都在进行

443
00:23:59,569 --> 00:24:02,980
to get marked with infinity.
标记无穷大。 

444
00:24:02,980 --> 00:24:07,019
And now, I've got to do some work on relaxation.
现在，我必须做一些放松的工作。 

445
00:24:07,019 --> 00:24:10,079
And I'm not going to get the shortest path instantly
而且我不会立即获得最短的路径

446
00:24:10,079 --> 00:24:14,529
for a particular vertex, once I get to it, because there
对于特定的顶点，一旦到达该顶点，因为

447
00:24:14,529 --> 00:24:16,250
may be better ways of getting there.
可能是到达那里的更好方法。 

448
00:24:16,250 --> 00:24:18,349
And especially if I have negative edges.
特别是如果我有消极的一面。 

449
00:24:18,349 --> 00:24:21,969
And that's certainly possible, that a longer length path
当然，这可能是更长的路径

450
00:24:21,970 --> 00:24:24,230
is going to be the shortest path.
将是最短的路径。 

451
00:24:24,230 --> 00:24:27,019
But what I'll do is take s.
但是我要做的是s。 

452
00:24:27,019 --> 00:24:30,609
And I'm going to relax edges that emanate from s.
我将放松从s发出的边缘。 

453
00:24:30,609 --> 00:24:32,519
And so, step one, all of these are
因此，第一步，所有这些都是

454
00:24:32,519 --> 00:24:34,349
going to be infinity to start with.
首先将是无穷大。 

455
00:24:34,349 --> 00:24:35,909
So everything is infinity.
所以一切都是无限的。 

456
00:24:35,910 --> 00:24:37,779
The ones to the left stay infinity.
左边的那些保持无限。 

457
00:24:37,779 --> 00:24:40,500
The ones to the right are going to be reachable.
右边的那些将是可及的。 

458
00:24:40,500 --> 00:24:47,109
And you're going to update those values.
您将更新这些值。 

459
00:24:47,109 --> 00:24:51,229
And so, when you go like so, this becomes 2.
因此，当您像这样前进时，该值为2。 

460
00:24:51,230 --> 00:24:52,970
This becomes 6.
这变成6。 

461
00:24:52,970 --> 00:24:54,149
As I follow that.
按照我的指示。 

462
00:24:54,349 --> 00:24:58,939
And I'm done with this vertex, s.
我已经完成了这个顶点s。 

463
00:24:58,940 --> 00:25:00,160
And this is what I have.
这就是我所拥有的。 

464
00:25:00,160 --> 00:25:01,109
2 and 6.
 2和6。 

465
00:25:01,309 --> 00:25:04,559
So the next step is to get to this vertex.
所以下一步就是到达这个顶点。 

466
00:25:04,559 --> 00:25:06,769
Let's call that the vertex a.
我们称顶点为a。 

467
00:25:06,769 --> 00:25:09,900
And I'm going relax the edges going out of a.
我要放松a的边缘。 

468
00:25:09,900 --> 00:25:14,359
And, when I go out of a, I get 2 plus 7
而且，当我淘汰a时，我得到2加7 

469
00:25:14,559 --> 00:25:17,009
is 9, which is greater than 6.
是9，大于6。 

470
00:25:17,009 --> 00:25:19,259
So there's no reason to update that.
因此，没有理由进行更新。 

471
00:25:19,259 --> 00:25:22,839
2 plus 4 is less than infinity.
 2加4小于无穷大。 

472
00:25:22,839 --> 00:25:26,750
And so, that's 6.
就是6。 

473
00:25:26,750 --> 00:25:31,140
2 plus 2 gives me 4 here.
 2加2给我4。 

474
00:25:31,140 --> 00:25:32,740
And so on and so forth.
等等等等。 

475
00:25:32,740 --> 00:25:34,710
So then, now I'm done with vertex a.
因此，现在我完成了顶点a。 

476
00:25:34,710 --> 00:25:39,019
If this vertex is b, then I have a value of 6 for this.
如果这个顶点是b，那么我的值为6。 

477
00:25:39,019 --> 00:25:42,254
And 6 minus 1 is less than 6.
 6减1小于6。 

478
00:25:42,255 --> 00:25:44,609
So this becomes 5.
这样就变成5。 

479
00:25:44,809 --> 00:25:49,929
And 5 minus 2-- well, that's the next step after that.
 5减2-好吧，这是之后的下一步。 

480
00:25:49,930 --> 00:25:52,630
I haven't put-- this is a 1.
我没有放-这是1。 

481
00:25:52,630 --> 00:25:55,717
And so 6 plus 1 is 7.
所以6加1是7 

482
00:25:55,717 --> 00:25:56,599
But that's greater than 4.
但这大于4。 

483
00:25:56,799 --> 00:25:58,869
So we don't have to anything there.
因此，我们不必在那儿做任何事情。 

484
00:25:58,869 --> 00:26:05,409
So the final values that I end up getting are 3 for this one.
因此，我最终得到的最终值是3。 

485
00:26:05,410 --> 00:26:07,230
So this is the final value.
所以这是最终值。 

486
00:26:07,230 --> 00:26:09,839
5 is the final value here.
 5是此处的最终值。 

487
00:26:09,839 --> 00:26:12,089
6 is the final value here.
此处的最终值为6。 

488
00:26:12,089 --> 00:26:14,019
2 is the final value here.
此处的最终值为2。 

489
00:26:14,019 --> 00:26:15,650
And that one is 0.
那是0。 

490
00:26:15,650 --> 00:26:17,460
And this stays infinity.
并且这保持无限。 

491
00:26:17,460 --> 00:26:18,470
OK?
好？ 

492
00:26:18,470 --> 00:26:20,680
So fairly straightforward.
非常简单。 

493
00:26:20,680 --> 00:26:22,359
Do a topological sort.
进行拓扑排序。 

494
00:26:22,559 --> 00:26:24,179
Find the starting point.
找到起点。 

495
00:26:24,180 --> 00:26:27,130
And then run all the way to the right.
然后一直向右运行。 

496
00:26:27,130 --> 00:26:30,379
Interestingly, this is actually a really simple example
有趣的是，这实际上是一个非常简单的示例

497
00:26:30,579 --> 00:26:33,149
of dynamic programming, which we'll talk about
动态编程，我们将讨论

498
00:26:33,150 --> 00:26:36,460
in gory detail, later in November.
详细信息，十一月下旬。 

499
00:26:36,460 --> 00:26:44,250
But what I have here is the simplest special case
但是我这里是最简单的特殊情况

500
00:26:44,250 --> 00:26:48,160
of a graph that has an order of v e [INAUDIBLE]
阶为ve的图的[听不清] 

501
00:26:48,160 --> 00:26:49,430
shortest path algorithm.
最短路径算法。 

502
00:26:49,430 --> 00:26:51,919
And the reason for that is we don't have cycles.
原因是我们没有周期。 

503
00:26:52,119 --> 00:26:53,149
All right?
好吧？ 

504
00:26:53,150 --> 00:26:55,220
Any questions about this?
对此有任何疑问吗？ 

505
00:26:55,220 --> 00:26:57,630
People buy this?
人们买这个？ 

506
00:26:57,630 --> 00:26:58,450
It works?
有用？ 

507
00:26:58,450 --> 00:26:59,169
OK.
好。 

508
00:26:59,369 --> 00:27:02,259
So, we've got one algorithm under our belt.
因此，我们掌握了一种算法。 

509
00:27:02,259 --> 00:27:05,079
And we look at, really, a more interesting case
我们来看一个更有趣的案例

510
00:27:05,079 --> 00:27:08,379
because most graphs are going to have cycles in them.
因为大多数图形都将包含循环。 

511
00:27:08,380 --> 00:27:11,889
But we will stay with the special case
但是我们会保留特殊情况

512
00:27:12,089 --> 00:27:13,339
of no negative edges, now.
现在没有负面影响。 

513
00:27:13,339 --> 00:27:13,839
All right?
好吧？ 

514
00:27:13,839 --> 00:27:18,720
So Dijkstra's algorithm doesn't work for negative edges.
因此Dijkstra的算法不适用于负边缘。 

515
00:27:18,720 --> 00:27:20,069
So it's different.
所以不一样。 

516
00:27:20,069 --> 00:27:23,149
This algorithm is not subsumed by Dijkstra.
 Dijkstra不包含此算法。 

517
00:27:23,150 --> 00:27:24,899
That's important to understand.
了解这一点很重要。 

518
00:27:25,099 --> 00:27:28,339
So Dijkstra's algorithm works for graphs with cycles.
因此Dijkstra的算法适用于带有循环的图。 

519
00:27:28,339 --> 00:27:32,740
But all of the edge ways have to be either 0 or positive.
但是所有边缘方式都必须为0或正数。 

520
00:27:32,740 --> 00:27:35,740
This algorithm works for DAGs that can have negative edges.
该算法适用于可能具有负边缘的DAG。 

521
00:27:35,740 --> 00:27:37,339
But you can't have cycles.
但是你不能有周期。 

522
00:27:37,339 --> 00:27:40,449
So both of these algorithms have their place under the sun.
因此，这两种算法都在阳光下占有一席之地。 

523
00:27:40,450 --> 00:27:43,129



524
00:27:43,329 --> 00:27:46,230
So, let's take a look at Dijkstra's algorithm.
因此，让我们看一下Dijkstra的算法。 

525
00:27:46,230 --> 00:27:48,009
Actually, I guess I have a demo.
实际上，我想我有一个演示。 

526
00:27:48,009 --> 00:27:57,390
So, the one demo we have in 6006.
因此，我们在6006中有一个演示。 

527
00:27:57,390 --> 00:28:00,460
[INAUDIBLE] Dijkstra is a very straightforward algorithm.
 [听不清] Dijkstra是一种非常简单的算法。 

528
00:28:00,460 --> 00:28:04,389
It's not trivial to prove its correctness.
证明其正确性并非易事。 

529
00:28:04,589 --> 00:28:07,769
But from a standpoint of coding, from a standpoint
但是从编码的角度来看

530
00:28:07,769 --> 00:28:10,639
of understanding the flow, it's a very straightforward
了解流程，这非常简单

531
00:28:10,640 --> 00:28:11,819
algorithm.
算法。 

532
00:28:12,019 --> 00:28:14,059
One of the reasons why that's the case
发生这种情况的原因之一

533
00:28:14,059 --> 00:28:17,259
is because it's a greedy algorithm.
是因为这是一种贪婪算法。 

534
00:28:17,259 --> 00:28:21,710
It does things incrementally, maximizing the benefit,
它会逐步执行任务，从而使收益最大化， 

535
00:28:21,710 --> 00:28:22,779
as you will.
随你便。 

536
00:28:22,779 --> 00:28:26,000
And intuitively builds the shortest paths.
并直观地构建最短路径。 

537
00:28:26,000 --> 00:28:28,769
And it goes vertex by vertex.
它逐个顶点。 

538
00:28:28,769 --> 00:28:31,410
So here's a demo of Dijkstra, which,
这是Dijkstra的演示， 

539
00:28:31,410 --> 00:28:33,419
the reason I want to show you this,
我想给你看这个的原因

540
00:28:33,419 --> 00:28:35,960
is because it will give you some intuition as to why Dijkstra
是因为它将使您对为什么Dijkstra有一些直觉

541
00:28:35,960 --> 00:28:36,752
works.
作品。 

542
00:28:36,752 --> 00:28:41,039
Now, some points of note.
现在，一些注意事项。 

543
00:28:41,039 --> 00:28:43,069
I can't tilt this more than about this much
我不能超过此程度

544
00:28:43,069 --> 00:28:45,149
because then these balls will fall off.
因为这些球会掉下来。 

545
00:28:45,150 --> 00:28:49,180
So, cameraman, can you get this?
那么，摄影师，你能得到这个吗？ 

546
00:28:49,180 --> 00:28:49,680
All right?
好吧？ 

547
00:28:49,680 --> 00:28:52,269
For posterity.
为了后代。 

548
00:28:52,269 --> 00:28:55,440
So I got an undirected graph here, right?
所以我在这里得到了无向图，对吗？ 

549
00:28:55,440 --> 00:28:58,480
And each of these things are nodes.
这些东西都是节点。 

550
00:28:58,480 --> 00:29:01,200
The balls are the nodes of the vertices.
球是顶点的节点。 

551
00:29:01,200 --> 00:29:03,009
And I've drawn the picture over there.
我在那边画了画。 

552
00:29:03,009 --> 00:29:04,279
And G stands for green.
 G代表绿色。 

553
00:29:04,279 --> 00:29:06,349
And Y stands for yellow, et cetera.
 Y代表黄色，等等。 

554
00:29:06,349 --> 00:29:09,079
So, this graph is essentially what I have up there.
所以，这张图本质上就是我在那里的东西。 

555
00:29:09,079 --> 00:29:16,539
And I've put strings connecting these balls, associated
我把连接这些球的弦放进去

556
00:29:16,539 --> 00:29:21,970
with the weights that you see up there.
与您在那里看到的重量。 

557
00:29:21,970 --> 00:29:25,700
So, if I got this right, the string
所以，如果我说对了，那么字符串

558
00:29:25,700 --> 00:29:30,190
that's connecting the green ball to the yellow ball up on top
将绿色球连接到顶部的黄色球

559
00:29:30,190 --> 00:29:31,659
is 19 centimeters.
是19厘米。 

560
00:29:31,859 --> 00:29:33,934
And so on and so forth for these other ones.
等等，以此类推。 

561
00:29:33,934 --> 00:29:35,250
All right?
好吧？ 

562
00:29:35,250 --> 00:29:37,799
So, that's Dijkstra.
那就是Dijkstra。 

563
00:29:37,799 --> 00:29:41,609
And what do you think I have to do
你觉得我该怎么办

564
00:29:41,609 --> 00:29:46,208
to compute shortest paths, mechanically speaking?
机械地计算最短路径？ 

565
00:29:46,209 --> 00:29:47,500
What do you think I have to do?
您认为我该怎么办？ 

566
00:29:47,500 --> 00:29:50,248



567
00:29:50,248 --> 00:29:50,909
Yeah, someone.
是的，有人。 

568
00:29:51,109 --> 00:29:53,740



569
00:29:53,740 --> 00:29:55,531
AUDIENCE: Pick up the green ball and just--
听众：拿起绿色的球，然后- 

570
00:29:55,531 --> 00:29:56,629
PROFESSOR: Pick up the ball and lift it up.
教授：拿起球并将其抬起。 

571
00:29:56,630 --> 00:29:57,171
That's right.
那就对了。 

572
00:29:57,171 --> 00:29:58,019
Good.
好。 

573
00:29:58,019 --> 00:30:00,250
It's worth a cushion.
值得缓冲。 

574
00:30:00,250 --> 00:30:02,089
All right, so, let's all this works.
好吧，让我们完成所有这些工作。 

575
00:30:02,089 --> 00:30:05,759



576
00:30:05,759 --> 00:30:10,720
So, first, let me show you by those values that I have there.
因此，首先，让我通过我那里的价值观向您展示。 

577
00:30:10,720 --> 00:30:15,730
If the green ball is the starting vertex, then
如果绿色球是起始顶点，则

578
00:30:15,730 --> 00:30:21,789
the shortest path to the purple vertex, p, is 7.
紫色顶点的最短路径p为7。 

579
00:30:21,789 --> 00:30:24,529
And that's the closest node to G.
那是最接近G的节点

580
00:30:24,529 --> 00:30:27,359
And then, the next closest node is
然后，下一个最近的节点是

581
00:30:27,359 --> 00:30:30,539
the blue one, which is b, which is 12.
蓝色的一个，即b，即12。 

582
00:30:30,539 --> 00:30:31,829
7 plus 5.
 7加5。 

583
00:30:31,829 --> 00:30:33,210
And so on and so forth.
等等等等。 

584
00:30:33,210 --> 00:30:35,890
And so, if this all works, and I haven't tried this out,
因此，如果这一切都可行，而我还没有尝试过， 

585
00:30:35,890 --> 00:30:37,930
because this is a one use demo.
因为这是一个一次性演示。 

586
00:30:37,930 --> 00:30:41,779
Once I pull this up, the strings get so tangled up,
一旦我把它拉起来，弦就变得如此纠结， 

587
00:30:41,779 --> 00:30:42,859
it doesn't work anymore.
它不再工作了。 

588
00:30:42,859 --> 00:30:43,439
All right?
好吧？ 

589
00:30:43,440 --> 00:30:45,889
So that's why I had to do all of this, lug these over.
所以这就是为什么我必须做所有这些，把这些都拖过去。 

590
00:30:46,089 --> 00:30:47,779
Otherwise, it'd be-- so this is not
否则会-所以这不是

591
00:30:47,779 --> 00:30:49,335
a computer reversible kind of thing.
一种计算机可逆的东西。 

592
00:30:49,335 --> 00:30:51,139
So, if you want to code Dijkstra up.
因此，如果您想对Dijkstra进行编码。 

593
00:30:51,339 --> 00:30:54,669
OK, so if I just lift it up, and if I do that,
好，所以如果我把它抬起来，如果这样做， 

594
00:30:54,670 --> 00:30:56,336
and if I tilt it in the right direction.
如果我朝正确的方向倾斜。 

595
00:30:56,336 --> 00:30:56,836
Yeah.
是的

596
00:30:56,836 --> 00:30:57,519
I want to that.
我想要那个。 

597
00:30:57,519 --> 00:30:59,720
So you can see that this is a little bit of fudging going on
所以您可以看到这有点令人困惑

598
00:30:59,720 --> 00:31:01,529
here, with respect to getting this right.
在这里，关于正确的选择。 

599
00:31:01,529 --> 00:31:03,115
But you see green is up on top.
但是您会看到绿色在最上面。 

600
00:31:03,115 --> 00:31:04,490
And what is the next one you see?
您接下来会看到什么？ 

601
00:31:04,490 --> 00:31:05,009
AUDIENCE: Purple.
听众：紫色。 

602
00:31:05,009 --> 00:31:05,450
PROFESSOR: Purple.
教授：紫色。 

603
00:31:05,450 --> 00:31:05,969
That's good.
那很好。 

604
00:31:05,969 --> 00:31:07,134
What's the next one you see?
您看到的下一个是什么？ 

605
00:31:07,134 --> 00:31:07,450
AUDIENCE: Blue.
听众：蓝色。 

606
00:31:07,450 --> 00:31:08,115
PROFESSOR: Blue.
教授：蓝色。 

607
00:31:08,115 --> 00:31:10,220
That's good.
那很好。 

608
00:31:10,220 --> 00:31:14,680
Y, and then R. And strings that are taught,
是Y，然后是R。 

609
00:31:14,680 --> 00:31:18,109
that have tension in them, are the predecessor vertices, OK?
它们之间有张力吗，前一个顶点好吗？ 

610
00:31:18,309 --> 00:31:19,879
That's the pie.
那是馅饼。 

611
00:31:19,880 --> 00:31:20,440
All right?
好吧？ 

612
00:31:20,440 --> 00:31:23,149
So, again, I computed the shortest paths, right?
所以，我又计算出最短路径，对吗？ 

613
00:31:23,349 --> 00:31:24,339
Mechanically.
机械上。 

614
00:31:24,339 --> 00:31:27,659
And, if I could have a way of measuring the tension
而且，如果我有办法测量张力

615
00:31:27,660 --> 00:31:30,921
on the strings, I have my pie, my predecessor relationship,
在弦上，我有我的馅饼，我的前任关系， 

616
00:31:30,921 --> 00:31:31,420
as well.
也一样

617
00:31:31,420 --> 00:31:31,859
All right?
好吧？ 

618
00:31:32,059 --> 00:31:33,971
Now, let's see if this works.
现在，让我们看看是否可行。 

619
00:31:33,971 --> 00:31:35,089
This works, right?
这样行对不对

620
00:31:35,089 --> 00:31:40,269
So, if the second thing doesn't work, don't hold it against me.
因此，如果第二件事不起作用，请不要反对我。 

621
00:31:40,269 --> 00:31:44,950
But, let's say if I take R, and I lift it up like that.
但是，假设我拿了R，然后像这样将它提起。 

622
00:31:44,950 --> 00:31:46,809
Yikes.
 kes。 

623
00:31:46,809 --> 00:31:50,429
So, R, followed by Y, followed by B, followed by P,
因此，R，Y，Y，B，P 

624
00:31:50,430 --> 00:31:51,490
followed by G.
其次是G。 

625
00:31:51,490 --> 00:31:52,819
Hey.
嘿。 

626
00:31:52,819 --> 00:31:54,559
Come on.
来吧。 

627
00:31:54,559 --> 00:31:55,169
All right?
好吧？ 

628
00:31:55,170 --> 00:31:55,670
This works.
这可行。 

629
00:31:55,670 --> 00:31:56,180
Thank you.
谢谢。 

630
00:31:56,180 --> 00:31:57,422
Thank you.
谢谢。 

631
00:31:57,422 --> 00:31:59,289
All right.
好吧。 

632
00:31:59,289 --> 00:32:06,750
So there's actually a reason why I did that demo.
所以实际上是我进行该演示的原因。 

633
00:32:06,750 --> 00:32:09,599
There's a greedy algorithm here.
这里有一个贪心算法。 

634
00:32:09,599 --> 00:32:11,389
And, I guess, greedy is gravity.
而且，我想，贪婪是引力。 

635
00:32:11,390 --> 00:32:11,890
Right?
对？ 

636
00:32:11,890 --> 00:32:13,629
Gravity is greedy.
重力是贪婪的。 

637
00:32:13,829 --> 00:32:16,903
So, obviously, the reason why those balls are hanging
所以，很明显，这些球悬挂的原因

638
00:32:16,903 --> 00:32:18,069
is because they have weight.
是因为他们有体重。 

639
00:32:18,069 --> 00:32:19,139
And they have gravity.
他们有重力。 

640
00:32:19,140 --> 00:32:21,611
And you can imagine that you could now-- people in physics.
您可以想象，您现在可以-物理学家。 

641
00:32:21,811 --> 00:32:23,519
I don't know anybody majoring in physics.
我不认识物理学专业的人。 

642
00:32:23,519 --> 00:32:26,299
Anyone double majoring in physics or something here?
有人在读物理学双专业吗？ 

643
00:32:26,299 --> 00:32:27,980
All right.
好吧。 

644
00:32:27,980 --> 00:32:30,000
So, you know your Newton's laws of mechanics.
因此，您知道您的牛顿力学定律。 

645
00:32:30,000 --> 00:32:31,900
And you know about gravity, and all of that.
您知道重力，以及所有这些。 

646
00:32:31,900 --> 00:32:33,579
So you can imagine that you said, you know,
所以你可以想象你说，你知道， 

647
00:32:33,779 --> 00:32:36,774
the heck with all this priority queue stuff in the problem set.
问题集中所有这些优先级队列内容的问题。 

648
00:32:36,775 --> 00:32:38,150
In the algorithm that we're going
在我们要使用的算法中

649
00:32:38,150 --> 00:32:39,660
to be talking about for Dijkstra,
为Dijkstra谈论， 

650
00:32:39,660 --> 00:32:43,769
I'm going to do a kinetic simulation of shortest paths
我将对最短路径进行动力学模拟

651
00:32:43,769 --> 00:32:47,790
in order to get the actual values of these shortest paths.
为了获得这些最短路径的实际值。 

652
00:32:47,790 --> 00:32:48,289
OK?
好？ 

653
00:32:48,289 --> 00:32:49,789
Now, that would be cool.
现在，那将很酷。 

654
00:32:49,789 --> 00:32:51,730
But it'd be horribly slow.
但这太慢了。 

655
00:32:51,730 --> 00:32:54,660
And so, the Dijkstra algorithm we're going to be talking about
因此，我们将要讨论的Dijkstra算法

656
00:32:54,660 --> 00:32:57,980
is going to just compute the steady state, corresponding
将只计算稳态，对应

657
00:32:57,980 --> 00:33:04,809
to the closest vertex that is closest to G. All right?
到最接近G的最近顶点。好吗？ 

658
00:33:04,809 --> 00:33:07,669
So Dijkstra, the algorithm, the intuition behind it,
所以Dijkstra，算法，其背后的直觉， 

659
00:33:07,670 --> 00:33:10,710
is that it's going to greedily construct shortest paths.
是它会贪婪地构建最短路径。 

660
00:33:10,710 --> 00:33:12,650
And it's going to be starting with G,
它将从G开始

661
00:33:12,650 --> 00:33:13,781
which is your source vertex.
这是您的源顶点。 

662
00:33:13,981 --> 00:33:15,440
And then, the first thing that it's
然后，第一件事是

663
00:33:15,440 --> 00:33:17,254
going to process, and find the shortest path to
进行处理，并找到最短的路径

664
00:33:17,454 --> 00:33:19,220
is going to be the purple vertex.
将成为紫色顶点。 

665
00:33:19,220 --> 00:33:20,069
And then the blue.
然后是蓝色。 

666
00:33:20,069 --> 00:33:21,119
And then the yellow.
然后是黄色。 

667
00:33:21,119 --> 00:33:21,939
And then the red.
然后是红色。 

668
00:33:21,940 --> 00:33:22,440
All right?
好吧？ 

669
00:33:22,440 --> 00:33:26,529
So it actually mimics, to some extent, this demo.
因此，它实际上在某种程度上模仿了这个演示。 

670
00:33:26,529 --> 00:33:29,761
All right?
好吧？ 

671
00:33:29,761 --> 00:33:31,970
So, let's take a look at the pseudocode for Dijkstra.
因此，让我们看一下Dijkstra的伪代码。 

672
00:33:31,970 --> 00:34:00,089



673
00:34:00,089 --> 00:34:01,289
So, g is your graph.
因此，g是您的图表。 

674
00:34:01,289 --> 00:34:03,049
w are the weights.
 w是权重。 

675
00:34:03,049 --> 00:34:06,759
Small s is the starting vertex.
小s是起始顶点。 

676
00:34:06,759 --> 00:34:16,369
We're going to initialize g and s, which means we just mark
我们将初始化g和s，这意味着我们只是标记

677
00:34:16,369 --> 00:34:18,329
s a starting vertex.
一个起始顶点。 

678
00:34:18,329 --> 00:34:22,779
And we're going to also have this capital S, that I'll
而且我们还要有这个资本S 

679
00:34:22,780 --> 00:34:27,050
use these little bars to differentiate from small s.
使用这些小条与小s区分。 

680
00:34:27,050 --> 00:34:28,199
So this is a set.
所以这是一个集合。 

681
00:34:28,199 --> 00:34:30,880
Capital S is a set.
大写S是一组。 

682
00:34:30,880 --> 00:34:33,590
And we're going to initialize that to null.
我们将其初始化为null。 

683
00:34:33,590 --> 00:34:36,170
And there's another set called Q,
还有另一个叫Q的集合

684
00:34:36,170 --> 00:34:40,400
which is initialized to the entire set of vertices.
初始化为整个顶点集。 

685
00:34:40,400 --> 00:34:43,110
And all this means is that, initially, we
而所有这些意味着，最初，我们

686
00:34:43,110 --> 00:34:44,420
haven't done any processing.
尚未进行任何处理。 

687
00:34:44,420 --> 00:34:49,230
And we don't know the shortest paths to any vertex
而且我们不知道通往任何顶点的最短路径

688
00:34:49,230 --> 00:34:52,860
because this set of vertices is null.
因为这组顶点为null。 

689
00:34:52,860 --> 00:34:56,309
And Q is the set of vertices that need to be processed.
 Q是需要处理的一组顶点。 

690
00:34:56,309 --> 00:34:59,559
And, as we start processing vertices from Q,
并且，当我们开始处理Q的顶点时， 

691
00:34:59,559 --> 00:35:01,960
we're going to move them to capital S.
我们将把它们移到首都S。 

692
00:35:01,960 --> 00:35:04,480
And they're going to contain the set of vertices
它们将包含一组顶点

693
00:35:04,480 --> 00:35:08,659
that we know the shortest paths to already.
我们已经知道最短的路径。 

694
00:35:08,659 --> 00:35:10,960
And that's the invariant in this algorithm.
这就是该算法的不变性。 

695
00:35:10,960 --> 00:35:13,422
s is going to contain the set of vertices
 s将包含一组顶点

696
00:35:13,422 --> 00:35:14,880
that we know the shortest paths to.
我们知道最短的路径。 

697
00:35:14,880 --> 00:35:17,440



698
00:35:17,440 --> 00:35:22,769
And so, Dijkstra is a little while loop
所以，Dijkstra有点循环

699
00:35:22,969 --> 00:35:24,739
that says, while they're vertices
也就是说，虽然它们是顶点

700
00:35:24,739 --> 00:35:32,299
that need to be processed, then I'm going to take u.
需要处理的东西，然后我带你去。 

701
00:35:32,300 --> 00:35:46,190
And I'm going to extract-min from Q.
我将从Q中提取分钟数。 

702
00:35:46,190 --> 00:35:54,409
And this is going to delete u from Q.
这将从Q中删除u。 

703
00:35:54,409 --> 00:35:58,429
And this initialization-- and this
这个初始化-还有这个

704
00:35:58,429 --> 00:36:05,239
is a small s here-- is going to set d of s to be 0.
在这里是小s-将s的d设置为0。 

705
00:36:05,239 --> 00:36:07,169
That's all this initialization does.
这就是初始化的全部工作。 

706
00:36:07,170 --> 00:36:08,730
Because that's all we know.
因为这就是我们所知道的。 

707
00:36:08,929 --> 00:36:10,333
We have a starting vertex.
我们有一个起始顶点。 

708
00:36:10,333 --> 00:36:12,750
And we know that the shortest path to the starting vertex,
我们知道到达起始顶点的最短路径

709
00:36:12,750 --> 00:36:15,239
from the starting vertex, is 0.
从起始顶点开始为0。 

710
00:36:15,239 --> 00:36:18,149
So, all that means is that, all of the other ones
所以，这意味着所有其他

711
00:36:18,150 --> 00:36:19,500
have infinity values.
具有无穷大值。 

712
00:36:19,699 --> 00:36:22,059
So, at this very first step, it makes sense
因此，在第一步中，这很有意义

713
00:36:22,059 --> 00:36:24,730
that extract-min Q is going to pull
提取最小Q将拉

714
00:36:24,730 --> 00:36:27,670
the starting vertex, small s, out.
起始顶点，小s，出。 

715
00:36:27,670 --> 00:36:31,659
And is going to assign it to this u value.
并将其分配给此u值。 

716
00:36:31,659 --> 00:36:35,039
And we're going to set s to be-- capital
我们将设置为-资本

717
00:36:35,039 --> 00:36:42,519
S-- to be capital S union u.
 S--成为资本S Union u。 

718
00:36:42,519 --> 00:36:49,349
And then, all we have to do is relax the edges from the vertex
然后，我们要做的就是放宽顶点的边缘

719
00:36:49,349 --> 00:36:50,639
that we just added.
我们刚刚添加的。 

720
00:36:50,639 --> 00:36:57,909
So, for each vertex, v belonging to adjacent
因此，对于每个顶点，v属于相邻的

721
00:36:57,909 --> 00:37:00,670
s, so that you can reach from u.
 s，以便您可以从u到达。 

722
00:37:00,670 --> 00:37:05,788
We relax u, v, w.
我们放松你，v，w。 

723
00:37:05,788 --> 00:37:08,476



724
00:37:08,476 --> 00:37:09,380
All right?
好吧？ 

725
00:37:09,380 --> 00:37:10,059
That's it.
而已。 

726
00:37:10,059 --> 00:37:10,916
That's Dijkstra.
那是迪克斯特拉。 

727
00:37:10,916 --> 00:37:14,690



728
00:37:14,889 --> 00:37:17,460
It's a greedy algorithm.
这是一个贪婪的算法。 

729
00:37:17,460 --> 00:37:18,929
It's iterative.
这是迭代的。 

730
00:37:18,929 --> 00:37:21,690
And the reason it's greedy is because of this step here.
贪婪的原因是因为这里的这一步。 

731
00:37:21,690 --> 00:37:25,590
It's just picking the min priority
只是选择最小优先级

732
00:37:25,590 --> 00:37:30,760
from the un-processed vertices, Q. And, essentially,
从未经处理的顶点Q 

733
00:37:30,760 --> 00:37:37,590
claiming that this min value is something that you already
声称这是您已经拥有的最小值

734
00:37:37,590 --> 00:37:39,960
computed the shortest paths for.
计算出最短路径。 

735
00:37:40,159 --> 00:37:42,799
So, when you're putting something into S,
因此，当您将某物放入S中时， 

736
00:37:42,800 --> 00:37:45,110
you're saying, I'm done.
你是说，我完成了。 

737
00:37:45,110 --> 00:37:48,019
I know the shortest path to this particular vertex.
我知道到达此特定顶点的最短路径。 

738
00:37:48,219 --> 00:37:51,579
And I need to now process it, in the sense that I
从某种意义上说，我现在需要对其进行处理

739
00:37:51,579 --> 00:37:55,250
have to relax the edges that are coming out of this vertex.
必须放松从该顶点出来的边缘。 

740
00:37:55,250 --> 00:37:58,610
And update the priority values because relax
并更新优先级值，因为放松

741
00:37:58,610 --> 00:38:02,780
is going to go change the d values, as we know,
我们将要更改d值， 

742
00:38:02,780 --> 00:38:07,280
corresponding to the vertex, v. It might change the value.
对应于顶点v。它可能会更改值。 

743
00:38:07,280 --> 00:38:08,110
It might not.
可能不会。 

744
00:38:08,309 --> 00:38:10,949
But there's a possibility that it would.
但是有可能会。 

745
00:38:10,949 --> 00:38:13,279
And you're going to do this for all of the edges
而您将为所有的边缘做到这一点

746
00:38:13,280 --> 00:38:15,737
that are emanating out of the vertex, u.
从顶点发出的

747
00:38:15,936 --> 00:38:18,269
And so you may be changing a bunch of different priority
因此，您可能会更改许多不同的优先级

748
00:38:18,269 --> 00:38:18,769
values.
价值观。 

749
00:38:18,769 --> 00:38:20,940
So the next time around, you will
所以下一次，你会

750
00:38:20,940 --> 00:38:27,269
get a different minimum priority vertex.
得到一个不同的最小优先级顶点。 

751
00:38:27,269 --> 00:38:27,969
For two reasons.
有两个原因。 

752
00:38:27,969 --> 00:38:31,049
One is that you've extracted out the minimum priority vertex.
一种是您已经提取了最小优先级顶点。 

753
00:38:31,050 --> 00:38:34,150
You've deleted it from Q. And the second reason
您已将其从Q中删除。第二个原因

754
00:38:34,150 --> 00:38:36,340
is that these priority values change
这些优先级值改变了吗

755
00:38:36,340 --> 00:38:38,000
as you go through the loop.
当您经历循环时。 

756
00:38:38,199 --> 00:38:39,109
All right?
好吧？ 

757
00:38:39,110 --> 00:38:41,960
And so, in our demo, essentially what happened was,
因此，在我们的演示中，本质上是

758
00:38:41,960 --> 00:38:46,119
the first time, the process of lifting the green vertex,
第一次，提升绿色顶点的过程， 

759
00:38:46,119 --> 00:38:49,219
corresponding to choosing it as a starting vertex.
对应于选择它作为起始顶点。 

760
00:38:49,219 --> 00:38:51,569
And the first thing that was closest
而最接近的第一件事

761
00:38:51,570 --> 00:38:55,550
to it, which had the taught string hanging from it,
上面悬挂着教taught的绳子， 

762
00:38:55,550 --> 00:38:57,173
has the min priority value.
具有最小优先级值。 

763
00:38:57,173 --> 00:38:58,090
And you pull that out.
然后你把它拔出来。 

764
00:38:58,090 --> 00:39:01,420
And then so on and so forth, as you go down.
然后下去，依此类推，下去。 

765
00:39:01,420 --> 00:39:04,445
And I'm not going to go through and prove this.
我不会去证明这一点。 

766
00:39:04,445 --> 00:39:06,570
But it's certainly something that is worth reading.
但这当然值得一读。 

767
00:39:06,570 --> 00:39:10,610
It's half of page proof, maybe a page in CLRS.
这是页面证明的一半，也许是CLRS中的页面。 

768
00:39:10,610 --> 00:39:12,480
And you should read the proof for Dijkstra,
您应该阅读Dijkstra的证明， 

769
00:39:12,480 --> 00:39:13,791
the formal proof for Dijkstra.
 Dijkstra的正式证明。 

770
00:39:13,791 --> 00:39:15,789
Which just, essentially, does all the accounting
本质上，所有会计工作

771
00:39:15,789 --> 00:39:16,940
and gets things right.
并把事情做好。 

772
00:39:16,940 --> 00:39:20,289
And uses the lemma that we have, with respect to the relaxation
并使用关于松弛的引理

773
00:39:20,289 --> 00:39:24,539
operation being safe.
操作安全。 

774
00:39:24,539 --> 00:39:25,369
OK?
好？ 

775
00:39:25,369 --> 00:39:26,769
Any questions about Dijkstra?
对Dijkstra有疑问吗？ 

776
00:39:26,769 --> 00:39:29,141
Or about the pseudocode, in particular?
还是关于伪代码？ 

777
00:39:29,141 --> 00:39:31,389
I guess you guys are going to code this at some point.
我想你们会在某个时候编写代码。 

778
00:39:31,389 --> 00:39:31,599
Yeah?
是啊

779
00:39:31,599 --> 00:39:33,349
AUDIENCE: How are the vertices comparable?
听众：顶点的可比性如何？ 

780
00:39:33,349 --> 00:39:34,250
In what way?
用什么方式？ 

781
00:39:34,250 --> 00:39:36,014
PROFESSOR: Oh, so that's a good question.
教授：哦，这是一个好问题。 

782
00:39:36,014 --> 00:39:37,514
And I should have made that clearer.
我应该更清楚地说明这一点。 

783
00:39:37,514 --> 00:39:40,809



784
00:39:40,809 --> 00:39:43,420
So, Q is a priority queue.
因此，Q是优先级队列。 

785
00:39:43,420 --> 00:39:47,840
And the priorities of the vertices are the d values, OK?
顶点的优先级是d值，好吗？ 

786
00:39:47,840 --> 00:39:52,690



787
00:39:52,889 --> 00:39:55,900
s being null is clear, I hope.
我希望可以将null清除。 

788
00:39:55,900 --> 00:39:56,920
That's clear.
很清楚

789
00:39:56,920 --> 00:39:59,579
And then Q being the set of vertices are clear, as well.
然后，作为顶点集合的Q也很清楚。 

790
00:39:59,579 --> 00:40:03,029
Now, Q is a priority queue, OK?
现在，Q是一个优先队列，好吗？ 

791
00:40:03,030 --> 00:40:06,530
And we'll talk about how we'll implement this priority
我们将讨论如何实现此优先级

792
00:40:06,530 --> 00:40:08,570
queue, and the complexity of Dijkstra,
排队以及Dijkstra的复杂性， 

793
00:40:08,570 --> 00:40:09,840
before we're done here.
在这里完成之前。 

794
00:40:09,840 --> 00:40:12,440
But, as an ADT, as an Abstract Data Type,
但是，作为ADT，作为抽象数据类型， 

795
00:40:12,440 --> 00:40:14,230
think of Q as being a priority queue.
认为Q是优先队列。 

796
00:40:14,230 --> 00:40:15,650
And there's priorities associated
还有优先事项

797
00:40:15,650 --> 00:40:19,650
with each vertex that's in Q. And these priorities change.
 Q中的每个顶点。这些优先级会改变。 

798
00:40:19,650 --> 00:40:21,010
And they're the d values.
它们是d值。 

799
00:40:21,210 --> 00:40:21,709
All right?
好吧？ 

800
00:40:21,710 --> 00:40:22,460
So the priorities.
因此优先考虑。 

801
00:40:22,460 --> 00:40:30,519



802
00:40:30,719 --> 00:40:34,859
So, initially, d of s-- small s-- is 0.
因此，最初，s的d（小s）为0。 

803
00:40:34,860 --> 00:40:37,280
And all of the other ones are infinity.
其他所有的都是无限的。 

804
00:40:37,280 --> 00:40:39,150
So it's clear that, the very first time, you're
很明显，第一次，你是

805
00:40:39,349 --> 00:40:42,589
going to set u to be small s, which is a starting vertex.
设置u为小s，这是一个起始顶点。 

806
00:40:42,590 --> 00:40:44,980
And then you relax the edges coming out of s,
然后放松从s出来的边缘， 

807
00:40:44,980 --> 00:40:47,889
potentially change some of these other infinity values
可能会更改其他一些无穷大值

808
00:40:47,889 --> 00:40:49,529
of the vertices that you can reach
您可以达到的顶点数

809
00:40:49,530 --> 00:40:51,650
from s to be less than infinity.
从s小于无穷大。 

810
00:40:51,849 --> 00:40:55,420
And you're going to, essentially,
从本质上讲，您将要

811
00:40:55,420 --> 00:40:58,579
change the values of the priority queue.
更改优先级队列的值。 

812
00:40:58,579 --> 00:40:59,186
And go around.
快走吧

813
00:40:59,186 --> 00:41:01,019
And then select the min value the next time.
然后下次选择最小值。 

814
00:41:01,019 --> 00:41:02,230
And so on and so forth.
等等等等。 

815
00:41:02,230 --> 00:41:03,860
OK?
好？ 

816
00:41:03,860 --> 00:41:04,860
Thanks for the question.
谢谢你的问题。 

817
00:41:04,860 --> 00:41:05,693
Any other questions?
还有其他问题吗？ 

818
00:41:05,693 --> 00:41:09,320



819
00:41:09,320 --> 00:41:10,300
OK.
好。 

820
00:41:10,300 --> 00:41:19,150
So, let's just go through a couple of steps in an example.
因此，在一个示例中，我们仅需完成几个步骤。 

821
00:41:19,349 --> 00:41:22,699
I'm not going to go through the whole thing.
我不会经历整个事情。 

822
00:41:22,699 --> 00:41:27,859
But you'll see an execution of Dijkstra in the nodes.
但是您会在节点中看到Dijkstra的执行。 

823
00:41:27,860 --> 00:41:30,789
I think it's worth spending just a couple of minutes going
我认为值得花几分钟的时间

824
00:41:30,789 --> 00:41:36,300
through the first few steps of a Dijkstra execution.
完成Dijkstra执行的前几个步骤。 

825
00:41:36,300 --> 00:41:45,340
Just so how this priority queue works is clear,
正因为如此，此优先级队列的工作方式很清楚， 

826
00:41:45,340 --> 00:41:48,539
let's take a look at a directed graph that has five vertices.
让我们看一下有五个顶点的有向图。 

827
00:41:48,739 --> 00:42:02,399



828
00:42:02,400 --> 00:42:03,110
So that's 7.
那就是7。 

829
00:42:03,110 --> 00:42:14,039



830
00:42:14,039 --> 00:42:18,759
So let's start with a being the starting vertex.
因此，让我们从成为起始顶点开始。 

831
00:42:18,760 --> 00:42:21,289
And so d of a is 0.
因此a的d为0。 

832
00:42:21,489 --> 00:42:26,189
And d of b through e are all infinity.
 b到e的d都是无穷大。 

833
00:42:26,190 --> 00:42:31,579
Your s is null to begin with.
您的s为null。 

834
00:42:31,579 --> 00:42:35,099
And Q has all of the five vertices in it.
 Q中包含所有五个顶点。 

835
00:42:35,099 --> 00:42:39,710



836
00:42:39,710 --> 00:42:43,721
So extract-min is going to select a.
因此，extract-min将选择a。 

837
00:42:43,721 --> 00:42:46,829
That's the only one that is a 0.
那是唯一一个为0的数字。 

838
00:42:46,829 --> 00:42:51,549
Because you've got 0, infinity, infinity, infinity, infinity.
因为您有0，所以无穷大，无穷大，无穷大，无穷大。 

839
00:42:51,550 --> 00:42:56,130
And so, you select that, and you set s to be a.
因此，您选择了它，并将s设置为a。 

840
00:42:56,130 --> 00:42:57,769
And once you set s to be a, you relax
一旦将设置为a，就可以放松

841
00:42:57,969 --> 00:42:59,639
the edges coming out of a.
边缘出来

842
00:42:59,639 --> 00:43:01,000
And there's two of them.
有两个。 

843
00:43:01,000 --> 00:43:07,010
So you end up with 0, 10, 3, infinity, infinity.
因此，您最终得到0、10、3，无穷大，无穷大。 

844
00:43:07,010 --> 00:43:10,210
And the next extract-min is going to select 3.
下一个提取分钟数将选择3。 

845
00:43:10,409 --> 00:43:14,819
And you're going to set s to be a comma c.
并且您将s设置为逗号c。 

846
00:43:14,820 --> 00:43:16,570
And so you're, essentially, doing
因此，从本质上讲，您正在做

847
00:43:16,570 --> 00:43:19,289
kind of a breadth-first search.
一种广度优先的搜索。 

848
00:43:19,289 --> 00:43:21,099
But you're being greedy.
但是你很贪心。 

849
00:43:21,099 --> 00:43:23,230
It's a mixed breadth-first depth-first search.
这是混合的广度优先深度优先的搜索。 

850
00:43:23,230 --> 00:43:24,730
You do a breadth-first search when
您何时进行广度优先搜索

851
00:43:24,730 --> 00:43:25,949
you're given a particular vertex,
给您一个特定的顶点， 

852
00:43:25,949 --> 00:43:27,407
and you look at all of the vertices
然后你看所有的顶点

853
00:43:27,407 --> 00:43:29,319
that you can reach from that vertex.
您可以从该顶点到达。 

854
00:43:29,320 --> 00:43:31,809
And then you say, I'm a greedy algorithm.
然后你说，我是一个贪婪的算法。 

855
00:43:31,809 --> 00:43:34,710
I'm going to pick the vertex in this frontier
我要在这个边界中选择顶点

856
00:43:34,710 --> 00:43:37,659
that I've just created, that is the shortest distance
我刚创建的那是最短的距离

857
00:43:37,659 --> 00:43:40,349
away from me, that has the lowest priority value.
远离我，那是最低优先级值。 

858
00:43:40,349 --> 00:43:43,029
And, in this case, it would be c because this other one is 10.
并且，在这种情况下，它将是c，因为另一个是10。 

859
00:43:43,030 --> 00:43:44,110
And this is shorter.
这更短。 

860
00:43:44,110 --> 00:43:44,610
Right?
对？ 

861
00:43:44,610 --> 00:43:46,690
So that's why we pick c over here.
这就是为什么我们在这里选择c。 

862
00:43:46,690 --> 00:43:48,619
And one last one.
最后一个。 

863
00:43:48,619 --> 00:43:52,940
Once you process c, you're going to end up
处理c之后，您将结束

864
00:43:52,940 --> 00:43:54,619
processing this edge going out here.
处理这个边缘在这里。 

865
00:43:54,619 --> 00:43:55,839
This edge going out there.
这个边缘在那里。 

866
00:43:55,840 --> 00:43:57,559
This edge going out this way.
这种优势以这种方式出现。 

867
00:43:57,559 --> 00:44:05,070
And you're going to end up with 0, 7, 3, 11, 5.
您将得到0、7、3、11、5。 

868
00:44:05,070 --> 00:44:08,280
And you've processed a bunch of edges coming out of c.
并且您已经处理了c产生的许多边缘。 

869
00:44:08,280 --> 00:44:11,730
And, at this point, 0 is gone and 3 is gone.
并且，此时，0消失了，3消失了。 

870
00:44:11,730 --> 00:44:13,309
I'm just writing the values here,
我只是在这里写值

871
00:44:13,309 --> 00:44:14,889
just so you know what they are.
以便您知道它们是什么。 

872
00:44:14,889 --> 00:44:17,670
But these are out of the picture because, in s, those values
但是这些都不在图片中，因为在s中，这些值

873
00:44:17,670 --> 00:44:18,920
should never change.
不应该改变。 

874
00:44:18,920 --> 00:44:21,500
Dijkstra essentially guarantees.
 Dijkstra本质上保证。 

875
00:44:21,500 --> 00:44:23,099
And that's the proof of correctness
这就是正确性的证明

876
00:44:23,099 --> 00:44:28,380
that takes a bit of doing, is that this value is never
需要花点时间做的是，这个值永远不会

877
00:44:28,380 --> 00:44:29,619
going to reduce anymore.
会减少。 

878
00:44:29,619 --> 00:44:31,809
The pre-value is never going to reduce.
预值永远不会减少。 

879
00:44:31,809 --> 00:44:33,710
And it's been put into s.
它已放入s。 

880
00:44:33,710 --> 00:44:35,800
But what's remaining now is 5.
但是现在剩下的是5。 

881
00:44:35,800 --> 00:44:39,090
And that corresponds to the e vertex.
并且对应于e顶点。 

882
00:44:39,090 --> 00:44:45,130
So s becomes a, c, e.
所以s变成a，c，e。 

883
00:44:45,130 --> 00:44:46,769
The 5 gets stuck in there.
 5个卡在那里。 

884
00:44:46,969 --> 00:44:48,579
And so on and so forth.
等等等等。 

885
00:44:48,579 --> 00:44:50,219
All right?
好吧？ 

886
00:44:50,219 --> 00:44:51,711
So, that's Dijkstra.
那就是Dijkstra。 

887
00:44:51,711 --> 00:44:53,045
And now, let's start complexity.
现在，让我们开始复杂性。 

888
00:44:53,045 --> 00:44:55,630



889
00:44:55,630 --> 00:44:58,440
So, it we have the code for Dijkstra on the left,
因此，左侧有Dijkstra的代码， 

890
00:44:58,639 --> 00:45:03,529
we have an ADT associated with the priority queue.
我们有一个与优先级队列关联的ADT。 

891
00:45:03,530 --> 00:45:06,550
And now, we're back to talking like we
现在，我们回到像我们这样说话

892
00:45:06,550 --> 00:45:11,210
did early on in the term, where we compared linked lists,
在学期初期比较链接列表， 

893
00:45:11,409 --> 00:45:15,170
and arrays, and heaps, and trees.
和数组，堆和树。 

894
00:45:15,170 --> 00:45:21,579
And said, for a particular set of operations,
并说，对于一组特定的操作， 

895
00:45:21,579 --> 00:45:24,019
which one is going to be the best?
哪一个最好？ 

896
00:45:24,019 --> 00:45:25,130
OK?
好？ 

897
00:45:25,130 --> 00:45:29,099
So, if you analyze Dijkstra, and you look at the pseudocode
因此，如果您分析Dijkstra，然后查看伪代码

898
00:45:29,099 --> 00:45:34,319
first, and you say, what are the operations that I'm performing?
首先，您说我正在执行什么操作？ 

899
00:45:34,320 --> 00:45:37,809



900
00:45:37,809 --> 00:45:43,440
I got an operation here, corresponding to theta v
我在这里做了一个操作，对应于theta v 

901
00:45:43,440 --> 00:45:47,670
inserts into the priority queue.
插入优先级队列。 

902
00:45:47,670 --> 00:45:53,760



903
00:45:53,760 --> 00:45:57,440
And that's inserting things into Q.
这就是在Q中插入东西。 

904
00:45:57,440 --> 00:46:02,860
I got theta v extract-min operations.
我得到了theta v extract-min操作。 

905
00:46:02,860 --> 00:46:08,289



906
00:46:08,289 --> 00:46:11,070
I'm only going to delete a vertex once, process of vertex
我只会删除一次顶点，顶点的过程

907
00:46:11,070 --> 00:46:11,960
once.
一旦。 

908
00:46:12,159 --> 00:46:15,779
And that's why I have theta v extract operations.
这就是为什么我要进行theta v提取操作。 

909
00:46:15,780 --> 00:46:22,840
And I have theta e, what decrease key or update
我有说什么，减少键或更新

910
00:46:22,840 --> 00:46:29,690
key operations because when I do, I relax here.
关键操作，因为当我这样做时，我会在这里放松。 

911
00:46:29,690 --> 00:46:32,019
I'm decreasing the key.
我正在减少钥匙。 

912
00:46:32,219 --> 00:46:34,718



913
00:46:34,719 --> 00:46:36,510
It's in particular, it's not an update key.
特别是，它不是更新密钥。 

914
00:46:36,510 --> 00:46:39,329
It happens to be a decrease key, which is not a big deal.
它恰好是一个减少键，这没什么大不了的。 

915
00:46:39,329 --> 00:46:40,420
We don't need to get into that.
我们不需要介入。 

916
00:46:40,619 --> 00:46:42,529
But you are reducing the d value.
但是您正在降低d值。 

917
00:46:42,530 --> 00:46:44,840
So it's a decrease key operation.
因此，这是一个减少键的操作。 

918
00:46:45,039 --> 00:46:51,295
And, again, it's theta e because, in a directed graph,
再说一次，这是因为在有向图中

919
00:46:51,295 --> 00:46:53,170
you're only going to process each edge that's
您只需要处理

920
00:46:53,170 --> 00:46:55,512
coming out of the vertex once.
从顶点出来一次。 

921
00:46:55,512 --> 00:46:57,019
Since you're processing each vertex once,
由于您一次处理每个顶点， 

922
00:46:57,219 --> 00:46:59,929
and you're looking at all of the outgoing edges
而且您正在查看所有向外的边缘

923
00:46:59,929 --> 00:47:01,469
from that vertex.
从那个顶点。 

924
00:47:01,469 --> 00:47:02,529
OK?
好？ 

925
00:47:02,530 --> 00:47:06,340
So that's what you can get looking at the pseudocode.
这就是您可以查看伪代码的地方。 

926
00:47:06,340 --> 00:47:09,230
And now, you're a data structure designer.
现在，您是数据结构设计师。 

927
00:47:09,230 --> 00:47:12,119
And you have some choices here, with respect
尊敬的您在这里有一些选择

928
00:47:12,119 --> 00:47:14,909
to actually implementing the priority queue.
实际实现优先级队列。 

929
00:47:14,909 --> 00:47:21,029
And let's look at the complexity of Dijkstra for arrays.
让我们看一下Dijkstra数组的复杂性。 

930
00:47:21,030 --> 00:47:25,420
So, suppose I ended up using an array
所以，假设我最终使用了一个数组

931
00:47:25,420 --> 00:47:28,039
structure for the priority queue.
优先级队列的结构。 

932
00:47:28,039 --> 00:47:31,800
But then, what do I have?
但是，那我有什么呢？ 

933
00:47:31,800 --> 00:47:37,570
I have, if I look at this, my extract-min, what
如果我看这个的话，我的提取物最小

934
00:47:37,570 --> 00:47:40,519
is the complexity of extract-min in an array?
数组中extract-min的复杂性是什么？ 

935
00:47:40,719 --> 00:47:41,539
AUDIENCE: Theta v.
听众：Theta v。 

936
00:47:41,539 --> 00:47:44,269
PROFESSOR: Theta v. And what's the complexity
教授：Theta v。复杂性是什么

937
00:47:44,269 --> 00:47:48,289
of a decrease key in an array?
数组中的减少键？ 

938
00:47:48,289 --> 00:47:50,210
I just go access that element.
我只是去访问那个元素。 

939
00:47:50,210 --> 00:47:51,599
And I change it.
我改变了。 

940
00:47:51,599 --> 00:47:53,139
State of one, right?
状态一，对不对？ 

941
00:47:53,139 --> 00:47:59,009
So I have theta v for extract-min.
所以我有theta v提取分钟。 

942
00:47:59,010 --> 00:48:00,610
I'll just call it ex-min.
我就叫它ex-min。 

943
00:48:00,809 --> 00:48:06,750
Theta one for decrease key.
减小键的Theta一。 

944
00:48:06,750 --> 00:48:09,889
And if I go do the multiplication,
如果我去做乘法， 

945
00:48:09,889 --> 00:48:17,289
I get theta v times v plus e times 1, or a constant,
我得到theta v乘以v加e乘以1或一个常数， 

946
00:48:17,289 --> 00:48:19,860
which is theta v squared.
是θv的平方。 

947
00:48:19,860 --> 00:48:23,260
Because I know that e is order v squared.
因为我知道e是v的平方。 

948
00:48:23,260 --> 00:48:23,760
Right?
对？ 

949
00:48:23,760 --> 00:48:26,900
If I have a simple graph, it may be a complete graph,
如果我有一个简单的图，它可能是一个完整的图， 

950
00:48:27,099 --> 00:48:29,460
but-- we talked about this last time.
但是-我们上一次谈到了这一点。 

951
00:48:29,460 --> 00:48:31,809
e is, at most, v squared.
 e最多为v的平方。 

952
00:48:31,809 --> 00:48:34,445
So I can just call this theta v squared.
所以我可以称这个θv平方。 

953
00:48:34,445 --> 00:48:35,340
All right?
好吧？ 

954
00:48:35,340 --> 00:48:39,000
So we have a theta v squared Dijkstra implementation
所以我们有一个theta v平方的Dijkstra实现

955
00:48:39,000 --> 00:48:42,012
that uses an array structure.
使用数组结构。 

956
00:48:42,012 --> 00:48:43,519
But do we want to use an array structure?
但是我们是否要使用数组结构？ 

957
00:48:43,719 --> 00:48:49,289
What data structure should we use?
我们应该使用什么数据结构？ 

958
00:48:49,289 --> 00:48:50,199
Yeah?
是啊

959
00:48:50,199 --> 00:48:50,828
AUDIENCE: Heap.
听众：堆。 

960
00:48:50,829 --> 00:48:52,170
PROFESSOR: You can use it a min-heap.
教授：您可以使用它的最小堆。 

961
00:48:52,369 --> 00:48:53,989
Exactly right.
非常正确。 

962
00:48:53,989 --> 00:49:00,839
So, if you use a binary min-heap,
因此，如果您使用二进制最小堆， 

963
00:49:00,840 --> 00:49:16,829
then my extract-min is finding the min is a constant
那么我的min-min就发现min是一个常数

964
00:49:16,829 --> 00:49:18,909
because you just pick it up from the top.
因为您只是从顶部拾起它。 

965
00:49:18,909 --> 00:49:22,769
But we know that, if you want to update the heap,
但是我们知道，如果您要更新堆， 

966
00:49:22,769 --> 00:49:28,219
and delete it, then it's going to take that theta log v.
并删除它，那么它将使用theta log v。 

967
00:49:28,219 --> 00:49:31,459
And decrease key is the same thing.
和减少键是同一回事。 

968
00:49:31,460 --> 00:49:35,135
Theta log v. So that's worse than array.
 Theta log v。因此，这比数组还糟。 

969
00:49:35,335 --> 00:49:37,879



970
00:49:37,880 --> 00:49:40,000
And if I go do the multiplication again,
如果我再去做乘法， 

971
00:49:40,000 --> 00:49:45,920
I get v log v plus e log v. OK?
我得到v log v加e log v。好吗？ 

972
00:49:45,920 --> 00:49:49,590
And this is not quite the complexity that I put up,
这并不是我所说的复杂性， 

973
00:49:49,590 --> 00:49:54,329
as some of you may remember, last time.
你们中有些人可能记得，上次

974
00:49:54,329 --> 00:49:57,789
This is not the optimum complexity of Dijkstra.
这不是Dijkstra的最佳复杂性。 

975
00:49:57,789 --> 00:50:01,279
Or an optimal complexity of Dijkstra.
或Dijkstra的最佳复杂度。 

976
00:50:01,280 --> 00:50:05,800
You can actually take this out by using a data structure that
实际上，您可以使用一个

977
00:50:05,800 --> 00:50:08,460
we won't talk about in 006.
我们不会在006中谈论。 

978
00:50:08,460 --> 00:50:11,190
But you can read about it.
但是您可以阅读。 

979
00:50:11,190 --> 00:50:15,659
It's not 6006 level material.
这不是6006级材料。 

980
00:50:15,659 --> 00:50:18,409
You're not responsible for this in 006.
您在006中对此不承担任何责任。 

981
00:50:18,409 --> 00:50:20,480
But it's got a Fibonacci heap.
但是有斐波那契堆。 

982
00:50:20,480 --> 00:50:22,780
And you might learn about it in 6046.
您可能会在6046年了解它。 

983
00:50:22,780 --> 00:50:27,440
The Fibonacci heap is an amortized data structure
 Fibonacci堆是分期摊销的数据结构

984
00:50:27,440 --> 00:50:31,980
that has theta log v for extract-min.
的theta log v为extract-min。 

985
00:50:31,980 --> 00:50:43,090
And theta one amortized time for decrease key.
并为减少密钥分摊一次时间。 

986
00:50:43,090 --> 00:50:44,690
And what's nice about it is that,
这样做的好处是， 

987
00:50:44,889 --> 00:50:52,319
once you do that, you end up with theta v log v plus e time.
一旦这样做，您最终将获得theta v log v加上e时间。 

988
00:50:52,320 --> 00:50:56,650
And that's the complexity I put up way back, I guess,
我想这就是我提出的复杂性， 

989
00:50:56,849 --> 00:50:59,610
last Thursday.
上周四。 

990
00:50:59,610 --> 00:51:04,000
So that's to show you, with respect to two special cases,
因此，这是针对两个特殊情况向您展示， 

991
00:51:04,000 --> 00:51:08,929
we have the DAGs, which are linear time, essentially.
我们有DAG，基本上是线性时间。 

992
00:51:08,929 --> 00:51:13,419
And Dijkstra, with amortized, and their proper data
还有Dijkstra（摊销后的费用）及其适当的数据

993
00:51:13,420 --> 00:51:16,101
structure, also, essentially, linear time.
结构，基本上也是线性时间。 

994
00:51:16,101 --> 00:51:16,599
Right?
对？ 

995
00:51:16,599 --> 00:51:18,307
Next time, we'll look at the general case
下次，我们将看一般情况

996
00:51:18,307 --> 00:51:20,550
where we have potentially negative cycles.
我们有潜在的负周期。 

997
00:51:20,550 --> 00:51:24,070
And we end up with algorithms that have greater complexity.
最后，我们得出了具有更高复杂性的算法。 

998
00:51:24,070 --> 00:51:29,070
See you next time.
下次见。 

