1
00:00:00,000 --> 00:00:00,070



2
00:00:00,070 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
B support will help MIT OpenCourseWare continue
 B支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,208
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,208 --> 00:00:17,833
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,833 --> 00:00:21,140



10
00:00:21,140 --> 00:00:23,389
VICTOR COSTAN: Any questions about the sorting methods
 VICTOR COSTAN：有关排序方法的任何问题

11
00:00:23,390 --> 00:00:27,570
that you want me to go over in that while I revise?
在我修改的同时，您要我过去吗？ 

12
00:00:27,570 --> 00:00:32,439



13
00:00:32,439 --> 00:00:34,743
OK.
好。 

14
00:00:34,743 --> 00:00:35,534
All right, sorting.
好吧，排序。 

15
00:00:35,534 --> 00:00:40,519



16
00:00:40,520 --> 00:00:44,030
What sorting methods have we learned?
我们学到了什么分类方法？ 

17
00:00:44,030 --> 00:00:46,395
Let's start from dumbest to smartest.
让我们从最笨拙到最聪明。 

18
00:00:46,395 --> 00:00:47,700
AUDIENCE: Merge sorting.
听众：合并排序。 

19
00:00:47,700 --> 00:00:50,349
VICTOR COSTAN: OK, somewhere in the middle.
维克多·科斯坦：好的，在中间的某个地方。 

20
00:00:50,549 --> 00:00:52,019
Merge sort isn't very bad.
合并排序不是很糟糕。 

21
00:00:52,020 --> 00:00:54,401
What's the easiest method to sort?
最简单的排序方法是什么？ 

22
00:00:54,401 --> 00:00:55,234
AUDIENCE: Insertion.
听众：插入。 

23
00:00:55,234 --> 00:00:57,919



24
00:00:58,119 --> 00:00:59,369
VICTOR COSTAN: Insertion sort.
 VICTOR COSTAN：插入排序。 

25
00:00:59,369 --> 00:01:00,369
Excellent.
优秀的。 

26
00:01:00,369 --> 00:01:00,929
All right.
好吧。 

27
00:01:00,929 --> 00:01:01,520
What else?
还有什么？ 

28
00:01:01,520 --> 00:01:06,730



29
00:01:06,730 --> 00:01:07,230
Heapsort.
堆排序。 

30
00:01:07,230 --> 00:01:10,869



31
00:01:11,069 --> 00:01:11,619
And?
和？ 

32
00:01:11,620 --> 00:01:14,239
I gave two away now.
我现在送了两个。 

33
00:01:14,239 --> 00:01:15,030
AUDIENCE: Counting.
听众：数数。 

34
00:01:15,030 --> 00:01:17,772



35
00:01:17,772 --> 00:01:18,980
VICTOR COSTAN: Counting sort.
维克多·科斯坦：计数排序。 

36
00:01:18,980 --> 00:01:20,189
Very good.
很好。 

37
00:01:20,189 --> 00:01:20,689
And?
和？ 

38
00:01:20,689 --> 00:01:25,799



39
00:01:25,799 --> 00:01:26,299
Oh, wow.
哦，哇

40
00:01:26,299 --> 00:01:29,129
If you don't even have the name of it.
如果您甚至没有名字。 

41
00:01:29,129 --> 00:01:32,119
So the last one is radix sort.
所以最后一个是基数排序。 

42
00:01:32,120 --> 00:01:35,319
What are the running times for these three
这三个的运行时间是多少

43
00:01:35,519 --> 00:01:36,554
that you guys remember?
你们还记得吗？ 

44
00:01:36,555 --> 00:01:40,191



45
00:01:40,191 --> 00:01:44,530
AUDIENCE: Insertion sort is linearly one more.
听众：插入排序线性地又一。 

46
00:01:44,530 --> 00:01:45,030
It's bad.
这不好。 

47
00:01:45,030 --> 00:01:47,695
VICTOR COSTAN: I want to see our pseudocode for insertion sorts.
维克托·科斯坦（VICTOR COSTAN）：我想看看我们的用于插入排序的伪代码。 

48
00:01:47,695 --> 00:01:49,914
AUDIENCE: n squared.
听众：n平方。 

49
00:01:49,915 --> 00:01:52,390
AUDIENCE: Now that's really bad.
听众：现在真的很糟糕。 

50
00:01:52,390 --> 00:01:55,430
VICTOR COSTAN: So linear is as good as you could possibly get.
维克多·科斯坦（VICTOR COSTAN）：线性尽可能好。 

51
00:01:55,430 --> 00:01:58,569
So sorting takes an array of random stuff
因此排序需要一系列随机的东西

52
00:01:58,769 --> 00:02:01,509
and outputs an array of things in a sorted order.
并按排序的顺序输出一组事物。 

53
00:02:01,510 --> 00:02:05,170
The array is size n, so it has to output an array of size n.
该数组的大小为n，因此必须输出大小为n的数组。 

54
00:02:05,170 --> 00:02:07,680
If you can do an algorithm that runs in order n time,
如果您可以执行按n次运行的算法， 

55
00:02:07,680 --> 00:02:09,979
then that's the best you could possibly accomplish,
那就是你可能完成的最好的事情， 

56
00:02:09,979 --> 00:02:12,340
because you have output n elements.
因为您有输出n个元素。 

57
00:02:12,340 --> 00:02:14,789
So the best possible time you could get for sorting
因此，您可以获得最佳的排序时间

58
00:02:14,789 --> 00:02:17,069
is theta of n.
是n的theta。 

59
00:02:17,069 --> 00:02:17,569
All right.
好吧。 

60
00:02:17,569 --> 00:02:18,572
How about merge sort?
合并排序如何？ 

61
00:02:18,573 --> 00:02:21,350



62
00:02:21,350 --> 00:02:22,549
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

63
00:02:22,549 --> 00:02:23,590
VICTOR COSTAN: Thank you.
维克多·科斯坦：谢谢。 

64
00:02:23,590 --> 00:02:26,259



65
00:02:26,259 --> 00:02:28,170
Heapsort.
堆排序。 

66
00:02:28,170 --> 00:02:30,506
AUDIENCE: Order h.
听众：订单h。 

67
00:02:30,506 --> 00:02:32,849
Order h is log n.
顺序h是对数n。 

68
00:02:32,849 --> 00:02:34,680
VICTOR COSTAN: Order h where h is log n.
维克多·波士坦（VICTOR COSTAN）：订购h，其中h为log n。 

69
00:02:34,680 --> 00:02:35,340
OK.
好。 

70
00:02:35,340 --> 00:02:37,900
And you're missing a factor.
而且您缺少一个因素。 

71
00:02:37,900 --> 00:02:41,300
So a heap operation takes order h, which is log n.
因此，堆操作的顺序为h，即日志n。 

72
00:02:41,300 --> 00:02:43,340
So if I have to insert a numbering in a heap
因此，如果我必须在堆中插入编号

73
00:02:43,539 --> 00:02:46,750
or extract a number from a heap, that's log n.
或从堆中提取一个数字，即为log n。 

74
00:02:46,750 --> 00:02:51,764
In order to start an array, how many insertions do I do?
为了开始一个数组，我要插入多少个？ 

75
00:02:51,764 --> 00:02:54,139
AUDIENCE: I think-- now I don't know.
听众：我想-现在我不知道。 

76
00:02:54,139 --> 00:02:55,089
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

77
00:02:55,090 --> 00:02:56,580
Wild guess.
胡乱猜测。 

78
00:02:56,580 --> 00:02:57,189
AUDIENCE: n.
听众： 

79
00:02:57,389 --> 00:02:58,609
VICTOR COSTAN: Very good.
 VICTOR COSTAN：很好。 

80
00:02:58,610 --> 00:03:00,560
See, there you go.
看，你去。 

81
00:03:00,560 --> 00:03:04,240
So you need to insert all your numbers in a heap
因此，您需要将所有数字插入到堆中

82
00:03:04,240 --> 00:03:05,740
and then extract them one by one.
然后一一提取。 

83
00:03:05,740 --> 00:03:07,750
And you will get them in the correct order
您将以正确的顺序获得它们

84
00:03:07,750 --> 00:03:09,360
that gives you the sorted results.
给您排序的结果。 

85
00:03:09,360 --> 00:03:12,240
So n log n.
所以n log n。 

86
00:03:12,439 --> 00:03:16,240
Does anyone remember what's special about these three
有谁记得这三个有什么特别之处

87
00:03:16,240 --> 00:03:19,427
sorting methods that does not apply to the other two?
排序方法不适用于其他两个吗？ 

88
00:03:19,627 --> 00:03:23,941
AUDIENCE: They're in place.
听众：他们到位了。 

89
00:03:23,942 --> 00:03:25,900
VICTOR COSTAN: Merge sort isn't quite in place.
维克多·科斯坦（VICTOR COSTAN）：合并排序还不够。 

90
00:03:25,900 --> 00:03:29,000
If it would be in place, it would be perfect.
如果到位，那将是完美的。 

91
00:03:29,000 --> 00:03:32,259
There is actually a way of making in place merge sort,
实际上，有一种方法可以进行合并排序， 

92
00:03:32,259 --> 00:03:35,819
but it requires a PhD degree to understand that.
但是需要博士学位才​​能理解。 

93
00:03:35,819 --> 00:03:40,120
So we will not cover it in 6006, because I do not understand it.
所以我们不会在6006中进行介绍，因为我不理解。 

94
00:03:40,120 --> 00:03:42,030
So I couldn't explain it.
所以我无法解释。 

95
00:03:42,229 --> 00:03:44,119
So merge sort is not quite in place.
因此，合并排序并不十分到位。 

96
00:03:44,120 --> 00:03:45,439
Which one is in place?
哪一个到位？ 

97
00:03:45,639 --> 00:03:49,950



98
00:03:49,950 --> 00:03:51,336
AUDIENCE: Heapsort.
听众：Heapsort。 

99
00:03:51,336 --> 00:03:52,169
VICTOR COSTAN: Good.
维克多·科斯坦：好。 

100
00:03:52,169 --> 00:03:54,209
So heapsort is in place.
这样堆排序就位了。 

101
00:03:54,210 --> 00:03:56,000
Merge sort is not in place.
合并排序不到位。 

102
00:03:56,000 --> 00:03:58,889
And insertion sort is really slow,
而且插入排序真的很慢， 

103
00:03:58,889 --> 00:04:00,799
so we don't care that much about it.
所以我们不在乎。 

104
00:04:00,800 --> 00:04:04,080
So what's special about these three
那这三个有什么特别之处

105
00:04:04,080 --> 00:04:05,550
that does not apply to these two?
那不适用于这两个？ 

106
00:04:05,550 --> 00:04:11,000



107
00:04:11,199 --> 00:04:13,319
AUDIENCE: You don't have to use integers.
听众：您不必使用整数。 

108
00:04:13,319 --> 00:04:14,069
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

109
00:04:14,069 --> 00:04:15,719
You don't have to use integers.
您不必使用整数。 

110
00:04:15,719 --> 00:04:17,519
What do they want to know instead
他们想知道些什么

111
00:04:17,519 --> 00:04:19,149
about the things you use?
关于你用的东西？ 

112
00:04:19,149 --> 00:04:20,302
So we'll call them keys.
所以我们称它们为钥匙。 

113
00:04:20,302 --> 00:04:22,218
AUDIENCE: You need to be able to compare them.
听众：您需要能够比较它们。 

114
00:04:22,218 --> 00:04:22,673
VICTOR COSTAN: All right.
维克多·科斯坦：好的。 

115
00:04:22,673 --> 00:04:24,728
AUDIENCE: You don't need to have a minimum
听众：您不需要最低要求

116
00:04:24,728 --> 00:04:27,805
and a maximum integer.
和最大整数。 

117
00:04:27,805 --> 00:04:30,430
VICTOR COSTAN: So turns out, if you have a comparison operator,
 VICTOR COSTAN：事实证明，如果您有比较运算符， 

118
00:04:30,430 --> 00:04:32,720
you will have a minimum and a maximum.
您将有一个最小值和最大值。 

119
00:04:32,720 --> 00:04:34,930
But that's complex abstract algebra
但这是复杂的抽象代数

120
00:04:35,129 --> 00:04:37,230
that we don't need to worry about.
我们不必担心。 

121
00:04:37,230 --> 00:04:39,060
So you gave me the good answer, which
所以你给了我很好的答案， 

122
00:04:39,060 --> 00:04:42,915
is we use something called a comparison model.
我们使用一种称为比较模型的东西吗？ 

123
00:04:42,915 --> 00:04:45,870



124
00:04:45,870 --> 00:04:47,970
And in that model, you do not need
在这种模式下，您不需要

125
00:04:47,970 --> 00:04:49,610
to know too much about your keys.
对您的钥匙了解太多。 

126
00:04:49,610 --> 00:04:52,639
So the elements in the area that you're sorting.
因此，您要排序的区域中的元素。 

127
00:04:52,639 --> 00:04:54,000
Your keys are blobs.
您的密钥是斑点。 

128
00:04:54,000 --> 00:04:55,750
And all they have to be able to do
他们必须要做的一切

129
00:04:55,750 --> 00:04:57,379
is know-- if you have two of them--
知道-如果您有两个- 

130
00:04:57,379 --> 00:05:01,670
you have to know which one's greater.
您必须知道哪个更大。 

131
00:05:01,670 --> 00:05:02,189
That's it.
而已。 

132
00:05:02,189 --> 00:05:03,819
Nothing else.
没有其他的。 

133
00:05:03,819 --> 00:05:05,719
What's the problem with the comparison model?
比较模型有什么问题？ 

134
00:05:05,720 --> 00:05:09,024



135
00:05:09,024 --> 00:05:11,384
AUDIENCE: It takes time to compare things.
听众：比较事物需要时间。 

136
00:05:11,384 --> 00:05:12,800
It's like with everything.
就像一切。 

137
00:05:12,800 --> 00:05:13,432
VICTOR COSTAN: Yeah.
维克多·科斯坦：是的。 

138
00:05:13,632 --> 00:05:16,192



139
00:05:16,192 --> 00:05:17,449
So we learned in lecture that there
所以我们在讲座中得知

140
00:05:17,649 --> 00:05:20,259
is a lower bound for the comparison model.
是比较模型的下限。 

141
00:05:20,259 --> 00:05:23,719
And if you want to sort using nothing but this information,
如果您只想使用此信息进行排序， 

142
00:05:23,720 --> 00:05:28,680
that will take you at least n log n time.
这将至少花费n log n次。 

143
00:05:28,680 --> 00:05:31,310
You cannot do better than n log n if all you're using is
如果您正在使用的是

144
00:05:31,310 --> 00:05:33,019
comparisons.
比较。 

145
00:05:33,019 --> 00:05:37,259
So in that respect, merge sort and heap sort are optimal.
因此，在这方面，合并排序和堆排序是最佳的。 

146
00:05:37,259 --> 00:05:39,170
If you want to stay within this model,
如果您想保持这种模式， 

147
00:05:39,170 --> 00:05:42,290
this is the best time you're going to get.
这是您将获得的最佳时间。 

148
00:05:42,290 --> 00:05:46,670
Does anyone know how you can implement this comparison model
有人知道您如何实现此比较模型

149
00:05:46,670 --> 00:05:47,730
in Python?
在Python中？ 

150
00:05:47,730 --> 00:05:51,189
So numbers respond to these operators, right?
数字对这些运算符有反应，对吗？ 

151
00:05:51,189 --> 00:05:54,019
Actually, in Python this is equals equals.
实际上，在Python中，它等于equals。 

152
00:05:54,019 --> 00:05:56,079
What if I have a random object and I
如果我有一个随机物体并且我该怎么办

153
00:05:56,079 --> 00:05:58,629
want to make it respond to these operators?
想使其对这些运营商做出反应？ 

154
00:05:58,629 --> 00:06:00,370
So for example, I write merge sort.
因此，例如，我编写合并排序。 

155
00:06:00,370 --> 00:06:01,639
We wrote merge sort.
我们写了合并排序。 

156
00:06:01,839 --> 00:06:03,951
And now I have my own objects, my own keys
现在我有了自己的对象，自己的钥匙

157
00:06:03,951 --> 00:06:05,410
which are not necessarily integers,
不一定是整数， 

158
00:06:05,410 --> 00:06:07,004
because that's why we like this.
因为这就是为什么我们喜欢这个。 

159
00:06:07,004 --> 00:06:09,170
And we want to make them respond to these operators.
我们想让他们对这些运营商做出回应。 

160
00:06:09,170 --> 00:06:11,490
So I can call merge sort on an array of them
所以我可以对它们的数组调用归并排序

161
00:06:11,490 --> 00:06:13,240
and it will crash.
它将崩溃。 

162
00:06:13,240 --> 00:06:15,841
What do I have to do?
我需要做什么？ 

163
00:06:16,041 --> 00:06:18,431
AUDIENCE: I mean, you have to give the keys
听众：我的意思是，你必须给钥匙

164
00:06:18,432 --> 00:06:21,300
values that can be compared.
可以比较的值。 

165
00:06:21,300 --> 00:06:23,430
VICTOR COSTAN: So suppose this is my key class.
维克多·科斯坦：所以假设这是我的重点课。 

166
00:06:23,430 --> 00:06:27,254



167
00:06:27,254 --> 00:06:31,119
AUDIENCE: This is lad, the lt, and gt.
听众：这是小伙子，lt和gt。 

168
00:06:31,119 --> 00:06:32,160
VICTOR COSTAN: All right.
维克多·科斯坦：好的。 

169
00:06:32,160 --> 00:06:34,360
There's a magical method in Python.
 Python中有一个神奇的方法。 

170
00:06:34,360 --> 00:06:36,410
So there is the old school model,
所以有旧式的模式

171
00:06:36,410 --> 00:06:41,480
which you might see in legacy code, which only works
您可能会在旧版代码中看到的

172
00:06:41,480 --> 00:06:45,000
in Python 2.x, which is you define the method called
在Python 2.x中，您可以定义称为

173
00:06:45,000 --> 00:06:52,480
cmp that takes self and other.
需要自我和其他的cmp。 

174
00:06:52,480 --> 00:06:54,699
And it has to return a number that's
它必须返回一个数字

175
00:06:54,899 --> 00:06:58,779
either smaller than zero, equal to zero, or greater than zero.
小于零，等于零或大于零。 

176
00:06:58,779 --> 00:07:01,659
And this maps to this.
这映射到此。 

177
00:07:01,660 --> 00:07:04,389



178
00:07:04,589 --> 00:07:06,129
So you'll see this in old code.
因此，您将在旧代码中看到这一点。 

179
00:07:06,129 --> 00:07:08,339
But you shouldn't use it in new code.
但是您不应该在新代码中使用它。 

180
00:07:08,339 --> 00:07:10,939
On this, you have a very good reason to.
因此，您有很好的理由。 

181
00:07:10,939 --> 00:07:14,019
Instead, the new model says that you
相反，新模型会说

182
00:07:14,019 --> 00:07:21,479
define special methods called lt, which stands for less than.
定义称为lt的特殊方法，它代表小于。 

183
00:07:21,480 --> 00:07:22,470
So it's this guy.
所以就是这个人。 

184
00:07:22,470 --> 00:07:24,980



185
00:07:24,980 --> 00:07:30,100
le, which is less or equal.
 le，小于或等于。 

186
00:07:30,100 --> 00:07:31,800
gt, which is greater than.
 gt，大于。 

187
00:07:31,800 --> 00:07:34,935
And ge, which is greater or equal.
与ge相等或更大。 

188
00:07:34,935 --> 00:07:37,629



189
00:07:37,629 --> 00:07:40,740
And if you look at our code for pieces two and three,
如果您看一下第二和第三部分的代码， 

190
00:07:40,740 --> 00:07:43,639
we have some objects that pretend they're keys.
我们有一些假装它们是钥匙的物体。 

191
00:07:43,639 --> 00:07:47,779
And we have to define these methods.
而且我们必须定义这些方法。 

192
00:07:47,779 --> 00:07:49,459
Also, when you define these, it's
另外，当您定义这些时， 

193
00:07:49,459 --> 00:07:56,419
a good idea to define eq for equality comparison.
为相等比较定义等式的好主意。 

194
00:07:56,420 --> 00:08:01,250
And ne, which is this guy.
 ne，这是那个家伙。 

195
00:08:01,250 --> 00:08:06,620
So these also take self and other key
因此这些也需要自我和其他关键

196
00:08:06,620 --> 00:08:08,790
that you're comparing with.
与您进行比较

197
00:08:08,790 --> 00:08:10,370
And they return true or false.
并且它们返回true或false。 

198
00:08:10,370 --> 00:08:13,439



199
00:08:13,439 --> 00:08:16,930
So this will help you understand the code better.
因此，这将帮助您更好地理解代码。 

200
00:08:16,930 --> 00:08:18,680
All right, so with relatively little work,
好吧，所以工作比较少， 

201
00:08:18,680 --> 00:08:23,449
you can have any wild object you want act as a key.
您可以让任何想要用作键的野生对象。 

202
00:08:23,449 --> 00:08:25,949
And then you have insertion sort,
然后您有插入排序， 

203
00:08:25,949 --> 00:08:31,050
merge sort, heapsort, heaps, binary trees, AVLs.
合并排序，堆排序，堆，二叉树，AVL。 

204
00:08:31,050 --> 00:08:34,019
Everything works, because everything uses the comparison
一切正常，因为一切都使用比较

205
00:08:34,019 --> 00:08:35,189
model.
模型。 

206
00:08:35,190 --> 00:08:37,600
The problem is this n log n bound.
问题是此n log n绑定。 

207
00:08:37,600 --> 00:08:40,200



208
00:08:40,200 --> 00:08:43,689
It's not as fast as the best possible sorting algorithm
它没有最好的排序算法快

209
00:08:43,889 --> 00:08:45,409
you could come up with.
你可以想出。 

210
00:08:45,409 --> 00:08:47,549
This is slower than this.
这比这慢。 

211
00:08:47,549 --> 00:08:50,250
So that's why we have to break out of the comparison model.
这就是为什么我们必须突破比较模型。 

212
00:08:50,250 --> 00:08:55,000
And we have to look into these boxes and get more information,
我们必须调查这些框并获取更多信息， 

213
00:08:55,000 --> 00:08:58,200
so that we can write faster sorting algorithms.
这样我们就可以编写更快的排序算法。 

214
00:08:58,200 --> 00:09:02,677
Does anyone remember the running time for counting sort?
有人记得计数时间吗？ 

215
00:09:02,677 --> 00:09:04,580
AUDIENCE: [INAUDIBLE] again?
听众：再次[听不清]？ 

216
00:09:04,580 --> 00:09:05,330
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

217
00:09:05,330 --> 00:09:09,524



218
00:09:09,524 --> 00:09:10,649
AUDIENCE: n plus e.
听众：n加e。 

219
00:09:10,649 --> 00:09:11,399
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

220
00:09:11,399 --> 00:09:15,720



221
00:09:15,720 --> 00:09:18,589
Let's remember how counting sort looks like.
让我们记住计数排序是什么样的。 

222
00:09:18,789 --> 00:09:27,709
Let's get this array that-- that should be enough-- four, one,
让我们得到这个数组-应该足够了-四个，一个， 

223
00:09:27,710 --> 00:09:30,970
three, two, three.
三二三

224
00:09:30,970 --> 00:09:32,979
How do we sort it using counting sort?
我们如何使用计数排序对其进行排序？ 

225
00:09:33,179 --> 00:09:38,079



226
00:09:38,080 --> 00:09:43,728
AUDIENCE: We initialize an array of all the possible values.
听众：我们初始化所有可能值的数组。 

227
00:09:43,928 --> 00:09:44,970
VICTOR COSTAN: Very good.
 VICTOR COSTAN：很好。 

228
00:09:44,970 --> 00:09:45,850
Very good.
很好。 

229
00:09:45,850 --> 00:09:48,370
So counting sort needs to know something about your values,
因此，计算排序需要了解您的价值观， 

230
00:09:48,370 --> 00:09:48,870
right?
对？ 

231
00:09:48,870 --> 00:09:49,870
It makes an assumption.
它做一个假设。 

232
00:09:49,870 --> 00:09:51,629
And the assumption is that these values
假设这些值

233
00:09:51,629 --> 00:09:57,169
are integers from 0 to, say, k minus 1.
是从0到k减去1的整数。 

234
00:09:57,169 --> 00:10:00,339
So you have k possible values.
因此，您有k个可能的值。 

235
00:10:00,340 --> 00:10:02,379
And they don't really have to be these as long
他们真的不需要那么久

236
00:10:02,379 --> 00:10:05,639
as you can map them to these numbers.
因为您可以将它们映射到这些数字。 

237
00:10:05,639 --> 00:10:10,090
So we are going to initialize an array.
因此，我们将初始化一个数组。 

238
00:10:10,090 --> 00:10:14,960
Let's say this is an array.
假设这是一个数组。 

239
00:10:14,960 --> 00:10:16,759
And zero, one.
零，一。 

240
00:10:16,759 --> 00:10:20,500
So zero, one, two, three, four, five.
所以零，一，二，三，四，五。 

241
00:10:20,500 --> 00:10:23,460



242
00:10:23,460 --> 00:10:26,090
So we're going to initialize it with--
因此，我们将使用- 

243
00:10:26,090 --> 00:10:27,440
AUDIENCE: Oh, zeroes.
听众：哦，零。 

244
00:10:27,440 --> 00:10:28,280
VICTOR COSTAN: All right.
维克多·科斯坦：好的。 

245
00:10:28,480 --> 00:10:31,019



246
00:10:31,019 --> 00:10:31,990
And then?
接着？ 

247
00:10:31,990 --> 00:10:37,379
AUDIENCE: Iterative over our list sort
观众：遍历我们的清单排序

248
00:10:37,379 --> 00:10:44,620
incrementing the corresponding value to each key in your--
将相应的值递增到您的- 

249
00:10:44,620 --> 00:10:46,889
VICTOR COSTAN: So which one am I incrementing here?
维克多·科斯坦：那我要增加哪一个？ 

250
00:10:46,889 --> 00:10:47,360
AUDIENCE: Pardon?
听众：对不起？ 

251
00:10:47,360 --> 00:10:48,789
VICTOR COSTAN: Which one am I incrementing here?
维克多·科斯坦：我要在这里增加哪一位？ 

252
00:10:48,789 --> 00:10:50,081
AUDIENCE: Zero ne through four.
听众：零到四之间。 

253
00:10:50,081 --> 00:10:53,450



254
00:10:53,450 --> 00:10:53,950
One.
一。 

255
00:10:53,950 --> 00:10:56,740



256
00:10:56,740 --> 00:10:59,799
VICTOR COSTAN: Three, two.
维克多·科斯坦：三，二。 

257
00:10:59,799 --> 00:11:00,697
And then?
接着？ 

258
00:11:00,697 --> 00:11:02,039
AUDIENCE: Three n.
听众：三名。 

259
00:11:02,039 --> 00:11:03,969
So this becomes a two.
这样就变成了两个。 

260
00:11:03,970 --> 00:11:06,629



261
00:11:06,629 --> 00:11:09,379
And what do I do now?
我现在该怎么办？ 

262
00:11:09,379 --> 00:11:14,481
AUDIENCE: Reiterate over that-- I don't know.
听众：重申一下-我不知道。 

263
00:11:14,481 --> 00:11:16,939
I don't know what to call that identity [INAUDIBLE] almost?
我几乎不知道该身份是什么[听不清]？ 

264
00:11:16,940 --> 00:11:20,069
OK, an array.
好，一个数组。 

265
00:11:20,269 --> 00:11:27,509
Printing into your output array one one, one two, two threes,
一一，一二，二三三打印到输出数组中

266
00:11:27,509 --> 00:11:28,210
one four.
一四

267
00:11:28,210 --> 00:11:28,820
VICTOR COSTAN: All right.
维克多·科斯坦：好的。 

268
00:11:28,820 --> 00:11:30,330
So there's no zeroes and now fives.
因此，没有零，现在没有五。 

269
00:11:30,330 --> 00:11:36,240
So one one, one two, one three, and one four.
所以一一，一二，一三和一四。 

270
00:11:36,240 --> 00:11:38,729



271
00:11:38,929 --> 00:11:39,829
OK, so far so good.
好的，到目前为止很好。 

272
00:11:39,830 --> 00:11:41,979
This is great.
这很棒。 

273
00:11:42,179 --> 00:11:44,309
There's one thing that's missing.
缺少一件事。 

274
00:11:44,309 --> 00:11:47,199
For counting sort and for other sorting algorithms,
对于计数排序和其他排序算法， 

275
00:11:47,200 --> 00:11:50,099
we care about the property called stability.
我们关心的是稳定性。 

276
00:11:50,299 --> 00:11:52,779
And stability means that if you have
稳定性意味着如果您有

277
00:11:52,779 --> 00:11:55,089
two equal keys, or at least two keys
两个相等的键，或至少两个键

278
00:11:55,090 --> 00:11:56,609
that look equal to the sorting algorithm,
看起来与排序算法相同

279
00:11:56,809 --> 00:11:58,683
they might be different objects, because they
它们可能是不同的对象，因为它们

280
00:11:58,683 --> 00:12:00,799
might be implementing that.
可能正在实施。 

281
00:12:00,799 --> 00:12:02,699
The one that shows up first in the input
在输入中首先出现的那个

282
00:12:02,700 --> 00:12:06,009
should also show up first in the output.
还应该首先显示在输出中。 

283
00:12:06,009 --> 00:12:07,710
And that requires particular care,
那需要特别注意

284
00:12:07,710 --> 00:12:10,267
because you can't just look at the keys
因为你不能只看按键

285
00:12:10,267 --> 00:12:11,850
from your sorting perspective and know
从您的排序角度了解

286
00:12:11,850 --> 00:12:13,224
which one's supposed to go where.
哪个应该去哪里。 

287
00:12:13,224 --> 00:12:15,459
You have to remember where they were in the input.
您必须记住它们在输入中的位置。 

288
00:12:15,659 --> 00:12:19,841
So if this guy is 3a, and this guy is 3b,
因此，如果这个人是3a，而这个人是3b， 

289
00:12:19,841 --> 00:12:21,586
I can't use this approach anymore, right?
我不能再使用这种方法了，对吧？ 

290
00:12:21,586 --> 00:12:23,419
Because when I'm outputting here, all I know
因为当我在这里输出时，我所知道的

291
00:12:23,419 --> 00:12:24,519
is I have to output a three.
是我必须输出三个。 

292
00:12:24,519 --> 00:12:25,936
I don't have any other information
我没有其他信息

293
00:12:25,936 --> 00:12:27,950
associated with the key.
与密钥关联。 

294
00:12:27,950 --> 00:12:29,805
So instead, I have to do something smarter.
因此，我必须做些更聪明的事情。 

295
00:12:30,005 --> 00:12:34,199
AUDIENCE: Either replace your array with a 2-D array.
听众：用二维阵列替换阵列。 

296
00:12:34,200 --> 00:12:36,719
Or I think better would be to replace
或者我认为最好是更换

297
00:12:36,919 --> 00:12:39,600
each value with a length list.
每个值都有一个长度列表。 

298
00:12:39,600 --> 00:12:40,350
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

299
00:12:40,350 --> 00:12:45,700
So we can replace each value with a length list, which
因此我们可以将每个值替换为长度列表

300
00:12:45,700 --> 00:12:47,829
would have the keys that map to it, right.
将具有映射到它的键，对。 

301
00:12:48,029 --> 00:12:49,699
So here I would have a one.
所以在这里我要一个。 

302
00:12:49,700 --> 00:12:51,970
Here I would have a two.
在这里，我有两个。 

303
00:12:51,970 --> 00:12:55,450
Here I would have 3a, and then 3b.
在这里，我将有3a，然后是3b。 

304
00:12:55,450 --> 00:12:59,120
and here I would have a four.
我这里有四个

305
00:12:59,120 --> 00:13:03,149
So then I can go through these and output them the right way.
这样我就可以检查这些内容并以正确的方式输出它们。 

306
00:13:03,149 --> 00:13:06,939
OK, now suppose I'm writing this in C.
 OK，现在假设我正在用C编写此代码。 

307
00:13:06,940 --> 00:13:09,089
Suppose I'm in a low level language.
假设我使用的是低级语言。 

308
00:13:09,089 --> 00:13:10,679
And I'm in a low level language because I'm
我使用低级语言，因为我

309
00:13:10,879 --> 00:13:14,759
hired by one of these startups that are doing NoSQL databases.
由从事NoSQL数据库的这些初创公司之一雇用。 

310
00:13:14,759 --> 00:13:16,490
And they're writing everything in C
他们正在用C编写所有内容

311
00:13:16,490 --> 00:13:18,659
to make their things really fast.
使他们的事情真正快速。 

312
00:13:18,659 --> 00:13:20,659
So I'm writing an index that uses counting sort.
所以我正在写一个使用计数排序的索引。 

313
00:13:20,659 --> 00:13:23,870
I don't have length lists, because if I'm writing in C,
我没有长度列表，因为如果我用C编写， 

314
00:13:23,870 --> 00:13:24,899
I have to write my own.
我必须写我自己的。 

315
00:13:24,899 --> 00:13:26,220
And that's hard.
那很难。 

316
00:13:26,220 --> 00:13:28,229
So I want to implement this in another way.
所以我想用另一种方式来实现。 

317
00:13:28,429 --> 00:13:32,239



318
00:13:32,240 --> 00:13:33,359
Length lists are hard.
长度列表很难。 

319
00:13:33,559 --> 00:13:36,069
What would I do instead?
我该怎么办？ 

320
00:13:36,070 --> 00:13:37,440
Can anyone think of another way?
谁能想到另一种方式？ 

321
00:13:37,440 --> 00:13:40,350
AUDIENCE: I think you can decrement the values
听众：我认为您可以降低价值

322
00:13:40,350 --> 00:13:43,705
for the C in the array that you have,
对于您拥有的数组中的C， 

323
00:13:43,905 --> 00:13:46,353
where you have to type the culture of each anyway.
无论如何，您必须在其中键入每种语言的文化。 

324
00:13:46,354 --> 00:13:48,069
VICTOR COSTAN: OK, so you have the right idea.
 VICTOR COSTAN：好的，所以您有一个正确的想法。 

325
00:13:48,269 --> 00:13:50,879



326
00:13:50,879 --> 00:13:51,909
You're missing one step.
您错过了一步。 

327
00:13:51,909 --> 00:13:53,350
So I'll give everyone else a hint
所以我会给其他人一个提示

328
00:13:53,350 --> 00:13:54,600
so that everyone can catch up.
这样每个人都可以赶上。 

329
00:13:54,600 --> 00:13:58,470
So what I want to do is I want to take this and transform it
所以我想做的就是接受并转化它

330
00:13:58,470 --> 00:14:02,330
into something that allows me to go through the keys.
可以让我通过按键的东西。 

331
00:14:02,330 --> 00:14:04,819
So I know I have five keys here.
所以我知道我这里有五把钥匙。 

332
00:14:05,019 --> 00:14:07,970
I'm going to make an output array of five elements.
我将制作一个包含五个元素的输出数组。 

333
00:14:07,970 --> 00:14:11,100
And I want to be able to see four and know
我希望能够看到四个并知道

334
00:14:11,100 --> 00:14:12,629
that it belongs here.
它属于这里。 

335
00:14:12,629 --> 00:14:15,179
See one, know that it belongs here.
看到一个，知道它属于这里。 

336
00:14:15,179 --> 00:14:18,469
See 3a, know that it belongs here.
参见3a，知道它属于这里。 

337
00:14:18,470 --> 00:14:21,209
Then probably update the value associated with three.
然后可能会更新与三关联的值。 

338
00:14:21,409 --> 00:14:23,039
See two, know that it belongs here.
看到两个，知道它属于这里。 

339
00:14:23,039 --> 00:14:26,009
And then when I see 3b, know that it belongs here.
然后，当我看到3b时，知道它属于这里。 

340
00:14:26,009 --> 00:14:28,720



341
00:14:28,720 --> 00:14:33,269
So I want to look, when I get to 3a, I want to look inside here.
所以我想看，当我到达3a时，我想看这里。 

342
00:14:33,269 --> 00:14:39,090
And I want this to tell me that 3 belongs here,
我想告诉我3属于这里， 

343
00:14:39,090 --> 00:14:39,960
3a belongs here.
 3a属于这里。 

344
00:14:39,960 --> 00:14:54,610



345
00:14:54,610 --> 00:14:58,570
So what would the position of 3a be?
那么3a的位置将是什么？ 

346
00:14:58,570 --> 00:14:59,700
That's not good, right?
那不好，对吗？ 

347
00:14:59,700 --> 00:15:02,759
Let's call this c instead so that I can say 3a be.
让我们将其称为c，这样我可以说3a是。 

348
00:15:02,759 --> 00:15:05,919



349
00:15:05,919 --> 00:15:09,469
So how would I define the position
那我怎么定义位置

350
00:15:09,470 --> 00:15:14,350
using the sorted property?
使用排序的属性？ 

351
00:15:14,350 --> 00:15:19,779
3a should go in the index that is how many keys smaller than 3
 3a应该进入比3小几个键的索引

352
00:15:19,779 --> 00:15:20,419
there are.
有。 

353
00:15:20,419 --> 00:15:22,969



354
00:15:22,970 --> 00:15:25,750
So if I can look through here and see
所以，如果我可以看这里

355
00:15:25,750 --> 00:15:29,799
how many keys do I have that are smaller than 3,
我有多少个小于3的钥匙， 

356
00:15:29,799 --> 00:15:33,209
this is where 3a needs to go.
这是3a需要去的地方。 

357
00:15:33,210 --> 00:15:34,979
If I look at four, there are four keys
如果我看四个，有四个关键

358
00:15:35,179 --> 00:15:36,449
that are smaller than four.
小于四个。 

359
00:15:36,450 --> 00:15:40,439
So it needs to go in position four.
因此，它需要排在第四位。 

360
00:15:40,639 --> 00:15:44,679
AUDIENCE: Well, that almost seems more like a compare.
听众：好吧，这似乎更像是一个比较。 

361
00:15:44,679 --> 00:15:46,252
I'm guessing that makes it-- I think
我猜是那样的-我认为

362
00:15:46,253 --> 00:15:47,586
it's kind of a comparison model.
这是一个比较模型。 

363
00:15:47,586 --> 00:15:51,529
But you're saying is it greater than.
但是您是说它大于。 

364
00:15:51,529 --> 00:15:54,179
So it's not really counting sort anymore as much.
因此，它不再真正地计算排序。 

365
00:15:54,179 --> 00:15:55,679
VICTOR COSTAN: Well, I'm telling you
维克多·科斯坦：好吧，我告诉你

366
00:15:55,679 --> 00:15:58,859
I can compute that using this.
我可以用这个来计算。 

367
00:15:58,860 --> 00:16:00,649
So I can use the counting sort algorithm
所以我可以使用计数排序算法

368
00:16:00,649 --> 00:16:05,129
and change this array a little bit so that I can do this trick
并稍微更改此数组，以便我可以完成此操作

369
00:16:05,129 --> 00:16:07,081
and know what goes where.
知道去哪里。 

370
00:16:07,081 --> 00:16:09,860
AUDIENCE: You already mentioned using a 2-D array.
听众：您已经提到过使用二维数组。 

371
00:16:09,860 --> 00:16:14,470
VICTOR COSTAN: But a 2-D array would be too much.
维克多·科斯坦：但是，二维阵列实在太多了。 

372
00:16:14,470 --> 00:16:16,459
In the end, I will be changing this in place.
最后，我将更改此位置。 

373
00:16:16,659 --> 00:16:22,909
So no extra space except for this array of size k.
因此，除了此大小为k的数组之外，没有其他空间。 

374
00:16:22,909 --> 00:16:25,319
But let's not worry about changing it in place right now.
但是，不必担心现在就更改它。 

375
00:16:25,320 --> 00:16:28,719
Let's say we're going to make another array of size k.
假设我们要制作另一个大小为k的数组。 

376
00:16:28,919 --> 00:16:34,919



377
00:16:34,919 --> 00:16:39,319
So I want it to tell me that-- I guess I don't care about this--
所以我想告诉我-我想我不在乎- 

378
00:16:39,320 --> 00:16:42,360
but I want it to tell me that one, the first one
但我想告诉我一个，第一个

379
00:16:42,360 --> 00:16:44,340
should go here, the first two should go here,
应该去这里，前两个应该去这里， 

380
00:16:44,340 --> 00:16:47,339
the first three should go here, the first four should go here.
前三个应该在这里，前四个应该在这里。 

381
00:16:47,539 --> 00:16:48,309
How do I do that?
我怎么做？ 

382
00:16:48,309 --> 00:16:51,471



383
00:16:51,471 --> 00:16:54,819
AUDIENCE: Well, you could make that array, right.
听众：好吧，你可以做那个数组，对。 

384
00:16:54,820 --> 00:16:56,620
VICTOR COSTAN: But how do I compute it?
维克多·科斯坦：但是我怎么计算呢？ 

385
00:16:56,620 --> 00:16:58,245
AUDIENCE: While you're making this one,
听众：在制作这个的时候

386
00:16:58,245 --> 00:17:01,120
you can start filling that one in.
您可以开始填充那个。 

387
00:17:01,120 --> 00:17:03,909
But while you're making the top one.
但是当您进入第一名时。 

388
00:17:03,909 --> 00:17:05,269
VICTOR COSTAN: Can I?
维克多·科斯坦：我可以吗？ 

389
00:17:05,269 --> 00:17:08,789
AUDIENCE: It would be like insertion sort though, kind of.
听众：有点像插入类。 

390
00:17:08,789 --> 00:17:11,654
So you come across the four.
所以您遇到了四个。 

391
00:17:11,654 --> 00:17:14,029
You put it in there, because you know how many there are.
您将其放入其中，因为您知道其中有多少个。 

392
00:17:14,029 --> 00:17:15,509
But that doesn't make a lot of sense.
但这没有多大意义。 

393
00:17:15,509 --> 00:17:16,509
VICTOR COSTAN: Yeah, OK.
维克多·科斯坦：是的，好的。 

394
00:17:16,509 --> 00:17:17,980
So let's abandon that route.
因此，让我们放弃那条路线。 

395
00:17:17,980 --> 00:17:20,308
Let's think of something else.
让我们想一想。 

396
00:17:20,308 --> 00:17:21,945
AUDIENCE: Could you populate the array
听众：您可以填充数组吗

397
00:17:21,945 --> 00:17:26,250
with the number of elements that are less than that [INAUDIBLE]?
元素数量少于[听不清]的元素？ 

398
00:17:26,250 --> 00:17:28,269
VICTOR COSTAN: So intuitively, I want
 VICTOR COSTAN：直观地说，我要

399
00:17:28,269 --> 00:17:30,150
this to tell me how many elements there
告诉我那里有多少元素

400
00:17:30,150 --> 00:17:32,170
are that are smaller than two.
小于两个。 

401
00:17:32,170 --> 00:17:34,084
This should tell me the number of elements
这应该告诉我元素的数量

402
00:17:34,084 --> 00:17:36,500
there are that are smaller than three, so on and so forth.
有小于三个的，依此类推。 

403
00:17:36,500 --> 00:17:39,519



404
00:17:39,519 --> 00:17:41,230
OK, how would I compute that?
好的，我该怎么计算呢？ 

405
00:17:41,230 --> 00:17:46,852



406
00:17:46,852 --> 00:17:48,109
Let's see what it's supposed to be.
让我们看看它应该是什么。 

407
00:17:48,309 --> 00:17:49,768
Let's fill it out with real values.
让我们用真实值填写它。 

408
00:17:49,768 --> 00:17:50,846
AUDIENCE: Zero.
听众：零。 

409
00:17:50,846 --> 00:17:51,680
VICTOR COSTAN: Zero.
维克多·科斯坦：零。 

410
00:17:51,680 --> 00:17:53,410
How many elements smaller than one?
多少个元素小于一个？ 

411
00:17:53,410 --> 00:17:54,650
AUDIENCE: Zero.
听众：零。 

412
00:17:54,650 --> 00:17:57,086
VICTOR COSTAN: How many elements smaller than two?
 VICTOR COSTAN：小于两个的元素有多少？ 

413
00:17:57,086 --> 00:17:58,031
AUDIENCE: One.
听众：一。 

414
00:17:58,031 --> 00:18:00,197
VICTOR COSTAN: How many elements smaller than three?
 VICTOR COSTAN：小于三个的元素有多少？ 

415
00:18:00,198 --> 00:18:01,950
AUDIENCE: Two.
听众：两个。 

416
00:18:01,950 --> 00:18:03,769
It's a cumulative sum.
这是累计金额。 

417
00:18:03,769 --> 00:18:04,799
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

418
00:18:04,799 --> 00:18:07,240
AUDIENCE: On the array above.
听众：在上面的阵列上。 

419
00:18:07,240 --> 00:18:09,650
VICTOR COSTAN: So this is how many elements smaller
维克多·科斯坦（VICTOR COSTAN）：这就是缩小了多少个元素

420
00:18:09,650 --> 00:18:11,236
than four?
比四个？ 

421
00:18:11,236 --> 00:18:13,329
Or how many elements smaller than 5 4?
或多少个元素小于5 4？ 

422
00:18:13,529 --> 00:18:14,809
OK.
好。 

423
00:18:14,809 --> 00:18:16,991
what's the difference between these two guys?
这两个家伙有什么区别？ 

424
00:18:16,991 --> 00:18:18,349
AUDIENCE: One.
听众：一。 

425
00:18:18,349 --> 00:18:19,723
VICTOR COSTAN: What's the difference between these two
 VICTOR COSTAN：两者之间有什么区别

426
00:18:19,723 --> 00:18:19,967
guys?
伙计们？ 

427
00:18:19,968 --> 00:18:20,350
AUDIENCE: One.
听众：一。 

428
00:18:20,550 --> 00:18:22,993



429
00:18:22,993 --> 00:18:24,409
VICTOR COSTAN: Yeah, you're right.
维克多·科斯坦：是的，您是对的。 

430
00:18:24,410 --> 00:18:26,410
Sorry.
抱歉。 

431
00:18:26,410 --> 00:18:27,529
Thank you.
谢谢。 

432
00:18:27,529 --> 00:18:29,981
What's the difference between these two guys?
这两个家伙有什么区别？ 

433
00:18:29,981 --> 00:18:32,142
AUDIENCE: Two.
听众：两个。 

434
00:18:32,142 --> 00:18:32,643
One.
一。 

435
00:18:32,643 --> 00:18:35,057
VICTOR COSTAN: And what's the difference between these two
 VICTOR COSTAN：两者之间有什么区别

436
00:18:35,057 --> 00:18:36,115
guys?
伙计们？ 

437
00:18:36,115 --> 00:18:38,560
AUDIENCE: Zero.
听众：零。 

438
00:18:38,560 --> 00:18:41,153
VICTOR COSTAN: OK, What did I just write here?
维克多·科斯坦：好的，我刚才在这里写了什么？ 

439
00:18:41,153 --> 00:18:42,615
AUDIENCE: Same series up there.
听众：同一系列。 

440
00:18:42,615 --> 00:18:44,079
AUDIENCE: Array.
听众：数组。 

441
00:18:44,079 --> 00:18:45,659
VICTOR COSTAN: All right.
维克多·科斯坦：好的。 

442
00:18:45,660 --> 00:18:49,409
So this guy is zero, right, because there's no element
所以这个人是零，对，因为没有元素

443
00:18:49,609 --> 00:18:52,379
that-- there's nothing that's smaller to the smallest key.
那-没有什么比最小的键更小了。 

444
00:18:52,380 --> 00:18:59,409
And then this guy is whatever was here plus this almost.
然后这个家伙就是这里的一切加上几乎所有的东西。 

445
00:18:59,609 --> 00:19:02,139
So the difference between this guy and this guy is this.
所以这个家伙和这个家伙之间的区别就是这样。 

446
00:19:02,140 --> 00:19:05,633



447
00:19:05,633 --> 00:19:07,428
AUDIENCE: So why go through an array?
听众：那么为什么要遍历数组呢？ 

448
00:19:07,628 --> 00:19:09,966
I mean, why did you bother?
我的意思是，你为什么要打扰？ 

449
00:19:09,967 --> 00:19:11,835
Why do we make a new array?
我们为什么要制作一个新的阵列？ 

450
00:19:11,835 --> 00:19:13,674
Because we could just get that information.
因为我们可以获取该信息。 

451
00:19:13,674 --> 00:19:15,049
VICTOR COSTAN: Making a new array
 VICTOR COSTAN：制作新阵列

452
00:19:15,049 --> 00:19:18,869
so that we can see how to compute it.
这样我们就可以看到如何计算它。 

453
00:19:18,869 --> 00:19:21,169
So now we're going to try to right pseudocode that
所以现在我们将尝试纠正伪代码

454
00:19:21,170 --> 00:19:23,950
does this in place.
做到这一点。 

455
00:19:23,950 --> 00:19:27,779
So suppose this array is a and this
所以假设这个数组是一个

456
00:19:27,779 --> 00:19:33,299
array is pass for position.
数组传递位置。 

457
00:19:33,299 --> 00:19:35,769
And suppose-- sorry, not this array.
并假设-抱歉，不是这个数组。 

458
00:19:35,769 --> 00:19:36,639
This array is a.
这个数组是一个。 

459
00:19:36,640 --> 00:19:39,460



460
00:19:39,460 --> 00:19:40,159
This array is pass.
该数组是合格的。 

461
00:19:40,359 --> 00:19:41,740
And I start with this.
我从这个开始。 

462
00:19:41,740 --> 00:19:45,019
And I want to end up with this.
我要结束这个。 

463
00:19:45,019 --> 00:19:48,509
So let's try to write the pseudocode for counting sort.
因此，让我们尝试编写用于计数排序的伪代码。 

464
00:19:48,509 --> 00:19:51,250
Counting sort with an array a.
用数组计数排序a。 

465
00:19:51,250 --> 00:19:57,299
I'm not going to write the first two lines that produce this.
我不会写产生这种情况的前两行。 

466
00:19:57,299 --> 00:19:59,826
Let's transform this to this.
让我们将其转换为此。 

467
00:19:59,826 --> 00:20:00,660
How would I do that?
我该怎么做？ 

468
00:20:00,660 --> 00:20:03,950



469
00:20:03,950 --> 00:20:06,769
AUDIENCE: Initialize an array of the same size.
听众：初始化大小相同的数组。 

470
00:20:06,769 --> 00:20:08,596
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

471
00:20:08,596 --> 00:20:09,805
Can we try to do it in place?
我们可以尝试就地做到吗？ 

472
00:20:09,805 --> 00:20:13,052



473
00:20:13,252 --> 00:20:13,877
AUDIENCE: Sure.
听众：好的。 

474
00:20:13,877 --> 00:20:15,864



475
00:20:15,864 --> 00:20:17,529
VICTOR COSTAN: How do we do it in place?
维克多·科斯坦：我们如何做到这一点？ 

476
00:20:17,529 --> 00:20:22,450



477
00:20:22,450 --> 00:20:25,529
AUDIENCE: You could, well for four, you get the four.
听众：四个人，你可以得到四个。 

478
00:20:25,529 --> 00:20:28,660
You're like, oh, I haven't encountered anything below me.
你就像，哦，我还没遇到什么。 

479
00:20:28,660 --> 00:20:31,544
So you put it in zero initially for four.
因此，您最初将其置零为四。 

480
00:20:31,744 --> 00:20:32,703
And then you get a one.
然后你得到一个。 

481
00:20:32,703 --> 00:20:35,036
And you're like, oh, I haven't gotten anything below me.
而且您就像，哦，我什么都没得到。 

482
00:20:35,036 --> 00:20:36,865
But I forget to keep track of the fact
但是我忘了跟踪事实

483
00:20:36,865 --> 00:20:39,115
that you have to iterate a whole list ever single time
您必须一次遍历整个列表

484
00:20:39,115 --> 00:20:40,259
you get a new input.
您会得到一个新的输入。 

485
00:20:40,259 --> 00:20:42,009
VICTOR COSTAN: So I don't want to do that,
维克多·科斯坦：所以我不想那样做， 

486
00:20:42,009 --> 00:20:43,050
because that's n squared.
因为那是平方。 

487
00:20:43,050 --> 00:20:50,539
AUDIENCE: What you need to do is keep a running sum.
听众：您需要做的是保持连续不断的增长。 

488
00:20:50,539 --> 00:20:51,440
Is it a register?
它是寄存器吗？ 

489
00:20:51,440 --> 00:20:52,139
Is that what you do call it?
那就是你所说的吗？ 

490
00:20:52,339 --> 00:20:52,919
VICTOR COSTAN: Running sum.
维克多·科斯坦：总计。 

491
00:20:52,920 --> 00:20:53,720
I like running sum.
我喜欢总和。 

492
00:20:53,720 --> 00:20:54,260
AUDIENCE: OK.
听众：好的。 

493
00:20:54,260 --> 00:20:55,480
Keep a running sum of--
保持- 

494
00:20:55,480 --> 00:20:58,769



495
00:20:58,769 --> 00:21:00,779
VICTOR COSTAN: Sums always start at zero, right?
维克多·科斯坦：总和总是从零开始，对吗？ 

496
00:21:00,779 --> 00:21:01,819
AUDIENCE: Right.
听众：对。 

497
00:21:01,819 --> 00:21:10,139
So you keep zero at-- you take the value
所以您将零保持在-您取值

498
00:21:10,140 --> 00:21:14,920
in each index of that array and add it to sum.
在该数组的每个索引中，并将其加和。 

499
00:21:14,920 --> 00:21:16,250
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

500
00:21:16,250 --> 00:21:23,279
So for i iterating from zero to-- so you
所以我从零迭代到

501
00:21:23,279 --> 00:21:26,576
want each value in this array, right?
想要这个数组中的每个值，对不对？ 

502
00:21:26,576 --> 00:21:27,160
AUDIENCE: Yes.
听众：是的。 

503
00:21:27,160 --> 00:21:30,980
VICTOR COSTAN: So it's going to iterate from zero to what?
 VICTOR COSTAN：那么它将从零迭代到什么？ 

504
00:21:30,980 --> 00:21:34,634
How many elements do I have there?
我在那里有几个元素？ 

505
00:21:34,634 --> 00:21:36,910
AUDIENCE: Length k.
听众：长度k。 

506
00:21:36,910 --> 00:21:38,400
VICTOR COSTAN: OK, almost.
维克多·科斯坦：好的，差不多。 

507
00:21:38,400 --> 00:21:43,220
So we're using Python numbering, which is zero base indexing.
因此，我们正在使用Python编号，即零基索引。 

508
00:21:43,220 --> 00:21:45,289
The indices look like this.
索引看起来像这样。 

509
00:21:45,289 --> 00:21:46,798
So it's zero to--
所以- 

510
00:21:46,798 --> 00:21:47,714
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

511
00:21:47,714 --> 00:21:48,755
VICTOR COSTAN: Very good.
 VICTOR COSTAN：很好。 

512
00:21:48,756 --> 00:21:50,669
Thank you.
谢谢。 

513
00:21:50,869 --> 00:21:53,789
And you said I'm going to add the elements to a sum.
你说我要把这些元素加起来。 

514
00:21:53,789 --> 00:22:03,299
So sum is sum plus position of i.
因此，总和就是i的和。 

515
00:22:03,299 --> 00:22:05,079
OK.
好。 

516
00:22:05,079 --> 00:22:05,589
And then?
接着？ 

517
00:22:05,589 --> 00:22:08,264



518
00:22:08,265 --> 00:22:12,509
AUDIENCE: The replace is the [INAUDIBLE].
听众：替换为[听不清]。 

519
00:22:12,509 --> 00:22:16,829
So zero should be zero still.
所以零应该仍然是零。 

520
00:22:16,829 --> 00:22:23,664
One should be the sum after evaluating zero.
评估为零后，总和应为1。 

521
00:22:23,664 --> 00:22:25,609
You'll need a temp variable.
您将需要一个临时变量。 

522
00:22:25,609 --> 00:22:26,399
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

523
00:22:26,400 --> 00:22:31,159
AUDIENCE: You'll need to graph position i when in temp.
听众：在温度下，您需要绘制位置i的图。 

524
00:22:31,359 --> 00:22:35,399
VICTOR COSTAN: Temp is position i.
 COSTAN COSTAN：温度在位置i。 

525
00:22:35,400 --> 00:22:42,605
AUDIENCE: Then say position i is sum before incremental sums.
听众：然后说位置i是总和，然后是增量和。 

526
00:22:42,605 --> 00:22:45,784



527
00:22:45,984 --> 00:22:46,484
No.
没有。 

528
00:22:46,484 --> 00:22:49,394
That's not it at all.
根本不是。 

529
00:22:49,394 --> 00:22:51,335
VICTOR COSTAN: Really?
维克多·科斯坦：真的吗？ 

530
00:22:51,335 --> 00:22:53,670
AUDIENCE: We'll have to say that sum is sum plus temp.
听众：我们不得不说总和是总和加上临时工。 

531
00:22:53,670 --> 00:23:01,341



532
00:23:01,541 --> 00:23:02,525
That is going to work.
那将起作用。 

533
00:23:02,526 --> 00:23:05,480



534
00:23:05,480 --> 00:23:06,230
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

535
00:23:06,230 --> 00:23:09,500
How does everyone else feel about this?
其他人对此感觉如何？ 

536
00:23:09,500 --> 00:23:11,395
Does it make sense?
是否有意义？ 

537
00:23:11,395 --> 00:23:12,282
AUDIENCE: Not really.
听众：不是。 

538
00:23:12,282 --> 00:23:14,323
AUDIENCE: [INAUDIBLE] temporary blast [INAUDIBLE]
听众：[听不清]临时爆炸[听不清] 

539
00:23:14,324 --> 00:23:19,500
previous adjuration, because-- so when you first started,
以前的裁决，因为-因此，当您第一次开始时， 

540
00:23:19,500 --> 00:23:21,930
it's the very initial case that doesn't work.
这是最初的情况，不起作用。 

541
00:23:21,930 --> 00:23:24,519
So like, if you're in the first column, everything's fine.
就像，如果您在第一列中，一切都很好。 

542
00:23:24,519 --> 00:23:27,282
Then you go to column one.
然后转到第一列。 

543
00:23:27,282 --> 00:23:29,918
You're looking at everything to the left of it.
您正在查看左侧的所有内容。 

544
00:23:29,919 --> 00:23:31,085
It's still going to be zero.
它仍将为零。 

545
00:23:31,085 --> 00:23:32,559
Then you go to the second column,
然后转到第二列， 

546
00:23:32,559 --> 00:23:35,250
but you already overwrote the previous column.
但是您已经覆盖了上一专栏。 

547
00:23:35,250 --> 00:23:39,619
So you need to store somehow the-- I don't know.
因此，您需要以某种方式存储-我不知道。 

548
00:23:39,619 --> 00:23:42,931
It's just the initial case from when it first
这只是第一次的最初情况

549
00:23:42,932 --> 00:23:46,047
goes from zero to an actual qualified number.
从零到实际合格数字。 

550
00:23:46,047 --> 00:23:47,547
Because otherwise, you're just going
因为否则，你只是去

551
00:23:47,547 --> 00:23:48,824
to get like zero, zero, zero.
得到零，零，零

552
00:23:48,824 --> 00:23:51,769
And you just overwrite.
而您只是覆盖。 

553
00:23:51,769 --> 00:23:56,189
AUDIENCE: Can you start [INAUDIBLE]?
听众：您可以开始[听不清]吗？ 

554
00:23:56,189 --> 00:23:59,092
Was that before you changed?
那是在您改变之前吗？ 

555
00:23:59,292 --> 00:24:00,042
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

556
00:24:00,042 --> 00:24:14,579



557
00:24:14,579 --> 00:24:16,649
Sorry, I'm getting confused.
抱歉，我很困惑。 

558
00:24:16,650 --> 00:24:24,769



559
00:24:24,769 --> 00:24:27,220
This is getting hard.
这越来越难了。 

560
00:24:27,220 --> 00:24:29,750
I will show you a trick to make life easier.
我将向您展示使生活更轻松的窍门。 

561
00:24:29,750 --> 00:24:33,160
I'm going to put-- how many elements do I have here?
我要说的是-我在这里有多少个元素？ 

562
00:24:33,160 --> 00:24:34,849
Five, right?
五对吧

563
00:24:35,049 --> 00:24:41,169
So I'm going to put a five here after the array.
因此，我将在阵列后放置5。 

564
00:24:41,170 --> 00:24:45,211
And then I'm going to ask you, what's this difference.
然后我要问你，这有什么区别。 

565
00:24:45,211 --> 00:24:47,109
AUDIENCE: Zero.
听众：零。 

566
00:24:47,109 --> 00:24:48,490
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

567
00:24:48,490 --> 00:24:50,380
So now we have this whole array.
所以现在我们有了整个数组。 

568
00:24:50,380 --> 00:24:57,650



569
00:24:57,650 --> 00:25:00,579
Can people see what's going on here.?
人们可以看到这里发生了什么吗？ 

570
00:25:00,779 --> 00:25:03,129
So instead of starting at the beginning,
因此，与其从头开始， 

571
00:25:03,130 --> 00:25:04,380
I'm going to start at the end.
我将从结尾开始。 

572
00:25:04,380 --> 00:25:09,750
And I'm going to know-- I know for sure there are n elements.
我要知道-我肯定知道有n个元素。 

573
00:25:09,750 --> 00:25:13,309
Therefore, the index of this guy is n minus--
因此，这个人的指数是n减去- 

574
00:25:13,309 --> 00:25:17,849
so the index of the last key is n minus how many keys I
所以最后一个键的索引是n减去我有多少个键

575
00:25:17,849 --> 00:25:18,769
have with this value.
有这个价值。 

576
00:25:18,769 --> 00:25:21,720



577
00:25:21,720 --> 00:25:24,140
Does this make sense?
这有意义吗？ 

578
00:25:24,140 --> 00:25:26,334
AUDIENCE: But you're iterating over an order, right?
听众：但是您要遍历一个订单，对吗？ 

579
00:25:26,334 --> 00:25:27,875
So we can't just take the whole thing
所以我们不能只拿整个东西

580
00:25:27,875 --> 00:25:30,299
and say we're going to shift it over to the right.
并说我们将其移至右侧。 

581
00:25:30,299 --> 00:25:31,383
VICTOR COSTAN: How about--
维克多·科斯坦：怎么样- 

582
00:25:31,383 --> 00:25:35,068



583
00:25:35,068 --> 00:25:37,109
AUDIENCE: And you're going through left to right.
听众：而且您正在经历从左到右的过程。 

584
00:25:37,109 --> 00:25:39,839
You'll only know what you see thus far.
您只会知道到目前为止所看到的。 

585
00:25:39,839 --> 00:25:48,149
VICTOR COSTAN: How about going it for ai from n minus 1 to 0.
维克多·科斯坦（VICTOR COSTAN）：ai从n减1到0的情况如何。 

586
00:25:48,150 --> 00:25:51,230
Will it work then?
那会行吗？ 

587
00:25:51,230 --> 00:25:52,169
So what would I write?
那我会写什么呢？ 

588
00:25:52,369 --> 00:25:54,509
AUDIENCE: But isn't that super inefficient?
听众：但是那不是超级低效吗？ 

589
00:25:54,509 --> 00:25:57,533
Because then you're starting looking at the whole list.
因为那样您便开始查看整个列表。 

590
00:25:57,534 --> 00:25:59,430
And then you're sort of, rather than just
然后你有点，而不只是

591
00:25:59,430 --> 00:26:02,754
looking at the previous sum that you just-- the cumulative.
查看您之前的总和-累计。 

592
00:26:02,954 --> 00:26:04,385
So your first adjuration, you have
因此，您的第一个裁决是

593
00:26:04,385 --> 00:26:05,817
to add up everything that you see.
汇总您看到的所有内容。 

594
00:26:05,817 --> 00:26:08,203
Like adjuration, you have to add everything up.
就像裁决一样，您必须将所有内容加起来。 

595
00:26:08,203 --> 00:26:10,119
VICTOR COSTAN: So if I add everything up here,
维克多·科斯坦：所以，如果我在这里添加所有内容， 

596
00:26:10,119 --> 00:26:12,789
what's the result going to be?
结果将是什么？ 

597
00:26:12,789 --> 00:26:13,569
AUDIENCE: Five.
听众：五。 

598
00:26:13,569 --> 00:26:14,319
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

599
00:26:14,319 --> 00:26:14,879
What's five?
五点什么？ 

600
00:26:14,880 --> 00:26:21,094



601
00:26:21,094 --> 00:26:23,869
So this counts how many zero keys
所以这算出多少个零键

602
00:26:24,069 --> 00:26:26,086
I've seen, how many one keys I've seen,
我看过，我看过多少个键， 

603
00:26:26,086 --> 00:26:29,188
how many two keys I've seen, so on and so forth.
我看过多少个两个键，依此类推。 

604
00:26:29,388 --> 00:26:29,929
So in total--
所以总共

605
00:26:29,930 --> 00:26:30,960
AUDIENCE: So you're subtracting
听众：所以你减去

606
00:26:30,960 --> 00:26:32,592
VICTOR COSTAN: It's how many keys I've seen.
维克多·科斯坦（VICTOR COSTAN）：我已经看过多少把钥匙。 

607
00:26:32,792 --> 00:26:36,039
All this, the sum of all these, is how many keys I've sent.
所有这些加起来就是我发送了多少个密钥。 

608
00:26:36,039 --> 00:26:37,539
How many keys do I have?
我有多少把钥匙？ 

609
00:26:37,539 --> 00:26:38,450
AUDIENCE: Five.
听众：五。 

610
00:26:38,450 --> 00:26:39,950
For each one you see, you can just--
对于您看到的每个人，您都可以- 

611
00:26:39,950 --> 00:26:42,846
VICTOR COSTAN: So who's five?
维克多·科斯坦：那五个是谁？ 

612
00:26:42,846 --> 00:26:45,319
It's the length of this guy, right?
这是这个人的长度，对吧？ 

613
00:26:45,319 --> 00:26:47,679
And we usually call that n.
我们通常称其为n。 

614
00:26:47,680 --> 00:26:53,419
So when we're doing sorting, this is n.
因此，当我们进行排序时，该值为n。 

615
00:26:53,619 --> 00:26:55,174
So maybe it's less confusing.
因此，也许它不那么令人困惑。 

616
00:26:55,174 --> 00:26:57,180
Oh, I already used n in two places.
哦，我已经在两个地方使用过n了。 

617
00:26:57,180 --> 00:26:59,930
So I guess that's it.
所以我想就是这样。 

618
00:26:59,930 --> 00:27:04,044
I could say the length of a, but there you go.
我可以说a的长度，但是你去了。 

619
00:27:04,244 --> 00:27:07,326



620
00:27:07,326 --> 00:27:09,660
So I could do the thing that we're going through before.
所以我可以做我们之前正在做的事情。 

621
00:27:09,660 --> 00:27:11,201
I could figure out my temp variables.
我可以弄清楚我的临时变量。 

622
00:27:11,201 --> 00:27:14,059
And I could make it work.
我可以使它工作。 

623
00:27:14,059 --> 00:27:15,144
Or I could do this.
或者我可以这样做。 

624
00:27:15,144 --> 00:27:16,440
AUDIENCE: I think it's the same though, isn't it?
听众：我想是一样的，不是吗？ 

625
00:27:16,440 --> 00:27:17,139
VICTOR COSTAN: Yup.
维克多·波士坦：是的。 

626
00:27:17,339 --> 00:27:20,615
It's the same thing, except I think this is easier to write.
是同一件事，除了我认为这更容易编写。 

627
00:27:20,615 --> 00:27:22,240
Does anyone want to help me write this?
有人想帮我写这个吗？ 

628
00:27:22,240 --> 00:27:28,635



629
00:27:28,635 --> 00:27:31,216
AUDIENCE: Maybe doing once you're
听众：也许一旦你

630
00:27:31,217 --> 00:27:33,851
starting with the top array, and then finding the bottom one.
从顶部的数组开始，然后找到底部的数组。 

631
00:27:34,051 --> 00:27:35,023
VICTOR COSTAN: Yeah.
维克多·科斯坦：是的。 

632
00:27:35,023 --> 00:27:35,959
AUDIENCE: Oh, OK.
听众：哦，好。 

633
00:27:35,960 --> 00:27:37,835
Well, you just-- you start with the first one
好吧，您只是-从第一个开始

634
00:27:37,835 --> 00:27:40,443
and the one ahead of it.
和前面的那个

635
00:27:40,443 --> 00:27:43,240
And oh, I mean starting with the top right.
哦，我的意思是从右上角开始。 

636
00:27:43,240 --> 00:27:43,819
Sorry.
抱歉。 

637
00:27:43,819 --> 00:27:46,399
VICTOR COSTAN: OK, so I have this.
 VICTOR COSTAN：好的，我有这个。 

638
00:27:46,400 --> 00:27:49,182
And then what do I do?
然后我该怎么办？ 

639
00:27:49,182 --> 00:27:51,596
AUDIENCE: [INAUDIBLE]?
听众：[听不清]？ 

640
00:27:51,596 --> 00:27:53,529
Oh, so you're starting from the back.
哦，所以您从背面开始。 

641
00:27:53,529 --> 00:27:54,533
VICTOR COSTAN: Yep.
维克多·科斯坦：是的。 

642
00:27:54,534 --> 00:28:00,720
AUDIENCE: Well, then you just compare that to-- I mean,
听众：好吧，那么你可以将其与-我的意思是， 

643
00:28:00,720 --> 00:28:03,444
you're going to start with zero difference.
您将从零差开始。 

644
00:28:03,444 --> 00:28:05,819
If you have-- well you don't have any of those last keys,
如果您有-那么您没有任何这些最后的钥匙， 

645
00:28:05,819 --> 00:28:07,433
so you'd be able to start with a zero.
因此您可以从零开始。 

646
00:28:07,433 --> 00:28:09,599
VICTOR COSTAN: So what's the difference between five
 VICTOR COSTAN：那么五个之间有什么区别

647
00:28:09,599 --> 00:28:12,779
here, which is n, and this guy?
这是n，还有这个家伙？ 

648
00:28:12,779 --> 00:28:13,436
What is this?
这是什么？ 

649
00:28:13,436 --> 00:28:14,769
AUDIENCE: It's going to be zero.
听众：它将为零。 

650
00:28:14,769 --> 00:28:16,139
VICTOR COSTAN: But what is it?
维克多·科斯坦：但是那是什么？ 

651
00:28:16,140 --> 00:28:16,669
Why is it zero?
为什么为零？ 

652
00:28:16,869 --> 00:28:19,349
So this one's zero, this one's one, this one's two.
所以这个为零，这个为一，这个为二。 

653
00:28:19,349 --> 00:28:21,909
What is this?
这是什么？ 

654
00:28:21,910 --> 00:28:23,160
It's the last guy here, right?
这是这里的最后一个人，对吗？ 

655
00:28:23,160 --> 00:28:24,180
AUDIENCE: Yeah, yeah.
听众：是的，是的。 

656
00:28:24,180 --> 00:28:29,450
VICTOR COSTAN: So this is pass of n minus 1.
维克多·科斯坦（VICTOR COSTAN）：这是n减1的通过。 

657
00:28:29,450 --> 00:28:33,889
And this is pass of n minus 2, so on and so forth.
这是n减2的通过，依此类推。 

658
00:28:34,089 --> 00:28:38,419
So to get from n to the value here,
所以要从n到这里的值， 

659
00:28:38,420 --> 00:28:40,029
I have to subtract this guy.
我要减去这个家伙。 

660
00:28:40,029 --> 00:28:45,416



661
00:28:45,416 --> 00:28:46,250
AUDIENCE: Pass of i.
听众：通过i。 

662
00:28:46,250 --> 00:28:48,858



663
00:28:48,858 --> 00:28:49,899
VICTOR COSTAN: Pass of i.
维克多·波士坦：通过i。 

664
00:28:49,900 --> 00:28:56,063



665
00:28:56,263 --> 00:28:57,179
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

666
00:28:57,180 --> 00:29:02,681



667
00:29:02,681 --> 00:29:03,430
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

668
00:29:03,430 --> 00:29:04,180
Very good.
很好。 

669
00:29:04,180 --> 00:29:07,659
AUDIENCE: And then update sum.
听众：然后更新总和。 

670
00:29:07,659 --> 00:29:10,144
Sum equals a pos value.
总和等于pos值。 

671
00:29:10,144 --> 00:29:13,140



672
00:29:13,140 --> 00:29:14,210
VICTOR COSTAN: Sweet.
维克多·科斯坦：甜。 

673
00:29:14,210 --> 00:29:17,681
No temp variables, aside from this, I guess.
我猜除了这个，没有临时变量。 

674
00:29:17,681 --> 00:29:18,680
How does this look like?
看起来如何？ 

675
00:29:18,680 --> 00:29:20,659
Do people get it?
人们明白了吗？ 

676
00:29:20,859 --> 00:29:22,689
AUDIENCE: You're subtracting positive i,
听众：您要减去正数i， 

677
00:29:22,690 --> 00:29:25,450
or you're subtracting a of i.
或者您要减去i。 

678
00:29:25,450 --> 00:29:26,669
AUDIENCE: It's all one array.
听众：全都是一个阵列。 

679
00:29:26,869 --> 00:29:28,119
AUDIENCE: It's the same thing.
听众：是同一回事。 

680
00:29:28,119 --> 00:29:28,660
That's right.
那就对了。 

681
00:29:28,661 --> 00:29:32,230
VICTOR COSTAN: So a is this array. a is the input array.
维克多·科斯坦：所以这个数组。 a是输入数组。 

682
00:29:32,230 --> 00:29:34,169
And pass is this guy.
通过的是这个人。 

683
00:29:34,369 --> 00:29:36,799
And this is pass before the four loop.
这是在四个循环之前通过的。 

684
00:29:36,799 --> 00:29:39,319
And this is pass after the four loop.
这是四个循环之后通过的。 

685
00:29:39,319 --> 00:29:41,149
So I guess this is pass zero.
所以我猜这是通过零。 

686
00:29:41,150 --> 00:29:42,849
And this is pass one.
这是第一关。 

687
00:29:43,049 --> 00:29:46,079
And here, we start with pass zero.
在这里，我们从传递零开始。 

688
00:29:46,079 --> 00:29:48,909
This, we end up with pass one.
这样，我们就获得了第一关。 

689
00:29:48,910 --> 00:29:53,099
OK
好

690
00:29:53,299 --> 00:29:55,746
So we're able to compute this.
这样我们就可以计算出这一点。 

691
00:29:55,747 --> 00:29:57,629
There are many ways of doing this, but in the end,
这样做的方法很多，但最后， 

692
00:29:57,829 --> 00:30:00,250
you want an array that looks like that.
您想要一个看起来像这样的数组。 

693
00:30:00,250 --> 00:30:01,378
This is counting sort.
这是计数排序。 

694
00:30:01,378 --> 00:30:03,419
This is the hard part of counting sort, coming up
这是计数排序的难点，即将到来

695
00:30:03,420 --> 00:30:04,650
with that array.
那个数组。 

696
00:30:04,650 --> 00:30:06,980
Once you come up with that array, you're golden.
一旦提出该阵列，您就很成功。 

697
00:30:06,980 --> 00:30:10,990
So let's see that we're golden and produce an output array
因此，让我们看一下我们是金色的，并产生一个输出数组

698
00:30:10,990 --> 00:30:12,500
with the keys in the right order.
以正确的顺序排列按键。 

699
00:30:12,500 --> 00:30:15,759



700
00:30:15,759 --> 00:30:18,049
So say we have an array called output.
可以这么说，我们有一个称为输出的数组。 

701
00:30:18,049 --> 00:30:21,529
And this is going to have these keys in the right order.
这将使这些键以正确的顺序排列。 

702
00:30:21,529 --> 00:30:24,955
What's the pseudocode for that?
伪代码是什么？ 

703
00:30:24,955 --> 00:30:28,159
First, I'm going to create a new array.
首先，我将创建一个新数组。 

704
00:30:28,160 --> 00:30:32,154
And I'm going to initialize it with n NIL values.
我将使用n个NIL值对其进行初始化。 

705
00:30:32,154 --> 00:30:34,990



706
00:30:34,990 --> 00:30:35,740
Then what do I do?
那我该怎么办？ 

707
00:30:35,740 --> 00:30:40,390



708
00:30:40,390 --> 00:30:41,849
AUDIENCE: Iterate over a.
听众：迭代一个。 

709
00:30:42,049 --> 00:30:44,470
VICTOR COSTAN: Very good.
 VICTOR COSTAN：很好。 

710
00:30:44,470 --> 00:30:47,149
For-- nah, it's too low.
因为，那太低了。 

711
00:30:47,349 --> 00:30:48,457
Let's do it here.
让我们在这里做。 

712
00:30:48,458 --> 00:30:49,253
AUDIENCE: i of a.
听众：我是。 

713
00:30:49,453 --> 00:30:53,440



714
00:30:53,440 --> 00:30:57,950
From zero to n minus 1.
从零到n减1。 

715
00:30:57,950 --> 00:30:59,660
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

716
00:30:59,660 --> 00:31:00,210
What do I do?
我该怎么办？ 

717
00:31:00,210 --> 00:31:03,069



718
00:31:03,069 --> 00:31:12,961
AUDIENCE: Out of [INAUDIBLE] has to be-- oh,
观众：[听不清]必须是哦， 

719
00:31:12,961 --> 00:31:14,450
can we modify pass one as we go?
我们可以在进行时修改通行证吗？ 

720
00:31:14,450 --> 00:31:15,149
VICTOR COSTAN: Yeah.
维克多·科斯坦：是的。 

721
00:31:15,349 --> 00:31:18,750
AUDIENCE: So you could say, out of pos one--
观众：所以您可以说，在第一个位置中， 

722
00:31:18,750 --> 00:31:20,500
VICTOR COSTAN: So by the way, this is pos.
维克多·科斯坦：顺便说一句，这是pos。 

723
00:31:20,500 --> 00:31:22,349
The reason I label them with zero and one,
我将它们标记为零和一的原因， 

724
00:31:22,349 --> 00:31:23,899
so we're doing the change in place.
因此，我们正在进行适当的更改。 

725
00:31:23,900 --> 00:31:24,150
AUDIENCE: Right.
听众：对。 

726
00:31:24,150 --> 00:31:25,407
VICTOR COSTAN: The reason I labeled
 VICTOR COSTAN：我标记的原因

727
00:31:25,607 --> 00:31:27,825
them is to say that this is what pos
他们是说这是pos 

728
00:31:27,825 --> 00:31:29,389
is before we going into the loop.
在我们进入循环之前。 

729
00:31:29,589 --> 00:31:31,599
This is what pos is afterwards.
这就是pos之后的事情。 

730
00:31:31,599 --> 00:31:33,439
But it's a single array.
但这是一个数组。 

731
00:31:33,440 --> 00:31:34,379
So let's call it pos.
所以我们称它为pos。 

732
00:31:34,579 --> 00:31:36,454
So out of pos of--
所以出于以下原因

733
00:31:36,454 --> 00:31:40,329
AUDIENCE: Pos of i equals a to the i.
受众：i的位置等于i。 

734
00:31:40,329 --> 00:31:43,280



735
00:31:43,280 --> 00:31:46,990
Positive i plus pos squared.
正数加正数平方。 

736
00:31:46,990 --> 00:31:48,829
VICTOR COSTAN: Yup.
维克多·波士坦：是的。 

737
00:31:48,829 --> 00:31:51,669
And I'm going to use the CLRS, the way
我将使用CLRS 

738
00:31:51,670 --> 00:31:54,389
which makes me write more.
这让我写得更多。 

739
00:31:54,589 --> 00:31:58,189



740
00:31:58,190 --> 00:31:59,470
So how this work?
那么如何工作？ 

741
00:31:59,470 --> 00:32:01,710
I have the survey here.
我在这里进行调查。 

742
00:32:01,710 --> 00:32:04,169
I start at four.
我从四点开始。 

743
00:32:04,369 --> 00:32:05,750
What's pos of four?
四个的pos是多少？ 

744
00:32:05,750 --> 00:32:08,582



745
00:32:08,582 --> 00:32:10,000
AUDIENCE: Four.
听众：四。 

746
00:32:10,000 --> 00:32:12,569
VICTOR COSTAN: All right, so I'm going
 VICTOR COSTAN：好的，我要走了

747
00:32:12,569 --> 00:32:14,519
to write this as position four.
将此写为位置四。 

748
00:32:14,519 --> 00:32:18,950
I should probably make this a proper array.
我可能应该将其设置为适当的数组。 

749
00:32:18,950 --> 00:32:21,509
One two, three, four, five.
一二三四五。 

750
00:32:21,509 --> 00:32:24,569



751
00:32:24,569 --> 00:32:26,740
So at four, I write four.
所以我四点钟就写四点

752
00:32:26,740 --> 00:32:30,420
And then I increment this guy to become five.
然后我将这个人增加到五个。 

753
00:32:30,420 --> 00:32:34,619



754
00:32:34,819 --> 00:32:36,069
Then I get to one.
然后我进入一个。 

755
00:32:36,069 --> 00:32:38,319
So I look at pos of--
所以我看一下- 

756
00:32:38,319 --> 00:32:39,679
AUDIENCE: One.
听众：一。 

757
00:32:39,680 --> 00:32:42,799
VICTOR COSTAN: And that is zero.
维克多·科斯坦：那是零。 

758
00:32:42,799 --> 00:32:46,579
So I'm going to write one at position zero.
所以我要在零位置写一个。 

759
00:32:46,579 --> 00:32:50,470
And I'm going to increment it.
我将增加它。 

760
00:32:50,470 --> 00:32:51,755
Then I get to 3a.
然后我到达3a。 

761
00:32:51,755 --> 00:32:53,419
I look at positive 3.
我看积极3。 

762
00:32:53,619 --> 00:32:54,599
It says 2.
它说2。 

763
00:32:54,599 --> 00:32:58,792
So I'm going to write 3a here and increment this.
所以我要在这里写3a并增加它。 

764
00:32:58,792 --> 00:33:03,139



765
00:33:03,140 --> 00:33:04,660
Then I get to two.
然后我到两个。 

766
00:33:04,660 --> 00:33:06,707
Pos of two is--
 Pos为两个

767
00:33:06,707 --> 00:33:07,089
AUDIENCE: One.
听众：一。 

768
00:33:07,289 --> 00:33:08,240
VICTOR COSTAN: One.
维克多·科斯坦：一。 

769
00:33:08,240 --> 00:33:10,559
So I write two here.
所以我在这里写两个。 

770
00:33:10,559 --> 00:33:14,529
Pos of two becomes two.
两个的位置变成两个。 

771
00:33:14,529 --> 00:33:19,609
Then I have 3c, which is pos of 3 is now 3.
然后我有3c，现在3的pos是3。 

772
00:33:19,609 --> 00:33:20,789
It's not two anymore.
不再是两个了。 

773
00:33:20,789 --> 00:33:23,869
So yay, I'm not overwriting 3a.
所以，我不会覆盖3a。 

774
00:33:23,869 --> 00:33:24,959
That's good.
那很好。 

775
00:33:24,960 --> 00:33:26,039
And this becomes four.
这变成四个。 

776
00:33:26,039 --> 00:33:31,558



777
00:33:31,558 --> 00:33:33,349
Are people getting what just happened here?
人们了解这里发生的事情了吗？ 

778
00:33:33,349 --> 00:33:35,990



779
00:33:35,990 --> 00:33:41,250
AUDIENCE: Wait, why didn't [INAUDIBLE] to just basically
听众：等等，为什么不[听不清]基本上

780
00:33:41,250 --> 00:33:45,638
train the next array into an index binder?
将下一个数组训练成索引绑定器？ 

781
00:33:45,638 --> 00:33:46,429
VICTOR COSTAN: Yep.
维克多·科斯坦：是的。 

782
00:33:46,430 --> 00:33:49,889
So this guy tells me if I have a key,
所以这个人告诉我是否有钥匙， 

783
00:33:50,089 --> 00:33:52,699
where do I write it in here?
我在哪里写呢？ 

784
00:33:52,700 --> 00:33:56,950
So these start out with pointers to the first element that
因此，这些开始于指向第一个元素的指针

785
00:33:56,950 --> 00:33:58,240
would store that key value.
将存储该键值。 

786
00:33:58,240 --> 00:34:01,910
And when I store a key, say when I start 3a, when I get to 3c,
当我存储密钥时，比如说我从3a开始，到3c， 

787
00:34:01,910 --> 00:34:03,769
I don't want to store it in the same place.
我不想将其存储在同一位置。 

788
00:34:03,769 --> 00:34:05,279
So I have to increment that.
所以我必须增加它。 

789
00:34:05,279 --> 00:34:07,910
I have to say, yo, I wrote 3a at position two.
我必须说，哟，我在第二位置写了3a。 

790
00:34:07,910 --> 00:34:10,510
So next time, write it-- next time you
所以下次再写一次

791
00:34:10,510 --> 00:34:13,090
see a three, right it at the position following that.
看到三个，将其放在紧随其后的位置。 

792
00:34:13,289 --> 00:34:16,750
And that's what this guy does.
这就是那个家伙所做的。 

793
00:34:16,750 --> 00:34:19,989



794
00:34:19,989 --> 00:34:22,710
So this is the relatively easy part.
因此，这是相对容易的部分。 

795
00:34:22,710 --> 00:34:26,159
And this is the hard magic in counting sort.
这是计数排序中的难点。 

796
00:34:26,159 --> 00:34:30,269



797
00:34:30,269 --> 00:34:33,289
So how are people feeling about it now?
那么人们现在对此感觉如何？ 

798
00:34:33,289 --> 00:34:35,969



799
00:34:35,969 --> 00:34:39,425
Any nods, or is still confusing as hell?
有没有点头，还是仍然感到困惑？ 

800
00:34:39,425 --> 00:34:40,299
AUDIENCE: It's a lot.
听众：很多。 

801
00:34:40,300 --> 00:34:43,340
I'm confused.
我糊涂了。 

802
00:34:43,340 --> 00:34:46,230
VICTOR COSTAN: OK.
维克多·科斯坦：好的。 

803
00:34:46,230 --> 00:34:47,690
Well what should we do?
那么我们该怎么办？ 

804
00:34:47,690 --> 00:34:49,690
Do you guys want to ask more questions?
你们想问更多问题吗？ 

805
00:34:49,690 --> 00:34:52,815
Do you want to run through another example?
您是否想通过另一个例子？ 

806
00:34:52,815 --> 00:34:55,750
Do you want to try to see how this becomes useful in radix
您是否想尝试一下这在基数中变得有用吗

807
00:34:55,750 --> 00:34:58,719
sort, so that you're motivated to figure it out on your own?
排序，以便您有动力自行解决？ 

808
00:34:58,719 --> 00:35:00,569
What would make more sense?
什么更有意义？ 

809
00:35:00,570 --> 00:35:01,070
All right.
好吧。 

810
00:35:01,070 --> 00:35:03,710
Who wants to do more count sort?
谁想做更多的计数排序？ 

811
00:35:03,710 --> 00:35:06,199
Who wants to do some radix sort.
谁想做一些基数排序。 

812
00:35:06,199 --> 00:35:07,189
All right.
好吧。 

813
00:35:07,190 --> 00:35:07,750
Radix sort it is.
基数排序。 

814
00:35:07,949 --> 00:35:10,398



815
00:35:10,398 --> 00:35:12,440
Next time you want to move on, tell me understood
下次您要继续前进时，请告诉我

816
00:35:12,440 --> 00:35:13,434
and I'll believe you.
我会相信你的

817
00:35:13,434 --> 00:35:14,400
And it'll look good on tape.
在磁带上看起来会很好。 

818
00:35:14,599 --> 00:35:17,309



819
00:35:17,309 --> 00:35:18,389
Two, three--
二三 - 

820
00:35:18,389 --> 00:35:20,056
AUDIENCE: You're not supposed to tell us
听众：你不应该告诉我们

821
00:35:20,056 --> 00:35:21,630
that there's a camera in here.
那里有一台照相机。 

822
00:35:21,630 --> 00:35:24,090
VICTOR COSTAN: One, four.
维克多·科斯坦：一，四。 

823
00:35:24,090 --> 00:35:26,339
I think you're supposed to know, because otherwise you
我认为您应该知道，因为否则

824
00:35:26,340 --> 00:35:30,210
don't know that we're violating your rights.
不知道我们侵犯了您的权利。 

825
00:35:30,409 --> 00:35:31,329
Two, four--
二四

826
00:35:31,329 --> 00:35:34,250
AUDIENCE: This is out the door.
听众：这是门外。 

827
00:35:34,250 --> 00:35:44,090
VICTOR COSTAN: One, two, four, three, two, one, four, three.
维克多·科斯坦：一，二，四，三，二，一，四，三。 

828
00:35:44,090 --> 00:35:44,875
And one more.
还有一个。 

829
00:35:45,074 --> 00:35:48,119
One, two, three, four.
一二三四。 

830
00:35:48,119 --> 00:35:50,150
So this is to refresh your memory.
因此，这是为了刷新您的记忆。 

831
00:35:50,150 --> 00:35:54,800
What do keys look like in merge and radix sort?
合并和基数排序中的键是什么样的？ 

832
00:35:54,800 --> 00:35:58,380
So in concert, the keys have to be numbers from 0 to k minus 1.
因此，一致地，密钥必须是0到k减去1的数字。 

833
00:35:58,579 --> 00:35:59,480
How about merge sort?
合并排序如何？ 

834
00:35:59,480 --> 00:36:00,507
What do keys look like?
钥匙是什么样的？ 

835
00:36:00,507 --> 00:36:10,559



836
00:36:10,559 --> 00:36:16,079
So radix sort says that a key is a sequence of digits.
因此，基数排序表示键是数字序列。 

837
00:36:16,079 --> 00:36:21,009
Say you have d digits in a key.
假设您的密钥中有d位数字。 

838
00:36:21,010 --> 00:36:23,880
But then each digit isn't necessarily a base 10 digit
但是，然后每个数字不一定是以10为基数的数字

839
00:36:23,880 --> 00:36:25,039
like we're used to.
就像我们习惯了

840
00:36:25,239 --> 00:36:27,919
Each digit is in base k.
每个数字以k为底。 

841
00:36:27,920 --> 00:36:31,940
So each digit can be from 0 to k minus 1.
因此，每个数字可以从0到k减去1。 

842
00:36:31,940 --> 00:36:36,820
And we're using base k.
而且我们正在使用基数k。 

843
00:36:36,820 --> 00:36:39,230
How many keys can I represent this way?
我可以用这种方式代表多少个钥匙？ 

844
00:36:39,230 --> 00:36:41,940



845
00:36:41,940 --> 00:36:44,309
So if you have numbers of n digits in base k,
因此，如果以k为底的数字为n位数字， 

846
00:36:44,309 --> 00:36:46,309
what's the biggest number that we can represent,
我们能代表的最大数字是多少

847
00:36:46,309 --> 00:36:48,389
or how many numbers can we represent with that?
或我们可以用多少个数字表示？ 

848
00:36:48,389 --> 00:36:49,596
AUDIENCE: n to the k.
听众：n至k。 

849
00:36:49,795 --> 00:36:53,078
No, d to the k.
不，d到k。 

850
00:36:53,079 --> 00:36:54,574
Right?
对？ 

851
00:36:54,773 --> 00:36:55,690
VICTOR COSTAN: Almost.
维克多·科斯坦：差不多了。 

852
00:36:55,690 --> 00:36:56,856
AUDIENCE: [INAUDIBLE] the d.
听众：[听不清] d。 

853
00:36:56,856 --> 00:37:00,278



854
00:37:00,478 --> 00:37:01,519
VICTOR COSTAN: All right.
维克多·科斯坦：好的。 

855
00:37:01,519 --> 00:37:03,900
So if our base is two, like if we're using bits,
因此，如果我们的底数是2，就像我们在使用位， 

856
00:37:03,900 --> 00:37:05,630
then our base is two.
那么我们的基数是两个

857
00:37:05,630 --> 00:37:08,010
And if I have eight bits, then two to the eight.
如果我有八位，那么二到八位。 

858
00:37:08,010 --> 00:37:10,400



859
00:37:10,599 --> 00:37:11,329
Cool.
凉。 

860
00:37:11,329 --> 00:37:14,489
So if I add one more digit, I get
所以如果再加上一位，我得到

861
00:37:14,489 --> 00:37:19,799
to multiply the number of keys I represent by k.
将我代表的键数乘以k。 

862
00:37:19,800 --> 00:37:21,650
How do I radix sort?
我如何对基数排序？ 

863
00:37:21,849 --> 00:37:24,610
Does anyone remember?
有人记得吗？ 

864
00:37:24,610 --> 00:37:28,692
AUDIENCE: We checked the log base k of everything.
观众：我们检查了所有内容的对数基数k。 

865
00:37:28,692 --> 00:37:32,329
I guess log base d.
我猜对数为D。 

866
00:37:32,329 --> 00:37:33,259
Oh, k.
哦，k。 

867
00:37:33,260 --> 00:37:34,190
It's based in--
它基于- 

868
00:37:34,190 --> 00:37:34,329
VICTOR COSTAN: No.
维克多·科斯坦：不。 

869
00:37:34,329 --> 00:37:35,340
That would be hard math.
那将是很难的数学运算。 

870
00:37:35,340 --> 00:37:36,820
We don't do hard math.
我们不做硬数学。 

871
00:37:36,820 --> 00:37:40,340
In sorting, if you have integers going into your sort,
在排序中，如果要输入整数

872
00:37:40,340 --> 00:37:41,690
you only do integer operations.
您只能执行整数运算。 

873
00:37:41,690 --> 00:37:43,690
You don't do anything math beyond them.
除了它们，您什么也不会做。 

874
00:37:43,690 --> 00:37:51,829



875
00:37:51,829 --> 00:37:54,519
So what we do is we've broken up the keys
因此，我们要做的是分解密钥

876
00:37:54,519 --> 00:37:55,949
into d digits for a reason.
变成d位数字是有原因的。 

877
00:37:55,949 --> 00:37:59,029
We're going to have d rounds in the sort.
我们将进行d回合。 

878
00:37:59,030 --> 00:38:03,659
And in each round, we're going to take all the keys
在每一轮中，我们将掌握所有关键

879
00:38:03,659 --> 00:38:04,000
that we have.
我们有。 

880
00:38:04,199 --> 00:38:08,939
And we're going to sort them according to one of the digits.
我们将根据数字之一对它们进行排序。 

881
00:38:08,940 --> 00:38:11,800
So in one round, we'll sort them according to this digit.
因此，在一轮中，我们将根据该数字对其进行排序。 

882
00:38:11,800 --> 00:38:13,539
In one round, we'll sort them according
在一轮中，我们将根据

883
00:38:13,539 --> 00:38:15,690
to this digit, this digit, this digit.
到这个数字，这个数字，这个数字。 

884
00:38:15,690 --> 00:38:18,750



885
00:38:18,750 --> 00:38:20,579
Which digit do we start with?
我们以哪个数字开头？ 

886
00:38:20,579 --> 00:38:21,987
What do you guys think?
你们有什么感想？ 

887
00:38:21,987 --> 00:38:23,899
AUDIENCE: To least significant digit, right?
听众：最低有效位数，对不对？ 

888
00:38:23,900 --> 00:38:25,490
AUDIENCE: And most significant on the left.
听众：最重要的在左边。 

889
00:38:25,690 --> 00:38:29,829



890
00:38:29,829 --> 00:38:32,271
VICTOR COSTAN: So this or this?
维克多·科斯坦：那么这个还是这个？ 

891
00:38:32,271 --> 00:38:33,579
AUDIENCE: The right side.
听众：右边。 

892
00:38:33,579 --> 00:38:36,179
AUDIENCE: 100 is bigger than 1, even
听众：100大于1，甚至

893
00:38:36,179 --> 00:38:41,219
though the 1 is greater than the 0 in 100.
尽管1大于100中的0。 

894
00:38:41,219 --> 00:38:42,760
VICTOR COSTAN: You're helping me out.
维克多·科斯坦：您正在帮助我。 

895
00:38:42,760 --> 00:38:44,730
So the point I'm trying to make here
所以我要在这里提出的要点

896
00:38:44,730 --> 00:38:47,280
is radix sort is unintuitive.
是基数排序是不直观的。 

897
00:38:47,280 --> 00:38:49,068
If we ask you on a quiz what do you start with,
如果我们在测验中问您从什么开始， 

898
00:38:49,268 --> 00:38:50,809
your intuition will tell you to start
你的直觉会告诉你开始

899
00:38:50,809 --> 00:38:52,460
with the most significant digit.
最高有效位数。 

900
00:38:52,460 --> 00:38:53,876
Go against it.
反对它。 

901
00:38:53,876 --> 00:38:56,726
In radix sort, you start with the least significant digit
在基数排序中，您从最低有效数字开始

902
00:38:56,726 --> 00:38:57,849
and then move your way out.
然后走出自己的路。 

903
00:38:57,849 --> 00:39:02,333
So radix sort goes like this.
所以基数排序是这样的。 

904
00:39:02,333 --> 00:39:03,673
AUDIENCE: I mean, it does make sense,
听众：我的意思是，这确实有道理， 

905
00:39:03,873 --> 00:39:05,961
because you don't have very much information unless you're
因为除非您

906
00:39:05,961 --> 00:39:06,766
looking at bits.
看着位。 

907
00:39:06,766 --> 00:39:09,175
You can get a bunch of twos, but that
你可以得到一堆二，但那

908
00:39:09,175 --> 00:39:10,621
doesn't give you much information.
没有给您太多信息。 

909
00:39:10,621 --> 00:39:12,399
The most information is the smallest bit.
信息最多的是最小的位。 

910
00:39:12,400 --> 00:39:14,471
And then you move up from there.
然后您从那里向上移动。 

911
00:39:14,670 --> 00:39:16,419
VICTOR COSTAN: It depends what information
 VICTOR COSTAN：这取决于哪些信息

912
00:39:16,420 --> 00:39:17,530
you're trying to get.
你想得到。 

913
00:39:17,530 --> 00:39:20,610
But maybe you know the algorithm, so you're thinking,
但是也许您知道算法，所以您在考虑， 

914
00:39:20,809 --> 00:39:22,469
oh, by knowing the algorithm, I know
哦，通过了解算法，我知道

915
00:39:22,469 --> 00:39:24,699
that I'll have the most information
我将获得最多的信息

916
00:39:24,699 --> 00:39:26,299
by looking at it this way.
通过这种方式看它。 

917
00:39:26,300 --> 00:39:30,050
All right, so let's sort these by the last digit.
好吧，让我们按最后一位排序。 

918
00:39:30,050 --> 00:39:30,789
Sweet.
甜。 

919
00:39:30,989 --> 00:39:33,659
Let's sort them by the digit, by the digit
让我们按数字，数字对它们进行排序

920
00:39:33,659 --> 00:39:35,969
before the last digit.
最后一位之前。 

921
00:39:35,969 --> 00:39:38,021
What do I have to do in my sorting?
排序时我该怎么办？ 

922
00:39:38,021 --> 00:39:39,480
What do I have to pay attention to?
我要注意什么？ 

923
00:39:39,480 --> 00:39:43,380



924
00:39:43,380 --> 00:39:46,280
So the sorting method that I use has to have a property.
因此，我使用的排序方法必须具有一个属性。 

925
00:39:46,280 --> 00:39:47,780
It can't be any kind of sorting.
不能进行任何排序。 

926
00:39:47,780 --> 00:39:50,251



927
00:39:50,251 --> 00:39:50,750
Stable.
稳定。 

928
00:39:50,750 --> 00:39:55,460



929
00:39:55,460 --> 00:39:57,789
So the reason we went through all this pain in counting sort
所以我们在计算排序时经历了所有这些痛苦的原因

930
00:39:57,989 --> 00:40:00,839
is because we want to have a stable sort here.
是因为我们希望在这里有一个稳定的排序。 

931
00:40:00,840 --> 00:40:05,750
Now, let's try to sort these in a stable manner.
现在，让我们尝试以稳定的方式对它们进行排序。 

932
00:40:05,750 --> 00:40:09,110
This is the first one, two, four, one, three.
这是第一个，两个，四个，一个，三个。 

933
00:40:09,110 --> 00:40:15,653
Then I have two threes, so one, four, three, two, one, two,
然后我有两个三，所以一，四，三，二，一，二

934
00:40:15,853 --> 00:40:16,779
three, four.
三四。 

935
00:40:16,780 --> 00:40:19,960
And then I have three fours.
然后我有三个四分之一。 

936
00:40:20,159 --> 00:40:22,159
Two, three, four, one.
二，三，四，一。 

937
00:40:22,159 --> 00:40:24,659
Two, four, one, three.
二，四，一，三

938
00:40:24,659 --> 00:40:27,319
Two, one, four, three.
二，一，四，三

939
00:40:27,320 --> 00:40:28,340
Way this isn't good.
这样不好。 

940
00:40:28,340 --> 00:40:32,860



941
00:40:32,860 --> 00:40:35,559
Two, three, four, one.
二，三，四，一。 

942
00:40:35,559 --> 00:40:36,735
One, two, four, three.
一二三四

943
00:40:36,735 --> 00:40:38,518
AUDIENCE: You should cross them off if you write them down.
听众：如果将它们写下来，则应将其划掉。 

944
00:40:38,717 --> 00:40:39,716
VICTOR COSTAN: I should.
维克多·科斯坦：我应该。 

945
00:40:39,717 --> 00:40:43,250



946
00:40:43,449 --> 00:40:47,019
I was hoping you guys would help me if I mess up.
我希望你们能帮上我的忙。 

947
00:40:47,019 --> 00:40:48,900
So now these are sorted stably.
因此，现在这些已稳定地排序。 

948
00:40:48,900 --> 00:40:53,329
Let's look at these last three that have the same digit here.
让我们看看这最后三个具有相同数字的数字。 

949
00:40:53,329 --> 00:40:54,900
So they have the same four.
因此它们具有相同的四个。 

950
00:40:54,900 --> 00:40:57,360
If you look at the last digit, because I
如果你看最后一位数字，因为我

951
00:40:57,360 --> 00:40:59,849
used a stable sorting, they're also
使用了稳定的排序， 

952
00:40:59,849 --> 00:41:02,230
sorted according to this last digit.
根据最后一位排序。 

953
00:41:02,230 --> 00:41:05,769
So they're sorted according to these last two digits,
因此，它们是根据最后两位数字排序的， 

954
00:41:05,769 --> 00:41:08,139
because the sorting that I used is stable.
因为我使用的排序是稳定的。 

955
00:41:08,139 --> 00:41:11,739
So now if I sort according to this digit,
所以现在如果我按照这个数字排序， 

956
00:41:11,739 --> 00:41:13,569
then if my sorting is stable, they're
如果我的排序稳定，那么他们

957
00:41:13,570 --> 00:41:17,150
going to be sorted according to the last three digits.
将根据最后三位数进行排序。 

958
00:41:17,349 --> 00:41:21,299
So as I go from my last digit to my first digit,
因此，当我从最后一位转到第一位时， 

959
00:41:21,300 --> 00:41:23,300
the keys are going to be sorted according
键将根据

960
00:41:23,300 --> 00:41:25,550
to the last digit, the last two digits, the last three
到最后一位数字，最后两位数字，最后三个

961
00:41:25,550 --> 00:41:28,190
digits, and then all the way up to everything.
数字，然后一直到所有内容。 

962
00:41:28,190 --> 00:41:29,760
This is why I need a stable sort.
这就是为什么我需要一种稳定的排序方式。 

963
00:41:29,760 --> 00:41:32,034
And also, this is why I need to start from the end.
而且，这就是为什么我需要从头开始。 

964
00:41:32,034 --> 00:41:39,960



965
00:41:40,159 --> 00:41:42,869
Does this make some sense?
这有意义吗？ 

966
00:41:42,869 --> 00:41:46,750
What stable sort did we just learn?
我们刚刚学到了什么稳定的排序？ 

967
00:41:46,750 --> 00:41:48,581
AUDIENCE: Counting.
听众：数数。 

968
00:41:48,581 --> 00:41:49,789
VICTOR COSTAN: Counting sort.
维克多·科斯坦：计数排序。 

969
00:41:49,789 --> 00:41:50,289
All right.
好吧。 

970
00:41:50,289 --> 00:41:52,929
So we're going to use counting sort for this.
因此，我们将为此使用计数排序。 

971
00:41:52,929 --> 00:41:54,679
What's the running time for one round?
一轮的时间是多少？ 

972
00:41:54,679 --> 00:41:57,519
So for one sorting.
因此，进行一种排序。 

973
00:41:57,519 --> 00:41:59,219
One counting sort takes how much time?
一种计数需要花费多少时间？ 

974
00:41:59,219 --> 00:42:02,093



975
00:42:02,094 --> 00:42:04,559
AUDIENCE: This is a radix sort.
听众：这是一个基数排序。 

976
00:42:04,559 --> 00:42:05,150
VICTOR COSTAN: Yes.
维克多·科斯坦：是的。 

977
00:42:05,349 --> 00:42:08,619
So radix sort is d rounds of counting sort.
因此，基数排序是d轮计数排序。 

978
00:42:08,619 --> 00:42:10,319
Count sort this, count sort this,
算一下，算一下， 

979
00:42:10,320 --> 00:42:12,690
count sort this, count sort this.
算一下，算一下。 

980
00:42:12,889 --> 00:42:15,549
So one round, one counting sort, what's the running time?
那么一轮，一种计数，运行时间是多少？ 

981
00:42:15,550 --> 00:42:18,056



982
00:42:18,255 --> 00:42:19,609
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

983
00:42:19,610 --> 00:42:20,451
VICTOR COSTAN: Thank you.
维克多·科斯坦：谢谢。 

984
00:42:20,650 --> 00:42:23,839



985
00:42:23,840 --> 00:42:31,750
Now how about d of these plus the running time?
现在，其中的d和运行时间如何？ 

986
00:42:31,750 --> 00:42:33,202
AUDIENCE: dn plus b.
听众：dn加b。 

987
00:42:33,202 --> 00:42:40,480



988
00:42:40,480 --> 00:42:43,039
VICTOR COSTAN: OK, but I want to come back here.
维克多·科斯坦：好的，但是我想回到这里。 

989
00:42:43,039 --> 00:42:46,449
And I want to be able to say that radix sort is optimal.
我想说基数排序是最佳的。 

990
00:42:46,449 --> 00:42:50,779
I want to be able to say that it is order n.
我想可以说这是n阶。 

991
00:42:50,780 --> 00:42:53,635
So what do I have to do in order to be able to say that?
那么，我必须做什么才能这样说？ 

992
00:42:53,635 --> 00:42:58,610



993
00:42:58,809 --> 00:43:02,549
AUDIENCE: [INAUDIBLE] k equal to m.
听众：[听不清] k等于m。 

994
00:43:02,550 --> 00:43:05,250
VICTOR COSTAN: So you're going from-- you know the answer.
维克多·科斯坦（VICTOR COSTAN）：所以您要走了，您就知道答案了。 

995
00:43:05,449 --> 00:43:07,615
You're going from the fact that you know the answer.
您从知道答案的事实出发。 

996
00:43:07,615 --> 00:43:08,659
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

997
00:43:08,659 --> 00:43:09,509
VICTOR COSTAN: OK, very good.
 VICTOR COSTAN：好的，很好。 

998
00:43:09,510 --> 00:43:11,010
What if we wouldn't know the answer?
如果我们不知道答案怎么办？ 

999
00:43:11,010 --> 00:43:12,525
What do I need to do?
我需要做什么？ 

1000
00:43:12,724 --> 00:43:14,807
AUDIENCE: Well, we know the first part is order n.
听众：好吧，我们知道第一部分是n阶。 

1001
00:43:14,807 --> 00:43:16,188
So--
所以 - 

1002
00:43:16,188 --> 00:43:17,480
VICTOR COSTAN: So d has to be--
维克多·科斯坦：所以必须- 

1003
00:43:17,480 --> 00:43:21,400
AUDIENCE: We want dn to be greater than dk, right?
听众：我们希望dn大于dk，对不对？ 

1004
00:43:21,400 --> 00:43:23,269
VICTOR COSTAN: Well, so dn.
维克多·科斯坦：恩，所以。 

1005
00:43:23,469 --> 00:43:26,817
dn has to be, at most, o of n, right.
 dn最多只能是n个中的o个。 

1006
00:43:26,817 --> 00:43:28,900
Because otherwise, the whole thing would go above.
因为否则，整个事情将会超越。 

1007
00:43:28,900 --> 00:43:30,150
So that wouldn't work.
所以那是行不通的。 

1008
00:43:30,150 --> 00:43:34,000
So then what can I say about d?
那么关于d我能说什么呢？ 

1009
00:43:34,000 --> 00:43:35,340
AUDIENCE: Constant.
听众：不变。 

1010
00:43:35,340 --> 00:43:36,181
VICTOR COSTAN: Very good.
 VICTOR COSTAN：很好。 

1011
00:43:36,380 --> 00:43:38,402
And how do you write constants in math mode?
以及如何在数学模式下编写常数？ 

1012
00:43:38,402 --> 00:43:39,509
AUDIENCE: Order one.
听众：第一。 

1013
00:43:39,509 --> 00:43:40,550
VICTOR COSTAN: Very good.
 VICTOR COSTAN：很好。 

1014
00:43:40,550 --> 00:43:41,860
So d has to be order one.
因此，d必须为一。 

1015
00:43:42,059 --> 00:43:44,980
Otherwise, it's not going to come out to that.
否则，就不会出现这种情况。 

1016
00:43:44,980 --> 00:43:46,289
Now, what else do we know?
现在，我们还知道什么？ 

1017
00:43:46,489 --> 00:43:50,699
We have this that's order n plus k.
我们的阶次为n加k。 

1018
00:43:50,699 --> 00:43:52,939
If I said this to be a lot smaller than k,
如果我说这个比k小很多， 

1019
00:43:52,940 --> 00:43:56,820
if I set it to be log n, it's going to be order n.
如果我将其设置为log n，则将为n。 

1020
00:43:56,820 --> 00:44:01,900
If I set it k to be a constant, if I use bits,
如果我将k设置为常数，如果我使用位， 

1021
00:44:01,900 --> 00:44:05,500
if I use base 2-- so I said k equal 2-- this is still
如果我使用基数2--所以我说k等于2-这仍然是

1022
00:44:05,500 --> 00:44:07,079
going to be order n.
将被命令n。 

1023
00:44:07,079 --> 00:44:09,739
So if k goes way below n, this step
因此，如果k低于n，则此步骤

1024
00:44:09,739 --> 00:44:11,359
is still going to be order n.
仍然是订单n。 

1025
00:44:11,360 --> 00:44:13,974
So I might as well set k as high as possible.
所以我可能将k设置得尽可能高。 

1026
00:44:13,974 --> 00:44:17,549



1027
00:44:17,550 --> 00:44:21,130
So k is order n, because that's the highest
所以k是n阶，因为那是最高的

1028
00:44:21,329 --> 00:44:22,650
thing I could set it to.
我可以将其设置为。 

1029
00:44:22,650 --> 00:44:25,119
Now why do I want to do that?
现在为什么要这样做？ 

1030
00:44:25,119 --> 00:44:26,373
Yes, you have a ques--
是的，您有疑问- 

1031
00:44:26,373 --> 00:44:29,145
AUDIENCE: [INAUDIBLE] represent in counting sort again?
听众：[听不清]又在计数排序中代表？ 

1032
00:44:29,146 --> 00:44:31,152
The length of what?
长度是多少？ 

1033
00:44:31,351 --> 00:44:32,809
VICTOR COSTAN: So in counting sort,
 VICTOR COSTAN：因此，从数量上来说， 

1034
00:44:32,809 --> 00:44:37,230
n is your input, how many keys you have.
 n是您的输入，即您有多少个键。 

1035
00:44:37,230 --> 00:44:41,150
And k is the size of this array.
 k是此数组的大小。 

1036
00:44:41,150 --> 00:44:41,858
AUDIENCE: Oh, OK.
听众：哦，好。 

1037
00:44:41,858 --> 00:44:43,690
VICTOR COSTAN: So you have to be able to map
 VICTOR COSTAN：因此，您必须能够绘制地图

1038
00:44:43,690 --> 00:44:45,089
your keys from 0 to k minus 1.
您的密钥从0到k减1。 

1039
00:44:45,090 --> 00:44:46,961
AUDIENCE: It's set by n, basically.
听众：基本上由n设置。 

1040
00:44:46,961 --> 00:44:48,369
Or it's set by the elements.
或者由元素设置。 

1041
00:44:48,369 --> 00:44:48,759
VICTOR COSTAN: Yeah.
维克多·科斯坦：是的。 

1042
00:44:48,760 --> 00:44:49,914
It's set by the nature of the keys.
它由按键的性质设置。 

1043
00:44:50,114 --> 00:44:50,389
AUDIENCE: OK.
听众：好的。 

1044
00:44:50,389 --> 00:44:50,909
Got it.
得到它了。 

1045
00:44:50,909 --> 00:44:52,451
VICTOR COSTAN: So in real life, we're
维克多·科斯坦：在现实生活中，我们

1046
00:44:52,451 --> 00:44:55,519
thinking maybe we have some huge numbers that we want to sort.
想也许我们有一些我们想排序的数字。 

1047
00:44:55,519 --> 00:44:57,829
And we're going to chunk them up into-- when we're
当我们将

1048
00:44:57,829 --> 00:44:59,329
writing on the board, we always have
在黑板上写字，我们总是

1049
00:44:59,329 --> 00:45:00,828
to chunk them up in base 10 digits,
将它们以10位为基数

1050
00:45:00,829 --> 00:45:02,670
because that's the only way we know how to write.
因为那是我们知道怎么写的唯一方法。 

1051
00:45:02,869 --> 00:45:05,889
But in a computer memory, we can chunk them up into, say,
但是在计算机内存中，我们可以将它们分成例如

1052
00:45:05,889 --> 00:45:08,440
base 10,000 digits.
基本10,000位数。 

1053
00:45:08,440 --> 00:45:10,440
And the fewer digits you have, the faster
位数越少越快

1054
00:45:10,440 --> 00:45:11,380
this is going to run.
这将要运行。 

1055
00:45:11,380 --> 00:45:14,480
So we have to figure out what's the base.
因此，我们必须找出基础。 

1056
00:45:14,480 --> 00:45:15,940
And it turns out that if you want
事实证明，如果你想

1057
00:45:15,940 --> 00:45:19,679
to have radix sort run in order and time, well,
让基数排序按时间顺序运行

1058
00:45:19,679 --> 00:45:24,389
the number of digits has to be sort of constant.
数字位数必须是常数。 

1059
00:45:24,389 --> 00:45:27,210
I know that k should be order n, because I
我知道k应该是n阶，因为我

1060
00:45:27,210 --> 00:45:30,320
have no interest in making it lower than that.
没有兴趣使其低于此值。 

1061
00:45:30,320 --> 00:45:32,050
So these two bounds together tell me
所以这两个界限一起告诉我

1062
00:45:32,050 --> 00:45:36,666
that the keys that I can sort are from zero
我可以排序的键从零开始

1063
00:45:36,666 --> 00:45:42,610
up to order n of order one.
直到第一阶的n。 

1064
00:45:42,610 --> 00:45:45,940
And this looks terrible, but what it comes up to
这看起来很糟糕，但是结果如何

1065
00:45:45,940 --> 00:45:49,690
is that you can sort keys that look
是您可以对看起来像

1066
00:45:49,690 --> 00:45:52,639
like n to some constant for any constant.
像n到某个常数。 

1067
00:45:52,639 --> 00:45:55,629



1068
00:45:55,630 --> 00:45:59,690
So you can sort huge keys, as long as huge still
因此，您可以对大型键进行排序，只要仍然

1069
00:45:59,690 --> 00:46:00,260
means finite.
表示有限。 

1070
00:46:00,260 --> 00:46:04,070



1071
00:46:04,070 --> 00:46:06,780
And as long as you can figure out how to map them to numbers.
并且只要您能弄清楚如何将它们映射到数字。 

1072
00:46:06,780 --> 00:46:09,860



1073
00:46:10,059 --> 00:46:13,170
Does this make some sense?
这有意义吗？ 

1074
00:46:13,170 --> 00:46:15,750
Would we ever want to use merge sort instead of counting sort?
我们是否要使用合并排序而不是计数排序？ 

1075
00:46:15,949 --> 00:46:17,869
Suppose we had a stable merge sort.
假设我们有一个稳定的合并排序。 

1076
00:46:17,869 --> 00:46:24,070
Would we want to use that instead of counting sort here?
我们要使用它而不是在此处计算排序吗？ 

1077
00:46:24,070 --> 00:46:24,819
What would happen?
会发生什么？ 

1078
00:46:24,820 --> 00:46:32,300



1079
00:46:32,300 --> 00:46:33,130
So suppose it's stable.
因此，假设它是稳定的。 

1080
00:46:33,329 --> 00:46:34,009
So it's correct.
所以这是正确的。 

1081
00:46:34,010 --> 00:46:35,351
The algorithm isn't going to blow up.
该算法不会爆炸。 

1082
00:46:35,550 --> 00:46:37,273
What's the running time for merge sort?
合并排序的运行时间是多少？ 

1083
00:46:37,273 --> 00:46:44,380



1084
00:46:44,380 --> 00:46:46,880
So if I use a merge sort.
因此，如果我使用合并排序。 

1085
00:46:46,880 --> 00:46:50,760
So if I use the merge sort, it's going to be d times n log n.
因此，如果使用合并排序，它将是d乘以n log n。 

1086
00:46:50,760 --> 00:46:52,980
So no matter how small d is, I'm still
所以无论d多么小，我仍然

1087
00:46:52,980 --> 00:46:55,190
not running in linear time.
不在线性时间内运行。 

1088
00:46:55,190 --> 00:46:57,657
So merge sort does not go well with radix sort.
因此，合并排序与基数排序不太匹配。 

1089
00:46:57,657 --> 00:47:01,340



1090
00:47:01,340 --> 00:47:03,280
So from my end, we're pretty much done.
因此，从我的角度来看，我们已经完成了许多工作。 

1091
00:47:03,280 --> 00:47:04,730
We started with n log n.
我们从n log n开始。 

1092
00:47:04,730 --> 00:47:08,217
And we got to a sorting algorithm that's order n.
然后我们得到一个排序为n的排序算法。 

1093
00:47:08,217 --> 00:47:10,300
We started at the beginning of [INAUDIBLE], saying
我们从[音频不清晰]的开头开始说

1094
00:47:10,300 --> 00:47:13,090
that the best thing we can do is omega--
我们能做的最好的事情就是欧米茄- 

1095
00:47:13,090 --> 00:47:14,960
is that omega-- omega of n.
是那个欧米茄-n的欧米茄。 

1096
00:47:15,159 --> 00:47:16,050
We got to that limit.
我们达到了那个极限。 

1097
00:47:16,050 --> 00:47:16,549
We're happy.
很高兴。 

1098
00:47:16,550 --> 00:47:17,750
We're going to be done with sorting.
我们将完成排序。 

1099
00:47:17,949 --> 00:47:19,139
Any questions from you guys?
你们有什么问题吗？ 

1100
00:47:19,139 --> 00:47:23,911



1101
00:47:23,911 --> 00:47:25,494
That means everyone's confused, right?
那意味着每个人都很困惑，对吧？ 

1102
00:47:25,494 --> 00:47:26,359
Yes, thank you.
是的，谢谢。 

1103
00:47:26,360 --> 00:47:28,610
AUDIENCE: Can you explain what the stability criteria
听众：您能解释一下稳定性标准吗

1104
00:47:28,610 --> 00:47:29,512
is again?
再来一次？ 

1105
00:47:29,512 --> 00:47:30,144
VICTOR COSTAN: The--
维克多·科斯坦： 

1106
00:47:30,344 --> 00:47:34,989
AUDIENCE: Stability for these sorting algorithms.
听众：这些排序算法的稳定性。 

1107
00:47:34,989 --> 00:47:37,031
Which ones are stable and what makes it unstable?
哪些是稳定的，什么使它不稳定？ 

1108
00:47:37,032 --> 00:47:38,530
VICTOR COSTAN: All right, very good.
维克多·科斯坦：好的，很好。 

1109
00:47:38,530 --> 00:47:39,159
Thank you.
谢谢。 

1110
00:47:39,159 --> 00:47:41,420
So I like especially the last part,
所以我特别喜欢最后一部分， 

1111
00:47:41,420 --> 00:47:42,673
with which ones are stable.
与哪些是稳定的。 

1112
00:47:42,673 --> 00:47:43,840
I'd like to go through that.
我想经历一下。 

1113
00:47:43,840 --> 00:47:46,210
So a stable sorting algorithm means
因此，稳定的排序算法意味着

1114
00:47:46,409 --> 00:47:49,299
that if you have two keys that are equal,
如果您有两个相等的键， 

1115
00:47:49,300 --> 00:47:51,480
the key that shows up first in the input
输入中首先显示的键

1116
00:47:51,480 --> 00:47:55,610
is the key that is produced to the output.
是产生到输出的密钥。 

1117
00:47:55,610 --> 00:47:58,920
So in this model, your keys are not necessarily integers.
因此，在此模型中，您的键不一定是整数。 

1118
00:47:58,920 --> 00:48:00,750
Your keys might be those weird classes
你的钥匙可能是那些奇怪的类

1119
00:48:00,949 --> 00:48:04,879
that implement some method that maps them to integers.
实现一些将它们映射为整数的方法。 

1120
00:48:04,880 --> 00:48:08,664
So say there is a method there, __int__,
所以说那里有一种方法，__ int__， 

1121
00:48:08,664 --> 00:48:11,880
that gives you the integer for that.
给你的整数。 

1122
00:48:11,880 --> 00:48:14,750
So the sorting algorithm would only see a three here.
因此，排序算法在这里只会看到3。 

1123
00:48:14,750 --> 00:48:17,010
But in fact, this is a complex object.
但是实际上，这是一个复杂的对象。 

1124
00:48:17,010 --> 00:48:18,630
And this is another complex object,
这是另一个复杂的对象， 

1125
00:48:18,829 --> 00:48:21,690
but the sorting only sees the three.
但排序只能看到这三个。 

1126
00:48:21,690 --> 00:48:24,380
If this guy shows up before this guy in the input,
如果此人在输入中出现在此人之前， 

1127
00:48:24,380 --> 00:48:28,077
they have to show up in the same order in the output.
它们必须以相同的顺序出现在输出中。 

1128
00:48:28,277 --> 00:48:31,480
AUDIENCE: Why would that be bad if they're switched?
听众：如果切换它们，那为什么会不好呢？ 

1129
00:48:31,480 --> 00:48:34,730
VICTOR COSTAN: It's not stable.
维克多·科斯坦：不稳定。 

1130
00:48:34,730 --> 00:48:39,900
If they're switched, then when we're using a stable sorting
如果切换了它们，那么当我们使用稳定的排序时

1131
00:48:39,900 --> 00:48:41,519
algorithm here.
算法在这里。 

1132
00:48:41,719 --> 00:48:46,049
So here, the key is this complicated object.
因此，这里的关键是这个复杂的对象。 

1133
00:48:46,050 --> 00:48:47,650
But say we're in the second round.
但是说我们在第二轮。 

1134
00:48:47,650 --> 00:48:49,900
We're in this round, which we played with.
我们在这一轮中，我们一起玩过。 

1135
00:48:49,900 --> 00:48:52,730
Even though the key is this whole complicated object,
即使关键是整个复杂的对象， 

1136
00:48:52,730 --> 00:48:55,730
the only thing that the counting sort sees is this number.
计数排序唯一看到的就是这个数字。 

1137
00:48:55,730 --> 00:48:58,400



1138
00:48:58,400 --> 00:49:00,230
So this guy looks like three.
所以这个家伙看起来像三个。 

1139
00:49:00,429 --> 00:49:01,929
This guy looks like three.
这个家伙看起来像三个。 

1140
00:49:01,929 --> 00:49:04,309
And these three guys, although they're different,
这三个家伙，尽管他们不同， 

1141
00:49:04,309 --> 00:49:06,429
they look like four.
他们看起来像四个。 

1142
00:49:06,429 --> 00:49:09,480
If I don't output them in the right order--
如果我的输出顺序不正确， 

1143
00:49:09,480 --> 00:49:12,769
say I output this one all the way at the end-- then
说我一路输出到最后-然后

1144
00:49:12,769 --> 00:49:16,550
I'm going to get two, three, four, one to be down here.
我将得到两个，三个，四个，一个在这里。 

1145
00:49:16,550 --> 00:49:20,360
And now my numbers aren't sorted by the last two digits anymore.
现在我的电话号码不再按最后两位数字排序。 

1146
00:49:20,360 --> 00:49:23,440
So it breaks any algorithm that assumes stability.
因此，它破坏了任何假定稳定性的算法。 

1147
00:49:23,440 --> 00:49:25,909
So stability is something that you get from a sort,
因此，稳定性是您从某种程度上获得的， 

1148
00:49:25,909 --> 00:49:27,940
because it's convenient to assume it
因为假设它很方便

1149
00:49:27,940 --> 00:49:30,579
in some other algorithm that builds up on that sort.
在其他基于这种算法的算法中

1150
00:49:30,579 --> 00:49:32,496
If you don't need it, you don't care about it.
如果您不需要它，则无需关心。 

1151
00:49:32,496 --> 00:49:34,920
But in some cases, you need it.
但是在某些情况下，您需要它。 

1152
00:49:34,920 --> 00:49:37,914
And for the second part, which algorithms are stable.
第二部分，哪些算法是稳定的。 

1153
00:49:37,914 --> 00:49:41,369



1154
00:49:41,369 --> 00:49:42,674
Is insertion sort stable?
插入排序稳定吗？ 

1155
00:49:42,675 --> 00:49:46,768



1156
00:49:46,967 --> 00:49:47,960
AUDIENCE: I assume so.
听众：我想是的。 

1157
00:49:47,960 --> 00:49:49,809
I mean, stable is being correct, right?
我的意思是，稳定是正确的，对吗？ 

1158
00:49:49,809 --> 00:49:50,559
VICTOR COSTAN: No.
维克多·科斯坦：不。 

1159
00:49:50,559 --> 00:49:53,481
We mean that property there.
我们的意思是那里的财产。 

1160
00:49:53,481 --> 00:49:54,344
AUDIENCE: Oh, I see.
听众：哦，我知道了。 

1161
00:49:54,344 --> 00:49:55,204
You mean in order.
你的意思是为了秩序。 

1162
00:49:55,204 --> 00:49:55,795
VICTOR COSTAN: Yep.
维克多·科斯坦：是的。 

1163
00:49:55,994 --> 00:49:56,904
AUDIENCE: Oh, OK.
听众：哦，好。 

1164
00:49:56,905 --> 00:50:00,927



1165
00:50:00,927 --> 00:50:03,463
Insertion sort goes in order.
插入排序按顺序进行。 

1166
00:50:03,463 --> 00:50:06,076
But I guess it could push other things out of order.
但是我想这可能会使其他事情乱七八糟。 

1167
00:50:06,076 --> 00:50:07,449
VICTOR COSTAN: So insertion sort,
 VICTOR COSTAN：所以插入排序， 

1168
00:50:07,449 --> 00:50:09,730
you're doing swapping to move things to the left.
您正在交换以将事物向左移动。 

1169
00:50:09,730 --> 00:50:11,480
But if you find two things that are equal,
但是，如果您发现两个相等的事物， 

1170
00:50:11,480 --> 00:50:14,000
you're never going to swap them.
您将永远不会交换它们。 

1171
00:50:14,000 --> 00:50:18,760
So insertion sort is in order, is stable.
因此插入排序是有序的，稳定的。 

1172
00:50:18,760 --> 00:50:23,130
Merge sort, the one we gave you in that list is not stable.
合并排序后，我们在该列表中给您的排序不稳定。 

1173
00:50:23,130 --> 00:50:25,907
But there is the one character change that makes it stable.
但是有一个字符更改使它稳定。 

1174
00:50:25,907 --> 00:50:27,539
And you should look at today's lecture notes
您应该看一下今天的讲义

1175
00:50:27,739 --> 00:50:29,259
to find out what that is.
找出是什么。 

1176
00:50:29,260 --> 00:50:31,380
So merge sort can be stable.
因此合并排序可以是稳定的。 

1177
00:50:31,579 --> 00:50:33,074
Heapsort, stable or unstable?
堆排序，稳定还是不稳定？ 

1178
00:50:33,074 --> 00:50:37,039



1179
00:50:37,039 --> 00:50:37,630
Unstable.
不稳定

1180
00:50:37,630 --> 00:50:39,070
And there's a really small example
有一个非常小的例子

1181
00:50:39,070 --> 00:50:40,980
that you should look at.
你应该看看。 

1182
00:50:41,179 --> 00:50:43,469
Counting sort, stable or unstable?
计数排序，稳定还是不稳定？ 

1183
00:50:43,469 --> 00:50:44,429
AUDIENCE: Stable.
听众：稳定。 

1184
00:50:44,429 --> 00:50:45,471
VICTOR COSTAN: Thank you.
维克多·科斯坦：谢谢。 

1185
00:50:45,471 --> 00:50:48,699
It would have broken my heart if this would have come out wrong.
如果这是错误的话，那会伤透我的心。 

1186
00:50:48,699 --> 00:50:50,877
And radix sort?
和基数排序？ 

1187
00:50:50,878 --> 00:50:52,130
AUDIENCE: Probably.
听众：大概吧。 

1188
00:50:52,329 --> 00:50:54,416
Yes.
是。 

1189
00:50:54,416 --> 00:50:56,000
VICTOR COSTAN: Probably stable, right?
维克多·科斯坦（VICTOR COSTAN）：也许稳定吧？ 

1190
00:50:56,000 --> 00:50:56,755
All right.
好吧。 

1191
00:50:56,755 --> 00:50:57,769
Any more questions?
还有其他问题吗？ 

1192
00:50:57,969 --> 00:51:00,980
I like that question by the way, because you made me do this.
顺便说一下，我喜欢这个问题，因为您让我这样做了。 

1193
00:51:00,980 --> 00:51:01,480
I like that.
我喜欢。 

1194
00:51:01,480 --> 00:51:02,405
Any more questions?
还有其他问题吗？ 

1195
00:51:02,405 --> 00:51:06,070



1196
00:51:06,070 --> 00:51:11,070
All right, thank you guys.
好的，谢谢大家。 

