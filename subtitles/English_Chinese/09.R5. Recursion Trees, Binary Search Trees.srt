1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,225
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,225 --> 00:00:17,850
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,850 --> 00:00:21,829



10
00:00:21,829 --> 00:00:23,829
PROFESSOR: If you guys want me to cover anything
教授：如果你们要我讲任何事情

11
00:00:23,829 --> 00:00:25,299
in particular, is there anything you
特别是你有什么事吗

12
00:00:25,300 --> 00:00:26,507
didn't understand in lecture?
听课没听懂吗

13
00:00:26,507 --> 00:00:29,839



14
00:00:29,839 --> 00:00:32,640
In the last section, I covered the recursion trees
在上一节中，我介绍了递归树

15
00:00:32,640 --> 00:00:34,170
because they will be on the Pset,
因为它们将位于Pset上， 

16
00:00:34,170 --> 00:00:35,739
and people said they were a bit unclear,
人们说他们不清楚

17
00:00:35,939 --> 00:00:42,311
so we can do that and cover less of the stuff that I have here.
因此我们可以做到这一点，并减少我在这里拥有的内容。 

18
00:00:42,311 --> 00:00:44,769
Or if there's anything else, you can tell me what you want.
或者，如果还有其他问题，您可以告诉我您想要什么。 

19
00:00:44,770 --> 00:00:47,839
So there I cover recursion trees because someone said, hey,
所以我覆盖了递归树，因为有人说，嘿， 

20
00:00:48,039 --> 00:00:50,000
can you go over that again?
你能再遍一遍吗？ 

21
00:00:50,000 --> 00:00:51,310
Is there any pain points?
有痛点吗？ 

22
00:00:51,310 --> 00:00:56,419



23
00:00:56,619 --> 00:00:57,119
No?
没有？ 

24
00:00:57,119 --> 00:00:57,936
OK.
好。 

25
00:00:57,936 --> 00:00:59,810
So then I'm going to give you the same choice
所以我要给你同样的选择

26
00:00:59,810 --> 00:01:02,310
that I gave to people last time, and that
我上次给人的东西

27
00:01:02,310 --> 00:01:06,119
is we can go over recursion trees again,
是我们可以再次遍历递归树， 

28
00:01:06,319 --> 00:01:08,629
but if I do that, then I won't have time to go over
但是如果我这样做，我将没有时间去做

29
00:01:08,629 --> 00:01:11,128
the code for deleting a node from a binary search tree.
用于从二叉搜索树中删除节点的代码。 

30
00:01:11,129 --> 00:01:12,920
So we'll go through the theory and you guys
所以我们将通过理论，你们

31
00:01:12,920 --> 00:01:14,869
will have to go through the code on your own.
将不得不自己检查代码。 

32
00:01:15,069 --> 00:01:19,459
But instead, we'll go over recursion trees again
但是相反，我们将再次遍历递归树

33
00:01:19,459 --> 00:01:21,769
and remember how you solve a recurrence using
并记住如何使用来解决复发

34
00:01:21,769 --> 00:01:23,450
recursion trees.
递归树。 

35
00:01:23,450 --> 00:01:25,120
The alternative is we don't do that
另一种选择是我们不这样做

36
00:01:25,120 --> 00:01:29,981
and we complete the deletions part.
然后完成删除部分。 

37
00:01:29,981 --> 00:01:31,689
AUDIENCE: I feel like covering deletions,
听众：我想涵盖删除内容， 

38
00:01:31,689 --> 00:01:34,358
since we didn't do that in lecture, that would probably
因为我们在演讲中没有这样做，所以很可能

39
00:01:34,358 --> 00:01:35,831
be more helpful.
更有帮助。 

40
00:01:36,031 --> 00:01:37,239
PROFESSOR: Let's take a vote.
教授：让我们投票。 

41
00:01:37,239 --> 00:01:40,729
Who wants to do deletions in painstaking detail?
谁想删除细心的细节？ 

42
00:01:40,730 --> 00:01:45,409
So deletions and not recursion?
那么删除而不是递归？ 

43
00:01:45,409 --> 00:01:49,451
Who wants to do recursion trees and not deletion?
谁想要做递归树而不是删除？ 

44
00:01:49,451 --> 00:01:50,579
AUDIENCE: It's about equal.
听众：差不多。 

45
00:01:50,579 --> 00:01:52,204
PROFESSOR: It's equal and nobody cares.
教授：平等，没有人在乎。 

46
00:01:52,204 --> 00:01:52,870
I'm really sad.
我真的很伤心。 

47
00:01:52,870 --> 00:01:58,376



48
00:01:58,376 --> 00:02:00,230
AUDIENCE: Let's do both in half detail.
听众：让我们同时做两个细节。 

49
00:02:00,230 --> 00:02:01,310
PROFESSOR: OK, sure.
教授：好的，当然。 

50
00:02:01,310 --> 00:02:04,079
Who remembers merge sort?
谁记得合并排序？ 

51
00:02:04,079 --> 00:02:06,489
What does merge sort do really quick?
合并排序能真正快速地完成什么？ 

52
00:02:06,489 --> 00:02:10,049
AUDIENCE: It takes some sort of unsorted array,
听众：它需要某种未排序的数组， 

53
00:02:10,050 --> 00:02:13,310
splits it in half, and then continually splits it,
将其分成两半，然后连续将其分开， 

54
00:02:13,310 --> 00:02:15,479
and then once it finally gets to the point
然后终于到了要点

55
00:02:15,479 --> 00:02:20,539
where you have arrays of two elements, then it sorts them,
您有两个元素的数组，然后将它们排序， 

56
00:02:20,539 --> 00:02:23,087
and then sorts those, and then sorts those.
然后对它们进行排序，然后对它们进行排序。 

57
00:02:23,087 --> 00:02:24,668
It's a fun thing.
这是一件有趣的事。 

58
00:02:24,669 --> 00:02:25,960
And then it merges [INAUDIBLE].
然后合并[音频不清晰]。 

59
00:02:25,960 --> 00:02:28,680
PROFESSOR: That's so much code.
教授：太多的代码。 

60
00:02:28,680 --> 00:02:31,360
I don't like to write much code because for every line of code
我不想写太多代码，因为每一行代码

61
00:02:31,360 --> 00:02:33,151
that you write, you might have a bug in it,
你写的，里面可能有一个bug， 

62
00:02:33,151 --> 00:02:34,530
so I like to write less code.
所以我想写更少的代码。 

63
00:02:34,530 --> 00:02:37,949
So the way I do it is when I get to an array size of one
所以我的方法是将数组大小设为1 

64
00:02:37,949 --> 00:02:40,549
element, I know it's already sorted.
元素，我知道它已经排序。 

65
00:02:40,550 --> 00:02:41,439
So merge sort.
所以合并排序。 

66
00:02:41,639 --> 00:02:43,379
You have an array, it's unsorted.
您有一个数组，它没有排序。 

67
00:02:43,379 --> 00:02:47,030
Split it into two halves, call merge sort on each half,
将其分成两半，在每一半上调用合并排序， 

68
00:02:47,030 --> 00:02:49,780
assume that magically, they're going to come back sorted,
假设他们会奇迹般地回来， 

69
00:02:49,780 --> 00:02:52,300
and then you merge the sorted halves.
然后合并排序的两半。 

70
00:02:52,300 --> 00:02:53,810
How much time does merging take?
合并需要多少时间？ 

71
00:02:53,810 --> 00:02:57,590



72
00:02:57,590 --> 00:02:58,460
OK.
好。 

73
00:02:58,460 --> 00:03:03,042
So the recursion for the running time of merge sort?
那么合并排序运行时间的递归？ 

74
00:03:03,042 --> 00:03:04,536
AUDIENCE: Why does it take n time?
听众：为什么要花n时间？ 

75
00:03:04,536 --> 00:03:05,161
Just too large?
太大了吗？ 

76
00:03:05,161 --> 00:03:06,868
AUDIENCE: Isn't it the finger thing where
听众：这不是手指吗

77
00:03:06,868 --> 00:03:09,018
you take each element, and you're like, this one,
你把每个元素都拿来，就像， 

78
00:03:09,018 --> 00:03:12,259
is that greater or less than, then you put it in the array.
是大于还是小于，则将其放入数组。 

79
00:03:12,259 --> 00:03:12,759
So you get--
所以你得到- 

80
00:03:12,759 --> 00:03:16,693
PROFESSOR: Please take my word for it that it's order n.
教授：请相信，这是命令n。 

81
00:03:16,693 --> 00:03:18,859
AUDIENCE: I'll explain it and then I'll be confused.
听众：我会解释，然后会感到困惑。 

82
00:03:18,860 --> 00:03:21,469



83
00:03:21,669 --> 00:03:22,984
PROFESSOR: OK, so order n.
教授：好的，所以订购n。 

84
00:03:22,985 --> 00:03:23,875
What's the recursion?
什么是递归？ 

85
00:03:24,074 --> 00:03:28,421



86
00:03:28,421 --> 00:03:30,129
Don't give me the solution because then I
不要给我解决方案，因为那样我

87
00:03:30,129 --> 00:03:32,530
can't do the trees anymore, so give me the recursion
不能再做树了，所以递归给我

88
00:03:32,530 --> 00:03:33,675
before it's solved.
在解决之前。 

89
00:03:33,675 --> 00:03:36,960
Give me the recurrence formula.
给我递归公式。 

90
00:03:37,159 --> 00:03:39,566
So it starts with T of N, right?
所以它以N的T开头，对吗？ 

91
00:03:39,566 --> 00:03:43,116
AUDIENCE: It starts with N over 2 plus N, I think.
听众：我认为N开头应为2加上N。 

92
00:03:43,116 --> 00:03:46,843



93
00:03:46,843 --> 00:03:47,634
PROFESSOR: Perfect.
教授：完美。 

94
00:03:47,634 --> 00:03:50,729



95
00:03:50,729 --> 00:03:52,689
So you take the array, you split it into two,
因此，您将阵列分成两部分， 

96
00:03:52,689 --> 00:03:56,150
you call merge sort on the two halves of the arrays.
您可以对两个数组的一半进行合并排序。 

97
00:03:56,150 --> 00:03:57,469
So you call merge sort twice.
因此，您两次调用合并排序。 

98
00:03:57,669 --> 00:03:59,139
That's why you have a 2 here.
这就是为什么您这里有2。 

99
00:03:59,139 --> 00:03:59,799
The 2 matters.
这两个很重要。 

100
00:03:59,800 --> 00:04:01,969
Without it, you get a different answer.
没有它，您将得到不同的答案。 

101
00:04:01,969 --> 00:04:04,039
And when you call it, the arrays that you
当您调用它时， 

102
00:04:04,039 --> 00:04:06,909
give it are half the size, and then merge
给它一半大小，然后合并

103
00:04:06,909 --> 00:04:08,759
takes order and time.
需要命令和时间。 

104
00:04:08,759 --> 00:04:11,750
Splitting depends on what you're using to store your arrays.
拆分取决于您用于存储阵列的内容。 

105
00:04:11,750 --> 00:04:14,860
Can be constant time or it can be order N. So the time
可以是恒定时间，也可以是阶数N。所以时间

106
00:04:14,860 --> 00:04:17,810
won't change because of split.
不会因为分裂而改变。 

107
00:04:17,810 --> 00:04:20,845
How do we solve this recurrence?
我们如何解决这种复发？ 

108
00:04:20,845 --> 00:04:23,961



109
00:04:24,161 --> 00:04:25,870
The recursion tree method says that we're
递归树方法说我们

110
00:04:25,870 --> 00:04:27,680
going to draw a call graph.
要绘制一个调用图。 

111
00:04:27,680 --> 00:04:29,199
So we start out with a call to merge
因此，我们从合并请求开始

112
00:04:29,199 --> 00:04:31,909
sort with an array of size N. Then
用大小为N的数组排序。 

113
00:04:31,910 --> 00:04:33,610
it's going to call merge sort again,
它会再次调用合并排序， 

114
00:04:33,610 --> 00:04:35,000
but after the array is split.
但是在数组拆分之后。 

115
00:04:35,000 --> 00:04:38,730
So it's going to call merge sort twice, size is N over 2.
因此，它将调用合并排序两次，大小为N大于2。 

116
00:04:38,730 --> 00:04:41,189



117
00:04:41,389 --> 00:04:45,680
This guy gets an array of N over 2, calls merge sort.
这个家伙得到2个N的数组，调用合并排序。 

118
00:04:45,680 --> 00:04:50,759
Two arrays, sizes N over 4, N over 4.
两个数组，大小N大于4，N大于4。 

119
00:04:50,759 --> 00:04:51,629
This does the same.
这也一样。 

120
00:04:51,629 --> 00:04:54,939



121
00:04:54,939 --> 00:05:00,420
So this goes on forever and ever and ever until at some point
因此，这种情况永远持续下去，直到某个时刻

122
00:05:00,420 --> 00:05:03,240
we reach our base case.
我们达到了基本情况。 

123
00:05:03,240 --> 00:05:05,939
So we're going to have a bunch of calls
所以我们要打很多电话

124
00:05:05,939 --> 00:05:09,459
here where the array size is?
这里的数组大小在哪里？ 

125
00:05:09,459 --> 00:05:10,520
What's our base case?
我们的基本情况是什么？ 

126
00:05:10,521 --> 00:05:10,819
1.
 1。 

127
00:05:11,019 --> 00:05:11,519
Excellent.
优秀的。 

128
00:05:11,519 --> 00:05:15,870



129
00:05:15,870 --> 00:05:18,240
So this is the call graph for merge sort, and let's
这是合并排序的调用图，让我们

130
00:05:18,240 --> 00:05:20,930
put the base case here so we know what we're talking about.
把基本情况放在这里，这样我们就知道我们在说什么。 

131
00:05:20,930 --> 00:05:23,370
T of 1 is theta 1.
 T的1是theta 1。 

132
00:05:23,370 --> 00:05:25,875



133
00:05:25,875 --> 00:05:27,250
Now inside the nodes, we're going
现在在节点内，我们要

134
00:05:27,250 --> 00:05:32,149
to put the cost for each call without counting
不用计算每次通话的费用

135
00:05:32,149 --> 00:05:34,769
the sub-call, so the children here.
子电话，所以孩子在这里。 

136
00:05:34,769 --> 00:05:38,370
That's this guy here, except instead of order N,
就是这个人，除了N阶， 

137
00:05:38,370 --> 00:05:40,160
I will write CN.
我会写CN。 

138
00:05:40,160 --> 00:05:42,870
Remember how sometimes we use CN instead
记住有时我们有时使用CN代替

139
00:05:42,870 --> 00:05:45,500
of the order of notation?
的顺序？ 

140
00:05:45,500 --> 00:05:49,149
The reason we do that is if I put in the asymptotic notation,
我们这样做的原因是，如果我采用渐近符号， 

141
00:05:49,149 --> 00:05:52,929
then we're going to be tempted to sum them up.
那么我们将很想对它们进行总结。 

142
00:05:52,930 --> 00:05:56,949
You're allowed to sum terms using asymptotic notation as
您可以使用渐进表示法对项求和

143
00:05:56,949 --> 00:05:59,199
long as there's a finite number of them,
只要数量有限， 

144
00:05:59,199 --> 00:06:02,420
but here, it turns out there's an infinite number of them.
但事实证明，这里有无数个。 

145
00:06:02,420 --> 00:06:04,949
Also, if you go this way, you can never go wrong.
同样，如果您采用这种方式，则永远不会出错。 

146
00:06:05,149 --> 00:06:08,029
You always get the right answer, so that's
您总是会得到正确的答案，因此

147
00:06:08,029 --> 00:06:11,619
why we switch from order N to CN.
为什么我们从N顺序切换到CN。 

148
00:06:11,620 --> 00:06:14,980
In order to merge sort an array of size N,
为了合并排序大小为N的数组， 

149
00:06:14,980 --> 00:06:18,100
we're going to merge sort two arrays of size N over 2
我们将合并大小为N的两个超过2的数组

150
00:06:18,100 --> 00:06:21,689
and then spend CN time on doing the merge.
然后花费CN时间进行合并。 

151
00:06:21,689 --> 00:06:23,355
What are the costs here?
这里的费用是多少？ 

152
00:06:23,355 --> 00:06:26,050



153
00:06:26,050 --> 00:06:28,139
To sort an array of N over 2, what's
要将N的数组排序为2，是什么

154
00:06:28,139 --> 00:06:31,669
the cost outside the cost to merge?
合并成本之外的成本？ 

155
00:06:31,670 --> 00:06:33,509
AUDIENCE: C of N over 2.
观众：C之N，超过2。 

156
00:06:33,509 --> 00:06:34,860
PROFESSOR: Perfect.
教授：完美。 

157
00:06:34,860 --> 00:06:37,000
C times N over 2.
 C乘以N乘以2。 

158
00:06:37,000 --> 00:06:39,410
C times N over 2.
 C乘以N乘以2。 

159
00:06:39,410 --> 00:06:40,846
How about here?
那呢

160
00:06:41,045 --> 00:06:42,978
AUDIENCE: C times N over 4.
听众：C乘以N乘以4。 

161
00:06:42,978 --> 00:06:45,675
PROFESSOR: Perfect.
教授：完美。 

162
00:06:45,875 --> 00:06:48,849
CN over 4.
 CN超过4。 

163
00:06:48,850 --> 00:06:50,610
My nodes are really ugly.
我的节点真的很丑。 

164
00:06:50,610 --> 00:06:52,860
I should have drawn them like this from the beginning.
我应该从一开始就这样吸引他们。 

165
00:06:52,860 --> 00:06:54,069
CN over 4.
 CN超过4。 

166
00:06:54,269 --> 00:06:55,250
There you go.
妳去

167
00:06:55,250 --> 00:06:57,620
How about down here?
在这里怎么样？ 

168
00:06:57,620 --> 00:07:01,141
AUDIENCE: C of N over 2 to the i.
受众：C大于2等于i。 

169
00:07:01,141 --> 00:07:03,490
PROFESSOR: You're going on step ahead.
教授：您将继续前进。 

170
00:07:03,490 --> 00:07:05,610
We'll do that right next.
接下来，我们将继续进行操作。 

171
00:07:05,610 --> 00:07:08,540
AUDIENCE: C of N over log N, right?
听众：C的N超过对数N，对不对？ 

172
00:07:08,540 --> 00:07:11,220
Because they're log N levels, so--
因为它们是N级日志，所以- 

173
00:07:11,220 --> 00:07:13,939
PROFESSOR: Let's not worry about the number of levels.
教授：我们不用担心级别数。 

174
00:07:14,139 --> 00:07:15,979
You're ruining my steps.
你毁了我的脚步

175
00:07:15,980 --> 00:07:18,254
I was going to get to that two steps after this.
在那之后，我打算去那两个步骤。 

176
00:07:18,454 --> 00:07:19,563
AUDIENCE: Is it just C?
听众：是C吗？ 

177
00:07:19,564 --> 00:07:20,319
PROFESSOR: Yep.
教授：是的。 

178
00:07:20,319 --> 00:07:21,839
So array size is 1, right?
数组大小为1，对吗？ 

179
00:07:21,839 --> 00:07:28,139
So the cost is C. C, C, C, C. OK, you guys got it
所以成本是C. C，C，C，C.好的，你们知道了

180
00:07:28,139 --> 00:07:30,178
if you're thinking of levels already.
如果您已经在考虑水平。 

181
00:07:30,178 --> 00:07:31,719
The next thing I want to do is I want
我想做的下一件事是

182
00:07:31,720 --> 00:07:34,740
to figure out how many levels I have in this tree.
弄清楚我在这棵树中有多少个等级。 

183
00:07:34,740 --> 00:07:36,600
Why do I care about that?
我为什么要在乎呢？ 

184
00:07:36,600 --> 00:07:40,699
The answer for T of N is the sum of all these costs in here
 N的T的答案是这里所有这些成本的总和

185
00:07:40,899 --> 00:07:44,549
because the cost of merge sorting an array of size N
因为合并对大小为N的数组进行排序的成本

186
00:07:44,550 --> 00:07:49,939
is the merge sort plus the costs for sorting the two arrays.
是合并排序加上对两个数组进行排序的成本。 

187
00:07:49,939 --> 00:07:52,889
And the nodes here keep track of all the time spent
并且这里的节点跟踪所有花费的时间

188
00:07:52,889 --> 00:07:56,839
in recursive sub-calls, so if we can add up everything up,
在递归子调用中，因此，如果我们可以将所有内容加起来， 

189
00:07:56,839 --> 00:08:01,879
we have the answer to T of N. It turns out the easiest
我们得到N的T的答案。事实证明最简单

190
00:08:01,879 --> 00:08:06,050
way to do that is to sum up the cost at each level
做到这一点的方法是汇总每个级别的成本

191
00:08:06,050 --> 00:08:10,875
because the costs are this guy copied over here.
因为费用是这个人复制到这里的。 

192
00:08:10,875 --> 00:08:13,800
For a level, they tend to be the same,
在某种程度上，它们往往是相同的， 

193
00:08:13,800 --> 00:08:17,360
so it's reasonably easy to add them up,
因此将它们加起来相当容易， 

194
00:08:17,360 --> 00:08:19,430
except in order to be able to add those up,
为了能够加起来， 

195
00:08:19,430 --> 00:08:22,980
you have to know how many levels you have.
您必须知道您有多少个级别。 

196
00:08:22,980 --> 00:08:26,920
So how do I know how many levels I have?
那么我怎么知道我有多少级呢？ 

197
00:08:26,920 --> 00:08:30,470
Someone already told me log N. How do I get to that log N?
有人已经告诉我日志N。如何获取该日志N？ 

198
00:08:30,470 --> 00:08:35,980



199
00:08:35,980 --> 00:08:40,440
So when I get to the bottommost level,
所以当我到达最底层时， 

200
00:08:40,440 --> 00:08:43,460
the number has to be 1, the number next to the node,
该数字必须为1，该节点旁边的数字， 

201
00:08:43,460 --> 00:08:45,080
because that's my base case.
因为那是我的基本情况。 

202
00:08:45,080 --> 00:08:47,490
When I have a one element array, it's sorted, I'm done.
当我有一个单元素数组时，就完成了排序。 

203
00:08:47,490 --> 00:08:49,649
I return.
我回来。 

204
00:08:49,649 --> 00:08:53,129
So I can say that for each level,
所以我可以说对于每个级别， 

205
00:08:53,129 --> 00:08:58,149
the number next to the node is something as a function of L.
节点旁边的数字是L的函数。 

206
00:08:58,149 --> 00:08:59,750
Here, I'm going to say that this is
在这里，我要说的是

207
00:08:59,750 --> 00:09:06,850
N over 1, which is N over 2 to the 0 power.
 N大于1，即N大于2等于0的幂。 

208
00:09:06,850 --> 00:09:11,480
And this is N over 2, so it's N over 2 to the first power.
这是N乘2，因此它是2乘以N等于第一乘方。 

209
00:09:11,480 --> 00:09:16,279
This is N over 2 to the second, and so on and so forth.
这是2到2之间的N，依此类推。 

210
00:09:16,279 --> 00:09:18,475
It might not be obvious if you only have two levels.
如果只有两个级别，则可能并不明显。 

211
00:09:18,475 --> 00:09:20,100
I don't want to draw a lot on the board
我不想在董事会上花很多钱

212
00:09:20,100 --> 00:09:22,979
because I don't have a lot of space and I'd get my nodes
因为我没有很多空间，所以我得到了节点

213
00:09:23,179 --> 00:09:25,419
all messed into each other.
彼此陷入混乱。 

214
00:09:25,419 --> 00:09:28,689
If it takes more than two levels to see the pattern, go for it.
如果需要两个以上的级别来查看模式，请继续尝试。 

215
00:09:28,690 --> 00:09:31,440
Expand for three levels, four levels, five levels,
展开三个级别，四个级别，五个级别， 

216
00:09:31,440 --> 00:09:35,070
whatever it takes to get it right on a Pset or on a test.
在Pset或测试上进行正确处理所需的一切。 

217
00:09:35,070 --> 00:09:37,229
So you see the pattern, then you write the formula
因此，您会看到模式，然后编写公式

218
00:09:37,429 --> 00:09:42,139
for the node size at the level.
在级别上的节点大小。 

219
00:09:42,139 --> 00:09:44,769
And assuming this pattern holds, we
假设这种模式成立，我们

220
00:09:44,769 --> 00:09:50,269
see that the size of a node at level l, the size
看到在级别l的节点的大小

221
00:09:50,269 --> 00:09:56,879
is 2 N over 2 to the l minus 1.
是2 N比2减去l减去1。 

222
00:09:56,879 --> 00:09:58,330
Fair enough?
很公平？ 

223
00:09:58,330 --> 00:10:01,569
You can say N over 2 to the l, and forget
您可以对L说2个N 

224
00:10:01,769 --> 00:10:04,730
that there's a minus 1, and then the asymptotics will save you,
减一，然后渐近会救你， 

225
00:10:04,730 --> 00:10:09,479
so it's no big deal, but this is the real number.
所以没什么大不了的，但这是真实的数字。 

226
00:10:09,679 --> 00:10:16,309
So that means that at the bottommost level, at level l,
因此，这意味着在最底层的l层， 

227
00:10:16,309 --> 00:10:18,899
this size is going to be 1.
这个大小将是1。 

228
00:10:18,899 --> 00:10:24,110
N over 2 to the l minus 1 equals 1.
 N大于2等于l减1等于1。 

229
00:10:24,110 --> 00:10:26,620
So now this is an equation, so I can solve for l.
所以现在这是一个方程式，所以我可以求解l。 

230
00:10:26,620 --> 00:10:31,629
I pull this on the right side, N equals 2 to the l minus 1,
我将其拉到右侧，N等于2减去l减去1， 

231
00:10:31,629 --> 00:10:37,770
so l minus 1 equals-- anyone?
所以我减去1等于-有人吗？ 

232
00:10:37,770 --> 00:10:39,019
The inverse of an exponential?
指数的倒数？ 

233
00:10:39,019 --> 00:10:41,720



234
00:10:41,720 --> 00:10:43,220
AUDIENCE: I wasn't paying attention.
听众：我没注意。 

235
00:10:43,220 --> 00:10:45,389
Sorry.
抱歉。 

236
00:10:45,389 --> 00:10:50,836
AUDIENCE: Log N.
听众：登录N。 

237
00:10:50,836 --> 00:10:53,169
PROFESSOR: The inverse of an exponential is a logarithm.
教授：指数的倒数是对数。 

238
00:10:53,169 --> 00:10:58,469
Keep that in mind for solving 6.006 problems.
为解决6.006问题而牢记这一点。 

239
00:10:58,470 --> 00:11:06,288
l minus 1 is log N so l is log n plus 1, roughly log n.
 l减1是log N，所以l是log n加1，大约是log n。 

240
00:11:06,288 --> 00:11:08,330
I could use log n plus 1 and go through the math.
我可以使用log n加1并进行数学运算。 

241
00:11:08,330 --> 00:11:10,580
It's a bit more painful and, because we're
有点痛苦，因为我们

242
00:11:10,580 --> 00:11:13,940
using asymptotics, it doesn't really matter.
使用渐近线，这并不重要。 

243
00:11:13,940 --> 00:11:15,610
So now we know how many levels we have.
现在我们知道了多少个级别。 

244
00:11:15,610 --> 00:11:17,849
Let's see what's the cost at the level.
让我们看看该级别的成本是多少。 

245
00:11:18,049 --> 00:11:19,740
So all the calls at a certain level,
因此，所有电话都处于一定水平， 

246
00:11:19,740 --> 00:11:21,639
what's the sum of the costs?
费用总和是多少？ 

247
00:11:21,639 --> 00:11:25,399
For this level, what's the cost?
对于这个级别，要花多少钱？ 

248
00:11:25,399 --> 00:11:29,600



249
00:11:29,600 --> 00:11:30,100
CN.
 CN 

250
00:11:30,100 --> 00:11:32,109
And That was the easy question.
这是一个简单的问题。 

251
00:11:32,309 --> 00:11:33,634
Just the root, right?
只是根，对不对？ 

252
00:11:33,634 --> 00:11:34,509
How about this level?
这个水平怎么样？ 

253
00:11:34,509 --> 00:11:38,769



254
00:11:38,769 --> 00:11:43,179
Because I have two nodes, the cost in each node is CN over 2.
因为我有两个节点，所以每个节点的成本超过2。 

255
00:11:43,179 --> 00:11:44,059
How about this level?
这个水平怎么样？ 

256
00:11:44,059 --> 00:11:49,799



257
00:11:49,799 --> 00:11:52,109
Four levels, each level CN over 4.
四个级别，每个级别CN大于4。 

258
00:11:52,110 --> 00:11:53,340
How about the bottom level?
底层如何？ 

259
00:11:53,340 --> 00:11:58,551



260
00:11:58,751 --> 00:12:01,679
AUDIENCE: CN.
观众：CN。 

261
00:12:01,679 --> 00:12:04,485
PROFESSOR: Why is it CN?
教授：为什么是CN？ 

262
00:12:04,485 --> 00:12:08,439
AUDIENCE: Because there are N arrays of size 1.
听众：因为有N个大小为1的数组。 

263
00:12:08,440 --> 00:12:09,710
PROFESSOR: N arrays of size 1.
教授：N个大小为1的数组。 

264
00:12:09,710 --> 00:12:11,329
Excellent.
优秀的。 

265
00:12:11,529 --> 00:12:14,509
A cute argument I heard once is you start out with N,
我曾经听过一个可爱的论点，就是你从N开始， 

266
00:12:14,509 --> 00:12:16,909
you split it into N over 2 and N over 2.
您将其分为2个N和2个N。 

267
00:12:16,909 --> 00:12:19,519
Then you split this guy in N over 4, N over 4,
然后，您将此人分成4个N分以上的N个， 

268
00:12:19,519 --> 00:12:21,980
so this is like conservation of mass.
所以这就像守恒

269
00:12:21,980 --> 00:12:26,379
If you start with N and here, you don't end up with N total,
如果您以N开头，那么这里的总和不是N， 

270
00:12:26,379 --> 00:12:30,210
then you lost some element somewhere on the way.
然后您在途中某处丢失了一些元素。 

271
00:12:30,210 --> 00:12:32,100
So CN.
所以CN。 

272
00:12:32,100 --> 00:12:33,109
CN, CN, CN, CN.
 CN，CN，CN，CN。 

273
00:12:33,309 --> 00:12:34,529
I think I see a pattern.
我想我看到了一个模式。 

274
00:12:34,529 --> 00:12:38,539
I think it's reasonable to say that for every level, it's CN.
我认为可以合理地说每个级别都是CN。 

275
00:12:38,539 --> 00:12:40,949
And if you write the proof, you can prove that
如果您撰写证明，则可以证明

276
00:12:40,950 --> 00:12:44,099
by using math instead of waving hands.
通过使用数学而不是挥手。 

277
00:12:44,299 --> 00:12:47,419
So CN times the number of levels, right?
那么CN乘以水平数吧？ 

278
00:12:47,419 --> 00:12:56,039
The answer for this guy is C of N is CN times l.
这个人的答案是N的C为CN乘以L。 

279
00:12:56,039 --> 00:12:57,586
What's l?
我怎么了

280
00:12:57,586 --> 00:12:59,288
AUDIENCE: N log N.
听众：N logN。 

281
00:12:59,288 --> 00:13:00,080
PROFESSOR: Roughly.
教授：大概吧。 

282
00:13:00,080 --> 00:13:10,240
OK So order of N log N. C becomes
 OK，所以N log N. C的阶变为

283
00:13:10,240 --> 00:13:14,629
order of, l is order of log N, N stays the same.
的顺序，l是对数N的顺序，N保持不变。 

284
00:13:14,629 --> 00:13:18,320



285
00:13:18,320 --> 00:13:18,970
Any questions?
任何问题？ 

286
00:13:18,970 --> 00:13:24,100



287
00:13:24,100 --> 00:13:27,836
Are people getting it or did I confuse you even more?
人们知道了吗？还是我使您更加困惑？ 

288
00:13:27,836 --> 00:13:28,669
AUDIENCE: We got it.
听众：我们明白了。 

289
00:13:28,669 --> 00:13:29,896
PROFESSOR: OK, sweet.
教授：好，甜。 

290
00:13:29,897 --> 00:13:31,230
Thank you for the encouragement.
谢谢你的鼓励。 

291
00:13:31,230 --> 00:13:36,200
So this gets you through problem one of Pset 2.
因此，这可以解决Pset 2的问题之一。 

292
00:13:36,200 --> 00:13:38,199
So in this case, the tree is nicely balanced.
因此，在这种情况下，树是很好的平衡。 

293
00:13:38,399 --> 00:13:40,283
The cost at each level is the same.
每个级别的成本是相同的。 

294
00:13:40,283 --> 00:13:42,700
When [INAUDIBLE] talked about recursion trees in lectures,
当[听不清]在讲座中谈论递归树时， 

295
00:13:42,700 --> 00:13:45,230
he showed two more trees, one where
他又展示了两棵树，其中一棵

296
00:13:45,230 --> 00:13:49,350
pretty much all the cost was up here-- the cost of the children
几乎所有的费用都在这里-孩子们的费用

297
00:13:49,350 --> 00:13:54,000
was negligible-- and one tree where all the cost was
可以忽略不计-一棵树，所有的成本

298
00:13:54,000 --> 00:13:57,240
concentrated here, so the cost of all the inner nodes
集中在这里，所以所有内部节点的成本

299
00:13:57,240 --> 00:14:01,159
was negligible and the leaves were doing all the real work.
可以忽略不计，叶子正在完成所有实际工作。 

300
00:14:01,159 --> 00:14:03,803
So don't be scared if your costs aren't the same.
因此，如果您的费用不相同，请不要害怕。 

301
00:14:03,803 --> 00:14:05,970
Just sum them up and you'll get to the right answer.
只需对它们进行总结，您将获得正确的答案。 

302
00:14:05,970 --> 00:14:11,470



303
00:14:11,470 --> 00:14:13,769
Now I'm going to talk about binary search trees,
现在，我将讨论二进制搜索树， 

304
00:14:13,769 --> 00:14:18,919
except I will make a five minute general talk about data
除了我将对数据进行五分钟的一般性讨论

305
00:14:18,919 --> 00:14:20,699
structures before I do that.
在我这样做之前的结构。 

306
00:14:20,700 --> 00:14:22,109
So we use the term "data structures."
因此，我们使用术语“数据结构”。 

307
00:14:22,309 --> 00:14:24,295
I think we covered it well, and I
我认为我们涵盖得很好，而我

308
00:14:24,296 --> 00:14:25,469
want to give you a couple of tips
想给你一些提示

309
00:14:25,669 --> 00:14:29,279
for dealing with them on Pset 1.
在Pset 1上处理它们。 

310
00:14:29,279 --> 00:14:31,389
A data structure is a bunch of algorithms
数据结构是一堆算法

311
00:14:31,389 --> 00:14:35,379
that help you store and then retrieve information.
帮助您存储然后检索信息。 

312
00:14:35,379 --> 00:14:36,960
You have two types of algorithms.
您有两种算法。 

313
00:14:36,960 --> 00:14:44,594
You have queries, and you have updates.
您有查询，也有更新。 

314
00:14:44,794 --> 00:14:49,849



315
00:14:49,850 --> 00:14:51,719
You start out with an empty data structure,
您从一个空的数据结构开始， 

316
00:14:51,919 --> 00:14:55,870
like an empty binary search tree or an empty list,
就像一个空的二进制搜索树或一个空列表， 

317
00:14:55,870 --> 00:14:58,370
and then you throw some data at it.
然后向它扔一些数据。 

318
00:14:58,370 --> 00:14:59,840
That's when you update it.
那就是您更新它的时间。 

319
00:14:59,840 --> 00:15:03,129
Then you ask it some questions, and that's when you query it.
然后，您要问一些问题，那就是在查询它时。 

320
00:15:03,129 --> 00:15:05,469
Then maybe you throw more data at it, so you do more updates,
然后，也许您要投入更多的数据，因此您需要进行更多的更新， 

321
00:15:05,669 --> 00:15:07,793
and you ask more questions, so you do more queries.
并且您提出了更多问题，因此您进行了更多查询。 

322
00:15:07,793 --> 00:15:10,189



323
00:15:10,190 --> 00:15:12,460
What are the queries and the updates
什么是查询和更新

324
00:15:12,460 --> 00:15:15,200
for the binary search trees that we talked about in lecture?
我们在讲座中讨论过的二叉搜索树？ 

325
00:15:15,200 --> 00:15:18,459



326
00:15:18,659 --> 00:15:21,139
AUDIENCE: A query would be like, what's
观众：查询就像是什么

327
00:15:21,139 --> 00:15:23,976
your right child, what's your left child?
你的右孩子，你的左孩子是什么？ 

328
00:15:23,976 --> 00:15:25,309
PROFESSOR: So that's for a node.
教授：那是给一个节点的。 

329
00:15:25,309 --> 00:15:28,501



330
00:15:28,501 --> 00:15:29,959
AUDIENCE: What are you looking for?
听众：您在找什么？ 

331
00:15:29,960 --> 00:15:31,460
PROFESSOR: I'm looking for something
教授：我在找东西

332
00:15:31,460 --> 00:15:32,812
for the entire infrastructure.
整个基础架构。 

333
00:15:32,812 --> 00:15:34,519
So for the entire tree, what's a question
所以对于整棵树，有什么问题

334
00:15:34,519 --> 00:15:36,090
that you would ask the tree?
你会问那棵树吗？ 

335
00:15:36,090 --> 00:15:37,147
PROFESSOR: Max.
教授：最高

336
00:15:37,147 --> 00:15:37,730
PROFESSOR: OK.
教授：好的。 

337
00:15:37,730 --> 00:15:46,750



338
00:15:46,750 --> 00:15:47,250
Min.
最小

339
00:15:47,250 --> 00:15:50,913



340
00:15:50,913 --> 00:15:51,830
AUDIENCE: Next larger.
听众：接下来更大。 

341
00:15:51,830 --> 00:15:52,460
PROFESSOR: Next larger.
教授：下一个更大。 

342
00:15:52,460 --> 00:15:53,940
Are you looking at the nodes?
您在看节点吗？ 

343
00:15:53,940 --> 00:15:58,439



344
00:15:58,639 --> 00:16:02,860
AUDIENCE: Is there an are you balanced question?
听众：您有一个平衡的问题吗？ 

345
00:16:02,860 --> 00:16:05,664
PROFESSOR: Well, I would say that the most popular operation
教授：好吧，我想说这是最受欢迎的手术

346
00:16:05,664 --> 00:16:08,980
in a binary search tree is Search, which
在二叉搜索树中是Search， 

347
00:16:08,980 --> 00:16:12,359
looks for-- we call it Find in the code
寻找-我们在代码中将其称为Find 

348
00:16:12,559 --> 00:16:16,639
because most code implementations call it Find
因为大多数代码实现都称它为Find 

349
00:16:16,639 --> 00:16:18,359
nowadays, but binary search tree.
如今，但是二进制搜索树。 

350
00:16:18,359 --> 00:16:19,449
What are you going to do in it?
您打算在其中做什么？ 

351
00:16:19,649 --> 00:16:20,870
You search for a value.
您搜索一个值。 

352
00:16:20,870 --> 00:16:23,919
That's why it has the Search in binary search.
这就是为什么它在二进制搜索中具有“搜索”的原因。 

353
00:16:23,919 --> 00:16:27,579
So queries are operations where you ask questions to the data
因此查询是您向数据提出问题的操作

354
00:16:27,580 --> 00:16:31,339
structure and it doesn't change.
结构，它不会改变。 

355
00:16:31,539 --> 00:16:32,399
How about updates?
更新如何？ 

356
00:16:32,399 --> 00:16:33,939
What did we learn for updates?
我们从中学到了什么？ 

357
00:16:33,940 --> 00:16:36,511



358
00:16:36,711 --> 00:16:37,639
AUDIENCE: Insert.
听众：插入。 

359
00:16:37,639 --> 00:16:39,740
PROFESSOR: Excellent.
教授：非常好。 

360
00:16:39,740 --> 00:16:41,629
So Insert was covered in lecture,
因此，Insert被演讲所涵盖， 

361
00:16:41,629 --> 00:16:44,399
and we're doing Delete today.
今天我们要进行删除

362
00:16:44,399 --> 00:16:49,740



363
00:16:49,740 --> 00:16:53,029
So data structures have this property
因此数据结构具有此属性

364
00:16:53,029 --> 00:16:56,459
that's called the representation invariant, RI,
这就是表示不变式RI 

365
00:16:56,460 --> 00:16:57,729
or Rep Invariant.
或Rep不变量。 

366
00:16:57,929 --> 00:17:05,818



367
00:17:05,818 --> 00:17:09,835
Actually, before I get there, the rep invariant
其实，在到达那里之前，代表不变式

368
00:17:09,835 --> 00:17:12,640
says that the data in the data structures
说数据结构中的数据

369
00:17:12,640 --> 00:17:14,628
is organized in this way, and as long
是这样组织的，而且只要

370
00:17:14,828 --> 00:17:17,348
as it's organized in this way, the data structure functions
由于以这种方式组织，因此数据结构起作用

371
00:17:17,348 --> 00:17:18,490
correctly.
正确地。 

372
00:17:18,490 --> 00:17:20,809
Can someone guess for a sorted array
有人可以猜测一个排序的数组

373
00:17:20,809 --> 00:17:24,828
what's the representation invariant?
什么是表示不变式？ 

374
00:17:24,828 --> 00:17:27,293
AUDIENCE: It can mean sorted.
听众：可以表示已排序。 

375
00:17:27,294 --> 00:17:27,960
PROFESSOR: Yeah.
教授：是的。 

376
00:17:27,960 --> 00:17:29,149
A sorted array should be sorted.
排序后的数组应排序。 

377
00:17:29,349 --> 00:17:31,689
Sounds like a very good rep invariant.
听起来像一个非常好的rep不变式。 

378
00:17:31,690 --> 00:17:33,529
So the elements should be stored an array.
因此，元素应存储为数组。 

379
00:17:33,529 --> 00:17:38,339
Every element should be smaller than any element after it.
每个元素都应小于其后的任何元素。 

380
00:17:38,339 --> 00:17:42,369
And as long as the rep invariant holds, so as long
只要rep不变量成立， 

381
00:17:42,369 --> 00:17:44,769
as elements are stored in the right way in the data
因为元素以正确的方式存储在数据中

382
00:17:44,769 --> 00:17:48,889
structure, the queries will return the right results.
结构，查询将返回正确的结果。 

383
00:17:48,890 --> 00:17:50,159
If the rep invariant doesn't hold,
如果rep不变量不成立， 

384
00:17:50,359 --> 00:17:53,363
then God knows what's going to happen.
然后上帝知道会发生什么。 

385
00:17:53,364 --> 00:17:54,779
What can you do in a storage array
您可以在存储阵列中做什么

386
00:17:54,779 --> 00:17:56,799
as long as the rep invariant holds?
只要代表不变式成立？ 

387
00:17:56,799 --> 00:18:00,970



388
00:18:00,970 --> 00:18:01,726
Sorted array.
排序数组。 

389
00:18:01,926 --> 00:18:04,009
What's the reason why I would have a sorted array?
为什么要排序数组是什么原因？ 

390
00:18:04,009 --> 00:18:06,390
What can I do that's fast in a sorted array?
我能快速完成排序数组中的操作吗？ 

391
00:18:06,390 --> 00:18:08,660
AUDIENCE: Min and Max.
听众：最小和最大。 

392
00:18:08,660 --> 00:18:10,140
PROFESSOR: I can do that very fast.
教授：我可以很快做到。 

393
00:18:10,140 --> 00:18:10,589
That's good.
那很好。 

394
00:18:10,789 --> 00:18:12,413
What's the running time?
几点钟了？ 

395
00:18:12,413 --> 00:18:13,289
AUDIENCE: A constant.
听众：一个常数。 

396
00:18:13,289 --> 00:18:14,219
PROFESSOR: Perfect.
教授：完美。 

397
00:18:14,219 --> 00:18:16,509
Min you look at the beginning, Max you look at the end.
最小的你看开始，最大的你看结束。 

398
00:18:16,509 --> 00:18:17,140
Yes?
是？ 

399
00:18:17,140 --> 00:18:18,210
AUDIENCE: Binary search.
受众：二进制搜索。 

400
00:18:18,210 --> 00:18:19,250
PROFESSOR: Binary search.
教授：二进制搜索。 

401
00:18:19,250 --> 00:18:21,129
That's the other reason for that.
那是另一个原因。 

402
00:18:21,130 --> 00:18:22,889
So binary search runs in order log
因此二进制搜索按顺序运行

403
00:18:23,089 --> 00:18:26,689
N time, doesn't have to look at most of the array,
 N次，不必看大部分阵列， 

404
00:18:26,690 --> 00:18:28,690
tells you whether an element is there are not.
告诉您元素是否不存在。 

405
00:18:28,690 --> 00:18:30,899
Now, what if the array is unsorted?
现在，如果数组未排序怎么办？ 

406
00:18:31,099 --> 00:18:33,839
Will the algorithm work?
该算法会起作用吗？ 

407
00:18:33,839 --> 00:18:35,269
It might say something isn't there
可能说没有东西

408
00:18:35,269 --> 00:18:36,353
when it actually is there.
当它实际存在时。 

409
00:18:36,353 --> 00:18:38,789
You can do binary search on a non-sorted array.
您可以对未排序的数组执行二进制搜索。 

410
00:18:38,789 --> 00:18:40,440
So if the rep invariant doesn't hold,
因此，如果rep不变量不成立， 

411
00:18:40,440 --> 00:18:42,390
your queries might give you a wrong answer.
您的查询可能会给您错误的答案。 

412
00:18:42,390 --> 00:18:44,940



413
00:18:44,940 --> 00:18:46,460
How about updates?
更新如何？ 

414
00:18:46,460 --> 00:18:49,169
How do you search something in a sorted list?
您如何搜索排序列表中的内容？ 

415
00:18:49,369 --> 00:18:53,222



416
00:18:53,222 --> 00:18:54,763
AUDIENCE: You find where it should go
观众：您找到应该去的地方

417
00:18:54,763 --> 00:18:55,884
and you move everything.
然后您移动所有东西。 

418
00:18:55,884 --> 00:18:56,509
PROFESSOR: Yep.
教授：是的。 

419
00:18:56,509 --> 00:18:59,109
So you have to move everything, make room for it,
因此，您必须移动所有东西，为其腾出空间， 

420
00:18:59,109 --> 00:19:01,029
and put it there so that the array is still
并放到那里，以便阵列仍然

421
00:19:01,029 --> 00:19:02,899
sorted at the end.
最后排序。 

422
00:19:02,900 --> 00:19:04,369
You can't just append things at the end,
您不能只在结尾附加内容， 

423
00:19:04,569 --> 00:19:10,609
even though that would be faster and lazier and less code.
即使这样会更快，更懒惰并且代码更少。 

424
00:19:10,609 --> 00:19:12,466
When you do an update to a data structure,
当您更新数据结构时， 

425
00:19:12,467 --> 00:19:14,349
you have to make sure that the rep invariant still
您必须确保rep不变

426
00:19:14,549 --> 00:19:16,299
holds at the end.
坚持到底。 

427
00:19:16,299 --> 00:19:18,799
Sort of a correctness proof for an update algorithm
某种更新算法的正确性证明

428
00:19:18,799 --> 00:19:21,579
says that if the rep invariant holds at the beginning,
说如果rep不变式在​​开始时成立， 

429
00:19:21,579 --> 00:19:24,899
the rep invariant is guaranteed to hold at the end.
代表不变式一定会保留在最后。 

430
00:19:24,900 --> 00:19:27,640
Why do we care about this rep invariant stuff?
我们为什么要关心这个代表不变的东西？ 

431
00:19:27,640 --> 00:19:32,700
Suppose you have a problem, say on the next Pset, that
假设您有一个问题，例如在下一个Pset上， 

432
00:19:32,700 --> 00:19:36,890
asks you to find the place that's slow in your code
要求您找到代码中速度较慢的地方

433
00:19:36,890 --> 00:19:39,490
and then speed it up.
然后加快速度。 

434
00:19:39,490 --> 00:19:42,336
And suppose you recognize the data structure there,
并假设您认识那里的数据结构， 

435
00:19:42,336 --> 00:19:43,960
and you say that's inefficient, and you
你说那效率低下，你

436
00:19:43,960 --> 00:19:46,430
want to implement another data structure that
想要实现另一个数据结构

437
00:19:46,430 --> 00:19:49,419
would be more efficient.
会更有效率。 

438
00:19:49,619 --> 00:19:52,000
You're going to implement it.
您将实现它。 

439
00:19:52,000 --> 00:19:54,390
You might have bugs in an update.
您可能在更新中存在错误。 

440
00:19:54,390 --> 00:19:56,460
How do you find the bugs?
您如何找到错误？ 

441
00:19:56,460 --> 00:19:58,569
Queries give you the wrong answers.
查询给您错误的答案。 

442
00:19:58,569 --> 00:20:01,509
You might do queries a long time after you do updates,
更新后可能会查询很长时间， 

443
00:20:01,509 --> 00:20:04,624
and you're not going to know which update failed.
而且您不会知道哪个更新失败。 

444
00:20:04,624 --> 00:20:06,789
The right way to do this is you implement the method
正确的方法是实现方法

445
00:20:06,789 --> 00:20:10,250
called Check RI-- that's what I call it-- so
叫做Check RI，这就是我所说的

446
00:20:10,250 --> 00:20:12,170
check the representation invariant.
检查表示形式不变。 

447
00:20:12,170 --> 00:20:14,630
And that method walks through the entire data structure
该方法遍历整个数据结构

448
00:20:14,630 --> 00:20:16,960
and make sure that the rep invariant holds,
并确保代表不变式成立， 

449
00:20:16,960 --> 00:20:19,088
and if it doesn't, it raises an exception
如果没有，则会引发异常

450
00:20:19,088 --> 00:20:21,379
because you know that whatever you try to do from there
因为您知道从那里尝试做什么

451
00:20:21,380 --> 00:20:25,379
is not going to work, so there's no reason to keep going.
无法正常工作，因此没有理由继续前进。 

452
00:20:25,579 --> 00:20:28,109
So at the end of every update, you add a call
因此，在每次更新结束时，您都会添加一个通话

453
00:20:28,109 --> 00:20:32,049
to this Check RI method until you're
直到您

454
00:20:32,049 --> 00:20:34,480
sure that your code is correct.
确保您的代码正确。 

455
00:20:34,480 --> 00:20:36,390
And after you're done debugging your code,
在调试完代码后， 

456
00:20:36,390 --> 00:20:40,180
you remove this method and you submit the code.
您删除此方法，然后提交代码。 

457
00:20:40,180 --> 00:20:42,109
Why do I want to remove the method?
为什么要删除该方法？ 

458
00:20:42,309 --> 00:20:45,289
It might be painfully slow and inefficient, much slower
它可能会很慢，效率很低，要慢得多

459
00:20:45,289 --> 00:20:47,529
than the actual queries and updates.
比实际的查询和更新。 

460
00:20:47,529 --> 00:20:49,009
For example, let's take a heap.
例如，让我们堆一堆。 

461
00:20:49,009 --> 00:20:52,609
Do people remember heaps from lecture?
人们还记得演讲中的堆吗？ 

462
00:20:52,609 --> 00:20:54,869
What's the query for a heap?
对堆的查询是什么？ 

463
00:20:54,869 --> 00:20:55,929
Say you have a max heap.
假设您有一个最大堆。 

464
00:20:55,930 --> 00:20:58,567
What's a query?
什么是查询？ 

465
00:20:58,567 --> 00:20:59,650
AUDIENCE: Where's the max?
听众：最高限额在哪里？ 

466
00:20:59,650 --> 00:21:00,599
PROFESSOR: OK, cool.
教授：好的，很酷。 

467
00:21:00,799 --> 00:21:03,569
So for a max heap, a query would be max.
因此，对于最大堆，查询将是最大。 

468
00:21:03,569 --> 00:21:04,200
Running time?
运行时间？ 

469
00:21:04,200 --> 00:21:07,510



470
00:21:07,510 --> 00:21:08,456
AUDIENCE: Constant.
听众：不变。 

471
00:21:08,457 --> 00:21:09,248
PROFESSOR: Perfect.
教授：完美。 

472
00:21:09,248 --> 00:21:10,159
Constant.
不变。 

473
00:21:10,359 --> 00:21:13,879
What do you do?
你是做什么？ 

474
00:21:13,880 --> 00:21:15,122
Look at the top?
看顶部？ 

475
00:21:15,122 --> 00:21:16,307
AUDIENCE: Yeah, exactly.
听众：是的，确实如此。 

476
00:21:16,307 --> 00:21:16,890
PROFESSOR: OK.
教授：好的。 

477
00:21:16,890 --> 00:21:17,640
Sweet.
甜。 

478
00:21:17,640 --> 00:21:23,430
So what are the two popular updates in a max heap?
那么最大堆中两个流行的更新是什么？ 

479
00:21:23,430 --> 00:21:25,399
AUDIENCE: There would be Insert as well.
听众：也会有插入。 

480
00:21:25,599 --> 00:21:28,480
PROFESSOR: OK.
教授：好的。 

481
00:21:28,480 --> 00:21:29,769
Insert.
插入。 

482
00:21:29,769 --> 00:21:32,306
And did we teach you general delete?
并且我们教过您一般删除吗？ 

483
00:21:32,306 --> 00:21:39,309



484
00:21:39,309 --> 00:21:44,817
Usually Extract Max is simpler.
通常，Extract Max更简单。 

485
00:21:44,817 --> 00:21:45,650
That's all you need.
这就是您所需要的。 

486
00:21:45,650 --> 00:21:51,369



487
00:21:51,569 --> 00:21:53,269
What's the running time for Insert?
插入的运行时间是几点？ 

488
00:21:53,269 --> 00:21:56,829



489
00:21:56,829 --> 00:21:59,389
Do people remember heaps?
人们还记得堆吗？ 

490
00:21:59,390 --> 00:22:03,190
AUDIENCE: I think it was per N, but I'm not completely sure.
听众：我认为是每N个，但我不确定。 

491
00:22:03,190 --> 00:22:04,559
PROFESSOR: Anyone else?
教授：还有其他人吗？ 

492
00:22:04,559 --> 00:22:05,250
It's not.
不是。 

493
00:22:05,250 --> 00:22:08,134
Life would be bad if it would be N.
如果它是N，生活将会很糟糕。 

494
00:22:08,134 --> 00:22:09,217
AUDIENCE: N squared?
听众：N平方？ 

495
00:22:09,217 --> 00:22:09,599
PROFESSOR: No.
教授：不。 

496
00:22:09,799 --> 00:22:13,835



497
00:22:13,835 --> 00:22:16,210
It's better than N, so you guys are doing a binary search
比N好，所以你们在做二进制搜索

498
00:22:16,210 --> 00:22:18,660
over the few running times that I gave you earlier.
在我之前给您的几个运行时间中。 

499
00:22:18,660 --> 00:22:19,917
AUDIENCE: [INAUDIBLE] add to the N,
观众：[听不清]加到N， 

500
00:22:20,117 --> 00:22:22,498
and then you compare your neighbor, and then you
然后你比较你的邻居，然后你

501
00:22:22,498 --> 00:22:24,044
[INAUDIBLE].
 [听不清]。 

502
00:22:24,244 --> 00:22:26,779
AUDIENCE: If it's an array, there isn't--
听众：如果是数组，就不会- 

503
00:22:26,779 --> 00:22:29,271
PROFESSOR: So conceptually, a heap looks like this.
教授：所以从概念上讲，堆看起来像这样。 

504
00:22:29,271 --> 00:22:30,980
And yeah, it becomes an array eventually,
是的，它最终成为一个数组， 

505
00:22:30,980 --> 00:22:32,750
but let's look at it this way.
但是让我们这样看。 

506
00:22:32,750 --> 00:22:36,500



507
00:22:36,500 --> 00:22:37,950
It is a full binary tree.
它是完整的二叉树。 

508
00:22:37,950 --> 00:22:41,289
Binary tree means that each node has at most two children,
二叉树表示每个节点最多有两个孩子， 

509
00:22:41,289 --> 00:22:44,159
and full means that every level except for the last level
满是指除最后一个级别外的每个级别

510
00:22:44,160 --> 00:22:45,420
is completely populated.
已完全填充。 

511
00:22:45,420 --> 00:22:48,769
So every internal node has exactly two children,
所以每个内部节点都有两个孩子

512
00:22:48,769 --> 00:22:53,049
and in here, every node except for some nodes
在这里，除某些节点外，每个节点

513
00:22:53,049 --> 00:22:56,700
and then some nodes after it will not have.
然后它之后的某些节点将没有。 

514
00:22:56,700 --> 00:22:58,889
Everything to the left is fully populated,
左侧的所有内容均已完全填充， 

515
00:22:59,089 --> 00:23:01,869
and then at some point, you stop having children.
然后在某个时候，您不再有孩子。 

516
00:23:01,869 --> 00:23:05,149
It turns out that this is easy to store in an array,
事实证明，这很容易存储在数组中， 

517
00:23:05,150 --> 00:23:06,660
but I will not go over that.
但是我不会再说了。 

518
00:23:06,660 --> 00:23:09,660
Instead, I want to go over inserting.
相反，我想遍历插入。 

519
00:23:09,660 --> 00:23:13,980
What's the rep invariant for a heap?
堆的代表不变式是什么？ 

520
00:23:13,980 --> 00:23:15,960
AUDIENCE: The max in the top, right?
听众：最上面的最大，对吗？ 

521
00:23:15,960 --> 00:23:18,371
Well, for max heap, and then the two children
好吧，为了最大堆，然后是两个孩子

522
00:23:18,571 --> 00:23:20,455
are less than the next node.
小于下一个节点。 

523
00:23:20,455 --> 00:23:21,329
PROFESSOR: All right.
教授：好的。 

524
00:23:21,329 --> 00:23:23,514
So the guy here has to be bigger than these guys,
所以这里的人必须比这些人大， 

525
00:23:23,515 --> 00:23:25,640
then the guy here has to be bigger than these guys,
那么这里的人必须比这些人大， 

526
00:23:25,640 --> 00:23:26,980
and so on and so forth.
等等等等。 

527
00:23:26,980 --> 00:23:29,990
And if you use induction, you can
如果您使用归纳法，您可以

528
00:23:29,990 --> 00:23:32,211
prove that if this is bigger than this,
证明如果这个比这个大， 

529
00:23:32,211 --> 00:23:34,170
it has to be bigger than these guys, and bigger
它必须比这些家伙更大，更大

530
00:23:34,170 --> 00:23:36,970
than these guys, and bigger than everything, and it's a max.
比这些家伙，比一切都更大，这是最大的。 

531
00:23:36,970 --> 00:23:40,059
That's the reason why we have that rep invariant.
这就是我们使该代表不变的原因。 

532
00:23:40,059 --> 00:23:42,480
So the way we insert a node is we add it
所以我们插入节点的方法是添加它

533
00:23:42,480 --> 00:23:45,279
at the bottom, the only place where we could add it.
在底部，这是我们可以添加的唯一位置。 

534
00:23:45,279 --> 00:23:48,190
And then if this guy is bigger than this guy,
然后如果这个人比这个人大， 

535
00:23:48,190 --> 00:23:50,909
the rep invariant is violated, so we swap them
代表不变式被违反，因此我们将其交换

536
00:23:51,109 --> 00:23:53,269
in order to fix that.
为了解决这个问题。 

537
00:23:53,269 --> 00:23:54,269
Now the guy is here.
现在那个家伙在这里。 

538
00:23:54,269 --> 00:23:56,889
If this is bigger than this, we do another swap.
如果大于此值，我们将进行另一次交换。 

539
00:23:56,890 --> 00:24:00,400
If this is bigger than this, we do another swap.
如果大于此值，我们将进行另一次交换。 

540
00:24:00,400 --> 00:24:03,990
So you're going to go from the bottom of the heap potentially
因此，您可能会从堆的底部开始

541
00:24:03,990 --> 00:24:06,210
all the way up to the root.
一直到根

542
00:24:06,210 --> 00:24:08,819
So the running time of insert is order
所以插入的运行时间是命令

543
00:24:08,819 --> 00:24:10,700
of the height of the heap.
堆的高度。 

544
00:24:10,700 --> 00:24:13,379



545
00:24:13,579 --> 00:24:16,809
Now, the heap is a full binary tree.
现在，堆是完整的二叉树。 

546
00:24:16,809 --> 00:24:17,444
I said "full."
我说“饱”。 

547
00:24:17,444 --> 00:24:18,319
I keep saying "full."
我一直说“满”。 

548
00:24:18,319 --> 00:24:20,764
The reason I care about full is that the full binary tree
我关心完全的原因是完全的二叉树

549
00:24:20,765 --> 00:24:24,767
is guaranteed to have a height of log N. It's always
保证高度为N。 

550
00:24:24,767 --> 00:24:26,149
log N, where N is the number of nodes.
 log N，其中N是节点数。 

551
00:24:26,349 --> 00:24:30,119



552
00:24:30,119 --> 00:24:35,302
So inserting in a heap takes log N.
因此，在堆中插入需要日志N。 

553
00:24:35,303 --> 00:24:36,469
AUDIENCE: I have a question.
听众：我有一个问题。 

554
00:24:36,469 --> 00:24:39,414
Didn't they say that because it's in an array,
他们不是这么说是因为它在一个数组中， 

555
00:24:39,414 --> 00:24:44,230
then to find it-- oh no, I guess because you can still
然后找到它-哦不，我想是因为您仍然可以

556
00:24:44,230 --> 00:24:44,949
do the swaps.
做交换。 

557
00:24:44,949 --> 00:24:46,490
PROFESSOR: You can still do the swaps
教授：您仍然可以进行交换

558
00:24:46,490 --> 00:24:48,720
when you have it serialized in an array.
当您将其序列化为数组时。 

559
00:24:48,720 --> 00:24:50,450
You know that given an item's index,
您知道给定项目的索引， 

560
00:24:50,450 --> 00:24:53,894
the parent is that index divided by 2.
父级是该索引除以2。 

561
00:24:53,894 --> 00:24:55,809
So you add an element at the end of the array,
因此，您在数组的末尾添加了一个元素， 

562
00:24:55,809 --> 00:24:57,099
and then you know what the parent is,
然后你知道父母是谁

563
00:24:57,099 --> 00:24:58,987
and then you keep swapping and swapping and swapping
然后你继续交换和交换

564
00:24:58,988 --> 00:24:59,943
towards the [INAUDIBLE].
向[听不清]。 

565
00:24:59,943 --> 00:25:01,299
AUDIENCE: You don't ever have to put it in
听众：您永远不必放入

566
00:25:01,299 --> 00:25:02,071
and shift everything over.
并转移一切。 

567
00:25:02,071 --> 00:25:02,419
You're only swapping.
您只是交换。 

568
00:25:02,420 --> 00:25:03,045
PROFESSOR: Yep.
教授：是的。 

569
00:25:03,045 --> 00:25:04,200
You only swap.
您只交换。 

570
00:25:04,200 --> 00:25:06,131
That's important.
那很重要

571
00:25:06,131 --> 00:25:06,880
Thanks for asking.
感谢您的询问。 

572
00:25:06,880 --> 00:25:07,650
That's important.
那很重要

573
00:25:07,650 --> 00:25:11,649
So log N. Extract max, take my word for it,
因此，登录N。提取最大，相信我， 

574
00:25:11,849 --> 00:25:16,379
also log N. What's the running time for checking
也记录N。检查的运行时间是多少

575
00:25:16,380 --> 00:25:19,559
the invariant in a heap?
堆中的不变式？ 

576
00:25:19,759 --> 00:25:22,589
So to make sure that this guy is a heap, if I had numbers here,
因此，请确保这个人是一个堆，如果我在这里有数字， 

577
00:25:22,589 --> 00:25:24,000
what would you have to do?
你要怎么办

578
00:25:24,000 --> 00:25:29,279



579
00:25:29,279 --> 00:25:31,295
AUDIENCE: You'd have to look at every node.
听众：您必须查看每个节点。 

580
00:25:31,295 --> 00:25:31,920
PROFESSOR: Yep.
教授：是的。 

581
00:25:31,920 --> 00:25:34,304
So running time?
那么运行时间？ 

582
00:25:34,304 --> 00:25:36,547
AUDIENCE: Theta of N.
观众：N的Theta。 

583
00:25:36,547 --> 00:25:37,172
PROFESSOR: Yep.
教授：是的。 

584
00:25:37,172 --> 00:25:40,819



585
00:25:40,819 --> 00:25:43,429
So if I'm going to submit code for a heap
因此，如果我要提交堆代码

586
00:25:43,430 --> 00:25:46,410
where the operations are our order of log N,
这些操作是我们的日志N的顺序， 

587
00:25:46,410 --> 00:25:50,730
or order 1, but then each of these calls Check RI,
或订单1，但随后每个调用RI， 

588
00:25:50,730 --> 00:25:52,640
that's going to be painfully slow because I'm
这将是痛苦的缓慢，因为我

589
00:25:52,640 --> 00:25:55,650
making the updates be order N instead of log N.
使更新的顺序为N，而不是日志N。 

590
00:25:55,650 --> 00:25:59,160
So you're putting Check RI calls in every update.
因此，您将在每次更新中添加Check RI调用。 

591
00:25:59,160 --> 00:26:00,606
You debug your code.
您调试代码。 

592
00:26:00,606 --> 00:26:02,690
When you make sure it's correct, you remove those,
如果确定正确无误，则将其删除， 

593
00:26:02,690 --> 00:26:05,809
and then you submit the Pset.
然后提交Pset。 

594
00:26:05,809 --> 00:26:08,529
Make sense?
说得通？ 

595
00:26:08,529 --> 00:26:09,759
Sweet.
甜。 

596
00:26:09,759 --> 00:26:12,069
And we looked a little bit at heaps, which is good.
我们稍微看了看堆，这很好。 

597
00:26:12,069 --> 00:26:16,519



598
00:26:16,519 --> 00:26:18,319
Binary search trees.
二进制搜索树。 

599
00:26:18,319 --> 00:26:21,000
So a binary tree is a tree where every node
所以二叉树是一棵树，每个节点

600
00:26:21,000 --> 00:26:23,829
has at most two children.
最多有两个孩子。 

601
00:26:23,829 --> 00:26:28,460
When we code this up, we represent a node as a Python
当我们编写代码时，我们将节点表示为Python 

602
00:26:28,460 --> 00:26:34,809
object, and for a node, we keep track of the left child,
对象，对于一个节点，我们跟踪左孩子， 

603
00:26:34,809 --> 00:26:41,879
of the right child, parent, and then this is a hollow tree.
正确的孩子，父母，然后这是一棵空心树。 

604
00:26:41,880 --> 00:26:42,899
It's not very useful.
这不是很有用。 

605
00:26:43,099 --> 00:26:46,369
This becomes useful when you start putting keys in the nodes
当您开始将密钥放入节点时，这将变得很有用

606
00:26:46,369 --> 00:26:49,689
so that you can find them and do other things with them.
这样您就可以找到它们并与他们一起做其他事情。 

607
00:26:49,690 --> 00:26:50,629
So each node has a key.
因此，每个节点都有一个密钥。 

608
00:26:50,829 --> 00:26:53,639



609
00:26:53,640 --> 00:26:55,390
Let me draw a binary search tree.
让我画一个二叉搜索树。 

610
00:26:55,390 --> 00:27:11,275



611
00:27:11,275 --> 00:27:14,159
Can people see this?
人们可以看到吗？ 

612
00:27:14,359 --> 00:27:15,750
So this is a binary tree.
所以这是一个二叉树。 

613
00:27:15,750 --> 00:27:18,359
Can someone say something a bit more specific about it?
有人可以说些具体一点吗？ 

614
00:27:18,359 --> 00:27:23,049



615
00:27:23,049 --> 00:27:24,399
AUDIENCE: It's unbalanced.
听众：不平衡。 

616
00:27:24,400 --> 00:27:24,690
PROFESSOR: OK.
教授：好的。 

617
00:27:24,690 --> 00:27:25,355
It's imbalanced.
它是不平衡的。 

618
00:27:25,355 --> 00:27:28,589



619
00:27:28,589 --> 00:27:31,259
So that means that finding things all the way
因此，这意味着始终寻找事物

620
00:27:31,259 --> 00:27:34,050
at the bottom is going to be expensive.
最底层的将是昂贵的。 

621
00:27:34,050 --> 00:27:34,549
What else?
还有什么？ 

622
00:27:34,549 --> 00:27:37,519



623
00:27:37,519 --> 00:27:39,139
So I said it's a binary tree.
所以我说这是一棵二叉树。 

624
00:27:39,140 --> 00:27:40,900
Give me something more specific.
给我一些更具体的东西。 

625
00:27:40,900 --> 00:27:45,629



626
00:27:45,829 --> 00:27:50,059
So binary tree just means that every node has two children.
因此，二叉树仅意味着每个节点都有两个孩子。 

627
00:27:50,059 --> 00:27:52,470
There's a bit more structure in this guy.
这个家伙有更多的结构。 

628
00:27:52,470 --> 00:27:55,839
So if I look at the root, if I look at 23,
所以，如果我看根，如果我看23， 

629
00:27:55,839 --> 00:27:58,740
all the nodes to the left are smaller.
左侧的所有节点都较小。 

630
00:27:58,740 --> 00:28:01,634
All the nodes to the right are bigger.
右边的所有节点都更大。 

631
00:28:01,634 --> 00:28:04,319
Now, if I look at 8, all the nodes to the left are smaller,
现在，如果我看8，左侧的所有节点都较小， 

632
00:28:04,319 --> 00:28:06,359
all the nodes to the right are greater.
右边的所有节点都更大。 

633
00:28:06,359 --> 00:28:10,309



634
00:28:10,309 --> 00:28:15,750
This additional rep invariant defines a binary search tree.
这个附加的rep不变式定义了一个二进制搜索树。 

635
00:28:15,750 --> 00:28:19,819
This is what we talked about in class.
这就是我们在课堂上谈到的。 

636
00:28:19,819 --> 00:28:22,319
BST.
 BST。 

637
00:28:22,319 --> 00:28:24,944
Why would I want to have this rep invariant?
为什么我要让这个代表不变？ 

638
00:28:24,944 --> 00:28:27,539
It sounds like a pain to maintain nodes
维护节点听起来很痛苦

639
00:28:27,539 --> 00:28:29,809
with all these ordering constraints.
所有这些排序约束。 

640
00:28:29,809 --> 00:28:32,710
What's the advantage of doing that?
这样做的好处是什么？ 

641
00:28:32,710 --> 00:28:33,996
AUDIENCE: Search is fast.
听众：搜索很快。 

642
00:28:33,996 --> 00:28:34,419
PROFESSOR: Yep.
教授：是的。 

643
00:28:34,619 --> 00:28:35,309
Search is fast.
搜索速度很快。 

644
00:28:35,309 --> 00:28:37,960
How do I do search?
我该如何搜寻？ 

645
00:28:37,960 --> 00:28:41,220
If you're looking for 42 or for 16,
如果您要寻找42或16， 

646
00:28:41,220 --> 00:28:43,440
you'd be like, oh, it's less than 23.
你会想，哦，不到23岁。 

647
00:28:43,440 --> 00:28:45,640
I'll get on this path.
我走这条路。 

648
00:28:45,640 --> 00:28:48,880
PROFESSOR: So start at the root, compare my key to the root.
教授：因此，从根开始，将我的密钥与根进行比较。 

649
00:28:48,880 --> 00:28:49,888
If it's smaller, go left.
如果较小，请向左走。 

650
00:28:50,088 --> 00:28:51,129
If it's bigger, go right.
如果更大，请继续。 

651
00:28:51,130 --> 00:28:53,399
Then keep doing that until I arrive somewhere
然后继续做，直到我到达某个地方

652
00:28:53,599 --> 00:28:57,589
or until I arrive at a dead end if I'm looking for 14.
或直到我走到尽头时才寻找14。 

653
00:28:57,589 --> 00:28:59,859
This is a lot like binary search.
这很像二进制搜索。 

654
00:28:59,859 --> 00:29:02,329
Binary search in an array, you look at the middle.
在数组中进行二进制搜索，您可以看中间。 

655
00:29:02,329 --> 00:29:03,759
If your key is smaller, go left.
如果密钥较小，请向左移动。 

656
00:29:03,759 --> 00:29:05,299
If your key is bigger, then go right.
如果您的钥匙更大，请继续。 

657
00:29:05,299 --> 00:29:09,680



658
00:29:09,680 --> 00:29:13,289
Let's look at the code for a little bit.
让我们看一下代码。 

659
00:29:13,289 --> 00:29:16,490
Look at the BST Node Class, and you'll
看一下BST节点类，您将

660
00:29:16,490 --> 00:29:19,019
see that it has the fields that we have up here.
看到它具有我们在此处拥有的字段。 

661
00:29:19,019 --> 00:29:21,369
And look at the Find method, and this is pretty much
看一下Find方法，这差不多

662
00:29:21,369 --> 00:29:23,019
the binary search code.
二进制搜索代码。 

663
00:29:23,019 --> 00:29:26,920
Lines 8 and 9 have the return condition when you're happy
第8行和第9行在您满意时具有返回条件

664
00:29:26,920 --> 00:29:30,986
and you found the key, and then line 10 compares
然后您找到了密钥，然后第10行进行了比较

665
00:29:31,186 --> 00:29:33,519
the key that you're looking for with the key in the node
您要查找的密钥与节点中的密钥

666
00:29:33,519 --> 00:29:38,009
that you're at, and then lines 11, 14, 16, and 19 are pretty
您所在的位置，然后第11、14、16和19行就很漂亮

667
00:29:38,009 --> 00:29:39,776
much copy pasted, except one of them
除了其中之一外，粘贴了很多副本

668
00:29:39,776 --> 00:29:41,400
deals with the left case, the other one
处理左边的情况，另一个

669
00:29:41,400 --> 00:29:44,910
deals with the right case.
处理正确的案例。 

670
00:29:44,910 --> 00:29:46,754
What is the running time for Find?
查找的运行时间是几点？ 

671
00:29:46,954 --> 00:29:57,889



672
00:29:57,890 --> 00:30:00,579
AUDIENCE: Wouldn't it be log N, right?
听众：是不是log N，对吗？ 

673
00:30:00,779 --> 00:30:03,440
PROFESSOR: I wish.
教授：我希望。 

674
00:30:03,440 --> 00:30:06,059
If this is all you have to do to get log N,
如果这是获取日志N所需要做的一切， 

675
00:30:06,059 --> 00:30:08,359
then I would have to write a lot less code.
那么我将不得不编写更少的代码。 

676
00:30:08,359 --> 00:30:11,059



677
00:30:11,059 --> 00:30:14,539
So not quite log N. We will have to go through next lecture
因此，没有完全登录N。我们将不得不进行下一讲

678
00:30:14,539 --> 00:30:20,019
to get to log N. Until then, what's the running time?
才能登录N。在那之前，运行时间是多少？ 

679
00:30:20,019 --> 00:30:20,900
AUDIENCE: Order h.
听众：订单h。 

680
00:30:20,900 --> 00:30:21,525
PROFESSOR: Yep.
教授：是的。 

681
00:30:21,525 --> 00:30:23,829



682
00:30:24,029 --> 00:30:26,029
So you told me at the beginning it's unbalanced.
所以您在一开始就告诉我这是不平衡的。 

683
00:30:26,029 --> 00:30:27,134
AUDIENCE: Yeah.
听众：是的。 

684
00:30:27,134 --> 00:30:29,009
PROFESSOR: So then it's not going to be fast.
教授：所以那不会很快。 

685
00:30:29,009 --> 00:30:32,799



686
00:30:32,799 --> 00:30:34,440
OK, so order h.
好，所以订购h。 

687
00:30:34,440 --> 00:30:36,889
The reason why we care about h, and the reason
我们关心h的原因以及原因

688
00:30:37,089 --> 00:30:39,980
we don't say order N, is because next
我们不说订单N，是因为下一个

689
00:30:39,980 --> 00:30:42,414
lecture after we learn how to balance a tree,
在学习如何平衡一棵树之后的讲座

690
00:30:42,414 --> 00:30:45,039
there's some magic that you can do to these binary search trees
您可以对这些二进制搜索树执行一些操作

691
00:30:45,039 --> 00:30:47,721
to guarantee that the height is order of log N.
以确保高度为对数N的量级。 

692
00:30:47,721 --> 00:30:50,220
And then we'll go through all the running times that we have
然后我们将经历所有的运行时间

693
00:30:50,220 --> 00:30:52,675
and replace h with log N.
并将h替换为logN。 

694
00:30:52,675 --> 00:30:55,049
Now, it happens that in this case, if you would have told
现在，在这种情况下，如果您会告诉

695
00:30:55,049 --> 00:30:59,259
me order N, I couldn't argue with you because worst case,
我下令N，我无法与您争论，因为最坏的情况是， 

696
00:30:59,259 --> 00:31:02,789
searches are order N. Can someone give me a binary search
搜索是顺序N。有人可以给我二进制搜索吗

697
00:31:02,789 --> 00:31:07,070
tree that exposes this degenerate case?
暴露这种退化情况的树？ 

698
00:31:07,070 --> 00:31:07,569
Yes?
是？ 

699
00:31:07,569 --> 00:31:09,194
AUDIENCE: If it's completely unbalanced
听众：如果完全不平衡

700
00:31:09,194 --> 00:31:13,149
and every node is greater than the parent nodes.
并且每个节点都大于父节点。 

701
00:31:13,150 --> 00:31:17,234
PROFESSOR: So give me some inserts that create it.
教授：所以请给我一些创建它的插件。 

702
00:31:17,434 --> 00:31:18,819
AUDIENCE: Insert 5.
听众：插入5。 

703
00:31:18,819 --> 00:31:20,621
PROFESSOR: 5.
教授：5。 

704
00:31:20,622 --> 00:31:22,390
AUDIENCE: Insert 10.
听众：插入10。 

705
00:31:22,390 --> 00:31:23,021
PROFESSOR: 10.
教授：10。 

706
00:31:23,221 --> 00:31:24,519
AUDIENCE: Insert 15.
听众：插入15。 

707
00:31:24,519 --> 00:31:25,637
PROFESSOR: 15.
教授：15。 

708
00:31:25,637 --> 00:31:27,041
AUDIENCE: Insert 20.
听众：插入20。 

709
00:31:27,041 --> 00:31:27,980
PROFESSOR: Yep.
教授：是的。 

710
00:31:27,980 --> 00:31:28,940
And I could keep going.
而且我可以继续。 

711
00:31:28,940 --> 00:31:30,539
I could say, 1, 2, 3, 4, 5.
我可以说1、2、3、4、5。 

712
00:31:30,539 --> 00:31:31,740
I could say 5, 10, 15.
我可以说5、10、15 

713
00:31:31,740 --> 00:31:34,000
As long as these keep growing, this is basically
只要这些保持增长，这基本上是

714
00:31:34,000 --> 00:31:37,289
going to be a list, so searching is
将成为一个列表，所以搜索是

715
00:31:37,289 --> 00:31:41,517
order N. This is a degenerate case.
 N阶。这是一个简并的情况。 

716
00:31:41,517 --> 00:31:43,399
Turns out it doesn't happen too often in practice.
事实证明，这种情况在实践中并不经常发生。 

717
00:31:43,599 --> 00:31:47,339
If you have random data, the height will be roughly log N.
如果您有随机数据，则高度大约为logN。 

718
00:31:47,339 --> 00:31:49,529
But in order to avoid those degenerate cases,
但是为了避免这些退化的情况， 

719
00:31:49,529 --> 00:31:54,180
we'll be doing balanced trees later on.
稍后我们将做平衡树。 

720
00:31:54,180 --> 00:31:55,680
So we covered Find.
因此，我们介绍了Find。 

721
00:31:55,680 --> 00:31:56,854
We know it's order h.
我们知道这是命令h。 

722
00:31:56,854 --> 00:31:58,269
How do you insert, really quickly?
如何快速插入？ 

723
00:31:58,269 --> 00:32:09,104



724
00:32:09,104 --> 00:32:10,519
AUDIENCE: Do you mean in searching
听众：您的意思是搜索

725
00:32:10,519 --> 00:32:13,000
when it's balanced or unbalanced?
什么时候平衡或不平衡？ 

726
00:32:13,000 --> 00:32:14,519
PROFESSOR: This guy.
教授：这个家伙。 

727
00:32:14,519 --> 00:32:16,309
So the trees look exactly the same.
所以树木看起来完全一样。 

728
00:32:16,309 --> 00:32:18,419
If it's balanced, it's going to look more
如果平衡，它将看起来更多

729
00:32:18,420 --> 00:32:20,380
like that than like this.
像这样比那样。 

730
00:32:20,380 --> 00:32:22,200
Actually, this is balanced.
实际上，这是平衡的。 

731
00:32:22,200 --> 00:32:23,549
This is perfectly unbalanced.
这是完全不平衡的。 

732
00:32:23,549 --> 00:32:25,125
This is somewhere in the middle.
这是在中间的某个地方。 

733
00:32:25,125 --> 00:32:27,500
If it's balanced, it's just going to look more like this,
如果平衡的话，看起来会更像这样， 

734
00:32:27,500 --> 00:32:30,180
but it's still a binary search tree.
但它仍然是二叉搜索树。 

735
00:32:30,180 --> 00:32:33,480
How would you insert a node?
您将如何插入节点？ 

736
00:32:33,480 --> 00:32:33,980
Yes?
是？ 

737
00:32:33,980 --> 00:32:35,943
AUDIENCE: Can't you start at the root
听众：你不能从根本开始

738
00:32:35,943 --> 00:32:38,398
and find your way down, and then the first open child
然后找到路，然后是第一个开放的孩子

739
00:32:38,398 --> 00:32:43,685
that you see that's applicable to your element, state it then?
您看到适用于您的元素的状态，然后声明？ 

740
00:32:43,685 --> 00:32:44,309
PROFESSOR: Yep.
教授：是的。 

741
00:32:44,309 --> 00:32:49,405
So if I wanted to insert 14, which way do I go?
因此，如果我想插入14，我应该走哪条路？ 

742
00:32:49,405 --> 00:32:51,279
AUDIENCE: So you'd look at 23, and you'd say,
听众：所以你看23，你会说， 

743
00:32:51,279 --> 00:32:53,214
it's less than 23, go left.
不到23，向左走。 

744
00:32:53,214 --> 00:32:54,669
You'd look at 8.
您会看到8。 

745
00:32:54,670 --> 00:32:56,409
You'd say, it's greater than 8.
您会说，它大于8。 

746
00:32:56,609 --> 00:32:57,564
You'd go right.
你会走对的。 

747
00:32:57,565 --> 00:32:58,065
Look at 16.
看16。 

748
00:32:58,065 --> 00:33:00,005
You'd say it's less, so you go left.
你会说它少了，所以你走了。 

749
00:33:00,005 --> 00:33:00,774
15, it's less.
 15，更少。 

750
00:33:00,974 --> 00:33:03,855
Then you have an open spot so you stick it there.
然后，您有一个开放的位置，可以将其粘贴在那里。 

751
00:33:03,855 --> 00:33:04,730
PROFESSOR: Excellent.
教授：非常好。 

752
00:33:04,730 --> 00:33:06,930
Thank you.
谢谢。 

753
00:33:06,930 --> 00:33:07,769
Yes?
是？ 

754
00:33:07,769 --> 00:33:08,935
AUDIENCE: I have a question.
听众：我有一个问题。 

755
00:33:08,935 --> 00:33:11,175
What if we want to insert 5?
如果要插入5怎么办？ 

756
00:33:11,175 --> 00:33:12,358
Then--
然后 - 

757
00:33:12,358 --> 00:33:14,024
PROFESSOR: So if you want to insert who?
教授：那么，如果您想插入谁？ 

758
00:33:14,025 --> 00:33:14,714
AUDIENCE: 5.
听众：5。 

759
00:33:14,914 --> 00:33:17,589
Or actually no, we can't.
或实际上不，我们不能。 

760
00:33:17,589 --> 00:33:22,183
I'm thinking, is there any case in which need to move a node?
我在想，是否有需要移动节点的情况？ 

761
00:33:22,183 --> 00:33:23,599
PROFESSOR: How would you insert 5?
教授：您将如何插入5？ 

762
00:33:23,599 --> 00:33:24,099
Let's see.
让我们来看看。 

763
00:33:24,099 --> 00:33:25,551
What would you do for 5?
你要做什么5？ 

764
00:33:25,551 --> 00:33:29,407
AUDIENCE: For 5, then we'd insert it to the right of 4,
听众：对于5，然后将其插入4的右侧

765
00:33:29,407 --> 00:33:30,859
right?
对？ 

766
00:33:30,859 --> 00:33:32,655
PROFESSOR: Smaller, smaller, greater, 5.
教授：更小，更小，更大，5。 

767
00:33:32,655 --> 00:33:33,154
Right?
对？ 

768
00:33:33,154 --> 00:33:36,410



769
00:33:36,410 --> 00:33:38,359
AUDIENCE: So there would be no case in which we'd
听众：因此，在任何情况下我们都不会

770
00:33:38,559 --> 00:33:41,359
need to swap nodes or something?
需要交换节点或其他东西吗？ 

771
00:33:41,359 --> 00:33:42,083
PROFESSOR: No.
教授：不。 

772
00:33:42,084 --> 00:33:43,000
You're thinking ahead.
你在想

773
00:33:43,000 --> 00:33:46,900
We'll talk about that a little later when we get to deleting.
我们稍后再讨论删除内容。 

774
00:33:46,900 --> 00:33:51,720
As long as you follow a path in the tree, the path that finding
只要您遵循树中的路径， 

775
00:33:51,720 --> 00:33:54,720
would get you to, as soon as you hit a dead end,
会让您一踏入死胡同， 

776
00:33:54,720 --> 00:33:56,046
that's where your node belongs.
这就是您的节点所属的位置。 

777
00:33:56,046 --> 00:33:58,420
Because you know next time you're going to search for it,
因为您知道下次要搜索它， 

778
00:33:58,420 --> 00:34:02,230
the search is going to follow that path and find the node.
搜索将遵循该路径并找到节点。 

779
00:34:02,230 --> 00:34:02,799
Yes?
是？ 

780
00:34:02,799 --> 00:34:04,923
AUDIENCE: If you have values are the same, like two
听众：如果您的值相同，例如两个

781
00:34:04,923 --> 00:34:07,619
nodes at the same number, does it
节点数目相同

782
00:34:07,619 --> 00:34:09,359
matter which side you put it on?
不管戴哪一边？ 

783
00:34:09,360 --> 00:34:10,990
PROFESSOR: You don't.
教授：你不知道。 

784
00:34:10,990 --> 00:34:11,880
AUDIENCE: Oh, I see.
听众：哦，我知道了。 

785
00:34:11,880 --> 00:34:15,670
It's more like you would only have four 1's in the tree.
这更像是树中只有四个1。 

786
00:34:15,670 --> 00:34:16,440
PROFESSOR: Yes.
教授：是的。 

787
00:34:16,440 --> 00:34:18,804
So if you're trying to store keys and values,
因此，如果您要存储键和值， 

788
00:34:18,804 --> 00:34:20,178
then what you'd have to do if you
那你该怎么办

789
00:34:20,179 --> 00:34:21,945
want to allow multiple values for the same key
想要为同一个键允许多个值

790
00:34:21,945 --> 00:34:23,539
is you have a linked list going off
你有一个链表关闭吗

791
00:34:23,539 --> 00:34:26,769
of this, which node becomes an array of values
其中，哪个节点成为值数组

792
00:34:26,769 --> 00:34:28,304
aside from the key.
除了钥匙。 

793
00:34:28,304 --> 00:34:28,928
Smart question.
聪明的问题。 

794
00:34:28,929 --> 00:34:29,699
Thank you.
谢谢。 

795
00:34:29,699 --> 00:34:33,800
That trips you up every time you do actual code,
每次您执行实际代码时，都会使您烦恼， 

796
00:34:33,800 --> 00:34:35,889
so that's the right question to ask yourself
所以这是问自己的正确问题

797
00:34:35,889 --> 00:34:36,880
when you're implementing this.
当您执行此操作时。 

798
00:34:36,880 --> 00:34:37,838
Will I have duplicates?
我会重复吗？ 

799
00:34:37,838 --> 00:34:39,610
How do I handle them?
我该如何处理？ 

800
00:34:39,809 --> 00:34:40,489
We don't.
我们没有。 

801
00:34:40,489 --> 00:34:43,300
We take the easy way out.
我们采取简单的方法。 

802
00:34:43,300 --> 00:34:45,460
So if you look at Insert, on the next page,
因此，如果您在下一页上查看“插入”， 

803
00:34:45,460 --> 00:34:48,440
you will see that the code is pretty much the Find code
您将看到该代码几乎是“查找”代码

804
00:34:48,440 --> 00:34:53,869
copy pasted, except when Self Left is None
复制粘贴，除非“自我左”为“无”时

805
00:34:53,869 --> 00:34:55,820
or Self Right is None, instead of returning,
或“自我权利”为“无”，而不是返回， 

806
00:34:55,820 --> 00:34:56,650
it creates a new node.
它创建一个新节点。 

807
00:34:56,849 --> 00:35:02,295



808
00:35:02,295 --> 00:35:03,819
Does that make sense to people?
这对人们有意义吗？ 

809
00:35:03,820 --> 00:35:06,914



810
00:35:06,914 --> 00:35:07,414
All right.
好吧。 

811
00:35:07,414 --> 00:35:10,719



812
00:35:10,719 --> 00:35:13,730
So Delete is going to be the hardest operation for today.
因此，删除将是当今最困难的操作。 

813
00:35:13,730 --> 00:35:15,760
Before we do that, let's do a warm up operation.
在此之前，让我们进行预热操作。 

814
00:35:15,760 --> 00:35:18,820



815
00:35:18,820 --> 00:35:29,150
Let's say I want to implement Find Next Larger, also called
假设我要实现“查找下一个更大的对象”，也称为

816
00:35:29,349 --> 00:35:32,110
Successor in some implementations.
在某些实现中的后继。 

817
00:35:32,110 --> 00:35:33,730
So I have a node.
所以我有一个节点。 

818
00:35:33,929 --> 00:35:41,129
Say I have node 8, and I want to find the next key
假设我有节点8，我想找到下一个密钥

819
00:35:41,130 --> 00:35:43,710
in the tree that's strictly larger than 8
在严格大于8的树中

820
00:35:43,710 --> 00:35:46,190
but smaller than anything else.
但比其他任何东西都小。 

821
00:35:46,190 --> 00:35:48,769
So if I would take these nodes and write them down in order,
因此，如果我将这些节点取下来并按顺序写下来， 

822
00:35:48,769 --> 00:35:52,400
I want to find the element that would go right after it.
我想找到紧随其后的元素。 

823
00:35:52,400 --> 00:35:53,826
How do I do that?
我怎么做？ 

824
00:35:54,025 --> 00:35:54,919
Don't cheat.
不要作弊

825
00:35:54,920 --> 00:35:59,588
Don't look at the code, or make my life easier and do searches.
不要看代码，也不要让我的生活更轻松并进行搜索。 

826
00:35:59,588 --> 00:36:01,079
AUDIENCE: Go down one to the right,
听众：向右下移一个， 

827
00:36:01,079 --> 00:36:03,297
and you try to get down left as far as you can.
然后您尽力往左走。 

828
00:36:03,297 --> 00:36:03,880
PROFESSOR: OK.
教授：好的。 

829
00:36:03,880 --> 00:36:04,869
Very good.
很好。 

830
00:36:04,869 --> 00:36:11,309
So I have a node, and it has some subtree here,
所以我有一个节点，这里有一些子树， 

831
00:36:11,309 --> 00:36:17,690
so I can go to the right here, I can go all the way left.
所以我可以在这里向右走，我可以一直向左走。 

832
00:36:17,690 --> 00:36:19,369
We have an operation that does this,
我们有一个操作可以做到这一点， 

833
00:36:19,369 --> 00:36:22,181
and it's called Min for a tree.
它被称为Min for a tree。 

834
00:36:22,181 --> 00:36:24,389
In order to find the minimum in a binary search tree,
为了在二叉搜索树中找到最小值， 

835
00:36:24,389 --> 00:36:25,869
you keep going left.
你一直往左走。 

836
00:36:25,869 --> 00:36:28,869
For example, in this case, you get 4, which is good.
例如，在这种情况下，您得到4，这很好。 

837
00:36:28,869 --> 00:36:31,969
So the way you would code this up is if you have Min,
因此，如果有Min，则可以编写此代码

838
00:36:31,969 --> 00:36:33,739
you go to the right if you can, and then
如果可以的话，您会向右走，然后

839
00:36:33,739 --> 00:36:36,389
you call Min on the subtree.
您在子树上调用Min。 

840
00:36:36,389 --> 00:36:41,339
And you can see that lines 3 and 4 do exactly that.
您会看到第3行和第4行正是这样做的。 

841
00:36:41,340 --> 00:36:42,980
Good guess.
不错的猜测。 

842
00:36:43,179 --> 00:36:45,629
But you can line 1 says case one,
但您可以在第1行说第一种情况， 

843
00:36:45,630 --> 00:36:50,039
so you have the right answer for one case.
因此，对于一种情况，您有正确的答案。 

844
00:36:50,039 --> 00:36:53,759
Now we have to handle more difficult cases.
现在我们必须处理更困难的情况。 

845
00:36:53,760 --> 00:36:59,289
What if instead, I go down a bunch of nodes,
相反，如果我走了一大堆节点， 

846
00:36:59,489 --> 00:37:04,779
and I want to find the successor for this guy, for example,
例如，我想找到这个人的继任者， 

847
00:37:04,780 --> 00:37:06,420
and there's nothing here.
这里什么都没有。 

848
00:37:06,420 --> 00:37:07,050
What do I do?
我该怎么办？ 

849
00:37:07,050 --> 00:37:12,090



850
00:37:12,090 --> 00:37:16,960
So if I want to find the successor for 8, what do I do?
因此，如果我想找到8的后继者，我该怎么办？ 

851
00:37:17,159 --> 00:37:17,659
Sorry.
抱歉。 

852
00:37:17,659 --> 00:37:18,367
It has an answer.
它有一个答案。 

853
00:37:18,367 --> 00:37:24,246
What if I want to find the successor for 4?
如果我想找到4的后继者怎么办？ 

854
00:37:24,246 --> 00:37:27,228



855
00:37:27,228 --> 00:37:28,230
AUDIENCE: Go up one.
听众：上去一个。 

856
00:37:28,230 --> 00:37:28,813
PROFESSOR: OK.
教授：好的。 

857
00:37:28,813 --> 00:37:29,900
Go up one.
上去一个。 

858
00:37:29,900 --> 00:37:31,521
Why does that work?
为什么行得通？ 

859
00:37:31,521 --> 00:37:33,369
AUDIENCE: You know it's going to be greater.
听众：您知道会越来越大。 

860
00:37:33,369 --> 00:37:37,779
PROFESSOR: So I'm going up right.
教授：所以我要走了。 

861
00:37:37,780 --> 00:37:41,000
So I know that everything here is guaranteed to be smaller,
所以我知道这里的所有东西都一定会变小， 

862
00:37:41,000 --> 00:37:44,329
everything here is guaranteed to be greater than this guy.
保证这里的一切都比这个家伙还伟大。 

863
00:37:44,329 --> 00:37:48,179
This guy is up right, so this is guaranteed to be greater
这个家伙是对的，所以可以保证更大

864
00:37:48,179 --> 00:37:50,039
than this, and everything here is
比这更重要的是

865
00:37:50,039 --> 00:37:52,550
guaranteed to be greater than this, and so on and so forth
保证大于此值，依此类推等等

866
00:37:52,550 --> 00:37:54,269
for the entire tree.
为整棵树。 

867
00:37:54,269 --> 00:37:58,150
So if I go up right, I'm happy.
因此，如果我正确向上走，我会很高兴。 

868
00:37:58,150 --> 00:38:00,030
I definitely found my answer.
我绝对找到了答案。 

869
00:38:00,030 --> 00:38:05,840
Now, what if I have something that looks like this,
现在，如果我有类似这样的东西， 

870
00:38:06,039 --> 00:38:08,159
and I want to find the successor for this guy?
我想找这个人的继任者？ 

871
00:38:08,159 --> 00:38:13,039



872
00:38:13,039 --> 00:38:14,730
AUDIENCE: There is none.
听众：没有。 

873
00:38:14,730 --> 00:38:16,469
PROFESSOR: In this case, there is none
教授：在这种情况下，没有

874
00:38:16,469 --> 00:38:18,209
if there's nothing else here.
如果这里没有别的。 

875
00:38:18,210 --> 00:38:22,909
What if I have this, but then I have this?
如果我有这个但我有这个怎么办？ 

876
00:38:22,909 --> 00:38:24,299
So I came down this way.
所以我就这样走了。 

877
00:38:24,300 --> 00:38:32,760



878
00:38:32,760 --> 00:38:35,565
AUDIENCE: Are you saying you're calling on that last node?
听众：您是说您正在呼叫最后一个节点吗？ 

879
00:38:35,764 --> 00:38:36,389
PROFESSOR: Yep.
教授：是的。 

880
00:38:36,389 --> 00:38:37,472
AUDIENCE: Find the larger?
听众：寻找更大的？ 

881
00:38:37,472 --> 00:38:41,300



882
00:38:41,300 --> 00:38:44,298
I guess you'd just trace back up.
我想你只是追溯。 

883
00:38:44,298 --> 00:38:45,590
PROFESSOR: And where do I stop?
教授：那我应该在哪里停下来？ 

884
00:38:45,590 --> 00:38:51,210



885
00:38:51,409 --> 00:38:54,109
AUDIENCE: It affects the tree, so you go up one from there.
听众：它会影响树，因此您从那里上一棵树。 

886
00:38:54,110 --> 00:38:56,320
You don't stop there.
你不止于此。 

887
00:38:56,320 --> 00:38:58,690
PROFESSOR: Why can't I stop here?
教授：为什么我不能在这里停下来？ 

888
00:38:58,889 --> 00:39:03,911
AUDIENCE: Because you know that that-- not necessarily.
听众：因为你知道那-不一定。 

889
00:39:03,911 --> 00:39:06,159
AUDIENCE: You know that everything in that long branch
听众：你知道那个长分支中的一切

890
00:39:06,159 --> 00:39:09,428
right there is less than that node [INAUDIBLE].
就比那个节点少[音频不清晰]。 

891
00:39:09,429 --> 00:39:11,019
PROFESSOR: This is to the left of this guy,
教授：这是这个人的左边， 

892
00:39:11,219 --> 00:39:16,619
so this guy has to be greater than everything here,
所以这个家伙必须比这里的一切都要强大， 

893
00:39:16,619 --> 00:39:20,639
and then you can repeat the argument that we had before.
然后您可以重复我们以前的论点。 

894
00:39:20,639 --> 00:39:22,059
So here, we could stop right away
所以在这里，我们可以马上停下来

895
00:39:22,059 --> 00:39:23,699
because we could branch left.
因为我们可以向左分支。 

896
00:39:23,699 --> 00:39:26,339
In this case, you have to go up until you're
在这种情况下，您必须上升直到

897
00:39:26,340 --> 00:39:29,579
able to go left and up.
能够向上和向左走。 

898
00:39:29,579 --> 00:39:34,309
If you get to the root, then what happened?
如果您扎根，那么发生了什么？ 

899
00:39:34,309 --> 00:39:37,025
Then we're in this case, and you have no successor.
那么在这种情况下，您就没有继任者了。 

900
00:39:37,025 --> 00:39:40,730



901
00:39:40,730 --> 00:39:42,539
So take a look at the code.
因此，请看一下代码。 

902
00:39:42,739 --> 00:39:45,319
The next larger, lines 1 through 9.
下一个较大的行1至9。 

903
00:39:45,320 --> 00:39:49,070
Case two, 6 through 8, does exactly that.
案例2到6到8正是这样做的。 

904
00:39:49,070 --> 00:39:52,710
If I can't go to my right and find the tree there,
如果我不能在右边找到那棵树， 

905
00:39:52,909 --> 00:39:57,569
then I go up through my parent chain,
然后我浏览我的父母链， 

906
00:39:57,570 --> 00:40:00,942
and as long as I have to go up to the left,
只要我必须向左走

907
00:40:00,942 --> 00:40:02,900
so as long as I'm the right child of my parent,
只要我是我父母的合适孩子， 

908
00:40:02,900 --> 00:40:04,119
I have to keep going.
我必须继续前进。 

909
00:40:04,119 --> 00:40:06,809
The moment I find the parent where I'm the left child,
当我找到父母在我的左生子的那一刻， 

910
00:40:06,809 --> 00:40:07,340
I stop.
我停下。 

911
00:40:07,340 --> 00:40:08,255
That's my successor.
那是我的继任者。 

912
00:40:08,255 --> 00:40:11,329



913
00:40:11,329 --> 00:40:14,269
What if I would have to find the predecessor instead?
如果我不得不找到前任怎么办？ 

914
00:40:14,269 --> 00:40:16,809
So the element that's smaller than me
所以这个元素比我小

915
00:40:16,809 --> 00:40:19,733
but bigger than everything else in the tree.
但比树上的所有其他东西都大。 

916
00:40:19,733 --> 00:40:20,400
What would I do?
我该怎么办？ 

917
00:40:20,400 --> 00:40:31,423



918
00:40:31,623 --> 00:40:33,639
AUDIENCE: It's just the opposite.
听众：相反。 

919
00:40:33,639 --> 00:40:35,422
PROFESSOR: Just the opposite.
教授：相反。 

920
00:40:35,422 --> 00:40:39,717
So how do I do the opposite?
那我该怎么做相反呢？ 

921
00:40:39,717 --> 00:40:43,808
AUDIENCE: You can take the max of the left side tree,
听众：您可以最大程度地利用左侧树， 

922
00:40:43,809 --> 00:40:53,400
or traverse up, and if that's less than--
或向上移动，如果小于- 

923
00:40:53,400 --> 00:40:55,900
PROFESSOR: OK, so if I have a left subtree, fine.
教授：好的，如果我有一个左子树，那就好。 

924
00:40:55,900 --> 00:40:59,070
Call max on it and get the rightmost node there.
在其上调用max，并在那里找到最右边的节点。 

925
00:40:59,070 --> 00:41:04,250
If not, I go up, and when do I stop?
如果没有，我会上去，什么时候停下来？ 

926
00:41:04,250 --> 00:41:10,597
When I go left or right?
当我左走还是右走？ 

927
00:41:10,597 --> 00:41:13,429
AUDIENCE: You'd have to go right.
听众：你必须走对。 

928
00:41:13,429 --> 00:41:14,849
Is that right?
那正确吗？ 

929
00:41:14,849 --> 00:41:15,630
PROFESSOR: Yep.
教授：是的。 

930
00:41:15,630 --> 00:41:20,300
So last time, in this case, when I was going up,
所以上一次，在这种情况下，当我上升时， 

931
00:41:20,300 --> 00:41:21,960
if I was going left, I had to keep going,
如果我要离开，我必须继续前进， 

932
00:41:22,159 --> 00:41:25,250
and the moment I went right, I was happy and I stopped.
当我走对的那一刻，我很高兴，我停了下来。 

933
00:41:25,250 --> 00:41:28,559
What if I want to find the predecessor?
如果我想找到前任怎么办？ 

934
00:41:28,559 --> 00:41:29,809
It's the opposite, right?
相反，对吗？ 

935
00:41:29,809 --> 00:41:34,769
So I will go this way, and the moment I can go this way,
所以我会走这条路，当我能走这条路的那一刻， 

936
00:41:34,769 --> 00:41:35,960
I'm done.
我受够了。 

937
00:41:35,960 --> 00:41:37,423
How do you do this in code?
您如何用代码做到这一点？ 

938
00:41:37,623 --> 00:41:42,569



939
00:41:42,570 --> 00:41:43,565
Slightly tricky.
有点棘手。 

940
00:41:43,764 --> 00:41:44,940
Just slightly, I promise.
我保证，只是一点点。 

941
00:41:44,940 --> 00:41:49,079



942
00:41:49,079 --> 00:41:51,615
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

943
00:41:51,615 --> 00:41:53,789
PROFESSOR: It's hard.
教授：很难。 

944
00:41:53,789 --> 00:41:56,630
What I would do is copy paste the code,
我要做的就是复制粘贴代码， 

945
00:41:56,630 --> 00:41:59,724
replace "left" with "right" everywhere, and replace "min"
到处将“ left”替换为“ right”，并替换“ min” 

946
00:41:59,724 --> 00:42:03,250
with "max."
与“最大”。 

947
00:42:03,251 --> 00:42:05,039
You get it done.
您完成了。 

948
00:42:05,239 --> 00:42:07,909
So we talked about how the tree is symmetric, right?
所以我们讨论了树是如何对称的，对吗？ 

949
00:42:07,909 --> 00:42:12,670
So every time, instead of saying "left," you say "right,"
因此，每次都说“对”而不是说“左” 

950
00:42:12,670 --> 00:42:14,829
and instead of saying "min," you say "max."
而不是说“最小”，而是说“最大”。 

951
00:42:14,829 --> 00:42:15,860
That's how you do this.
这就是您的做法。 

952
00:42:15,860 --> 00:42:18,760



953
00:42:18,760 --> 00:42:19,905
How do we do deletions?
我们如何删除？ 

954
00:42:19,905 --> 00:42:23,170



955
00:42:23,170 --> 00:42:25,909
So suppose I'm in this tree and I want to delete 15.
因此，假设我在这棵树中，我想删除15。 

956
00:42:25,909 --> 00:42:28,710
What do I do?
我该怎么办？ 

957
00:42:28,710 --> 00:42:29,570
AUDIENCE: Kill it.
听众：杀了它。 

958
00:42:29,570 --> 00:42:30,510
PROFESSOR: Kill it.
教授：杀了它。 

959
00:42:30,510 --> 00:42:31,514
Very good.
很好。 

960
00:42:31,713 --> 00:42:32,880
What if I want to delete 16?
如果要删除16怎么办？ 

961
00:42:32,880 --> 00:42:34,010
What do I do?
我该怎么办？ 

962
00:42:34,010 --> 00:42:39,663



963
00:42:39,663 --> 00:42:43,797
AUDIENCE: You need to put 15 where 16 is.
听众：您需要将15放在16。 

964
00:42:43,797 --> 00:42:44,380
PROFESSOR: OK.
教授：好的。 

965
00:42:44,380 --> 00:42:46,715
So I would put 15 here.
所以我要在这里放15。 

966
00:42:46,715 --> 00:42:51,769



967
00:42:51,769 --> 00:42:53,639
So I had 16.
所以我有16岁

968
00:42:53,639 --> 00:42:56,519



969
00:42:56,519 --> 00:42:58,085
Suppose I have a big tree here.
假设我这里有一棵大树。 

970
00:42:58,085 --> 00:43:03,086



971
00:43:03,086 --> 00:43:04,670
Actually, let's go for an easier case.
实际上，让我们来看一个简单的案例。 

972
00:43:04,670 --> 00:43:09,920
Let's say I have this tree here.
假设我在这里有这棵树。 

973
00:43:09,920 --> 00:43:12,000
So you're here, you have a big tree here,
所以你在这里，你有一棵大树， 

974
00:43:12,000 --> 00:43:13,070
you don't have anything here, and you
你这里什么都没有，你

975
00:43:13,070 --> 00:43:14,070
want to delete this guy.
要删除此人。 

976
00:43:14,070 --> 00:43:17,250



977
00:43:17,449 --> 00:43:19,164
AUDIENCE: You know that everything less
听众：你知道一切都更少

978
00:43:19,164 --> 00:43:21,369
than the top node is going to be less than it,
比顶部节点要小于它， 

979
00:43:21,369 --> 00:43:22,829
so you can just move that up.
因此您可以将其向上移动。 

980
00:43:22,829 --> 00:43:27,768
PROFESSOR: Everything less than this guy is also
教授：比这家伙还少的一切

981
00:43:27,768 --> 00:43:29,059
going to be less than this guy.
会比这个家伙少。 

982
00:43:29,059 --> 00:43:32,250
So you're saying move the whole tree up.
所以您说的是将整个树向上移动。 

983
00:43:32,250 --> 00:43:32,992
AUDIENCE: Yep.
听众：是的。 

984
00:43:32,992 --> 00:43:34,250
PROFESSOR: So the way we do that is
教授：所以我们这样做的方法是

985
00:43:34,449 --> 00:43:38,289
we'd take this node's left link and make it point here,
我们将使用该节点的左链接并将其指向此处， 

986
00:43:38,289 --> 00:43:42,690
and take this guy's parent link and make it point here,
并把这个人的父母链接指向此处， 

987
00:43:42,690 --> 00:43:44,730
and this guy sort of goes away.
这个家伙就走了

988
00:43:44,730 --> 00:43:48,250



989
00:43:48,250 --> 00:43:50,090
So we have two cases for deleting.
因此，我们有两种情况需要删除。 

990
00:43:50,090 --> 00:43:53,250
We have if you're a leaf, we'll take you out.
如果您是一片叶子，我们会带您出去的。 

991
00:43:53,250 --> 00:44:00,599



992
00:44:00,599 --> 00:44:01,099
Sorry.
抱歉。 

993
00:44:01,099 --> 00:44:02,190
I got confused.
我很困惑。 

994
00:44:02,190 --> 00:44:04,349
If you have one child and that child
如果你有一个孩子，那个孩子

995
00:44:04,349 --> 00:44:07,860
is in the same direction as your parent, then you can do this.
与您父母的方向相同，那么您可以执行此操作。 

996
00:44:07,860 --> 00:44:21,730
What if you have one child, but it's a zigzag like this?
如果您有一个孩子，但是像这样的锯齿状怎么办？ 

997
00:44:21,730 --> 00:44:22,380
What do you do?
你是做什么？ 

998
00:44:22,380 --> 00:44:29,519



999
00:44:29,519 --> 00:44:32,019
AUDIENCE: It's still greater than, so you do the same thing.
听众：仍然大于，所以您做同样的事情。 

1000
00:44:32,019 --> 00:44:33,250
PROFESSOR: Exactly.
教授：是的。 

1001
00:44:33,250 --> 00:44:33,800
Same thing.
一样。 

1002
00:44:33,800 --> 00:44:37,000



1003
00:44:37,199 --> 00:44:40,268
Just change this guy, change this guy, and I'm happy.
只是换这个人，换这个人，我很高兴。 

1004
00:44:40,268 --> 00:44:42,809
So it doesn't matter if you have a zigzag or a straight line.
因此，无论您是锯齿形还是直线形都没关系。 

1005
00:44:42,809 --> 00:44:45,289
It might help you think about it to convince yourself
它可以帮助您考虑一下以说服自己

1006
00:44:45,289 --> 00:44:49,969
that the code is correct, but in the end, you do the same thing.
该代码是正确的，但最后，您做同样的事情。 

1007
00:44:49,969 --> 00:44:54,839
Now, what if I want to delete node 8?
现在，如果要删除节点8，该怎么办？ 

1008
00:44:54,840 --> 00:45:10,170
So what if I have a nasty case where I want to delete this guy
那如果我有一个讨厌的案例要删除这个家伙怎么办

1009
00:45:10,369 --> 00:45:12,833
and it has children both on the left and on the right?
它的左边和右边都有孩子？ 

1010
00:45:12,833 --> 00:45:22,000



1011
00:45:22,199 --> 00:45:25,029
AUDIENCE: You have to take 8, compare it to its parent
听众：您必须输入8，并将其与其父级进行比较

1012
00:45:25,030 --> 00:45:26,605
and compare it to its right child,
并将其与合适的孩子进行比较

1013
00:45:26,605 --> 00:45:28,666
and see which one is greater in order
看看哪个更大

1014
00:45:28,666 --> 00:45:33,856
to figure out which node gets replaced in its spot.
找出哪个节点在其位置被替换。 

1015
00:45:33,856 --> 00:45:34,440
PROFESSOR: OK.
教授：好的。 

1016
00:45:34,440 --> 00:45:37,063
So there is replacing that's going to happen.
因此，将要进行替换。 

1017
00:45:37,063 --> 00:45:38,230
The answer is really tricky.
答案确实很棘手。 

1018
00:45:38,230 --> 00:45:41,289
I always forget this when coding.
我总是在编码时忘记这一点。 

1019
00:45:41,289 --> 00:45:44,130
Try to understand it, and if it doesn't work,
尝试了解它，如果它不起作用， 

1020
00:45:44,130 --> 00:45:45,300
refer to the textbook.
请参阅教科书。 

1021
00:45:45,300 --> 00:45:48,269
When you forget it, because you will, refer to the textbook
当您忘记它时，可以参考该教科书

1022
00:45:48,269 --> 00:45:50,119
or to the internet.
或上网。 

1023
00:45:50,119 --> 00:45:54,650
So what you do is I can't just magically replace this node
所以你要做的就是我不能神奇地替换这个节点

1024
00:45:54,650 --> 00:45:57,650
with one of the subtrees, but we talked right
与其中一个子树，但我们说的没错

1025
00:45:57,650 --> 00:46:07,030
before this about Next Greater, so finding a node's successor.
在此之前，关于Next Greater，请先找到节点的后继者。 

1026
00:46:07,030 --> 00:46:10,360
If this node has both a left subtree and a right subtree,
如果此节点同时具有左子树和右子树， 

1027
00:46:10,559 --> 00:46:13,460
then I know that if I call Find Successor on it,
那我知道如果我打电话给它， 

1028
00:46:13,460 --> 00:46:17,599
I'm going to go somewhere inside here,
我要去这里里面的某个地方

1029
00:46:17,599 --> 00:46:23,000
and I'm going to find a node somewhere in here all the way
我将一直在这里找到一个节点

1030
00:46:23,000 --> 00:46:25,510
to the left that is this guy's successor.
在左边是这个家伙的继任者。 

1031
00:46:25,510 --> 00:46:29,670



1032
00:46:29,670 --> 00:46:32,340
So what I'm going to do is I'm going
所以我要做的是

1033
00:46:32,340 --> 00:46:38,030
to delete this node instead, and then I'm going to take its key
删除该节点，然后我要获取其密钥

1034
00:46:38,030 --> 00:46:38,789
and put it up here.
放在这里

1035
00:46:38,989 --> 00:46:42,879



1036
00:46:42,880 --> 00:46:48,550
So if I want to delete 8, what I do is I find its successor,
因此，如果要删除8，我要做的就是找到它的后继者， 

1037
00:46:48,550 --> 00:46:52,980
then I delete it, then I take the 15 that was here-- you
然后我删除它，然后取那15个-你

1038
00:46:53,179 --> 00:46:53,929
can see it, right?
可以看到吧？ 

1039
00:46:53,929 --> 00:46:54,637
It's still there.
它仍然在那里。 

1040
00:46:54,637 --> 00:46:57,289



1041
00:46:57,289 --> 00:46:59,679
Put it here.
放在这里。 

1042
00:46:59,679 --> 00:47:05,469
So the reason this works is that everything here
所以这样做的原因是这里的一切

1043
00:47:05,469 --> 00:47:08,009
is greater than this guy.
比这个家伙还伟大。 

1044
00:47:08,010 --> 00:47:11,039
Everything here is smaller than this guy.
这里的一切都比这个家伙小。 

1045
00:47:11,239 --> 00:47:14,479
This is the next node that's greater than this guy,
这是下一个比这个家伙更大的节点， 

1046
00:47:14,480 --> 00:47:16,760
but everything else is bigger than it,
但其他一切都比它更大， 

1047
00:47:16,760 --> 00:47:19,590
right, because we wanted it to be a successor.
是的，因为我们希望它成为继任者。 

1048
00:47:19,590 --> 00:47:22,840
So if I take this value and I put it up here,
因此，如果我采用此值并将其放在这里， 

1049
00:47:22,840 --> 00:47:25,500
everything in here is still going to be greater than it.
这里的一切仍将大于它。 

1050
00:47:25,500 --> 00:47:30,309



1051
00:47:30,309 --> 00:47:33,000
This is a successor of this guy, so everything here
这是这个家伙的继任者，所以这里的一切

1052
00:47:33,000 --> 00:47:35,000
is still going to be smaller than the successor.
仍将小于后继者。 

1053
00:47:35,000 --> 00:47:44,309



1054
00:47:44,309 --> 00:47:45,360
Great.
大。 

1055
00:47:45,360 --> 00:47:48,420
In order to do a delete, I find the successor,
为了进行删除，我找到了后继者， 

1056
00:47:48,619 --> 00:47:50,454
and then I call Delete on it.
然后我叫删除。 

1057
00:47:50,454 --> 00:47:51,829
How do I know that this will end?
我怎么知道这将结束？ 

1058
00:47:51,829 --> 00:47:54,210
How do I know that I'm not going to go
我怎么知道我不会去

1059
00:47:54,210 --> 00:47:58,532
into a loop that runs forever?
进入永远运行的循环？ 

1060
00:47:58,532 --> 00:47:59,699
AUDIENCE: Because it's not--
听众：因为不是- 

1061
00:47:59,699 --> 00:48:01,947
AUDIENCE: It's acyclic, right?
听众：它是非循环的，对吗？ 

1062
00:48:01,947 --> 00:48:02,530
PROFESSOR: OK.
教授：好的。 

1063
00:48:02,530 --> 00:48:05,670



1064
00:48:05,670 --> 00:48:07,539
First answer, good.
第一个答案，很好。 

1065
00:48:07,539 --> 00:48:11,289
Eventually, worst case, I'm going to get to the maximum,
最终，在最坏的情况下，我将发挥最大作用， 

1066
00:48:11,289 --> 00:48:16,340
and then not going on have to delete the successor anymore.
然后就不必再删除后继了。 

1067
00:48:16,340 --> 00:48:17,780
Now, another thing to note here is
现在，这里要注意的另一件事是

1068
00:48:17,780 --> 00:48:20,710
that if this guy is the successor of this guy,
如果这个人是这个人的继任者， 

1069
00:48:20,710 --> 00:48:24,300
it can't have anything on the left, because if it would,
它的左边不能有任何东西，因为如果有的话， 

1070
00:48:24,300 --> 00:48:27,800
then whatever is down here has to be bigger than this,
那么这里的任何东西都必须大于这个， 

1071
00:48:27,800 --> 00:48:29,519
and whatever's to the left of this node
以及该节点左侧的任何内容

1072
00:48:29,519 --> 00:48:32,559
has to be smaller than this.
必须小于这个。 

1073
00:48:32,559 --> 00:48:34,739
But we said that this is the successor of this,
但是我们说这是继任者， 

1074
00:48:34,739 --> 00:48:36,500
so there's nothing here.
所以这里什么都没有。 

1075
00:48:36,500 --> 00:48:40,000
So this will be one of the easy cases that we talked about.
因此，这将是我们讨论过的简单案例之一。 

1076
00:48:40,000 --> 00:48:42,500
The successor either has no kids,
继任者没有孩子

1077
00:48:42,500 --> 00:48:47,940
or it has only one child, only one subtree.
或者它只有一个孩子，只有一棵子树。 

1078
00:48:47,940 --> 00:48:51,139
So then I can delete it using one of the easy cases.
因此，我可以使用一种简单的情况将其删除。 

1079
00:48:51,139 --> 00:48:55,170
So in fact, worst case that happens in a delete is my node
所以事实上，在删除中发生的最坏情况是我的节点

1080
00:48:55,170 --> 00:48:56,230
has two subtrees.
有两个子树。 

1081
00:48:56,230 --> 00:48:59,460
Then I find the successor that's only going to have one subtree,
然后，我发现只有一个子树的后继者， 

1082
00:48:59,460 --> 00:49:01,130
I change my links there, and I'm done.
我在那里更改了链接，然后完成。 

1083
00:49:01,130 --> 00:49:03,769



1084
00:49:03,969 --> 00:49:05,659
What is the running time for Delete?
 Delete的运行时间是几点？ 

1085
00:49:05,659 --> 00:49:15,103



1086
00:49:15,103 --> 00:49:17,186
AUDIENCE: Is it order h, because you should do it
听众：是命令h，因为你应该这样做

1087
00:49:17,186 --> 00:49:19,739
all the way down to the bottom of the tree, right?
一直到树的底部，对不对？ 

1088
00:49:19,938 --> 00:49:21,480
PROFESSOR: You have the right answer.
教授：您的回答正确。 

1089
00:49:21,480 --> 00:49:22,684
Let's see why it's order h.
让我们看看为什么要订购h。 

1090
00:49:22,684 --> 00:49:23,650
It has to be order h, right?
必须是命令h，对不对？ 

1091
00:49:23,849 --> 00:49:25,432
Otherwise, the tree would be too slow.
否则，树将太慢。 

1092
00:49:25,432 --> 00:49:29,130
If it's order N, then it's bad.
如果是N阶，那就不好了。 

1093
00:49:29,130 --> 00:49:32,289
So why would Delete be order h?
那么为什么删除命令是h？ 

1094
00:49:32,489 --> 00:49:35,349
This was a heap, right, so I can't use this.
这是一堆，对，所以我不能使用它。 

1095
00:49:35,349 --> 00:49:39,400
I'm going to write "delete" here again.
我将在这里再次写“删除”。 

1096
00:49:39,400 --> 00:49:41,899
So the first thing you do is you have to search for the key,
因此，您要做的第一件事就是必须搜索密钥， 

1097
00:49:41,900 --> 00:49:42,630
right?
对？ 

1098
00:49:42,630 --> 00:49:43,610
That's order h.
那是命令h。 

1099
00:49:43,610 --> 00:49:46,320



1100
00:49:46,320 --> 00:49:48,960
Now, if it's a happy case, if it's case one or two,
现在，如果是一个快乐的情况，如果是一两个情况， 

1101
00:49:48,960 --> 00:49:50,750
you change some links and you're done.
您更改一些链接就可以了。 

1102
00:49:50,750 --> 00:49:51,829
What's the time for that?
现在几点了？ 

1103
00:49:51,829 --> 00:49:54,679



1104
00:49:54,679 --> 00:49:55,269
AUDIENCE: Constant.
听众：不变。 

1105
00:49:55,469 --> 00:49:56,809
PROFESSOR: Constant.
教授：不变。 

1106
00:49:56,809 --> 00:49:59,949
So happy case, order h for sure.
非常高兴，请确定要订购h。 

1107
00:49:59,949 --> 00:50:00,658
Now sad case.
现在可悲的情况。 

1108
00:50:00,659 --> 00:50:02,000
If you have two children, what do you
如果您有两个孩子，那您呢

1109
00:50:02,199 --> 00:50:06,579
have to do after you realize that you have two subtrees?
您意识到自己有两个子树后必须做什么？ 

1110
00:50:06,579 --> 00:50:08,047
AUDIENCE: Find the successor.
听众：找到继任者。 

1111
00:50:08,047 --> 00:50:08,630
PROFESSOR: OK.
教授：好的。 

1112
00:50:08,630 --> 00:50:12,378
What's the running time for finding a successor?
寻找继任者的时间是多少？ 

1113
00:50:12,378 --> 00:50:14,269
AUDIENCE: Order h.
听众：订单h。 

1114
00:50:14,269 --> 00:50:15,090
PROFESSOR: Order h.
教授：命令h。 

1115
00:50:15,090 --> 00:50:19,309



1116
00:50:19,309 --> 00:50:21,286
Once I find the successor, what do I do?
找到继任者后，我该怎么办？ 

1117
00:50:21,286 --> 00:50:25,559



1118
00:50:25,559 --> 00:50:29,286
Call Delete on that, and what happens?
致电Delete，会发生什么？ 

1119
00:50:29,286 --> 00:50:30,619
It's a happy case or a sad case?
这是一个快乐的案例还是一个悲伤的案例？ 

1120
00:50:30,619 --> 00:50:32,409
AUDIENCE: It's a happy case.
听众：这是一个快乐的案例。 

1121
00:50:32,409 --> 00:50:35,076
PROFESSOR: Happy case, a few links get swapped,
教授：很高兴，一些链接被交换了， 

1122
00:50:35,076 --> 00:50:36,070
constant time.
恒定的时间。 

1123
00:50:36,070 --> 00:50:40,010
So worst case, order h plus order h.
因此，最坏的情况是命令h加命令h。 

1124
00:50:40,010 --> 00:50:41,260
Order h.
订单h。 

1125
00:50:41,260 --> 00:50:45,280
So insertions are order h, deletions are order h.
因此，插入是顺序h，删除是顺序h。 

1126
00:50:45,280 --> 00:50:46,210
AUDIENCE: The first one.
听众：第一个。 

1127
00:50:46,409 --> 00:50:47,949
Because the second one is from finding the successor.
因为第二个是从寻找继任者。 

1128
00:50:47,949 --> 00:50:49,032
What is the first one for?
第一个是做什么用的？ 

1129
00:50:49,032 --> 00:50:52,929
PROFESSOR: Finding the node for a key in the tree.
教授：在树中找到键的节点。 

1130
00:50:52,929 --> 00:50:55,909
So if I say Delete 8, then you have to find 8.
因此，如果我说删除8，那么您必须找到8。 

1131
00:50:55,909 --> 00:50:58,879
If I give you the node, then you don't have that.
如果我给您节点，那么您就没有了。 

1132
00:50:58,880 --> 00:50:59,306
Good question.
好问题。 

1133
00:50:59,505 --> 00:51:00,379
It's a good question.
这是一个好问题。 

1134
00:51:00,380 --> 00:51:01,000
Thank you.
谢谢。 

1135
00:51:01,000 --> 00:51:06,380



1136
00:51:06,380 --> 00:51:07,500
So that's insertion.
这就是插入。 

1137
00:51:07,500 --> 00:51:08,469
That's deletion.
那是删除。 

1138
00:51:08,469 --> 00:51:11,168



1139
00:51:11,168 --> 00:51:12,585
Let's look at the code for Delete.
让我们看一下删除的代码。 

1140
00:51:12,585 --> 00:51:17,429



1141
00:51:17,429 --> 00:51:18,809
Looks kind of long.
看起来有点长。 

1142
00:51:18,809 --> 00:51:22,320



1143
00:51:22,320 --> 00:51:26,637
So lines through 21, happy case or sad case?
那么，通过21行，快乐案例还是悲伤案例？ 

1144
00:51:26,637 --> 00:51:31,210



1145
00:51:31,409 --> 00:51:33,149
Try to do it by looking at the "if"
尝试通过查看“如果”来做到这一点

1146
00:51:33,150 --> 00:51:35,010
instead of looking at the comments.
而不是看评论。 

1147
00:51:35,010 --> 00:51:38,130



1148
00:51:38,130 --> 00:51:41,980
So lines through 21 for Delete.
因此，通过21行删除。 

1149
00:51:42,179 --> 00:51:45,483



1150
00:51:45,483 --> 00:51:46,900
AUDIENCE: On this tree?
听众：在这棵树上？ 

1151
00:51:46,900 --> 00:51:49,057
Which tree, because there are two deletes?
哪棵树，因为有两个删除？ 

1152
00:51:49,257 --> 00:51:50,132
PROFESSOR: Oh really?
教授：真的吗？ 

1153
00:51:50,132 --> 00:51:53,439



1154
00:51:53,440 --> 00:51:53,940
Sorry.
抱歉。 

1155
00:51:53,940 --> 00:51:56,144
Why do we have two deletes?
为什么我们有两个删除？ 

1156
00:51:56,144 --> 00:52:01,409
AUDIENCE: There's BST Delete and then there's BST Node Delete.
听众：有BST删除，然后有BST节点删除。 

1157
00:52:01,409 --> 00:52:02,250
PROFESSOR: So BST Delete.
教授：请删除BST。 

1158
00:52:02,449 --> 00:52:06,000



1159
00:52:06,000 --> 00:52:08,400
Finds the node, and then calls Delete on the node.
查找节点，然后在该节点上调用Delete。 

1160
00:52:08,400 --> 00:52:11,539



1161
00:52:11,539 --> 00:52:13,460
And then if the node is a tree's root,
然后，如果节点是树的根， 

1162
00:52:13,460 --> 00:52:16,480
then it updates the tree's root.
然后更新树的根。 

1163
00:52:16,480 --> 00:52:19,409
So let's look at the nodes delete.
因此，让我们看一下节点删除。 

1164
00:52:19,409 --> 00:52:20,295
Oh, I see.
哦，我明白了。 

1165
00:52:20,295 --> 00:52:21,920
I think I was looking at the wrong one.
我想我看错了。 

1166
00:52:21,920 --> 00:52:26,019



1167
00:52:26,019 --> 00:52:26,579
Thank you.
谢谢。 

1168
00:52:26,579 --> 00:52:29,279
My Delete was much longer than yours.
我的删除比您的删除时间长得多。 

1169
00:52:29,280 --> 00:52:33,760
So lines 3 through 12, happy case or sad case?
那么第3行到第12行是快乐的情况还是悲伤的情况？ 

1170
00:52:33,760 --> 00:52:39,980



1171
00:52:40,179 --> 00:52:44,289
Look at the "if" on line 3 and tell me,
看一下第3行的“如果”，然后告诉我， 

1172
00:52:44,289 --> 00:52:45,650
what case is it going for?
这是什么情况？ 

1173
00:52:45,650 --> 00:52:51,208



1174
00:52:51,208 --> 00:52:51,923
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

1175
00:52:52,123 --> 00:52:55,659



1176
00:52:55,659 --> 00:52:57,579
PROFESSOR: If it doesn't have a left child
教授：如果没有孩子

1177
00:52:57,579 --> 00:52:59,279
or it doesn't have a right child,
或没有合适的孩子

1178
00:52:59,280 --> 00:53:01,750
is that the happy case or the sad case?
是快乐的情况还是悲伤的情况？ 

1179
00:53:01,750 --> 00:53:02,480
AUDIENCE: Happy.
听众：很高兴。 

1180
00:53:02,480 --> 00:53:03,396
PROFESSOR: Happy case.
教授：很高兴。 

1181
00:53:03,396 --> 00:53:08,300
So lines 4 through 12 handle the happy case.
因此，第4至12行处理了这种情况。 

1182
00:53:08,300 --> 00:53:10,789
Lines 14 through 16 handle the sad case.
第14行到第16行处理这种情况。 

1183
00:53:10,989 --> 00:53:14,709



1184
00:53:14,710 --> 00:53:17,860
Do lines 14 through 16 make sense?
第14到16行有意义吗？ 

1185
00:53:17,860 --> 00:53:19,539
Find the successor, then swap the keys,
找到继任者，然后交换密钥， 

1186
00:53:19,739 --> 00:53:21,147
then delete that successor.
然后删除该后继者。 

1187
00:53:21,148 --> 00:53:26,820



1188
00:53:26,820 --> 00:53:29,460
Now, lines 4 through 11 are pretty much what
现在，第4至11行几乎是什么

1189
00:53:29,659 --> 00:53:33,960
we talked about here, except I can't draw arrows on the board
我们在这里讨论过，除了我不能在板上画箭头

1190
00:53:33,960 --> 00:53:37,472
and instead I have to change left and right links.
相反，我必须更改左右链接。 

1191
00:53:37,472 --> 00:53:41,130
Line 4 has to see if we're a left child or a right child,
第4行必须查看我们是左孩子还是右孩子， 

1192
00:53:41,130 --> 00:53:45,039
and then lines 5 through 7 and 9 through 11 are pretty much
然后第5至7行和9至11行

1193
00:53:45,239 --> 00:53:48,599
copy paste, swap left with right.
复制粘贴，左右互换。 

1194
00:53:48,599 --> 00:53:51,165
And they changed the links like we changed them here.
他们更改了链接，就像我们在此处更改链接一样。 

1195
00:53:51,166 --> 00:53:59,130



1196
00:53:59,329 --> 00:54:03,150
Do we have any questions on Deletes?
我们对删除有任何疑问吗？ 

1197
00:54:03,150 --> 00:54:08,440
AUDIENCE: So if the successor had a right child,
听众：所以，如果继任者有一个合适的孩子， 

1198
00:54:08,440 --> 00:54:15,050
then all you do, you just do the workaround thing where
然后您所做的所有事情，您只需执行解决方法

1199
00:54:15,050 --> 00:54:15,550
you just--
你刚才 - 

1200
00:54:15,550 --> 00:54:17,530
PROFESSOR: Yep.
教授：是的。 

1201
00:54:17,530 --> 00:54:19,789
So the case that it doesn't have two children.
因此，它没有两个孩子。 

1202
00:54:19,989 --> 00:54:21,869
As long as it doesn't have both children,
只要没有两个孩子

1203
00:54:21,869 --> 00:54:24,327
you're in the happy case and you can do some link swapping.
您情况很好，可以进行一些链接交换。 

1204
00:54:24,327 --> 00:54:28,355



1205
00:54:28,355 --> 00:54:29,869
Are you guys burned out already?
你们已经精疲力尽了吗？ 

1206
00:54:29,869 --> 00:54:33,239



1207
00:54:33,239 --> 00:54:33,909
Fair enough.
很公平。 

1208
00:54:33,909 --> 00:54:37,250



1209
00:54:37,250 --> 00:54:38,539
I left a part out.
我遗漏了一部分。 

1210
00:54:38,539 --> 00:54:43,119
What I left out is how to augment a binary tree.
我遗漏的是如何增加二叉树。 

1211
00:54:43,119 --> 00:54:46,739
So binary trees by default can answer the question,
因此默认情况下，二叉树可以回答这个问题， 

1212
00:54:46,739 --> 00:54:49,500
what's the minimum node in a tree in order h.
树中按h顺序排列的最小节点是多少？ 

1213
00:54:49,500 --> 00:54:51,710
You go all the way to the left, you find the minimum.
您一直走到最左边，找到最小值。 

1214
00:54:51,710 --> 00:54:53,260
That's the minimum.
那是最低的。 

1215
00:54:53,260 --> 00:54:56,920
It turns out that if you make a node a little bit fatter,
事实证明，如果使节点更胖， 

1216
00:54:56,920 --> 00:55:03,070
so if instead of storing, say, 23 in this node, I store 23,
因此，如果我不是在该节点中存储23，而是存储23， 

1217
00:55:03,070 --> 00:55:05,630
and I store the fact that the minimum in my left subtree
我将最小值存储在我的左子树中

1218
00:55:05,630 --> 00:55:10,230
is 4, then it turns out that I can answer the question
是4，那么事实证明我可以回答这个问题

1219
00:55:10,230 --> 00:55:13,065
in constant time, what's the minimum?
在恒定时间内，最低要求是多少？ 

1220
00:55:13,065 --> 00:55:15,474
Oh gee, if you store the minimum here,
哦，天哪，如果您将最小值存储在这里， 

1221
00:55:15,474 --> 00:55:18,549
of course you can retrieve it in constant time, right?
当然，您可以在固定时间内检索它，对吗？ 

1222
00:55:18,550 --> 00:55:21,940
The hard part is, how do you handle insertions and updates
困难的部分是，您如何处理插入和更新

1223
00:55:21,940 --> 00:55:25,579
in the same time?
在同一时间？ 

1224
00:55:25,579 --> 00:55:27,769
So the idea is that if I have a node
所以想法是，如果我有一个节点

1225
00:55:27,769 --> 00:55:33,989
and I have a function here, say the minimum of everything,
我在这里有一个功能，要说的是最少的， 

1226
00:55:33,989 --> 00:55:40,529
if I have two children, here they're 15 and 42,
如果我有两个孩子，他们分别是15岁和42岁

1227
00:55:40,530 --> 00:55:42,800
and say the minimum in this tree is 4
并说这棵树的最小值是4 

1228
00:55:42,800 --> 00:55:45,650
and the minimum in this tree is.
这棵树的最小值是

1229
00:55:45,849 --> 00:55:50,076
So if I already computed the function for these guys,
因此，如果我已经为这些人计算了函数， 

1230
00:55:50,076 --> 00:55:51,699
how do I compute the function for this?
我该如何计算函数？ 

1231
00:55:51,699 --> 00:55:54,038



1232
00:55:54,039 --> 00:55:55,380
AUDIENCE: [INAUDIBLE] and compare it?
听众：[听不清]，然后进行比较吗？ 

1233
00:55:55,579 --> 00:55:56,219
PROFESSOR: Yep.
教授：是的。 

1234
00:55:56,219 --> 00:55:59,189
Take the minimum of these two guys, right?
拿这两个家伙中最小的一个吧？ 

1235
00:55:59,190 --> 00:56:02,289
There are some special cases if you don't have a child.
如果您没有孩子，则有一些特殊情况。 

1236
00:56:02,289 --> 00:56:06,539
If you don't have a left child, then you're the minimum.
如果您没有孩子，那么您就是最低要求。 

1237
00:56:06,539 --> 00:56:08,440
But you write down those special cases,
但是你写下那些特殊情况

1238
00:56:08,440 --> 00:56:10,929
and you can compute this in how much time?
您可以计算多少时间？ 

1239
00:56:10,929 --> 00:56:14,649



1240
00:56:14,650 --> 00:56:17,019
AUDIENCE: Order h, right?
听众：命令h，对不对？ 

1241
00:56:17,019 --> 00:56:19,250
PROFESSOR: What if I already computed the answer
教授：如果我已经计算出答案，该怎么办

1242
00:56:19,250 --> 00:56:20,759
for the children?
为了孩子？ 

1243
00:56:20,759 --> 00:56:22,300
How much time does it take to compute
计算需要多少时间

1244
00:56:22,300 --> 00:56:24,231
the answer for a single node?
一个节点的答案？ 

1245
00:56:24,431 --> 00:56:25,303
AUDIENCE: Constant.
听众：不变。 

1246
00:56:25,304 --> 00:56:26,137
PROFESSOR: Constant.
教授：不变。 

1247
00:56:26,137 --> 00:56:26,519
OK.
好。 

1248
00:56:26,719 --> 00:56:28,270
AUDIENCE: For a tree, though.
听众：不过是一棵树。 

1249
00:56:28,271 --> 00:56:29,769
PROFESSOR: For a tree, it's order h.
教授：对于一棵树，它的顺序是h。 

1250
00:56:29,769 --> 00:56:30,269
Yeah.
是的

1251
00:56:30,269 --> 00:56:32,791
You're getting ahead.
您正在前进。 

1252
00:56:32,791 --> 00:56:33,539
You're rushing me.
你在催我。 

1253
00:56:33,539 --> 00:56:34,748
You're not letting me finish.
你不让我说完。 

1254
00:56:34,748 --> 00:56:38,000
AUDIENCE: Are you saying that we store the minimum value?
听众：您是说我们存储最小值吗？ 

1255
00:56:38,199 --> 00:56:39,344
PROFESSOR: So for every--
教授：所以对于每个人- 

1256
00:56:39,344 --> 00:56:43,424
AUDIENCE: Each node has a field that
听众：每个节点都有一个字段， 

1257
00:56:43,425 --> 00:56:46,115
says what the minimum value is in that tree.
说出那棵树的最小值。 

1258
00:56:46,315 --> 00:56:47,549
PROFESSOR: Yep, exactly.
教授：好的。 

1259
00:56:47,550 --> 00:56:51,340
So for each node, what's the minimum in the subtree.
因此，对于每个节点，子树中的最小值是多少。 

1260
00:56:51,340 --> 00:56:54,539
So if I add a node here, suppose I add three
所以如果我在这里添加一个节点，假设我添加了三个

1261
00:56:54,739 --> 00:57:01,839
and I had my minimums, what changed?
我有最低要求，什么改变了？ 

1262
00:57:01,840 --> 00:57:03,670
This subtree changed, this subtree changed,
这个子树变了，这个子树变了， 

1263
00:57:03,869 --> 00:57:07,670
this subtree changed, and then this subtree changed.
此子树更改，然后此子树更改。 

1264
00:57:07,670 --> 00:57:12,150
So I have to update the minimums here, here, here, here.
所以我必须在这里，这里，这里，这里更新最小值。 

1265
00:57:12,150 --> 00:57:13,710
Nothing else changed.
没有其他改变。 

1266
00:57:13,909 --> 00:57:16,190
Outside the path where I did the Insert,
在我执行插入操作的路径之外， 

1267
00:57:16,190 --> 00:57:19,679
nothing changed, so I don't have to update anything.
没什么改变，所以我不必更新任何东西。 

1268
00:57:19,679 --> 00:57:22,789
So what I do is after the Insert, I go back up
所以我要做的是在插入之后，我回去

1269
00:57:22,789 --> 00:57:25,304
and I re-compute the values.
然后我重新计算值。 

1270
00:57:25,304 --> 00:57:26,179
So here, I'll have 3.
所以在这里，我有3。 

1271
00:57:26,179 --> 00:57:29,773
I go back up 3, 3, 3.
我备份3、3、3。 

1272
00:57:29,773 --> 00:57:32,980
AUDIENCE: You could when you're passing down, though.
听众：不过，当你传下去时，你可以。 

1273
00:57:32,980 --> 00:57:35,818
When you're going down that column,
当您浏览该专栏时， 

1274
00:57:35,818 --> 00:57:37,400
you can just compare it on the way down.
您可以在下降的过程中进行比较。 

1275
00:57:37,599 --> 00:57:39,099
You don't have to go back up, right?
您不必备份，对吗？ 

1276
00:57:39,099 --> 00:57:40,039
PROFESSOR: Yep.
教授：是的。 

1277
00:57:40,039 --> 00:57:42,480
So the advantage of doing it the way I'm saying it
所以以我所说的方式做的好处

1278
00:57:42,480 --> 00:57:46,400
is that you can have other functions instead of minimum.
是您可以具有其他功能，而不是最少的功能。 

1279
00:57:46,400 --> 00:57:48,639
As long as you can compute the function
只要你能算出函数

1280
00:57:48,639 --> 00:57:51,480
inside the parent in constant time
在恒定时间内进入父母

1281
00:57:51,480 --> 00:57:53,849
using the function from the children,
利用孩子们的功能

1282
00:57:53,849 --> 00:57:57,378
it makes sense to compute the function on the children first.
首先计算子代函数是有意义的。 

1283
00:57:57,378 --> 00:57:59,420
There's an obvious function that I can't tell you
有一个明显的功能我不能告诉你

1284
00:57:59,420 --> 00:58:02,760
because that's on the Pset, but when you see the next Pset,
因为它在Pset上，但是当您看到下一个Pset时， 

1285
00:58:02,760 --> 00:58:05,610
you'll see what I mean.
你会明白我的意思的。 

1286
00:58:05,809 --> 00:58:08,565
So if you have a function where you
所以如果你有一个功能

1287
00:58:08,565 --> 00:58:11,190
know the result for the children and you can compute the result
知道孩子的结果，您可以计算结果

1288
00:58:11,190 --> 00:58:15,820
for the parent in constant time, then after you do the Insert,
固定时间为父级，然后在执行插入操作后， 

1289
00:58:15,820 --> 00:58:21,550
you go up on the path and you re-compute the function.
您沿着路径前进，然后重新计算该函数。 

1290
00:58:21,550 --> 00:58:25,478
When you delete, what do you do?
删除后，您会做什么？ 

1291
00:58:25,478 --> 00:58:26,673
AUDIENCE: Same thing.
听众：一样。 

1292
00:58:26,873 --> 00:58:27,789
PROFESSOR: Same thing.
教授：也是。 

1293
00:58:27,789 --> 00:58:30,639



1294
00:58:30,639 --> 00:58:35,849
If this goes away, then this subtree changed, and then
如果此方法消失，则此子树将更改，然后

1295
00:58:35,849 --> 00:58:37,529
if there would be something else here,
如果这里还有其他事情， 

1296
00:58:37,530 --> 00:58:41,039
then this subtree changed, but nothing else changed.
然后这个子树改变了，但是没有其他改变。 

1297
00:58:41,239 --> 00:58:43,879
So whenever you do an Insert or a Delete, all you have to do
因此，无论何时执行插入或删除操作，都要做

1298
00:58:43,880 --> 00:58:46,210
is go back up the path to the parent
是回到父级的路径

1299
00:58:46,210 --> 00:58:52,000
and re-compute the function that you're trying to compute.
并重新计算您要计算的函数。 

1300
00:58:52,000 --> 00:58:55,309
And that's tree augmentation.
那就是树的增强。 

1301
00:58:55,309 --> 00:58:58,369
Does this make sense somewhat?
这有道理吗？ 

1302
00:58:58,369 --> 00:58:59,440
That's it.
而已。 

1303
00:58:59,440 --> 00:59:00,960
So what you'll find in lecture notes
所以您会在讲义中找到

1304
00:59:00,960 --> 00:59:05,849
is a harder way of doing it that works for minimum,
是一种很难做到的方法，但效果最低

1305
00:59:05,849 --> 00:59:08,989
but what I told you works for everything.
但是我告诉你的一切都是可行的。 

1306
00:59:08,989 --> 00:59:12,789
So don't tell people I told you how to do this for everything.
所以，不要告诉别人我告诉过你如何做到这一点。 

1307
00:59:12,789 --> 00:59:17,789
Sure nobody's going to know.
当然没有人会知道。 

