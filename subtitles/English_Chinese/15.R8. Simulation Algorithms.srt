1
00:00:00,000 --> 00:00:00,150



2
00:00:00,150 --> 00:00:01,839
The following content is provided
提供以下内容

3
00:00:01,840 --> 00:00:04,080
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,080 --> 00:00:06,929
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,929 --> 00:00:10,779
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,779 --> 00:00:13,389
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,390 --> 00:00:17,295
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,295 --> 00:00:17,920
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,920 --> 00:00:21,679



10
00:00:21,679 --> 00:00:23,800
PROFESSOR: We're going to cover hashing next time.
教授：下次我们将讨论散列。 

11
00:00:23,800 --> 00:00:25,379
Now we're Going to focus on pset three
现在我们将重点介绍pset第三

12
00:00:25,579 --> 00:00:27,879
because I heard pset three is hard
因为我听说pset 3很难

13
00:00:27,879 --> 00:00:32,216
so we're going to look at the code and try to understand it.
因此，我们将看一下代码并尝试理解它。 

14
00:00:32,216 --> 00:00:33,560
AUDIENCE: This course is hard.
听众：这门课很难。 

15
00:00:33,560 --> 00:00:35,143
PROFESSOR: I've tried to make it easy.
教授：我试图使其变得简单。 

16
00:00:35,143 --> 00:00:36,039
I really tried.
我真的尝试过

17
00:00:36,039 --> 00:00:40,140



18
00:00:40,140 --> 00:00:42,209
How many people recognize the code?
有多少人识别该密码？ 

19
00:00:42,409 --> 00:00:44,219
Does this look familiar?
这看起来很熟悉吗？ 

20
00:00:44,219 --> 00:00:44,949
One, two, three.
一二三。 

21
00:00:44,950 --> 00:00:47,989
Everyone else got stuck on question one?
其他人都陷入一个问题吗？ 

22
00:00:48,189 --> 00:00:50,599
I'm not going to give you the answers to the psets.
我不会为您提供这些pset的答案。 

23
00:00:50,600 --> 00:00:51,310
We are going to--
我们准备去 - 

24
00:00:51,310 --> 00:00:51,530
AUDIENCE: [LAUGHING]
观众：[笑声] 

25
00:00:51,530 --> 00:00:52,169
PROFESSOR: Sorry.
教授：对不起。 

26
00:00:52,369 --> 00:00:54,381
We're going to look at the code and understand
我们将看一下代码并了解

27
00:00:54,381 --> 00:00:56,589
what it does because once you understand what it does
它会做什么，因为一旦您了解了它的作用

28
00:00:56,590 --> 00:01:00,270
you can understand how to modify it.
您可以了解如何进行修改。 

29
00:01:00,270 --> 00:01:02,444
All right, before I do that, any questions?
好吧，在我这样做之前，有什么问题吗？ 

30
00:01:02,444 --> 00:01:04,069
And I might not answer them right away,
而且我可能不会立即回答他们， 

31
00:01:04,069 --> 00:01:08,189
but I will keep them in mind while I go through the code.
但是在阅读代码时，我会牢记它们。 

32
00:01:08,189 --> 00:01:10,332
Are there any specific pin-points.
是否有任何具体的要点。 

33
00:01:10,332 --> 00:01:12,549
AUDIENCE: The types.
听众：类型。 

34
00:01:12,549 --> 00:01:14,409
PROFESSOR: Yep.
教授：是的。 

35
00:01:14,409 --> 00:01:15,519
Covered in five minutes.
五分钟内覆盖。 

36
00:01:15,519 --> 00:01:21,509



37
00:01:21,510 --> 00:01:22,010
Oh well.
那好吧。 

38
00:01:22,010 --> 00:01:28,572



39
00:01:28,572 --> 00:01:30,280
The first thing that I want to talk about
我想谈的第一件事

40
00:01:30,280 --> 00:01:33,150
is sweep line algorithms.
是扫线算法。 

41
00:01:33,150 --> 00:01:35,399
We're asking you to implement the sweep line algorithm
我们要求您实施扫线算法

42
00:01:35,400 --> 00:01:39,140
and we're giving you one that is horribly inefficient.
我们正在为您提供效率极低的产品。 

43
00:01:39,140 --> 00:01:43,659
Suppose you have some line segments that look like this.
假设您有一些看起来像这样的线段。 

44
00:01:43,659 --> 00:01:48,280



45
00:01:48,280 --> 00:01:49,530
Sorry, drawing isn't.
抱歉，不是。 

46
00:01:49,530 --> 00:01:56,030



47
00:01:56,030 --> 00:01:56,920
They look like this.
他们看起来像这样。 

48
00:01:56,920 --> 00:02:01,189



49
00:02:01,189 --> 00:02:05,841
And suppose you want to find the intersections between them.
并假设您想找到它们之间的交点。 

50
00:02:05,841 --> 00:02:07,730
Now let's figure out what the algorithm
现在让我们找出什么算法

51
00:02:07,730 --> 00:02:09,740
that we gave you does.
我们给你的。 

52
00:02:09,740 --> 00:02:12,400
Did people look at the trace for that?
人们看到了这条痕迹吗？ 

53
00:02:12,400 --> 00:02:16,000
Not the good trace, the trace that's output by the algorithm
不是好的跟踪，而是算法输出的跟踪

54
00:02:16,000 --> 00:02:18,620
that we gave you.
我们给你的

55
00:02:18,620 --> 00:02:21,598
Does anyone understand what that does.
有谁知道那是什么。 

56
00:02:21,598 --> 00:02:23,245
AUDIENCE: I kind of get it.
听众：我有点明白。 

57
00:02:23,444 --> 00:02:24,027
PROFESSOR: OK.
教授：好的。 

58
00:02:24,027 --> 00:02:26,443
AUDIENCE: I think what it does is it just hits through all
听众：我认为它的作用是贯穿所有人

59
00:02:26,443 --> 00:02:29,463
the horizontal lines and it goes through all the vertical ones.
水平线，并穿过所有垂直线。 

60
00:02:29,463 --> 00:02:31,379
First it goes through all the horizontal lines
首先，它穿过所有水平线

61
00:02:31,379 --> 00:02:32,889
and what does it do with them?
对他们有什么作用？ 

62
00:02:32,889 --> 00:02:34,729
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

63
00:02:34,729 --> 00:02:37,019
PROFESSOR: They get bolded in the visualizer which
教授：他们在可视化工具中加粗了

64
00:02:37,020 --> 00:02:39,780
means they're added to the range index.
表示将它们添加到范围索引中。 

65
00:02:39,780 --> 00:02:44,060
So one, add all the horizontal lines.
因此，添加所有水平线。 

66
00:02:44,060 --> 00:02:48,020
And two-- oh you said it goes through all the vertical lines
还有两个-哦，你说的是它贯穿所有垂直线

67
00:02:48,020 --> 00:02:50,219
after that.
之后。 

68
00:02:50,219 --> 00:02:52,306
Any idea what it does?
知道它做什么吗？ 

69
00:02:52,306 --> 00:02:54,060
AUDIENCE: It looks for intersections.
听众：它寻找路口。 

70
00:02:54,259 --> 00:03:00,289
PROFESSOR: When he looks at a vertical line segment
教授：当他看着垂直线段时

71
00:03:00,289 --> 00:03:01,989
you'll see some blue square and you'll
你会看到一些蓝色方块，你会

72
00:03:01,990 --> 00:03:03,800
see some segments that are green.
看到一些绿色的段。 

73
00:03:03,800 --> 00:03:05,930
This is a query to the range index
这是对范围索引的查询

74
00:03:06,129 --> 00:03:08,710
and the green segments are the answers
绿色部分就是答案

75
00:03:08,710 --> 00:03:13,316
and the blue square is the range that's queried.
蓝色正方形是要查询的范围。 

76
00:03:13,515 --> 00:03:15,389
First add all the segments to the range index
首先将所有细分添加到范围索引

77
00:03:15,389 --> 00:03:21,469
and then do a query.
然后进行查询。 

78
00:03:21,469 --> 00:03:23,419
In principle sweep line algorithms
原则上扫线算法

79
00:03:23,419 --> 00:03:25,739
have some geometric inputs.
有一些几何输入。 

80
00:03:25,740 --> 00:03:27,590
For example, a bunch of lines.
例如，一堆线。 

81
00:03:27,789 --> 00:03:30,609
And conceptually they have this vertical line
从概念上讲，他们有垂直线

82
00:03:30,610 --> 00:03:33,990
that they sweep across the plane all the way from minus infinity
他们从负无穷处一直扫过飞机

83
00:03:33,990 --> 00:03:35,870
to plus infinity.
加上无限。 

84
00:03:35,870 --> 00:03:37,800
Now if you try to sweep a line continuously
现在，如果您尝试连续扫描一条线

85
00:03:37,800 --> 00:03:39,830
from minus infinity to plus infinity in code
从负无穷大到正无穷大

86
00:03:39,830 --> 00:03:41,800
it might take forever.
这可能需要永远。 

87
00:03:41,800 --> 00:03:43,250
We don't really do it that way.
我们并不是真的那样做。 

88
00:03:43,449 --> 00:03:46,181
The way we do it in code is you know
我们在代码中执行此操作的方式是

89
00:03:46,181 --> 00:03:48,909
when something interesting is going to happen
当一些有趣的事情要发生时

90
00:03:48,909 --> 00:03:51,639
and you only simulate what happens to the sweep line
而且你只模拟扫掠线发生了什么

91
00:03:51,639 --> 00:03:53,729
at that point.
在那时候。 

92
00:03:53,729 --> 00:03:57,759
In this case the sweep line starts at minus infinity
在这种情况下，扫描线始于负无穷大

93
00:03:57,759 --> 00:03:59,539
and then all the horizontal segments
然后所有的水平线段

94
00:03:59,539 --> 00:04:01,889
are added to our range index.
被添加到我们的范围索引中。 

95
00:04:01,889 --> 00:04:06,419
And then as the sweep line goes across the plane, when
然后当扫掠线越过飞机时， 

96
00:04:06,419 --> 00:04:09,009
it hits a vertical segment a query happens.
它碰到一个垂直段，查询就会发生。 

97
00:04:09,009 --> 00:04:11,769



98
00:04:11,770 --> 00:04:13,965
The only times when the sweep line stops
扫线停止的唯一时间

99
00:04:14,164 --> 00:04:18,360
is first, at the beginning to add all the horizontal line
首先，在开始时添加所有水平线

100
00:04:18,360 --> 00:04:24,920
segments, and then every time it hits a vertical line segment.
线段，然后每次碰到垂直线段时

101
00:04:24,920 --> 00:04:26,819
We know this ahead of time so we can
我们提前知道这一点，所以我们可以

102
00:04:27,019 --> 00:04:29,789
compute a list of all these coordinates
计算所有这些坐标的列表

103
00:04:29,790 --> 00:04:31,670
of interesting things.
有趣的事情。 

104
00:04:31,670 --> 00:04:33,920
And then we can sort them and then go through them
然后我们可以对它们进行排序，然后遍历它们

105
00:04:33,920 --> 00:04:37,990
and simulate the behavior of the sweep line that way.
并以此方式模拟扫描线的行为。 

106
00:04:37,990 --> 00:04:40,259
If you look at the code listing at events from there,
如果您查看代码清单中发生的事件， 

107
00:04:40,259 --> 00:04:41,659
this is the gist of it.
这就是要点。 

108
00:04:41,660 --> 00:04:43,060
This is what it does.
这就是它的作用。 

109
00:04:43,259 --> 00:04:45,789
It compiles a list of events.
它编译事件列表。 

110
00:04:45,790 --> 00:04:50,579
The first key in each event is the x, is that x?
每个事件的第一个键是x，是x吗？ 

111
00:04:50,779 --> 00:04:53,609
Yeah. x like this, y like this.
是的x像这样，y像这样。 

112
00:04:53,610 --> 00:04:56,230
The first case, the x-coordinate of an event
第一种情况，事件的x坐标

113
00:04:56,230 --> 00:04:59,259
and by sorting that list of events
并通过排序事件列表

114
00:04:59,259 --> 00:05:02,599
it will then process them in order.
然后它将按顺序处理它们。 

115
00:05:02,600 --> 00:05:05,490
Events from there is responsible for looking at all the wires
来自那里的事件负责查看所有连线

116
00:05:05,490 --> 00:05:08,420
and compiling events.
和编译事件。 

117
00:05:08,420 --> 00:05:10,990
How does an event for a horizontal layer look like?
水平图层的事件看起来如何？ 

118
00:05:10,990 --> 00:05:12,480
Can anyone tell me?
谁能告诉我？ 

119
00:05:12,480 --> 00:05:15,435
Sorry, for a horizontal wire.
对不起，对于水平线。 

120
00:05:15,435 --> 00:05:16,942
AUDIENCE: It will run across [INAUDIBLE].
听众：它将跨[听不清]运行。 

121
00:05:17,142 --> 00:05:21,459



122
00:05:21,459 --> 00:05:24,329
PROFESSOR: First off it looks like a list, right?
教授：首先，它看起来像一个列表，对吗？ 

123
00:05:24,329 --> 00:05:26,149
It's a regular python list.
这是一个常规的python列表。 

124
00:05:26,149 --> 00:05:29,359
And I will try to call it vector so that we don't confuse it
我会尝试称其为向量，以便我们不会混淆它

125
00:05:29,360 --> 00:05:31,629
with a big list of all the events.
包含所有事件的大清单。 

126
00:05:31,829 --> 00:05:34,609
You said the first thing is the leftmost point.
您说的第一件事是最左边的地方。 

127
00:05:34,610 --> 00:05:36,860
Right?
对？ 

128
00:05:36,860 --> 00:05:39,990
If this segment, for example, starts at minus 100,
举例来说，如果这个区隔的开头是负100， 

129
00:05:39,990 --> 00:05:44,680
this one starts at minus 95, this one starts at minus 90,
这个从负95开始，这个从负90开始， 

130
00:05:44,680 --> 00:05:49,889
and this one starts at minus 50, by the way not to scale,
而这个开始于负50，顺便说一下， 

131
00:05:49,889 --> 00:05:52,534
then the leftmost point is minus 100.
那么最左边的点是负100。 

132
00:05:52,535 --> 00:05:54,110
Right?
对？ 

133
00:05:54,110 --> 00:05:58,230
This is the first element in the vector.
这是向量中的第一个元素。 

134
00:05:58,230 --> 00:06:00,795
And that's computed on line four where
那是在第四行计算的

135
00:06:00,795 --> 00:06:02,170
it goes through all the segments,
它遍及所有细分市场

136
00:06:02,170 --> 00:06:07,199
looks at all the X-coordinates and chooses the minimum.
查看所有X坐标并选择最小值。 

137
00:06:07,199 --> 00:06:09,226
What's the next thing in the vector?
向量中的下一件事是什么？ 

138
00:06:09,226 --> 00:06:10,560
We don't have to understand why.
我们不必了解原因。 

139
00:06:10,560 --> 00:06:12,180
We'll go through why in a bit.
我们稍后会详细说明为什么。 

140
00:06:12,180 --> 00:06:14,656
I'm just interested in what?
我只是对什么感兴趣？ 

141
00:06:14,656 --> 00:06:15,079
AUDIENCE: Zero.
听众：零。 

142
00:06:15,279 --> 00:06:15,945
PROFESSOR: Zero.
教授：零。 

143
00:06:15,946 --> 00:06:17,240
Excellent.
优秀的。 

144
00:06:17,439 --> 00:06:21,189
PROFESSOR: After that there is a wire ID.
教授：之后有一个电线ID。 

145
00:06:21,189 --> 00:06:24,540
Each wire gets a unique ID, that's a number between zero
每条线都有一个唯一的ID，即介于零之间的数字

146
00:06:24,540 --> 00:06:26,939
and the number of wires.
和电线数量。 

147
00:06:27,139 --> 00:06:29,789
Say this is one, two, three.
说这是一，二，三。 

148
00:06:29,790 --> 00:06:31,560
This is going to be one.
这将是一个。 

149
00:06:31,759 --> 00:06:34,779
And then I have the string add.
然后我有字符串添加。 

150
00:06:34,779 --> 00:06:36,509
And then I have the actual wire object.
然后我有了实际的电线对象。 

151
00:06:36,509 --> 00:06:39,399



152
00:06:39,399 --> 00:06:45,269
What does the vector look like for a query event?
向量对于查询事件是什么样的？ 

153
00:06:45,269 --> 00:06:49,031
Sorry, what does it look like for a vertical wire?
抱歉，垂直电线看起来像什么？ 

154
00:06:49,031 --> 00:06:50,490
I'm giving away some of the answer.
我正在给出一些答案。 

155
00:06:50,490 --> 00:06:51,319
Bad, bad, bad.
不好不好

156
00:06:51,319 --> 00:06:55,120



157
00:06:55,120 --> 00:06:57,689
All right, vertical wire, look at the code and.
好的，垂直线，看代码和。 

158
00:06:57,689 --> 00:07:03,156



159
00:07:03,156 --> 00:07:06,311
AUDIENCE: It keeps the left [INAUDIBLE].
听众：保持左侧[听不清]。 

160
00:07:06,312 --> 00:07:07,069
PROFESSOR: Of the wire.
教授：电线。 

161
00:07:07,269 --> 00:07:08,049
OK.
好。 

162
00:07:08,050 --> 00:07:09,379
And?
和？ 

163
00:07:09,379 --> 00:07:11,177
AUDIENCE: It keeps the x-coordinate [INAUDIBLE].
听众：保持x坐标[音频不清晰]。 

164
00:07:11,377 --> 00:07:14,502



165
00:07:14,502 --> 00:07:16,759
PROFESSOR: A vertical wire will have the same X-coordinates
教授：垂直导线的X坐标相同

166
00:07:16,959 --> 00:07:18,543
for all the points on the wire, right?
对于电线上的所有点，对不对？ 

167
00:07:18,543 --> 00:07:21,379
I don't really worry about which coordinate it is.
我真的不担心它是什么坐标。 

168
00:07:21,379 --> 00:07:23,319
This wire is at minus 50.
该导线的负值为50。 

169
00:07:23,319 --> 00:07:27,430
The first element here is going to be minus 50.
这里的第一个元素将是负50。 

170
00:07:27,430 --> 00:07:29,329
What's next?
下一步是什么？ 

171
00:07:29,329 --> 00:07:30,720
AUDIENCE: A 1.
听众：A 1。 

172
00:07:30,720 --> 00:07:32,069
PROFESSOR: A 1.
教授：A 1。 

173
00:07:32,269 --> 00:07:33,079
OK.
好。 

174
00:07:33,079 --> 00:07:36,599
And suppose this is wire ID 4.
并假设这是电线ID 4。 

175
00:07:36,600 --> 00:07:40,329
I'm going to have 4.
我要去4。 

176
00:07:40,529 --> 00:07:41,449
AUDIENCE: Query.
听众：查询。 

177
00:07:41,449 --> 00:07:42,603
PROFESSOR: Query.
教授：查询。 

178
00:07:42,603 --> 00:07:45,159
AUDIENCE: And the wire.
听众：还有电线。 

179
00:07:45,160 --> 00:07:46,160
PROFESSOR: And the wire.
教授：还有电线。 

180
00:07:46,160 --> 00:07:51,000



181
00:07:51,199 --> 00:07:54,250
All right, what happens with these in the init method, which
好吧，在init方法中这些会发生什么， 

182
00:07:54,250 --> 00:07:56,329
is not shown in the code listing,
没有显示在代码清单中， 

183
00:07:56,329 --> 00:08:01,750
is after the list is put together sort is called on it.
是将列表放在一起后对它进行排序。 

184
00:08:01,750 --> 00:08:04,980
These are all compared and then reordered
比较所有这些，然后重新排序

185
00:08:04,980 --> 00:08:09,319
to be sorted according to some ordering relationship.
根据某种排序关系进行排序。 

186
00:08:09,519 --> 00:08:11,699
Does anyone know what the ordering relationship
有谁知道订购关系

187
00:08:11,699 --> 00:08:14,666
is for Python lists?
是用于Python列表？ 

188
00:08:14,666 --> 00:08:16,133
Yeah.
是的

189
00:08:16,134 --> 00:08:18,579
AUDIENCE: It starts from the first, from zero,
听众：从第一个开始，从零开始， 

190
00:08:18,579 --> 00:08:24,367
and the next it goes to sort the same with as X 1.
接下来，它的排序与X 1相同。 

191
00:08:24,367 --> 00:08:24,750
PROFESSOR: OK.
教授：好的。 

192
00:08:24,949 --> 00:08:33,644
Say if I have 1, 2, 3 and 1, 3, 2.
假设我有1、2、3和1、3、2。 

193
00:08:33,644 --> 00:08:36,319



194
00:08:36,320 --> 00:08:42,950
Sorry, and 2, 1, 2.
抱歉，还有2，1，2。 

195
00:08:42,950 --> 00:08:44,870
He's going to look at the first element
他要看第一个元素

196
00:08:44,870 --> 00:08:47,340
and if they are different than the one with the smaller
如果它们与较小的那些不同

197
00:08:47,340 --> 00:08:49,019
element is smaller.
元素较小。 

198
00:08:49,019 --> 00:08:52,269
1, 2, 3 as a vector, sorry, as a list,
 1、2、3作为向量，对不起，作为列表， 

199
00:08:52,269 --> 00:08:54,470
is smaller than 2, 1, 2 as a list.
小于2、1、2作为列表。 

200
00:08:54,470 --> 00:08:57,250



201
00:08:57,250 --> 00:09:00,429
If this guy becomes one then they're equal.
如果这个人成为一个人，那么他们是平等的。 

202
00:09:00,429 --> 00:09:02,279
Then it has to go to the next element,
然后必须转到下一个元素， 

203
00:09:02,279 --> 00:09:06,029
compare them and see if they're different we have
比较它们，看看它们是否不同

204
00:09:06,029 --> 00:09:07,459
an answer, if not we have to keep
一个答案，如果没有，我们必须保持

205
00:09:07,460 --> 00:09:10,090
going all the way until the end of the list.
一直到列表末尾。 

206
00:09:10,090 --> 00:09:11,969
This is called lexicographic comparison
这称为词典比较

207
00:09:12,169 --> 00:09:15,729
and this is the same ordering that you have for the words
这与您对单词的排序相同

208
00:09:15,730 --> 00:09:17,219
in a dictionary.
在字典中。 

209
00:09:17,419 --> 00:09:19,039
Right, if you think of each letter
是的，如果您想到每个字母

210
00:09:19,039 --> 00:09:22,449
as an element in a list and the word is the list
作为列表中的元素，单词是列表

211
00:09:22,450 --> 00:09:26,820
then this is how you look up words in a dictionary.
这就是您在字典中查找单词的方式。 

212
00:09:26,820 --> 00:09:30,850
The reason events look like this is
事件看起来像这样的原因是

213
00:09:30,850 --> 00:09:33,210
so that sort would output them in the right order
这样排序将以正确的顺序输出

214
00:09:33,210 --> 00:09:34,949
for the next state.
对于下一个状态。 

215
00:09:35,149 --> 00:09:36,910
So, yes.
所以，是的。 

216
00:09:36,910 --> 00:09:38,993
AUDIENCE: Does that mean all the horizontal wires,
听众：这是否意味着所有水平线， 

217
00:09:38,994 --> 00:09:41,682
does that mean that they start at same place even though that
这是否意味着即使他们

218
00:09:41,682 --> 00:09:42,806
they don't?
他们不？ 

219
00:09:42,806 --> 00:09:43,229
PROFESSOR: Yup.
教授：是的。 

220
00:09:43,429 --> 00:09:45,699
all the horizontal wires will be sorted.
所有水平导线将被分类。 

221
00:09:45,700 --> 00:09:50,850
All these add events will be sorted before the query events.
所有这些添加事件将在查询事件之前进行排序。 

222
00:09:50,850 --> 00:09:52,080
Yup, very good observation.
是的，很好的观察。 

223
00:09:52,080 --> 00:09:53,990
This is what I'm trying to achieve.
这就是我要实现的目标。 

224
00:09:53,990 --> 00:09:56,404
That's why I have this special value here.
这就是为什么我在这里有这个特殊的价值。 

225
00:09:56,404 --> 00:09:58,279
I go through some extra effort to compute it.
我花了一些额外的精力来计算它。 

226
00:09:58,279 --> 00:09:59,779
I had to write an extra line of code
我不得不多写一行代码

227
00:09:59,779 --> 00:10:01,894
so this is the motivation for it.
所以这就是它的动力。 

228
00:10:01,894 --> 00:10:06,539



229
00:10:06,539 --> 00:10:09,730
The first key in the vector is the X element
向量中的第一个键是X元素

230
00:10:09,730 --> 00:10:10,788
on the sweep line.
在清扫线上

231
00:10:10,788 --> 00:10:13,779



232
00:10:13,779 --> 00:10:17,370
I could've also had the very large negative value
我也可以拥有很大的负值

233
00:10:17,370 --> 00:10:20,000
that something that would behave like minus infinity here
在这里表现为负无穷大的东西

234
00:10:20,000 --> 00:10:21,789
and that would work just as well.
而且效果也一样。 

235
00:10:21,789 --> 00:10:24,449



236
00:10:24,450 --> 00:10:26,719
By computing the left edge I don't have to deal with that.
通过计算左边缘，我不必处理。 

237
00:10:26,919 --> 00:10:29,319
I don't have to worry of whether my negative infinity is
我不必担心我的负无穷大是

238
00:10:29,320 --> 00:10:32,189
small enough, because if it's not I will fail the test
足够小，因为如果不是，我将无法通过测试

239
00:10:32,389 --> 00:10:34,379
and that's bad.
那很糟糕。 

240
00:10:34,379 --> 00:10:37,340
This is the x-coordinate at which the sweep line stops
这是扫掠线停止的x坐标

241
00:10:37,340 --> 00:10:39,340
and something happens.
发生了一些事情。 

242
00:10:39,340 --> 00:10:41,629
So if all the events are different the x-coordinates
因此，如果所有事件都不相同，则x坐标

243
00:10:41,629 --> 00:10:43,389
then I have my ordering, I'm done.
然后我下订单了，我完成了。 

244
00:10:43,389 --> 00:10:46,220
Now what if I have two events at the same time?
现在，如果我同时有两个事件怎么办？ 

245
00:10:46,220 --> 00:10:49,599
For example, what if I have two vertical wires?
例如，如果我有两条垂直线怎么办？ 

246
00:10:49,799 --> 00:10:54,550



247
00:10:54,551 --> 00:10:56,099
The x-coordinates are going to be the same
 x坐标将相同

248
00:10:56,299 --> 00:11:00,039
so I need to use something else to break the ties, right?
所以我需要用别的东西打破平局，对吗？ 

249
00:11:00,039 --> 00:11:01,919
The first thing that I use to break the ties
我打破关系的第一件事

250
00:11:01,919 --> 00:11:05,120
is all add events have a zero here
是所有添加事件在这里都为零

251
00:11:05,120 --> 00:11:07,529
and all the query events have a one.
并且所有查询事件都有一个。 

252
00:11:07,529 --> 00:11:09,720
And the point of that is if I have
关键是如果我有

253
00:11:09,720 --> 00:11:11,350
two events at the same x-coordinate,
两个事件在相同的x坐标上

254
00:11:11,350 --> 00:11:13,940
if I have a query and an add, I want
如果我有一个查询和一个添加，我想要

255
00:11:13,940 --> 00:11:16,099
the add to happen before the query.
添加发生在查询之前。 

256
00:11:16,299 --> 00:11:18,779
If this is the same this is going
如果相同的话

257
00:11:18,779 --> 00:11:20,629
to be different for ad versus query.
在广告和查询方面有所不同。 

258
00:11:20,629 --> 00:11:24,200



259
00:11:24,200 --> 00:11:25,250
Does that make sense?
那有意义吗？ 

260
00:11:25,250 --> 00:11:27,610
This is how we order events relatively
这是我们相对地订购事件的方式

261
00:11:27,610 --> 00:11:29,769
to each other on the same line.
彼此在同一条线上。 

262
00:11:29,769 --> 00:11:33,009
Now suppose I have these two wires,
现在假设我有两条线， 

263
00:11:33,009 --> 00:11:35,470
they're both vertical so they're both going to be queries.
它们都是垂直的，因此它们都是查询。 

264
00:11:35,470 --> 00:11:37,269
They're both at the same index.
他们都在同一索引。 

265
00:11:37,269 --> 00:11:40,519
I need something else, and that other thing that I have
我需要其他东西，还有我拥有的其他东西

266
00:11:40,519 --> 00:11:44,370
is the wire ID which is guaranteed to be unique.
是保证唯一的电线ID。 

267
00:11:44,370 --> 00:11:47,620
I know for sure the comparison will stop here.
我知道比较会在这里停止。 

268
00:11:47,620 --> 00:11:49,409
And the comparison had better stop here
比较最好在这里停止

269
00:11:49,409 --> 00:11:52,289
because if the comparison gets all the way to here,
因为如果比较一直到这里

270
00:11:52,289 --> 00:11:54,740
wires aren't comparable so the code is going to crash.
电线不具有可比性，因此代码将崩溃。 

271
00:11:54,740 --> 00:11:59,389



272
00:11:59,389 --> 00:12:02,129
It stops here because the IDs are unique, everyone is happy.
因为ID是唯一的，所以每个人都很高兴，这里就停止了。 

273
00:12:02,129 --> 00:12:04,769



274
00:12:04,769 --> 00:12:06,649
All right, do the events make more sense now?
好吧，这些事件现在有意义吗？ 

275
00:12:06,649 --> 00:12:09,350



276
00:12:09,350 --> 00:12:10,979
To complete the picture if you look
要看完整的图片

277
00:12:11,179 --> 00:12:14,359
at compute crossings, lines nine and ten.
在计算交叉口，第9和10行。 

278
00:12:14,360 --> 00:12:16,740
Line nine goes through the vector-- sorry,
第9行经过向量-抱歉， 

279
00:12:16,740 --> 00:12:19,340
goes through the list of events that have been sorted
浏览已排序的事件列表

280
00:12:19,340 --> 00:12:21,750
and processes them in order so sort
并按顺序处理它们

281
00:12:21,750 --> 00:12:23,480
had better do the right job.
最好做正确的工作。 

282
00:12:23,480 --> 00:12:27,134
And then it extracts the x-coordinate, that's here,
然后提取x坐标，就在这里， 

283
00:12:27,134 --> 00:12:30,120
it extracts the event type, that's here,
它提取事件类型，就在这里， 

284
00:12:30,120 --> 00:12:32,803
and then it extracts the wire from here.
然后从这里提取电线。 

285
00:12:32,803 --> 00:12:35,220
These guys really are just there to help with the sorting,
这些家伙真的在那里帮助您进行分类， 

286
00:12:35,220 --> 00:12:37,355
they're never read afterwards.
他们以后再也不会阅读。 

287
00:12:37,355 --> 00:12:39,230
AUDIENCE: Where are the events actually sort?
听众：这些事件实际上在哪里排序？ 

288
00:12:39,230 --> 00:12:42,110
I thought they just put into order.
我以为他们只是整理好了。 

289
00:12:42,110 --> 00:12:47,134
PROFESSOR: The events are sorted in an init method that's
教授：这些事件按以下方法的init方法排序： 

290
00:12:47,134 --> 00:12:47,634
not here.
不在这里。 

291
00:12:47,634 --> 00:12:49,990
It's in the piece of code but it's not here.
它在代码段中，但不在这里。 

292
00:12:49,990 --> 00:12:54,740
And that may be a hint that you don't want to change it.
这可能暗示您不想更改它。 

293
00:12:54,740 --> 00:12:55,740
As in you don't need to.
就像您不需要的那样。 

294
00:12:55,740 --> 00:12:58,990



295
00:12:58,990 --> 00:13:00,789
All right, events look like this.
好吧，事件看起来像这样。 

296
00:13:00,789 --> 00:13:04,799



297
00:13:04,799 --> 00:13:08,479
Any questions about events?
对活动有任何疑问吗？ 

298
00:13:08,480 --> 00:13:10,639
Everything make sense?
一切都有意义吗？ 

299
00:13:10,639 --> 00:13:12,729
Presumably when you write your own sweep line algorithm
大概是在编写自己的扫掠线算法时

300
00:13:12,929 --> 00:13:16,346
you're going to come up with your own events which
您将提出自己的事件

301
00:13:16,346 --> 00:13:17,429
are going to be different.
将会有所不同。 

302
00:13:17,429 --> 00:13:20,829
You're going to change these methods to add
您将更改这些方法以添加

303
00:13:20,830 --> 00:13:22,363
your own events to the list.
您自己的事件进入列表。 

304
00:13:22,563 --> 00:13:24,230
And then it's going to be sorted for you
然后将为您进行排序

305
00:13:24,230 --> 00:13:27,072
and then you're going to change compute crossings to process
然后您将更改计算交叉以进行处理

306
00:13:27,072 --> 00:13:29,279
your events in the way that they should be processed.
您的事件的处理方式。 

307
00:13:29,279 --> 00:13:36,730



308
00:13:36,730 --> 00:13:40,539
Let's look at the range index.
让我们看一下范围索引。 

309
00:13:40,539 --> 00:13:41,995
What do we store in a range index?
我们在范围索引中存储什么？ 

310
00:13:41,995 --> 00:13:44,745



311
00:13:44,745 --> 00:13:47,303
AUDIENCE: The horizontal wires.
听众：水平线。 

312
00:13:47,303 --> 00:13:48,470
PROFESSOR: Horizontal wires.
教授：水平线。 

313
00:13:48,470 --> 00:13:49,379
Very good.
很好。 

314
00:13:49,379 --> 00:13:53,070
What's the point of storing horizontal wires in an index?
将水平线存储在索引中有什么意义？ 

315
00:13:53,070 --> 00:13:55,719
AUDIENCE: That's when you want to query,
听众：那是您要查询的时候， 

316
00:13:55,919 --> 00:13:57,819
the area has a line through it.
该区域有一条线穿过。 

317
00:13:57,820 --> 00:14:01,219



318
00:14:01,419 --> 00:14:03,889
PROFESSOR: For the algorithm that we gave you
教授：对于我们给您的算法

319
00:14:03,889 --> 00:14:05,590
how does a query look like?
查询看起来如何？ 

320
00:14:05,590 --> 00:14:10,070
Suppose I have this wire here and I'm doing a query for it.
假设我在这里有这根线，并且正在对其进行查询。 

321
00:14:10,070 --> 00:14:13,194
AUDIENCE: Just ask to list horizontal wires that
听众：只要求列出水平线

322
00:14:13,394 --> 00:14:17,669
are between that Y.
在那个Y之间。 

323
00:14:17,669 --> 00:14:20,019
PROFESSOR: Between this guy's top and this guy's bottom.
教授：在这个人的顶部和这个人的底部之间。 

324
00:14:20,019 --> 00:14:20,519
Right?
对？ 

325
00:14:20,519 --> 00:14:21,269
AUDIENCE: Yeah.
听众：是的。 

326
00:14:21,269 --> 00:14:22,936
PROFESSOR: A query would look like this.
教授：查询看起来像这样。 

327
00:14:22,936 --> 00:14:27,500



328
00:14:27,500 --> 00:14:31,759
Basically all the horizontal wires
基本上所有的水平线

329
00:14:31,759 --> 00:14:35,450
that have their y-coordinates between this guy and this guy.
在这个家伙和这个家伙之间有y坐标

330
00:14:35,450 --> 00:14:40,509
Now if I have a wire that's way up here or way down here
现在，如果我的电线在这里或在这里

331
00:14:40,509 --> 00:14:43,490
I know for sure that it's not going to intersect this wire.
我确定它不会与这条线相交。 

332
00:14:43,490 --> 00:14:43,990
Right?
对？ 

333
00:14:43,990 --> 00:14:46,479
I don't care about it.
我不在乎。 

334
00:14:46,679 --> 00:14:50,399
The range index helps me eliminate some wires.
范围索引可帮助我消除一些导线。 

335
00:14:50,399 --> 00:14:53,840
Now, will the range index eliminate all the wires
现在，范围索引会消除所有导线吗

336
00:14:53,840 --> 00:14:58,019
that don't intersect with this wire?
不与这根线相交？ 

337
00:14:58,019 --> 00:14:59,789
No, OK.
不行

338
00:14:59,789 --> 00:15:01,079
Why not?
为什么不？ 

339
00:15:01,080 --> 00:15:04,435
AUDIENCE: Well in this code it doesn't.
听众：在这段代码中没有。 

340
00:15:04,635 --> 00:15:06,259
PROFESSOR: OK, in this code it doesn't.
教授：好的，在此代码中没有。 

341
00:15:06,259 --> 00:15:07,717
We're only talking about this code,
我们只是在谈论这段代码， 

342
00:15:07,717 --> 00:15:09,360
I'm not talking about the solution code
我不是在说解决方案代码

343
00:15:09,360 --> 00:15:12,277
that you guys have to implement.
你们必须实现。 

344
00:15:12,477 --> 00:15:15,851
AUDIENCE: It doesn't because it never
听众：不是因为从来没有

345
00:15:15,851 --> 00:15:18,750
removes the horizontal wires.
移除水平导线。 

346
00:15:18,750 --> 00:15:21,419
PROFESSOR: OK.
教授：好的。 

347
00:15:21,419 --> 00:15:27,879
What's an example of a query that would give me
可以给我一个查询的例子是什么

348
00:15:27,879 --> 00:15:32,095
some wires that don't intersect my wire?
一些不与我的电线相交的电线？ 

349
00:15:32,095 --> 00:15:35,065
AUDIENCE: Like if they're in between the y-axis,
听众：就像它们位于y轴之间一样， 

350
00:15:35,065 --> 00:15:38,287
they're, yeah but they're not actually.
是的，但实际上并非如此。 

351
00:15:38,287 --> 00:15:38,870
PROFESSOR: OK.
教授：好的。 

352
00:15:38,870 --> 00:15:40,508
So you mean.
所以你的意思是

353
00:15:40,708 --> 00:15:41,333
AUDIENCE: Yeah.
听众：是的。 

354
00:15:41,333 --> 00:15:43,973



355
00:15:43,974 --> 00:15:46,224
AUDIENCE: Negative infinity and infinity on the x-axis
观众：x轴上的负无穷大和无穷大

356
00:15:46,224 --> 00:15:49,633
would give you a bunch of wires and not many of them
会给你一堆电线，但不会很多

357
00:15:49,633 --> 00:15:52,354
will intersect with the vertical wires.
将与垂直线相交。 

358
00:15:52,554 --> 00:15:55,476
AUDIENCE: If the end were a vertical wire, [INAUDIBLE].
听众：如果末端是垂直线，则[听不清]。 

359
00:15:55,476 --> 00:15:58,909



360
00:15:58,909 --> 00:15:59,870
PROFESSOR: OK.
教授：好的。 

361
00:15:59,870 --> 00:16:03,580
I understood this because it matches what I drew.
我理解这一点是因为它与我绘制的内容匹配。 

362
00:16:03,580 --> 00:16:05,709
I didn't understand the minus infinity plus infinity.
我不明白负无穷大和无穷大。 

363
00:16:05,909 --> 00:16:07,120
AUDIENCE: Well if you think about the x-axis on the bottom,
观众：好吧，如果您考虑底部的x轴， 

364
00:16:07,120 --> 00:16:09,721
if you go from all the way on the left to all the way
如果您从左边一直走到一直

365
00:16:09,721 --> 00:16:12,399
on the right you're going to get a whole bunch of wires that are
在右边，您将获得一堆电线

366
00:16:12,399 --> 00:16:14,100
short that--
简而言之- 

367
00:16:14,100 --> 00:16:17,350
PROFESSOR: Are you talking about one wire
教授：您在谈论一根电线吗？ 

368
00:16:17,350 --> 00:16:18,879
that's like that, or many?
就是那样，还是很多？ 

369
00:16:18,879 --> 00:16:21,259
AUDIENCE: If you're grabbing from your range index.
听众：如果您要从范围索引中获取信息。 

370
00:16:21,259 --> 00:16:28,939
PROFESSOR: The range index has horizontal wires in it.
教授：范围索引中有水平导线。 

371
00:16:28,940 --> 00:16:31,238
AUDIENCE: Right.
听众：对。 

372
00:16:31,238 --> 00:16:34,099
AUDIENCE: Are you assuming that they're all short?
听众：您是否假设它们都很矮？ 

373
00:16:34,099 --> 00:16:34,682
AUDIENCE: Yes.
听众：是的。 

374
00:16:34,682 --> 00:16:36,649
But it's not necessarily true.
但这不一定是真的。 

375
00:16:36,649 --> 00:16:38,139
Some of them will be short.
其中一些会很短。 

376
00:16:38,139 --> 00:16:40,730
PROFESSOR: You're saying a lot of short horizontal lines--
教授：您说的是很多短的水平线- 

377
00:16:40,730 --> 00:16:41,845
you mean like this, right?
你的意思是这样吧？ 

378
00:16:41,845 --> 00:16:42,980
AUDIENCE: Yeah.
听众：是的。 

379
00:16:42,980 --> 00:16:43,860
PROFESSOR: OK.
教授：好的。 

380
00:16:43,860 --> 00:16:45,099
That's what you mean.
那就是你的意思

381
00:16:45,299 --> 00:16:46,145
AUDIENCE: You have one intersection and--
听众：您有一个十字路口，而且- 

382
00:16:46,145 --> 00:16:47,154
PROFESSOR: A ton of non-intersections.
教授：大量的不交叉口。 

383
00:16:47,154 --> 00:16:47,519
AUDIENCE: Exactly.
听众：是的。 

384
00:16:47,519 --> 00:16:48,079
PROFESSOR: OK, cool.
教授：好的，很酷。 

385
00:16:48,080 --> 00:16:48,580
Thank you.
谢谢。 

386
00:16:48,580 --> 00:16:51,479



387
00:16:51,679 --> 00:16:53,459
Doing a range query on this can give me
对此进行范围查询可以给我

388
00:16:53,460 --> 00:16:55,479
a lot of false positives.
很多误报。 

389
00:16:55,679 --> 00:16:57,620
That's why after I get them I have
这就是为什么我得到他们之后

390
00:16:57,620 --> 00:16:59,659
to make sure that they intersect and I
确保他们和我相交

391
00:16:59,659 --> 00:17:02,829
can't just blindly output them.
不能盲目输出它们。 

392
00:17:02,830 --> 00:17:07,160
These are bad false positives, these are bad false positive.
这些都是错误的误报，这些都是错误的误报。 

393
00:17:07,160 --> 00:17:09,650
Now let's look at how the range index works.
现在让我们看看范围索引是如何工作的。 

394
00:17:09,650 --> 00:17:13,291
Can anyone remind me of what the range index does?
谁能提醒我范围索引的作用？ 

395
00:17:13,491 --> 00:17:14,700
It's a data structure, right?
这是一个数据结构，对不对？ 

396
00:17:14,700 --> 00:17:16,098
And it has some operations.
并且它有一些操作。 

397
00:17:16,098 --> 00:17:17,389
What are the operations for it?
它的作用是什么？ 

398
00:17:17,390 --> 00:17:25,435



399
00:17:25,635 --> 00:17:27,760
AUDIENCE: It returns everything between two values.
听众：它返回两个值之间的所有值。 

400
00:17:27,760 --> 00:17:30,430



401
00:17:30,430 --> 00:17:33,109
PROFESSOR: You have a list operation where you give it
教授：您在其中进行列表操作

402
00:17:33,309 --> 00:17:38,769
two values and it will return everything inside the index,
两个值，它将返回索引中的所有内容， 

403
00:17:38,769 --> 00:17:44,250
in the interval between those two values.
在这两个值之间的间隔中。 

404
00:17:44,250 --> 00:17:45,720
What else can I do?
我还可以做些什么？ 

405
00:17:45,720 --> 00:17:50,539



406
00:17:50,539 --> 00:17:52,950
AUDIENCE: It can also tell you how many.
听众：它也可以告诉您有多少。 

407
00:17:52,950 --> 00:17:57,769
It returns those keys and how many there are.
它返回这些键以及有多少键。 

408
00:17:57,769 --> 00:17:59,470
PROFESSOR: I have the count and you
教授：我有伯爵，你

409
00:17:59,470 --> 00:18:03,329
said that I have some things in the index.
说我索引中有一些东西。 

410
00:18:03,329 --> 00:18:03,829
Right?
对？ 

411
00:18:03,829 --> 00:18:05,909
How do I get them in there?
我怎样才能把他们带到那里？ 

412
00:18:05,910 --> 00:18:08,293
These are queries, I need updates.
这些是查询，我需要更新。 

413
00:18:08,493 --> 00:18:09,534
AUDIENCE: Add and remove.
听众：添加和删除。 

414
00:18:09,535 --> 00:18:20,159



415
00:18:20,359 --> 00:18:22,819
PROFESSOR: For the code that they gave you,
教授：对于他们给您的代码， 

416
00:18:22,819 --> 00:18:25,189
what is the running time for each of these operations?
这些操作的运行时间是多少？ 

417
00:18:25,190 --> 00:18:30,745



418
00:18:30,945 --> 00:18:35,286
AUDIENCE: It would be constant had to be removed.
听众：必须将其删除。 

419
00:18:35,287 --> 00:18:35,669
PROFESSOR: OK.
教授：好的。 

420
00:18:35,869 --> 00:18:36,730
Add calls the pend.
添加呼叫待命。 

421
00:18:36,730 --> 00:18:37,230
Right?
对？ 

422
00:18:37,230 --> 00:18:38,680
So that is constant.
因此，这是恒定的。 

423
00:18:38,680 --> 00:18:41,609
I will agree there.
我会同意的。 

424
00:18:41,809 --> 00:18:44,214
AUDIENCE: To remove it you had to shift everything.
听众：要删除它，您必须转移所有内容。 

425
00:18:44,214 --> 00:18:44,839
PROFESSOR: Yep.
教授：是的。 

426
00:18:44,839 --> 00:18:48,000



427
00:18:48,000 --> 00:18:50,529
Let's start with an example.
让我们从一个例子开始。 

428
00:18:50,529 --> 00:18:54,344
Say I have these keys in my range index.
假设我在范围索引中有这些键。 

429
00:18:54,344 --> 00:18:55,119
5, 8, 11, 13.
 5、8、11、13 

430
00:18:55,319 --> 00:18:59,990



431
00:18:59,990 --> 00:19:03,259
Suppose they're magically inserted in this order.
假设以这种顺序神奇地插入了它们。 

432
00:19:03,259 --> 00:19:05,569
If I want to remove two, since this is an array
如果我要删除两个，因为这是一个数组

433
00:19:05,569 --> 00:19:07,376
I have to shift everything to the left.
我必须将所有内容向左移动。 

434
00:19:07,376 --> 00:19:07,960
AUDIENCE: Yes.
听众：是的。 

435
00:19:07,960 --> 00:19:08,835
PROFESSOR: So that's.
教授：就是这样。 

436
00:19:08,835 --> 00:19:10,539
AUDIENCE: Order and time.
听众：顺序和时间。 

437
00:19:10,539 --> 00:19:13,139
PROFESSOR: OK.
教授：好的。 

438
00:19:13,140 --> 00:19:15,298
How about list and counts?
列表和计数如何？ 

439
00:19:15,298 --> 00:19:24,021



440
00:19:24,021 --> 00:19:25,480
What's the running time for counts?
计数的运行时间是多少？ 

441
00:19:25,480 --> 00:19:28,531
How does count work?
计数如何工作？ 

442
00:19:28,531 --> 00:19:31,500
AUDIENCE: It's not just through all of the keys.
听众：不只是通过所有按键。 

443
00:19:31,500 --> 00:19:33,569
PROFESSOR: Count goes through everything and--
教授：数不胜数，而且- 

444
00:19:33,569 --> 00:19:34,649
AUDIENCE: It has to be order [INAUDIBLE].
听众：必须定购[听不清]。 

445
00:19:34,650 --> 00:19:35,680
PROFESSOR: Cool.
教授：太好了。 

446
00:19:35,680 --> 00:19:37,430
Count goes through all the keys, evaluates
计数遍历所有关键，评估

447
00:19:37,430 --> 00:19:40,460
the predicate that checks whether they're in the range
检查它们是否在范围内的谓词

448
00:19:40,460 --> 00:19:45,659
and then it adds up one to the sum for the right place.
然后将其加到正确位置的总和。 

449
00:19:45,859 --> 00:19:46,609
How about list?
清单怎么样？ 

450
00:19:46,609 --> 00:19:49,603



451
00:19:49,604 --> 00:19:51,919
AUDIENCE: Also [INAUDIBLE].
听众：也[听不清]。 

452
00:19:51,919 --> 00:19:53,710
PROFESSOR: OK, that's a list comprehension.
教授：好的，这是一个列表理解。 

453
00:19:53,710 --> 00:19:55,486
The code is a bit tricky, but it pretty much
该代码有点棘手，但几乎

454
00:19:55,686 --> 00:19:56,519
does the same thing.
做同样的事情。 

455
00:19:56,519 --> 00:19:59,099
It goes through the list and it puts all the keys
它遍历列表，并放入所有键

456
00:19:59,099 --> 00:20:01,213
that are in the interval in the list.
在列表中的时间间隔中。 

457
00:20:01,213 --> 00:20:04,849



458
00:20:04,849 --> 00:20:06,569
Now let's look at another version
现在让我们看看另一个版本

459
00:20:06,569 --> 00:20:09,720
on the next page of our range index that is slightly better.
在范围索引的下一页上会略好一些。 

460
00:20:09,720 --> 00:20:12,440



461
00:20:12,440 --> 00:20:14,149
What's the rapid variance for this?
快速变化是什么？ 

462
00:20:14,349 --> 00:20:18,553
How is it different from the first one?
与第一个有何不同？ 

463
00:20:18,554 --> 00:20:20,207
AUDIENCE: Sorted already.
观众：已经排序。 

464
00:20:20,207 --> 00:20:21,089
PROFESSOR: Sorted already.
教授：已经排序。 

465
00:20:21,289 --> 00:20:23,190
Very good.
很好。 

466
00:20:23,190 --> 00:20:25,778
The keys look exactly like this.
键看起来完全像这样。 

467
00:20:25,778 --> 00:20:26,278
Right?
对？ 

468
00:20:26,278 --> 00:20:28,900



469
00:20:28,900 --> 00:20:33,678
What is the running time for-- let's start with add or remove,
运行时间是多少？让我们从添加或删除开始， 

470
00:20:33,678 --> 00:20:35,998
what's the running time for add and remove?
添加和删​​除的运行时间是多少？ 

471
00:20:35,998 --> 00:20:37,659
AUDIENCE: N, order of N.
听众：N，N的阶数。 

472
00:20:37,859 --> 00:20:40,507
PROFESSOR: Why is it order of N?
教授：为什么是N阶？ 

473
00:20:40,508 --> 00:20:42,410
AUDIENCE: No, oder log N.
听众：否，输入对数N。 

474
00:20:42,410 --> 00:20:43,897
PROFESSOR: Why is it order log N.
教授：为什么要订购日志N。 

475
00:20:44,097 --> 00:20:46,912
AUDIENCE: Because if it's sorted you can look in the middle
观众：因为如果排序的话，您可以在中间查看

476
00:20:46,912 --> 00:20:49,930
and do a binary search.
并进行二进制搜索。 

477
00:20:49,930 --> 00:20:51,609
PROFESSOR: I can do a binary search in order
教授：我可以按顺序进行二进制搜索

478
00:20:51,809 --> 00:20:53,350
to find out where I insert something.
找出我在哪里插入东西。 

479
00:20:53,351 --> 00:20:54,240
Right?
对？ 

480
00:20:54,240 --> 00:20:56,990
But what if I want to insert zero in this?
但是，如果我想在其中插入零怎么办？ 

481
00:20:56,990 --> 00:21:00,726
AUDIENCE: Is it log N plus order N?
听众：是对数N加上顺序N？ 

482
00:21:00,726 --> 00:21:01,399
Does that make sense?
那有意义吗？ 

483
00:21:01,599 --> 00:21:05,359
Because you have to shift all of the [INAUDIBLE].
因为您必须转移所有[音频不清晰]。 

484
00:21:05,359 --> 00:21:06,299
PROFESSOR: Yeah.
教授：是的。 

485
00:21:06,299 --> 00:21:08,269
So worst case if I have to insert zero here,
所以最糟糕的情况是如果我必须在此处插入零， 

486
00:21:08,269 --> 00:21:11,089
I have to shift everything to the right to make room for it.
我必须将所有内容移至右侧以为其腾出空间。 

487
00:21:11,089 --> 00:21:11,589
Right?
对？ 

488
00:21:11,589 --> 00:21:13,809
So your first instinct was good.
所以你的第一个直觉是好的。 

489
00:21:13,809 --> 00:21:18,230
Order N. And questions?
订单N。还有问题吗？ 

490
00:21:18,230 --> 00:21:18,669
No more?
不再？ 

491
00:21:18,869 --> 00:21:19,841
Cool.
凉。 

492
00:21:19,842 --> 00:21:20,349
How about remove?
如何删除？ 

493
00:21:20,549 --> 00:21:23,710



494
00:21:23,710 --> 00:21:26,069
AUDIENCE: Order N.
观众：N号订单。 

495
00:21:26,069 --> 00:21:28,816
PROFESSOR: Order N. Why is it order N?
教授：N阶。为什么是N阶？ 

496
00:21:28,816 --> 00:21:32,529
AUDIENCE: You have to shift left everything to the right.
听众：您必须将所有内容向左移动。 

497
00:21:32,529 --> 00:21:35,410
PROFESSOR: Is this what you were going to say too?
教授：这也是您要说的吗？ 

498
00:21:35,410 --> 00:21:37,389
Same reason as before, if I want to remove 2
如果要删除2，原因与以前相同

499
00:21:37,589 --> 00:21:39,639
I still have to move everything to the left.
我仍然必须将所有内容移到左侧。 

500
00:21:39,640 --> 00:21:42,180
I can find the key that I want to remove very fast
我可以很快找到想要删除的密钥

501
00:21:42,180 --> 00:21:44,640
but then shifting things is still
但是转移事物仍然是

502
00:21:44,640 --> 00:21:50,400
order N. OK how about count?
订购N。好吧，算一下吗？ 

503
00:21:50,400 --> 00:21:53,498
How does count work?
计数如何工作？ 

504
00:21:53,498 --> 00:21:56,480
AUDIENCE: It's the same thing, isn't it?
听众：是同一回事，不是吗？ 

505
00:21:56,480 --> 00:21:58,970
AUDIENCE: Binary search so it's log n.
听众：二进制搜索，因此为n。 

506
00:21:58,970 --> 00:22:01,460
PROFESSOR: Binary search, so it's log n.
教授：二进制搜索，因此为n。 

507
00:22:01,460 --> 00:22:03,315
If I look at the count there it's--
如果我看一下伯爵，那是- 

508
00:22:03,315 --> 00:22:04,690
AUDIENCE: It's not though, that's
听众：不是，那是

509
00:22:04,690 --> 00:22:06,164
telling you how many keys between.
告诉您之间有多少键。 

510
00:22:06,164 --> 00:22:07,748
AUDIENCE: So it's a simple subtraction
听众：这是一个简单的减法

511
00:22:07,748 --> 00:22:09,490
to find the number of keys between.
查找之间的键数。 

512
00:22:09,490 --> 00:22:12,799



513
00:22:12,799 --> 00:22:14,549
PROFESSOR: Count calls binary search twice
教授：计数两次调用二进制搜索

514
00:22:14,549 --> 00:22:18,104
and then it does a arithmetic operation, yes.
然后执行算术运算，是的。 

515
00:22:18,104 --> 00:22:20,723
AUDIENCE: It would be log n because with the count where
观众：这是log n，因为计数在哪里

516
00:22:20,723 --> 00:22:22,973
the range is that's log n because you have to actually
范围是log n，因为您必须实际

517
00:22:22,973 --> 00:22:25,328
sift through it, but binary search you have two
通过它进行筛选，但是二进制搜索有两个

518
00:22:25,328 --> 00:22:27,369
other operations and then you just do a surprise.
其他操作，然后您会感到惊讶。 

519
00:22:27,369 --> 00:22:28,452
PROFESSOR: Yep, thank you.
教授：是的，谢谢。 

520
00:22:28,452 --> 00:22:30,329
Very good.
很好。 

521
00:22:30,329 --> 00:22:35,569
This is log n because of good old binary search.
由于良好的旧二进制搜索，因此这是log n。 

522
00:22:35,569 --> 00:22:36,929
How about lists?
列表呢？ 

523
00:22:36,930 --> 00:22:38,783
I think you were thinking ahead of lists.
我认为您在考虑清单之前。 

524
00:22:38,983 --> 00:22:39,649
How about lists?
列表呢？ 

525
00:22:39,650 --> 00:22:43,669



526
00:22:43,869 --> 00:22:46,369
AUDIENCE: You have to list every single thing that you read.
听众：您必须列出您阅读的每件事。 

527
00:22:46,369 --> 00:22:46,753
AUDIENCE: You've got the values you might potentially
听众：您已经拥有了潜在的价值

528
00:22:46,753 --> 00:22:48,289
have to [INAUDIBLE].
必须[听不清]。 

529
00:22:48,289 --> 00:22:52,909
AUDIENCE: Is it log n plus the length of the list.
听众：是log n加上列表的长度。 

530
00:22:52,910 --> 00:22:54,129
PROFESSOR: Yeah.
教授：是的。 

531
00:22:54,329 --> 00:22:56,460
I was going to do a nice long analysis
我打算做一个很好的长期分析

532
00:22:56,460 --> 00:22:58,539
and there's the answer.
答案就在那里。 

533
00:22:58,539 --> 00:23:03,849
Log n plus, suppose you return i values from the list, i.
登录n加号，假设您从列表i返回i值。 

534
00:23:03,849 --> 00:23:06,449
Why does this matter?
为什么这么重要？ 

535
00:23:06,450 --> 00:23:11,819
If I have a range query from minus infinity to plus infinity
如果我有从负无穷大到正无穷大的范围查询

536
00:23:11,819 --> 00:23:14,564
I have to create a new list, copy all these keys in
我必须创建一个新列表，将所有这些键复制到

537
00:23:14,565 --> 00:23:15,659
and return them.
并退还给他们。 

538
00:23:15,859 --> 00:23:17,159
That's order n.
那是命令n。 

539
00:23:17,160 --> 00:23:19,609
I can't just say it's log n.
我不能只说它是log n。 

540
00:23:19,809 --> 00:23:22,619
On the other hand, if the answers to my list queries
另一方面，如果我列表的答案查询

541
00:23:22,619 --> 00:23:25,319
are small, if they're one element,
很小，如果它们是一个要素， 

542
00:23:25,319 --> 00:23:29,470
then it's going to take log n time to do a binary search
那么将需要log n的时间来进行二进制搜索

543
00:23:29,470 --> 00:23:32,700
and then order one to produce the list if I
然后如果我订购一个来产生清单

544
00:23:32,700 --> 00:23:34,640
have a constant size list.
具有固定的尺寸列表。 

545
00:23:34,640 --> 00:23:36,970
If I just say order n I'm selling myself short.
如果我只说订单n，我就是卖空自己。 

546
00:23:36,970 --> 00:23:41,500
It's a lot better if I want to have short queries.
如果我想简短查询，那就更好了。 

547
00:23:41,500 --> 00:23:45,859



548
00:23:45,859 --> 00:23:48,394
What would be the best possible running time for lists?
列表的最佳运行时间是什么？ 

549
00:23:48,394 --> 00:23:56,460



550
00:23:56,460 --> 00:24:02,480
If I had a magic algorithm that works as fast as possible would
如果我有一个魔术算法可以尽快工作

551
00:24:02,480 --> 00:24:05,185
I be able to run in order one time?
我可以一次运行吗？ 

552
00:24:05,185 --> 00:24:07,309
AUDIENCE: No.
听众：不。 

553
00:24:07,309 --> 00:24:09,460
PROFESSOR: Super fast magic algorithm order one.
教授：超快速魔术算法排名第一。 

554
00:24:09,460 --> 00:24:11,644
No, why not?
不，为什么不呢？ 

555
00:24:11,644 --> 00:24:16,451
AUDIENCE: Because you still have to find l and h in your array.
听众：因为您仍然必须在数组中找到l和h。 

556
00:24:16,451 --> 00:24:18,160
PROFESSOR: Suppose I have some other data
教授：假设我还有其他数据

557
00:24:18,160 --> 00:24:21,324
structure, a super magical data structure.
结构，超级神奇的数据结构。 

558
00:24:21,324 --> 00:24:23,895
AUDIENCE: You can do searches in order one time,
听众：您可以一次搜索一次， 

559
00:24:23,895 --> 00:24:25,169
is what you're saying.
是你的意思

560
00:24:25,170 --> 00:24:27,504
AUDIENCE: You still have to have the contents of it
听众：您仍然必须拥有其中的内容

561
00:24:27,704 --> 00:24:29,663
for what you're listing.
您要列出的内容。 

562
00:24:29,663 --> 00:24:30,829
It would have to be order i.
它必须是命令i。 

563
00:24:30,829 --> 00:24:36,308



564
00:24:36,308 --> 00:24:38,224
PROFESSOR: Even if I have a super magical data
教授：即使我有超级神奇的数据

565
00:24:38,224 --> 00:24:40,949
structure where I can do everything that I want inside
我可以在其中做我想做的所有事情的结构

566
00:24:40,950 --> 00:24:43,909
in order one time then when I produce the output
然后一次当我产生输出时

567
00:24:44,109 --> 00:24:47,679
I still have to write the output.
我仍然必须写输出。 

568
00:24:47,680 --> 00:24:50,900
This thing is going to be omega i
这东西将会是欧米茄我

569
00:24:50,900 --> 00:24:53,849
and I can't possibly do any better than that.
我不可能做得更好。 

570
00:24:54,049 --> 00:24:56,389
No matter what running time you have
无论您有多长时间

571
00:24:56,390 --> 00:24:59,410
for list it has to include this i.
对于列表，它必须包括这个。 

572
00:24:59,410 --> 00:25:01,680
Unless you're running time is order i, in which case
除非您的跑步时间是订单i，在这种情况下

573
00:25:01,680 --> 00:25:04,698
i is smaller or equal to n.
 i小于或等于n。 

574
00:25:04,698 --> 00:25:08,019



575
00:25:08,019 --> 00:25:09,529
Does this look right to you?
这看起来合适吗？ 

576
00:25:09,529 --> 00:25:14,539



577
00:25:14,539 --> 00:25:16,119
There is a small bug in this code.
此代码中有一个小错误。 

578
00:25:16,119 --> 00:25:19,989
What if I do count of 4, 11.
如果我算4、11怎么办？ 

579
00:25:19,990 --> 00:25:22,210
Binary search returns, if there's a key
如果有密钥，则返回二进制搜索

580
00:25:22,210 --> 00:25:24,670
there it will give me the position of that key.
在那里，它将给我该钥匙的位置。 

581
00:25:24,670 --> 00:25:29,009
And if there's no key it will tell me
如果没有钥匙，它将告诉我

582
00:25:29,009 --> 00:25:31,869
where I should insert the key if the key doesn't
如果没有，我应该在哪里插入钥匙

583
00:25:31,869 --> 00:25:33,359
exist in theory.
在理论上存在。 

584
00:25:33,359 --> 00:25:39,519
So if this is my array then the positions are 0, 1, 2, 3, 4, 5.
因此，如果这是我的数组，则位置为0、1、2、3、4、5。 

585
00:25:39,519 --> 00:25:43,250



586
00:25:43,250 --> 00:25:47,549
Count of 4, 11 would do a binary search of 11 and see 4
计数4、11将对11进行二进制搜索并查看4 

587
00:25:47,549 --> 00:25:51,430
and then it will do a binary search for 4 and return 2.
然后它将对4进行二进制搜索并返回2。 

588
00:25:51,430 --> 00:25:51,930
Right?
对？ 

589
00:25:51,930 --> 00:25:53,506
Because if I want to insert 4 I would
因为如果我要插入4，我会

590
00:25:53,506 --> 00:25:56,450
have to put it here and then shift everything to the right.
必须将其放在此处，然后将所有内容移至右侧。 

591
00:25:56,450 --> 00:26:01,556
And 4 minus 2 is 2 therefore it's broken.
 4减2是2，所以它被破坏了。 

592
00:26:01,556 --> 00:26:03,410
AUDIENCE: Off by one block.
听众：减少一格。 

593
00:26:03,410 --> 00:26:05,379
PROFESSOR: Off by one block, right?
教授：分开一格，对吗？ 

594
00:26:05,579 --> 00:26:08,869
Well the interesting thing about it is that I had this code,
有趣的是，我有这段代码， 

595
00:26:08,869 --> 00:26:11,859
we actually shipped this code between Saturday morning
我们实际上在星期六早上之间发送了此代码

596
00:26:11,859 --> 00:26:14,619
and Sunday evening and it passed all the tests.
和周日晚上，它通过了所有测试。 

597
00:26:14,619 --> 00:26:16,439
As we go to the next section keep in mind
当我们转到下一部分时，请记住

598
00:26:16,440 --> 00:26:19,000
that this is broken but it would still
这是坏的，但它仍然会

599
00:26:19,000 --> 00:26:23,417
pass the test for our problem and we'll see why in a bit.
通过测试以解决我们的问题，稍后我们将了解原因。 

600
00:26:23,417 --> 00:26:26,099
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

601
00:26:26,099 --> 00:26:29,115
PROFESSOR: Count of 4, 11.
教授：数4、11。 

602
00:26:29,115 --> 00:26:30,824
AUDIENCE: So confined to them then
听众：当时仅限于他们

603
00:26:30,824 --> 00:26:34,970
it says that when you're down 5, right?
它说当你情绪低落的时候5，对吗？ 

604
00:26:34,970 --> 00:26:35,470
Four.
四。 

605
00:26:35,470 --> 00:26:36,135
PROFESSOR: Four.
教授：四。 

606
00:26:36,135 --> 00:26:40,690



607
00:26:40,690 --> 00:26:42,159
Binary search, if it finds the key
二进制搜索（如果找到密钥） 

608
00:26:42,359 --> 00:26:44,873
it returns the position of they key.
它返回键的位置。 

609
00:26:44,874 --> 00:26:46,707
AUDIENCE: [INAUDIBLE] 4 divided by x, and 4,
观众：[听不清] 4除以x，再加上4， 

610
00:26:46,707 --> 00:26:54,150
4 would it have had two?
 4它会有两个？ 

611
00:26:54,150 --> 00:26:56,643
PROFESSOR: Yeah, because it tells me where to insert it.
教授：是的，因为它告诉我在哪里插入。 

612
00:26:56,643 --> 00:26:58,535
AUDIENCE: OK, then it is.
听众：好的，是的。 

613
00:26:58,535 --> 00:27:02,118



614
00:27:02,318 --> 00:27:03,301
[INAUDIBLE]
 [听不清] 

615
00:27:03,301 --> 00:27:05,009
PROFESSOR: Well it says 4 minus 2, right?
教授：好吧，是4减2，对不对？ 

616
00:27:05,009 --> 00:27:07,920
The last line is high index minus low index?
最后一行是高指数减去低指数？ 

617
00:27:07,920 --> 00:27:10,119
AUDIENCE: Oh, well that's wrong. [INAUDIBLE].
听众：哦，那是错误的。 [听不清]。 

618
00:27:10,319 --> 00:27:11,399
AUDIENCE: So are you saying that it tells you where to insert it
观众：您是说它告诉您插入位置

619
00:27:11,400 --> 00:27:12,775
instead of actually inserting it.
而不是实际插入。 

620
00:27:12,775 --> 00:27:14,844



621
00:27:14,844 --> 00:27:15,509
PROFESSOR: Yeah.
教授：是的。 

622
00:27:15,509 --> 00:27:17,640
Binary search doesn't insert the element.
二进制搜索不会插入该元素。 

623
00:27:17,640 --> 00:27:19,490
It just tells me this is where you put it.
它只是告诉我这是您放置的位置。 

624
00:27:19,490 --> 00:27:24,450
And then if you look at add, add inserts it right there.
然后，如果您查看添加，添加将在此处插入。 

625
00:27:24,450 --> 00:27:25,957
That's why binary search is done that way
这就是为什么以这种方式进行二进制搜索

626
00:27:26,157 --> 00:27:27,238
so that that would work.
这样就可以了。 

627
00:27:27,239 --> 00:27:29,284
AUDIENCE: Can I ask a style question?
听众：我可以问一个风格问题吗？ 

628
00:27:29,284 --> 00:27:29,950
PROFESSOR: Sure.
教授：当然可以。 

629
00:27:29,950 --> 00:27:31,865
AUDIENCE: The underscore before binary search,
听众：二进制搜索前的下划线， 

630
00:27:31,865 --> 00:27:33,914
is that like saying private?
像是私下说吗？ 

631
00:27:33,914 --> 00:27:34,539
PROFESSOR: Yep.
教授：是的。 

632
00:27:34,539 --> 00:27:36,491
AUDIENCE: OK.
听众：好的。 

633
00:27:36,491 --> 00:27:39,230
AUDIENCE: Wait, what does private mean?
听众：等等，私人意味着什么？ 

634
00:27:39,230 --> 00:27:41,390
PROFESSOR: Private means that it's not
教授：私人意味着不是

635
00:27:41,390 --> 00:27:43,339
part of the public interface of the class.
该类的公共接口的一部分。 

636
00:27:43,539 --> 00:27:46,646



637
00:27:46,646 --> 00:27:48,730
If we're in a team and we're working on something,
如果我们在团队中并且正在做某事， 

638
00:27:48,730 --> 00:27:52,930
if I mark a method as private that means if you use my class,
如果我将方法标记为私有，则意味着如果您使用我的课程， 

639
00:27:52,930 --> 00:27:55,289
you're not supposed to call it because I might change
你不应该叫它，因为我可能会改变

640
00:27:55,289 --> 00:27:57,470
it's name, I might delete it completely,
它的名字，我可能会完全删除它， 

641
00:27:57,470 --> 00:27:59,230
I can do anything I want to it.
我可以做任何我想做的事。 

642
00:27:59,230 --> 00:28:02,589
But if the method is public, so add, remove, list, and count,
但是，如果该方法是公开的，那么添加，删除，列出和计数， 

643
00:28:02,589 --> 00:28:06,509
those are the API or the public interface of the class.
这些是该类的API或公共接口。 

644
00:28:06,509 --> 00:28:10,259
I guarantee that as long as the blit range index class exists
我保证只要blit range索引类存在

645
00:28:10,259 --> 00:28:12,650
it's going to have an add to remove a list
它会有一个添加来删除列表

646
00:28:12,650 --> 00:28:15,601
and the conduct will behave in exactly in that way.
行为将完全按照这种方式行事。 

647
00:28:15,801 --> 00:28:17,509
Once you have a class with public methods
一旦有了公共方法的类

648
00:28:17,509 --> 00:28:18,769
you're not supposed to change them
你不应该改变他们

649
00:28:18,769 --> 00:28:20,565
because other people might depend on them
因为其他人可能依赖他们

650
00:28:20,565 --> 00:28:22,756
and that would make other people unhappy.
那会让其他人不高兴。 

651
00:28:22,756 --> 00:28:31,000



652
00:28:31,000 --> 00:28:36,880
We said that this range index holds wires.
我们说这个范围指数包含电线。 

653
00:28:36,880 --> 00:28:37,380
Right?
对？ 

654
00:28:37,380 --> 00:28:43,136
So if you have these wires here they're not really numbers.
因此，如果您在这里使用这些导线，它们并不是真正的数字。 

655
00:28:43,336 --> 00:28:44,920
I know how to compare numbers, I don't
我知道如何比较数字，我不知道

656
00:28:44,920 --> 00:28:45,879
know how to compare wires.
知道如何比较电线。 

657
00:28:46,079 --> 00:28:51,039
That's not something that's readily comparable, right?
那不是可以立即比较的东西，对吗？ 

658
00:28:51,039 --> 00:28:58,519
We have to bridge the gap between numbers or things
我们必须弥合数字或事物之间的鸿沟

659
00:28:58,519 --> 00:29:00,829
that are comparable and wires.
可比的和电线。 

660
00:29:00,829 --> 00:29:04,460
The way we do that is the key wire pair class.
我们这样做的方法是关键线对类。 

661
00:29:04,460 --> 00:29:06,180
If you look at key wire pair class
如果看钥匙线对类

662
00:29:06,180 --> 00:29:10,769
it has-- I will write it as KWP here.
它有-我将在此处将其编写为KWP。 

663
00:29:10,769 --> 00:29:12,599
So it has a key and the wire.
因此，它具有钥匙和电线。 

664
00:29:12,599 --> 00:29:13,099
Right?
对？ 

665
00:29:13,099 --> 00:29:16,849
That's why it's a key wire pair.
这就是为什么它是关键线对。 

666
00:29:16,849 --> 00:29:19,579
And if you look at the comparison methods,
如果您看一下比较方法， 

667
00:29:19,579 --> 00:29:23,039
lines 11 through 26, but if you look at 11
第11至26行，但如果您看一下11 

668
00:29:23,039 --> 00:29:26,509
through 13 pretty much everything else is the same.
至13几乎其他所有内容都是相同的。 

669
00:29:26,509 --> 00:29:30,410
Then comparisons are done in a certain way.
然后以某种方式进行比较。 

670
00:29:30,410 --> 00:29:33,099
So the first criterion is the key.
因此，第一个标准是关键。 

671
00:29:33,299 --> 00:29:36,680
If you have two key wire pairs that have different keys,
如果您有两个具有不同按键的按键线对， 

672
00:29:36,680 --> 00:29:39,200
then the one with the bigger key wins.
那么拥有较大钥匙的那个人将获胜。 

673
00:29:39,200 --> 00:29:41,390
Now if they have the same key then
现在，如果它们具有相同的密钥，则

674
00:29:41,390 --> 00:29:43,619
this field called wire IDs is used to break ties.
此字段称为“电线ID”用于打破平局。 

675
00:29:43,819 --> 00:29:46,490



676
00:29:46,490 --> 00:29:51,669
So first key and then wire ID.
因此，首先要输入密钥，然后再输入导线ID。 

677
00:29:51,869 --> 00:29:54,899
What's the wire ID set to?
电线ID设置为什么？ 

678
00:29:54,900 --> 00:29:55,507
And where?
在哪

679
00:29:55,507 --> 00:29:58,130



680
00:29:58,130 --> 00:30:00,899
Where would you set a field in a nice class?
您会在哪里安排好班级的课程？ 

681
00:30:01,099 --> 00:30:02,551
AUDIENCE: The constructor.
听众：构造函数。 

682
00:30:02,551 --> 00:30:04,259
PROFESSOR: In the constructor, very good.
教授：在构造函数中，非常好。 

683
00:30:04,259 --> 00:30:05,589
Where is it set?
在哪里设置？ 

684
00:30:05,589 --> 00:30:08,339
Line number?
电话号码？ 

685
00:30:08,339 --> 00:30:09,319
AUDIENCE: 10.
听众：10。 

686
00:30:09,319 --> 00:30:10,110
PROFESSOR: Line 10.
教授：第10行。 

687
00:30:10,111 --> 00:30:13,250
So the wire ID uses the same object IDs that we had earlier.
因此，导线ID使用与之前相同的对象ID。 

688
00:30:13,250 --> 00:30:16,779
So each wire has a unique ID that's between zero
因此，每根导线都有一个介于零之间的唯一ID 

689
00:30:16,779 --> 00:30:17,849
and the number of wires.
和电线数量。 

690
00:30:17,849 --> 00:30:21,959



691
00:30:21,960 --> 00:30:25,329
This works when I insert my wires into the index.
当我将电线插入索引时，此方法有效。 

692
00:30:25,329 --> 00:30:28,490
What's the key for wires, by the way?
顺便问一下，电线的关键是什么？ 

693
00:30:28,490 --> 00:30:31,150
Where are wires inserted into the index in the algorithm
算法中将电线插入索引的位置

694
00:30:31,150 --> 00:30:32,900
that we have and what's the key?
我们拥有什么，关键是什么？ 

695
00:30:32,900 --> 00:30:35,769



696
00:30:35,769 --> 00:30:37,650
The algorithm that we gave you.
我们给您的算法。 

697
00:30:37,650 --> 00:30:38,450
Yes.
是。 

698
00:30:38,450 --> 00:30:39,674
AUDIENCE: The y-coordinates.
听众：y坐标。 

699
00:30:39,674 --> 00:30:40,299
PROFESSOR: The?
教授：那个？ 

700
00:30:40,299 --> 00:30:41,591
Which one, I couldn't hear you.
哪一个，我听不到您的声音。 

701
00:30:41,592 --> 00:30:42,515
AUDIENCE: The y-coordinate.
听众：y坐标。 

702
00:30:42,715 --> 00:30:43,989
PROFESSOR: The y-coordinate.
教授：y坐标。 

703
00:30:43,990 --> 00:30:45,115
Can you tell me which line?
你能告诉我哪条线吗？ 

704
00:30:45,115 --> 00:30:47,599



705
00:30:47,599 --> 00:30:48,829
The intuition is very good.
直觉非常好。 

706
00:30:48,829 --> 00:30:52,659
You want the wires to be keyed by the y-coordinate
您希望电线由y坐标锁定

707
00:30:52,660 --> 00:30:56,430
so that when you a range query between this guy and this guy
这样当您在这个人和这个人之间进行范围查询时

708
00:30:56,430 --> 00:30:59,484
you get these wires.
你得到这些电线。 

709
00:30:59,684 --> 00:31:00,559
That's the intuition.
这是直觉。 

710
00:31:00,559 --> 00:31:03,379
Now what's the code?
现在的代码是什么？ 

711
00:31:03,380 --> 00:31:04,130
AUDIENCE: Line 13.
观众：第13行。 

712
00:31:04,130 --> 00:31:07,480



713
00:31:07,480 --> 00:31:08,296
PROFESSOR: Line?
教授：行吗？ 

714
00:31:08,296 --> 00:31:09,269
I didn't hear you well.
我听不太清楚。 

715
00:31:09,269 --> 00:31:09,979
Line?
线？ 

716
00:31:09,979 --> 00:31:10,519
AUDIENCE: 13.
听众：13。 

717
00:31:10,519 --> 00:31:12,519
PROFESSOR: 13.
教授：13。 

718
00:31:12,519 --> 00:31:16,150
Wires are added to the index when an event of type
当类型为事件的导线被添加到索引

719
00:31:16,150 --> 00:31:17,390
add is processed.
添加已处理。 

720
00:31:17,390 --> 00:31:18,410
Right?
对？ 

721
00:31:18,410 --> 00:31:20,457
Line 12 says if event type is add
第12行说明是否添加了事件类型

722
00:31:20,457 --> 00:31:21,589
so that's probably what we want.
所以这可能就是我们想要的。 

723
00:31:21,789 --> 00:31:24,889
And line 13 adds it to the index and builds the key wire repair
第13行将其添加到索引中，并构建关键线修复

724
00:31:24,890 --> 00:31:28,119
with the key, the y-coordinate of the wire.
用键，导线的y坐标。 

725
00:31:28,319 --> 00:31:31,460



726
00:31:31,460 --> 00:31:35,269
Now let's look back at the keys and see
现在让我们回顾一下按键，看看

727
00:31:35,269 --> 00:31:40,809
that we have two special key wire repair classes.
我们有两个特殊的钥匙线维修课程。 

728
00:31:40,809 --> 00:31:44,279
Key wire pair l and key wire pair h.
钥匙线对l和钥匙线对h。 

729
00:31:44,279 --> 00:31:47,339
These don't want the wire.
这些不需要电线。 

730
00:31:47,339 --> 00:31:51,459
Why would I make a wire key pair that doesn't want the wire?
为什么要制作不需要电线的电线钥匙对？ 

731
00:31:51,460 --> 00:31:52,450
Why is that useful?
为什么这样有用？ 

732
00:31:52,450 --> 00:31:56,797



733
00:31:56,797 --> 00:32:02,750
AUDIENCE: You have the minimum and maximum wire at ease.
听众：您轻松拥有最小和最大的电线。 

734
00:32:02,750 --> 00:32:04,125
PROFESSOR: Very good observation.
教授：非常好的观察。 

735
00:32:04,125 --> 00:32:08,079
The wire ID for the low key pair looks
低键对的电线ID看起来

736
00:32:08,079 --> 00:32:11,730
like minus infinity and the one for the high key pair
如负无穷大和高键对之一

737
00:32:11,730 --> 00:32:14,019
look like plus infinity as long as I
看起来像加无限，只要我

738
00:32:14,019 --> 00:32:16,839
don't have more than a billion wires.
电线不超过十亿。 

739
00:32:16,839 --> 00:32:19,049
What do these things not have?
这些东西没有什么？ 

740
00:32:19,049 --> 00:32:22,859



741
00:32:22,859 --> 00:32:25,109
They don't have a wire.
他们没有电线。 

742
00:32:25,109 --> 00:32:27,240
So if you look at key wire pair l and h,
因此，如果您看一下关键线对l和h， 

743
00:32:27,240 --> 00:32:30,589
if you look at the initializers on lines two and eight,
如果您看第二和第八行的初始化程序， 

744
00:32:30,589 --> 00:32:33,819
they only take a key they don't take a wire.
他们只需要一把钥匙，而不需要电线。 

745
00:32:33,819 --> 00:32:37,259
This is useful in which situation?
这在哪种情况下有用？ 

746
00:32:37,259 --> 00:32:40,529
Where do I want to create an index key that's
我要在哪里创建索引键

747
00:32:40,529 --> 00:32:42,487
not associated with the real wire?
不与真正的电线关联？ 

748
00:32:42,487 --> 00:32:44,362
AUDIENCE: When you want to make the list when
听众：当你想做清单的时候

749
00:32:44,362 --> 00:32:46,339
you want to do a query.
您想查询。 

750
00:32:46,539 --> 00:32:48,450
PROFESSOR: When I do a query.
教授：我进行查询时。 

751
00:32:48,450 --> 00:32:49,960
Very good.
很好。 

752
00:32:49,960 --> 00:32:53,769
If I'm querying, if I have this vertical wire, which
如果要查询，是否有垂直线， 

753
00:32:53,769 --> 00:33:01,779
starts from minus 80 to plus 80 then I
从负80到正80开始，然后我

754
00:33:01,779 --> 00:33:04,529
would like to make a low key that corresponds to minus 80
想做一个对应于负80的低调

755
00:33:04,529 --> 00:33:07,299
and a high key that corresponds to plus 80,
和对应于加号80的高键， 

756
00:33:07,299 --> 00:33:11,799
but I don't have any wire with a horizontal coordinate of 80.
但我没有水平坐标为80的电线。 

757
00:33:11,799 --> 00:33:12,299
Right?
对？ 

758
00:33:12,299 --> 00:33:13,799
A hackish solution would be to make
一个棘手的解决方案是

759
00:33:13,799 --> 00:33:15,250
fake wires with those coordinates
假电线与那些坐标

760
00:33:15,250 --> 00:33:18,960
but if I make fake wires God knows where my system is going
但是如果我制造假电线，上帝就会知道我的系统要去哪里

761
00:33:18,960 --> 00:33:20,460
to break elsewhere.
在其他地方休息。 

762
00:33:20,460 --> 00:33:23,720
Instead the clean solution is to have these key wire pairs
相反，干净的解决方案是让这些关键线对

763
00:33:23,720 --> 00:33:25,880
so that when I insert wires I have a wire
这样，当我插入电线时，我就有一根电线

764
00:33:25,880 --> 00:33:28,200
and when I don't the wire is set to none.
而当我不这样做时，电线设置为无。 

765
00:33:28,200 --> 00:33:30,380
And the wire IDs are these special values,
电线ID是这些特殊值， 

766
00:33:30,380 --> 00:33:32,920
minus infinity and plus infinity.
负无穷大和正无穷大。 

767
00:33:32,920 --> 00:33:36,250
What's cool about setting the wire IDs to minus infinity
将电线ID设置为负无穷大是很酷的

768
00:33:36,250 --> 00:33:37,059
and plus infinity?
加上无限？ 

769
00:33:37,059 --> 00:33:42,039



770
00:33:42,039 --> 00:33:44,031
AUDIENCE: It's so that if you have a y of 80
听众：如果您年满80岁

771
00:33:44,031 --> 00:33:46,023
this y is at negative infinity so it's
这个y是负无穷大，所以

772
00:33:46,023 --> 00:33:53,923
going to take that y also because its y value is
也会取那个y，因为它的y值是

773
00:33:53,923 --> 00:33:56,349
[INAUDIBLE].
 [听不清]。 

774
00:33:56,349 --> 00:33:58,069
PROFESSOR: All right.
教授：好的。 

775
00:33:58,069 --> 00:33:58,569
Cool.
凉。 

776
00:33:58,569 --> 00:34:01,409
If I have a real key wire pair and it
如果我有真正的钥匙线对， 

777
00:34:01,410 --> 00:34:05,139
has a wire whose coordinate is 80
导线的坐标为80 

778
00:34:05,339 --> 00:34:12,090
this is going to be bigger than a key wire pair
这将比钥匙线对更大

779
00:34:12,090 --> 00:34:15,429
l with coordinate 80 and it's going
我的坐标是80 

780
00:34:15,429 --> 00:34:22,159
to be smaller than a key wire pair h with coordinate 80.
比具有坐标80的钥匙线对h小。 

781
00:34:22,159 --> 00:34:25,269
If you do a query using this and this
如果您使用此查询进行查询

782
00:34:25,269 --> 00:34:28,000
it's going to grab all the wires with coordinate 80.
它将抓住坐标为80的所有导线。 

783
00:34:28,000 --> 00:34:34,940



784
00:34:34,940 --> 00:34:36,860
Does this makes sense?
这有意义吗？ 

785
00:34:36,860 --> 00:34:38,840
So what's cool about this in terms of coding?
那么，就编码而言，有什么很棒的呢？ 

786
00:34:38,840 --> 00:34:45,010



787
00:34:45,010 --> 00:34:47,719
Do I have equal keys in my range index?
范围索引中是否有相同的键？ 

788
00:34:47,719 --> 00:34:51,800
Do I have to handle multiple equal keys?
我必须处理多个相等的键吗？ 

789
00:34:51,800 --> 00:34:56,264



790
00:34:56,264 --> 00:34:58,744
AUDIENCE: No because, actually in this case yes.
听众：否，因为在这种情况下实际上是。 

791
00:34:58,744 --> 00:35:02,519



792
00:35:02,719 --> 00:35:03,839
PROFESSOR: Do I?
教授：可以吗？ 

793
00:35:03,840 --> 00:35:06,090
AUDIENCE: Because if you have all the horizontal wires
听众：因为如果您有所有水平导线

794
00:35:06,090 --> 00:35:09,565
then it's possible that you have two
那么你可能有两个

795
00:35:09,764 --> 00:35:11,980
horizontal wires at the same--
同一水平线

796
00:35:11,980 --> 00:35:14,050
PROFESSOR: If I have two horizontal wires,
教授：如果我有两条水平线， 

797
00:35:14,050 --> 00:35:16,250
say this guy here and this other guy
在这里说这个人和另一个人

798
00:35:16,250 --> 00:35:19,750
here, this guy here, what's the key value pair for it?
在这里，这个人在这里，关键是什么？ 

799
00:35:19,750 --> 00:35:20,469
Key wire pair?
钥匙线对？ 

800
00:35:20,469 --> 00:35:25,639



801
00:35:25,639 --> 00:35:29,699
Let's say the coordinate is minus 95 and the wire ID is 2.
假设坐标为负95，导线ID为2。 

802
00:35:29,699 --> 00:35:34,599
The key wire pair is they key is minus 95
关键线对是他们的关键是负95 

803
00:35:34,599 --> 00:35:36,480
and the wire ID is 2, right?
电线ID为2，对吗？ 

804
00:35:36,480 --> 00:35:37,260
AUDIENCE: Yeah.
听众：是的。 

805
00:35:37,260 --> 00:35:38,726
PROFESSOR: And then for this other wire,
教授：然后，对于另一条线， 

806
00:35:38,925 --> 00:35:43,170
suppose the wire ID is 10, the coordinate is
假设导线ID为10，坐标为

807
00:35:43,170 --> 00:35:48,940
going to be minus 95 then the wire ID is going to be 10.
减为95，则导线ID为10。 

808
00:35:48,940 --> 00:35:51,579
So how are they going to compare?
那么他们将如何比较？ 

809
00:35:51,579 --> 00:35:53,695
AUDIENCE: Then that one is less than that one.
听众：那么那个小于那个。 

810
00:35:53,695 --> 00:35:54,319
PROFESSOR: Yup.
教授：是的。 

811
00:35:54,320 --> 00:35:58,010
So even though I have two wires with the same y-coordinates
因此，即使我有两条线的y坐标相同

812
00:35:58,010 --> 00:36:01,210
of the key as far as the algorithm is concerned
关于算法的密钥

813
00:36:01,409 --> 00:36:03,529
is the same, in the implementation
在实现上是一样的

814
00:36:03,530 --> 00:36:06,940
the keys are artificially different because I introduce
键是人为的，因为我介绍了

815
00:36:07,139 --> 00:36:10,629
an artificial ordering on the wires using that wire ID.
使用该电线ID对电线进行人工订购。 

816
00:36:10,630 --> 00:36:13,880



817
00:36:13,880 --> 00:36:17,340
In Which case would I have the same key inserted in my index
在那种情况下，我会在索引中插入相同的密钥

818
00:36:17,340 --> 00:36:17,839
twice?
两次？ 

819
00:36:17,840 --> 00:36:25,900



820
00:36:26,099 --> 00:36:26,769
Yes?
是？ 

821
00:36:26,769 --> 00:36:27,686
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

822
00:36:27,686 --> 00:36:31,690



823
00:36:31,889 --> 00:36:32,869
PROFESSOR: OK.
教授：好的。 

824
00:36:32,869 --> 00:36:36,289
If these two wires overlap, say this guy ends here
如果这两根线重叠，说这个家伙到此为止

825
00:36:36,289 --> 00:36:39,154
and this guy ends here, and if I put their keys into the index
这个家伙到此结束，如果我把他们的钥匙放入索引

826
00:36:39,155 --> 00:36:40,574
they're still different.
他们仍然不同。 

827
00:36:40,773 --> 00:36:42,772
AUDIENCE: Only if they're the same wire ID would
听众：只有它们的电线ID相同

828
00:36:42,773 --> 00:36:45,190
they have the same--
他们有相同的- 

829
00:36:45,389 --> 00:36:48,908
PROFESSOR: OK, and when do two wires have the same wire ID?
教授：好的，两条线何时具有相同的线号？ 

830
00:36:48,909 --> 00:36:50,867
AUDIENCE: If one of them was negative infinity.
听众：如果其中之一是负无穷大。 

831
00:36:50,867 --> 00:36:56,179



832
00:36:56,179 --> 00:36:57,769
PROFESSOR: Let's assume that the infinities
教授：让我们假设无穷

833
00:36:57,969 --> 00:37:00,649
were in the right way.
是正确的方式。 

834
00:37:00,650 --> 00:37:01,559
Yes?
是？ 

835
00:37:01,559 --> 00:37:02,059
No?
没有？ 

836
00:37:02,059 --> 00:37:04,610



837
00:37:04,610 --> 00:37:05,900
Wire IDs are unique.
电线ID是唯一的。 

838
00:37:05,900 --> 00:37:07,789
Every wire has it's own wire ID.
每条电线都有自己的电线ID。 

839
00:37:07,789 --> 00:37:10,219
Wires will never have the same wire ID.
电线永远不会具有相同的电线ID。 

840
00:37:10,219 --> 00:37:11,989
So the only case in which you have
所以唯一的情况是

841
00:37:11,989 --> 00:37:14,899
two equal keys in the index is if you insert the same wire
索引中的两个相等的键是如果您插入相同的导线

842
00:37:14,900 --> 00:37:16,960
twice.
两次。 

843
00:37:17,159 --> 00:37:20,449
Would you ever want to do that?
您是否愿意这样做？ 

844
00:37:20,449 --> 00:37:21,069
Probably not.
可能不是。 

845
00:37:21,070 --> 00:37:23,500
You're going to the same wire twice from the range query
您要通过范围查询两次访问同一条导线

846
00:37:23,699 --> 00:37:26,509
and that's not useful.
这没有用。 

847
00:37:26,510 --> 00:37:29,349
When implementing a data structure for the range index
为范围索引实现数据结构时

848
00:37:29,349 --> 00:37:30,690
we don't have to deal with equal keys
我们不必使用相同的键

849
00:37:30,889 --> 00:37:34,759
and that is nice because that's less thinking.
那很好，因为这没什么想法。 

850
00:37:34,760 --> 00:37:38,570
Now when we do a query, will the keys in the query
现在，当我们执行查询时，查询中的键

851
00:37:38,570 --> 00:37:41,577
be in the range index?
在范围索引内？ 

852
00:37:41,577 --> 00:37:42,460
AUDIENCE: Not necessarily.
听众：不一定。 

853
00:37:42,659 --> 00:37:48,734



854
00:37:48,735 --> 00:37:50,110
PROFESSOR: How would I do a query
教授：我将如何查询

855
00:37:50,110 --> 00:37:52,846
if I want to do a query from minus 80 to plus 80?
如果我要从负80到正80进行查询？ 

856
00:37:52,846 --> 00:37:54,887
AUDIENCE: You grab all the horizontal wires whose
观众：您抓住所有水平线， 

857
00:37:54,887 --> 00:37:58,539
y-coordinates are--
 y坐标为- 

858
00:37:58,539 --> 00:38:01,570
PROFESSOR: You're thinking in the range index.
教授：您正在考虑范围索引。 

859
00:38:01,570 --> 00:38:04,289
I'm thinking as the client of the range index.
我在想作为范围索引的客户。 

860
00:38:04,489 --> 00:38:06,059
So you have this range index class,
所以你有这个范围索引类， 

861
00:38:06,059 --> 00:38:09,960
how would you issue a query to the range index?
您将如何向范围索引发出查询？ 

862
00:38:09,960 --> 00:38:12,317
AUDIENCE: The list on this page.
听众：此页面上的列表。 

863
00:38:12,317 --> 00:38:12,900
PROFESSOR: OK.
教授：好的。 

864
00:38:12,900 --> 00:38:16,690
I would call the list method.
我将调用list方法。 

865
00:38:16,690 --> 00:38:20,000
And-- oh crap, I thought I was going
而且-糟糕，我以为我要去

866
00:38:20,000 --> 00:38:22,800
to avoid doing that today.
避免今天这样做。 

867
00:38:22,800 --> 00:38:24,519
l and h are keys, right?
 l和h是键，对不对？ 

868
00:38:24,519 --> 00:38:27,867
How do I construct my keys?
我该如何构造我的钥匙？ 

869
00:38:27,867 --> 00:38:31,110
AUDIENCE: Use key wire pair.
听众：使用钥匙线对。 

870
00:38:31,110 --> 00:38:34,250
PROFESSOR: Key wire pair left of 80--
教授：钥匙线对的左侧80-- 

871
00:38:34,250 --> 00:38:39,739
sorry low, and key wire pair high of 80.
对不起低，关键线对高80。 

872
00:38:39,739 --> 00:38:42,329
So then I'm going to get to these--
因此，我将介绍这些内容- 

873
00:38:42,329 --> 00:38:44,889
I don't have wires for this 80 coordinate.
我没有用于该80坐标的导线。 

874
00:38:44,889 --> 00:38:46,989
Sorry, minus 80 to 80 because that's
抱歉，要减去80到80，因为

875
00:38:46,989 --> 00:38:48,433
what the query looks like.
查询的样子。 

876
00:38:48,434 --> 00:38:49,900
I don't have wires for these coordinates
我没有这些坐标线

877
00:38:50,099 --> 00:38:53,023
so I'm going to use these special values
所以我将使用这些特殊值

878
00:38:53,023 --> 00:38:55,440
and this one is smaller than all the wires with coordinate
并且这比所有具有坐标的电线都小

879
00:38:55,440 --> 00:38:57,210
minus 80 and this one is bigger than all
减80，这个比所有的都大

880
00:38:57,210 --> 00:38:59,280
the wires with coordinate 80.
坐标为80的电线。 

881
00:38:59,280 --> 00:39:00,670
Will these keys ever be in the index?
这些键是否会出现在索引中？ 

882
00:39:00,869 --> 00:39:03,429



883
00:39:03,429 --> 00:39:05,129
Nope, we're only using them for updates.
不，我们仅将它们用于更新。 

884
00:39:05,130 --> 00:39:06,769
If you put this in the index then when
如果将其放在索引中，则何时

885
00:39:06,769 --> 00:39:09,666
you're getting it back and you try to get the wire associated
您将其取回，并尝试获取关联的电线

886
00:39:09,666 --> 00:39:11,039
with it you're going to get none,
有了它，你将一无所获， 

887
00:39:11,039 --> 00:39:14,340
your code is going to crash.
您的代码将崩溃。 

888
00:39:14,340 --> 00:39:17,210
If I have a query will the keys in the query ever
如果我有查询，查询中的键是否会

889
00:39:17,409 --> 00:39:18,319
being the index?
是索引？ 

890
00:39:18,320 --> 00:39:19,039
AUDIENCE: No.
听众：不。 

891
00:39:19,239 --> 00:39:20,329
PROFESSOR: No.
教授：不。 

892
00:39:20,329 --> 00:39:22,869
That means fewer border cases to consider
这意味着需要考虑的边境案件更少

893
00:39:22,869 --> 00:39:25,565
when implementing query.
在实现查询时。 

894
00:39:25,565 --> 00:39:27,440
All the keys in the range index are different
范围索引中的所有键都不相同

895
00:39:27,440 --> 00:39:31,025
and they keys in the query will never be in the range index.
并且它们在查询中的键将永远不在范围索引中。 

896
00:39:31,025 --> 00:39:32,420
AUDIENCE: When you do the count l
听众：当你做点数

897
00:39:32,420 --> 00:39:37,070
and h aren't in your range index you have to count that.
并且h不在您的范围索引中，您必须进行计数。 

898
00:39:37,070 --> 00:39:37,670
PROFESSOR: Yeah.
教授：是的。 

899
00:39:37,869 --> 00:39:42,609
In this case that's why the code didn't fail any test.
在这种情况下，这就是代码没有通过任何测试的原因。 

900
00:39:42,610 --> 00:39:45,599
Because I'm not using numbers I'm actually using this.
因为我没有使用数字，所以实际上是在使用数字。 

901
00:39:45,599 --> 00:39:48,339
So for the number analogy this is
因此，对于数字类比，这是

902
00:39:48,340 --> 00:39:53,920
equivalent to when I'm doing a count of 4,11 that
等于我做4,11时

903
00:39:54,119 --> 00:40:05,359
would get rewritten as count of 3, 99 and 11.01 and this works.
将被重写为3、99和11.01的计数，并且可以正常工作。 

904
00:40:05,360 --> 00:40:10,539
This is what these two values are doing.
这就是这两个值的作用。 

905
00:40:10,739 --> 00:40:14,819
Except if you try to do 0.99 and 0.01
除非您尝试执行0.99和0.01 

906
00:40:14,820 --> 00:40:19,106
that's brittle because you might actually have those keys.
这很脆弱，因为您实际上可能拥有这些键。 

907
00:40:19,106 --> 00:40:20,440
All right, does this make sense?
好吧，这有意义吗？ 

908
00:40:20,440 --> 00:40:23,800



909
00:40:23,800 --> 00:40:25,121
Any questions on this part?
对这部分有任何疑问吗？ 

910
00:40:25,320 --> 00:40:25,819
Nope?
不？ 

911
00:40:25,820 --> 00:40:27,590
Yes?
是？ 

912
00:40:27,590 --> 00:40:28,250
Yes.
是。 

913
00:40:28,250 --> 00:40:30,250
AUDIENCE: Is this thing in a count off situation
听众：这件事在盘算中吗

914
00:40:30,250 --> 00:40:31,635
where you have a gap in the wires
电线上有空隙

915
00:40:31,635 --> 00:40:34,096
but you still have a [INAUDIBLE] associated with it
但您仍然有一个[音频不清晰] 

916
00:40:34,096 --> 00:40:37,059
as it's going through it.
因为它正在经历。 

917
00:40:37,059 --> 00:40:38,976
PROFESSOR: Sorry, say that again.
教授：对不起，再说一遍。 

918
00:40:38,976 --> 00:40:40,567
AUDIENCE: So with that example right there.
听众：所以有了那个例子。 

919
00:40:40,766 --> 00:40:41,839
PROFESSOR: Yeah.
教授：是的。 

920
00:40:41,840 --> 00:40:42,960
PROFESSOR: Are you worried about the fact
教授：您是否担心这个事实

921
00:40:42,960 --> 00:40:45,610
that I'll have two equal keys or are you worried about the fact
我有两个相等的钥匙，或者您担心这个事实

922
00:40:45,610 --> 00:40:46,980
that these wires are crossing?
这些电线交叉吗？ 

923
00:40:46,980 --> 00:40:48,730
AUDIENCE: No that they're not overlapping.
听众：不，它们没有重叠。 

924
00:40:48,730 --> 00:40:51,929



925
00:40:51,929 --> 00:40:54,076
You have a wire and you have a wire coming down
你有电线，电线掉下来

926
00:40:54,076 --> 00:40:55,159
and you have another wire.
你还有另一根电线。 

927
00:40:55,159 --> 00:40:56,730
PROFESSOR: OK.
教授：好的。 

928
00:40:56,929 --> 00:40:58,669
This is not going to account for that.
这不会说明这一点。 

929
00:40:58,670 --> 00:41:01,101
You have to write the better sweep line algorithm.
您必须编写更好的扫掠线算法。 

930
00:41:01,101 --> 00:41:03,056
AUDIENCE: OK.
听众：好的。 

931
00:41:03,056 --> 00:41:04,429
PROFESSOR: What I'm talking about
教授：我在说什么

932
00:41:04,429 --> 00:41:08,009
now will make your range index faster.
现在将使您的范围索引更快。 

933
00:41:08,010 --> 00:41:11,827
Or it makes your range index simpler to implement.
或者，它使范围索引更易于实现。 

934
00:41:11,827 --> 00:41:12,168
AUDIENCE: OK.
听众：好的。 

935
00:41:12,367 --> 00:41:14,661



936
00:41:14,661 --> 00:41:16,619
PROFESSOR: This is magic behind the scenes that
教授：这是幕后的魔法， 

937
00:41:16,619 --> 00:41:18,355
makes your code smaller.
使您的代码更小。 

938
00:41:18,355 --> 00:41:20,730
You still have to implement the sweep line algorithm that
您仍然必须实现扫线算法

939
00:41:20,730 --> 00:41:23,190
makes sure that when you a range query
确保当您进行范围查询时

940
00:41:23,190 --> 00:41:27,420
it will either return less false positives or ideally no false
它将返回较少的误报或理想情况下不返回错误

941
00:41:27,420 --> 00:41:28,610
positives.
积极的。 

942
00:41:28,610 --> 00:41:30,670
And then the code will be faster.
然后代码会更快。 

943
00:41:30,869 --> 00:41:32,940
But then when you do that, you'll
但是当你这样做的时候，你会

944
00:41:32,940 --> 00:41:35,860
see that it's still slow because the range index
看到它仍然很慢，因为范围索引

945
00:41:35,860 --> 00:41:37,565
that we have here isn't optimal.
我们在这里并不是最佳选择。 

946
00:41:37,565 --> 00:41:39,690
Why isn't the range index here optimal, by the way?
顺便说一下，为什么这里的范围索引不是最佳的？ 

947
00:41:39,690 --> 00:41:43,510



948
00:41:43,510 --> 00:41:44,710
What can I improve about it?
我对此有何改进？ 

949
00:41:44,909 --> 00:41:47,789



950
00:41:47,789 --> 00:41:49,230
AUDIENCE: Add and remove.
听众：添加和删除。 

951
00:41:49,230 --> 00:41:49,849
PROFESSOR: Add and remove.
教授：添加和删除。 

952
00:41:49,849 --> 00:41:50,349
OK.
好。 

953
00:41:50,349 --> 00:41:55,289



954
00:41:55,289 --> 00:41:57,590
We're using the comparison model because it's
我们正在使用比较模型，因为它

955
00:41:57,590 --> 00:41:59,340
convenient to use the comparison model.
方便使用比较模型。 

956
00:41:59,340 --> 00:42:02,050
You have complex objects to implement those six methods
您有复杂的对象来实现这六个方法

957
00:42:02,050 --> 00:42:04,269
that you see in key wire pair and bam.
在钥匙线对和bam中看到的

958
00:42:04,269 --> 00:42:07,860
You can do comparisons, you can use any data structure
您可以进行比较，可以使用任何数据结构

959
00:42:07,860 --> 00:42:10,730
or algorithm that assume a comparison model.
或采用比较模型的算法。 

960
00:42:10,730 --> 00:42:13,329
What's the penalty of the comparison model?
比较模型的代价是什么？ 

961
00:42:13,329 --> 00:42:14,809
What's the problem with it?
有什么问题吗？ 

962
00:42:14,809 --> 00:42:15,311
Yes.
是。 

963
00:42:15,311 --> 00:42:17,184
AUDIENCE: It will be slower, or it will never
听众：会变慢，或者永远不会

964
00:42:17,184 --> 00:42:18,610
be faster than the [INAUDIBLE].
比[听不清]快。 

965
00:42:18,610 --> 00:42:19,300
PROFESSOR: Yup.
教授：是的。 

966
00:42:19,300 --> 00:42:24,764
If I want to do a sort that is n log n.
如果我要执行的排序是n log n。 

967
00:42:24,963 --> 00:42:27,750



968
00:42:27,750 --> 00:42:32,945
And if I want to do a search that is theta what?
如果我要搜索theta怎么办？ 

969
00:42:32,945 --> 00:42:33,862
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

970
00:42:33,862 --> 00:42:38,003



971
00:42:38,003 --> 00:42:40,670
PROFESSOR: Now what are the best bounds that they have for these
教授：现在，他们的最佳界限是什么

972
00:42:40,670 --> 00:42:42,657
if we can go outside the comparison model?
是否可以超越比较模型？ 

973
00:42:42,657 --> 00:42:44,789
Just to see if you guys are paying attention in lecture.
只是为了看看你们在讲课时是否注意。 

974
00:42:44,989 --> 00:42:48,639



975
00:42:48,639 --> 00:42:50,150
So best running time for sort if we
所以最好的运行时间来排序，如果我们

976
00:42:50,150 --> 00:42:51,775
don't have to use the comparison model.
不必使用比较模型。 

977
00:42:51,775 --> 00:42:52,539
AUDIENCE: n.
听众： 

978
00:42:52,739 --> 00:42:53,449
PROFESSOR: n.
教授： 

979
00:42:53,449 --> 00:42:54,619
OK.
好。 

980
00:42:54,619 --> 00:42:56,923
Best running time for search if we
如果我们能提供最佳搜索时间

981
00:42:56,923 --> 00:42:58,340
don't to use the comparison model.
不要使用比较模型。 

982
00:42:58,340 --> 00:43:00,880



983
00:43:00,880 --> 00:43:02,630
AUDIENCE: It's order one with [INAUDIBLE].
听众：用[听不清]订购一。 

984
00:43:02,630 --> 00:43:06,010
PROFESSOR: Order one, with hashing.
教授：一阶，带有哈希。 

985
00:43:06,010 --> 00:43:08,596
Can you do any better than that?
你能做得更好吗？ 

986
00:43:08,795 --> 00:43:10,549
AUDIENCE: You can code it as zero.
听众：您可以将其编码为零。 

987
00:43:10,550 --> 00:43:12,789
[LAUGHING]
 [笑] 

988
00:43:12,989 --> 00:43:14,829
PROFESSOR: Sort has to output an array
教授：排序必须输出一个数组

989
00:43:14,829 --> 00:43:18,799
of elements so it can be faster than order n.
元素，因此它可以比n阶更快。 

990
00:43:18,800 --> 00:43:21,690
Search has to output yes or no so it has to output
搜索必须输出是或否，因此必须输出

991
00:43:21,690 --> 00:43:23,940
something so it has to be order one.
东西，所以它必须是第一。 

992
00:43:23,940 --> 00:43:27,150
So this is as fast as it gets, we're
所以这是最快的，我们

993
00:43:27,150 --> 00:43:30,030
definitely not going to go faster than that.
绝对不会比这快。 

994
00:43:30,030 --> 00:43:33,360
We have this extra log n factor that we
我们有这个额外的log n因子

995
00:43:33,360 --> 00:43:37,099
pay if we use the comparison model if we don't collect
如果我们不使用比较模型，则付款

996
00:43:37,099 --> 00:43:39,179
more information about our keys.
有关我们钥匙的更多信息。 

997
00:43:39,179 --> 00:43:40,730
But in return we have the convenience
但是作为回报，我们有方便

998
00:43:40,730 --> 00:43:42,204
that all we have to do is establish
我们要做的就是建立

999
00:43:42,204 --> 00:43:43,045
an ordering relationship.
排序关系。 

1000
00:43:43,244 --> 00:43:48,019



1001
00:43:48,019 --> 00:43:50,139
Does it make sense?
是否有意义？ 

1002
00:43:50,139 --> 00:43:50,809
Cool.
凉。 

1003
00:43:50,809 --> 00:43:55,829
Let's try to talk about the list pseudocode, which
让我们尝试谈谈列表伪代码， 

1004
00:43:55,829 --> 00:43:58,340
you might have seen on the pset before.
您可能以前在pset上看到过。 

1005
00:43:58,340 --> 00:44:02,250
And that's on the last page here.
那是这里的最后一页。 

1006
00:44:02,250 --> 00:44:04,159
I can't give you a proof of why it works,
我无法证明它为何有效， 

1007
00:44:04,159 --> 00:44:07,500
but we can work together to figure out how it works
但是我们可以一起努力弄清楚它是如何工作的

1008
00:44:07,500 --> 00:44:10,170
and get an intuitive understanding.
并获得直观的理解。 

1009
00:44:10,170 --> 00:44:11,849
Let's get the keys here and let's
让我们在这里获取钥匙，然后

1010
00:44:11,849 --> 00:44:16,324
assume we're using a regular BSD for implementing a range index.
假设我们使用常规BSD来实现范围索引。 

1011
00:44:16,324 --> 00:44:22,980



1012
00:44:22,980 --> 00:44:25,085
I'm going to put my keys in a BSD.
我将把密钥放在BSD中。 

1013
00:44:25,085 --> 00:44:28,039



1014
00:44:28,239 --> 00:44:32,609
8, 3, 2, 5.
 8、3、2、5 

1015
00:44:32,610 --> 00:44:39,849



1016
00:44:39,849 --> 00:44:41,460
OK.
好。 

1017
00:44:41,460 --> 00:44:43,050
List those two things.
列出这两件事。 

1018
00:44:43,050 --> 00:44:46,670
LCA and no list.
 LCA，没有列表。 

1019
00:44:46,670 --> 00:44:47,170
Right.
对。 

1020
00:44:47,170 --> 00:44:48,329
What's LCA?
什么是LCA？ 

1021
00:44:48,329 --> 00:44:52,369
Suppose I want to list all the keys between one and six.
假设我要列出一到六个之间的所有键。 

1022
00:44:52,369 --> 00:44:57,859



1023
00:44:57,860 --> 00:45:00,400
First I'm going to call LCA and get some answer
首先，我将打电话给LCA并得到一些答案

1024
00:45:00,400 --> 00:45:02,170
and then I'm going to call node list.
然后我要调用节点列表。 

1025
00:45:02,170 --> 00:45:03,800
What's the answer for LCA?
 LCA的答案是什么？ 

1026
00:45:03,800 --> 00:45:06,789



1027
00:45:06,789 --> 00:45:07,929
OK.
好。 

1028
00:45:07,929 --> 00:45:08,929
AUDIENCE: Node at three.
听众：节点在三点。 

1029
00:45:08,929 --> 00:45:10,364
Key value three.
关键值三。 

1030
00:45:10,364 --> 00:45:13,039



1031
00:45:13,239 --> 00:45:14,349
PROFESSOR: What is this?
教授：这是什么？ 

1032
00:45:14,349 --> 00:45:15,650
What's LCA?
什么是LCA？ 

1033
00:45:15,650 --> 00:45:19,253
It's OK to give out an answer to a dumb question on the pset.
可以在pset上回答一个愚蠢的问题，这是可以的。 

1034
00:45:19,253 --> 00:45:22,089



1035
00:45:22,090 --> 00:45:24,400
So LCA is lowest common ancestor.
因此，LCA是最低的共同祖先。 

1036
00:45:24,599 --> 00:45:25,630
Very good.
很好。 

1037
00:45:25,630 --> 00:45:27,530
It's the lowest common ancestor of what?
它是什么的最低祖先？ 

1038
00:45:27,530 --> 00:45:31,420



1039
00:45:31,420 --> 00:45:39,329
AUDIENCE: Subtree of values that should be returned nodeless.
受众：应无节点返回的值的子树。 

1040
00:45:39,329 --> 00:45:41,559
PROFESSOR: So usually you have two nodes in a tree
教授：所以通常您在一棵树上有两个节点

1041
00:45:41,559 --> 00:45:43,559
and you want to return the LCA.
并且您想返回LCA。 

1042
00:45:43,559 --> 00:45:47,940
If I want to find out the LCA of 2 and 5, that is 3.
如果我想找出2和5的LCA，那就是3。 

1043
00:45:47,940 --> 00:45:51,780
If I want to find out the LCA of 2 and 13, that's 8.
如果我想找出2和13的LCA，那就是8。 

1044
00:45:51,780 --> 00:45:56,054
Now if the keys are not in the tree what does the LCA give me?
现在，如果密钥不在树中，那么LCA会给我什么？ 

1045
00:45:56,253 --> 00:45:57,712
AUDIENCE: It's where they would be.
听众：这就是他们要去的地方。 

1046
00:45:57,713 --> 00:45:59,929
PROFESSOR: It's where they would be if they were inserted.
教授：如果将它们插入，它将在这里。 

1047
00:46:00,128 --> 00:46:00,819
Right.
对。 

1048
00:46:00,820 --> 00:46:06,885
So 1 would be inserted here and 6 would be inserted here.
因此，将在此处插入1，在此处插入6。 

1049
00:46:06,885 --> 00:46:09,650



1050
00:46:09,650 --> 00:46:12,730
And then their LCA is indeed 3.
然后他们的LCA确实为3。 

1051
00:46:12,929 --> 00:46:13,980
What does that tell me?
这告诉我什么？ 

1052
00:46:13,980 --> 00:46:14,940
Why is that useful?
为什么这样有用？ 

1053
00:46:14,940 --> 00:46:17,820



1054
00:46:17,820 --> 00:46:20,019
AUDIENCE: You can cut off a bunch of the rest of the tree
听众：您可以砍掉一棵树的其余部分

1055
00:46:20,219 --> 00:46:24,059
so you don't have to look at that.
因此您不必去看。 

1056
00:46:24,059 --> 00:46:26,835
PROFESSOR: A bunch of, or the rest of the tree?
教授：是一棵树还是其余的树？ 

1057
00:46:26,835 --> 00:46:28,086
AUDIENCE: The rest of the tree.
听众：树的其余部分。 

1058
00:46:28,286 --> 00:46:29,619
PROFESSOR: The rest of the tree.
教授：这棵树的其余部分。 

1059
00:46:29,619 --> 00:46:33,619
So if 1 is here and 6 is here, then I
所以如果1在这里6在这里，那么我

1060
00:46:33,619 --> 00:46:41,730
know that all the keys-- sorry, so 3 is to the left of 8
知道所有键-对不起，所以8的左边是3 

1061
00:46:41,730 --> 00:46:48,809
so all the keys to the right of 8
所以所有键在8的右边

1062
00:46:48,809 --> 00:46:51,279
are going to be bigger than 6, for example.
例如，将大于6。 

1063
00:46:51,280 --> 00:46:51,780
Right.
对。 

1064
00:46:51,780 --> 00:46:54,500
Because 6 is here and it's under 8.
因为6在这里，而在8以下。 

1065
00:46:54,699 --> 00:46:56,049
I can throw this away.
我可以扔掉它。 

1066
00:46:56,050 --> 00:46:58,900
Now if this would be to the left of something else,
现在，如果这是其他内容的左侧， 

1067
00:46:58,900 --> 00:47:02,759
because 1 is here I know that all the keys
因为这里是1我知道所有的钥匙

1068
00:47:02,958 --> 00:47:05,250
to the left side of that thing would be smaller than 1.
那东西的左侧小于1。 

1069
00:47:05,250 --> 00:47:10,559



1070
00:47:10,559 --> 00:47:13,969
This subtree has to have all the keys between 1 and 6.
该子树必须具有1到6之间的所有键。 

1071
00:47:13,969 --> 00:47:16,919



1072
00:47:16,920 --> 00:47:17,914
Yes.
是。 

1073
00:47:17,914 --> 00:47:19,664
AUDIENCE: You don't have to move 8, right?
听众：您不必搬8，对吗？ 

1074
00:47:19,664 --> 00:47:21,264
Where would you move 8?
您将8移到哪里？ 

1075
00:47:21,264 --> 00:47:21,889
PROFESSOR: Yup.
教授：是的。 

1076
00:47:21,889 --> 00:47:25,400
So we only look at the subtree rooted at LCA.
因此，我们仅查看根于LCA的子树。 

1077
00:47:25,400 --> 00:47:28,210
LCA is passed as an argument to node list,
 LCA作为参数传递给节点列表， 

1078
00:47:28,409 --> 00:47:31,844
and node list seems to do sort of an-- this
和节点列表似乎做了一个

1079
00:47:31,844 --> 00:47:34,329
is a pre-ordered traversal.
是预定的遍历。 

1080
00:47:34,329 --> 00:47:36,590
You look at the key, you look at the left node,
看一下键，看一下左节点， 

1081
00:47:36,590 --> 00:47:39,150
at the left subtree, you look at the right subtree.
在左侧的子树中，您可以看到右侧的子树。 

1082
00:47:39,150 --> 00:47:41,590
Except there is some magic there and in some cases
除了那里有魔法，在某些情况下

1083
00:47:41,590 --> 00:47:44,798
it doesn't go and look.
它不会去看。 

1084
00:47:44,998 --> 00:47:47,539
Let's see what would a good case where it doesn't go and look
让我们来看看不去看看的好情况

1085
00:47:47,539 --> 00:47:47,739
like.
喜欢。 

1086
00:47:47,739 --> 00:47:48,779
Let's get the same tree.
让我们得到同一棵树。 

1087
00:47:48,780 --> 00:47:58,019



1088
00:47:58,019 --> 00:48:04,016
Suppose I want to do a list between 4 and 11--
假设我要在4到11之间列出一个清单， 

1089
00:48:04,016 --> 00:48:08,019
sorry between 4 and 10.
抱歉，在4点到10点之间。 

1090
00:48:08,019 --> 00:48:10,001
We'll the LCA of 4 and 10?
我们的LCA为4和10？ 

1091
00:48:10,001 --> 00:48:10,668
AUDIENCE: Eight.
听众：八。 

1092
00:48:10,668 --> 00:48:13,769



1093
00:48:13,969 --> 00:48:17,730
PROFESSOR: OK, so node list would have to start here.
教授：好的，因此节点列表必须从这里开始。 

1094
00:48:17,730 --> 00:48:21,420
Suppose I'm here and I go to 3.
假设我在这里，然后转到3。 

1095
00:48:21,420 --> 00:48:23,920
I know 3 is smaller than 4.
我知道3比4小。 

1096
00:48:23,920 --> 00:48:26,159
Do I want to go left?
我要走吗

1097
00:48:26,159 --> 00:48:29,170
Everything to the left of 3 is smaller than 4.
 3左侧的所有内容都小于4。 

1098
00:48:29,170 --> 00:48:32,510
This entire subtree can be pruned.
可以修剪整个子树。 

1099
00:48:32,510 --> 00:48:37,590
Now suppose I'm on the right side and I'm at the 11.
现在假设我在右侧，我在11号。 

1100
00:48:37,789 --> 00:48:42,550
11 is bigger than 10, do I want to go right?
 11大于10，我要走对吗？ 

1101
00:48:42,550 --> 00:48:44,420
So if 11 is bigger than 10 I never
所以如果11大于10我就不会

1102
00:48:44,619 --> 00:48:46,219
want to go right because everything
想去正确的地方，因为一切

1103
00:48:46,219 --> 00:48:48,029
to the right of that is bigger.
在右边更大。 

1104
00:48:48,030 --> 00:48:50,400



1105
00:48:50,599 --> 00:48:55,949
OK so this is how pruning works.
好的，这就是修剪的方式。 

1106
00:48:55,949 --> 00:48:58,009
Now if I'm at 3, can I stop?
现在如果我三点钟，我可以停下来吗？ 

1107
00:48:58,010 --> 00:49:00,860



1108
00:49:01,059 --> 00:49:05,116
I can't stop and exit completely because on the right side of 3
我无法完全停止并退出，因为在3的右侧

1109
00:49:05,117 --> 00:49:06,750
I might have keys that are bigger than three
我可能有大于三个的钥匙

1110
00:49:06,949 --> 00:49:08,659
and that are in my interval.
而这是我的间隔。 

1111
00:49:08,659 --> 00:49:11,059
And in this example that seems to be the case.
在这个例子中似乎是这样。 

1112
00:49:11,059 --> 00:49:15,289



1113
00:49:15,289 --> 00:49:22,150
Let's look very quickly at the intuitive way
让我们快速看一下直观的方式

1114
00:49:22,150 --> 00:49:26,019
of analyzing the running time for this.
分析运行时间。 

1115
00:49:26,219 --> 00:49:30,879
Suppose I have my LCA up here and suppose
假设我在这里有我的LCA，并假设

1116
00:49:30,880 --> 00:49:36,500
I go on a path from LCA to L and then-- let's
我走了一条从LCA到L的道路，然后- 

1117
00:49:36,500 --> 00:49:39,809
not worry about the right, about h. h is somewhere here,
不用担心权利，关于h。 h在这里

1118
00:49:39,809 --> 00:49:42,049
the case is going to be symmetric.
这种情况将是对称的。 

1119
00:49:42,050 --> 00:49:46,710
When I go down the path, after I go here would I ever want to go
当我沿着这条路走之后，我会想去

1120
00:49:46,909 --> 00:49:47,409
left?
剩下？ 

1121
00:49:47,409 --> 00:49:50,369



1122
00:49:50,369 --> 00:49:52,659
If this node is before a right turn then
如果此节点在右转弯之前

1123
00:49:52,659 --> 00:49:56,409
I know that l is going to be bigger than that node.
我知道我会比那个节点大。 

1124
00:49:56,409 --> 00:49:57,079
Right?
对？ 

1125
00:49:57,079 --> 00:50:00,190
So I'm never going to take a left turn.
所以我永远不会左转。 

1126
00:50:00,190 --> 00:50:03,420
This subtree be pruned, this subtree will be pruned,
该子树将被修剪，该子树将被修剪， 

1127
00:50:03,420 --> 00:50:05,750
this subtree will be pruned.
该子树将被修剪。 

1128
00:50:05,949 --> 00:50:08,324
Now if I go right here, what happens?
现在，如果我去这里，会发生什么？ 

1129
00:50:08,324 --> 00:50:11,377



1130
00:50:11,378 --> 00:50:12,164
AUDIENCE: It's node--
听众：这是节点

1131
00:50:12,364 --> 00:50:13,739
PROFESSOR: All the nodes here are
教授：这里的所有节点都是

1132
00:50:13,739 --> 00:50:16,369
going to be between l and LCA.
将在l和LCA之间。 

1133
00:50:16,369 --> 00:50:19,719
LCA is smaller or equal to h so all these nodes here
 LCA小于或等于h，所以这里所有这些节点

1134
00:50:19,719 --> 00:50:23,839
are guaranteed to be nodes that come out in my list.
保证是我列表中列出的节点。 

1135
00:50:23,840 --> 00:50:26,170
All right, why am I doing this?
好吧，为什么我要这样做？ 

1136
00:50:26,170 --> 00:50:29,090
I was saying before that I absolutely
我之前说过我绝对

1137
00:50:29,090 --> 00:50:31,820
have to have an order i because I
我必须下订单，因为我

1138
00:50:31,820 --> 00:50:34,670
have to produce the output list.
必须产生输出列表。 

1139
00:50:34,670 --> 00:50:38,599
If we look at the lines three and four,
如果我们看第三和第四行， 

1140
00:50:38,599 --> 00:50:42,429
line four outputs a key right?
第四行输出一个密钥对吗？ 

1141
00:50:42,429 --> 00:50:45,074
Line four is definitely order i and line three
第四行肯定是我和第三行

1142
00:50:45,074 --> 00:50:47,029
is an if condition so we know for sure
是一个if条件，因此我们可以肯定地知道

1143
00:50:47,030 --> 00:50:48,500
that line four is only going to execute
那第四行只会执行

1144
00:50:48,699 --> 00:50:52,719
four keys that are between l and h.
 l和h之间的四个键。 

1145
00:50:52,719 --> 00:50:56,079
This algorithm is going to visit some nodes in the tree.
该算法将访问树中的某些节点。 

1146
00:50:56,079 --> 00:51:01,860
For example, if I have a list of 4 and 10 it's going to visit 8,
例如，如果我有一个清单4和10，那么它将访问8， 

1147
00:51:01,860 --> 00:51:06,019
it's going to visit 3, 5, and 11.
它将访问3、5和11。 

1148
00:51:06,219 --> 00:51:09,019
And for some of the nodes that are visited
对于某些被访问的节点

1149
00:51:09,019 --> 00:51:11,489
it's going to output them.
将输出它们。 

1150
00:51:11,489 --> 00:51:16,289
Right this guy gets output and this guy gets output.
对，这个家伙得到输出，这个家伙得到输出。 

1151
00:51:16,289 --> 00:51:20,300
The nodes that are outputs are order i.
输出的节点是顺序i。 

1152
00:51:20,300 --> 00:51:22,407
Those are already covered in the i term.
第i项已经涵盖了这些内容。 

1153
00:51:22,407 --> 00:51:24,539
And in order to get the running time what I need to know
为了获得运行时间，我需要知道

1154
00:51:24,739 --> 00:51:27,089
is, how many nodes do I visit that are not
是，我要访问多少个不属于的节点

1155
00:51:27,090 --> 00:51:29,940
part of the output.
输出的一部分。 

1156
00:51:29,940 --> 00:51:32,250
Because if I end up visiting the entire tree then
因为如果我最终访问整棵树， 

1157
00:51:32,449 --> 00:51:33,719
that's order n plus i.
那是n加i的命令。 

1158
00:51:33,719 --> 00:51:35,159
So order n.
因此订购n。 

1159
00:51:35,159 --> 00:51:38,369
But if I only end up visiting a few nodes outside of the output
但是如果我最后只访问输出之外的几个节点

1160
00:51:38,369 --> 00:51:42,089
then that might be a lot better.
那可能会好得多。 

1161
00:51:42,090 --> 00:51:44,500
And here I'm trying to argue that I will only
在这里，我试图证明我只会

1162
00:51:44,699 --> 00:51:48,089
visit a few notes the outside the path.
在路径外访问一些笔记。 

1163
00:51:48,090 --> 00:51:51,010



1164
00:51:51,010 --> 00:51:52,690
In fact, for every node I'm going
实际上，我要去的每个节点

1165
00:51:52,690 --> 00:51:57,650
to visit at most of the node and the node at its left.
访问最多的节点及其左侧的节点。 

1166
00:51:57,650 --> 00:52:01,369
And then everything to the right of the path is between l and h,
然后，路径右边的所有东西都在l和h之间， 

1167
00:52:01,369 --> 00:52:04,460
so everything to the right is going to be output.
因此，将输出右侧的所有内容。 

1168
00:52:04,460 --> 00:52:08,000
Everything here is in order i and everything here
这里的一切都是为了我和这里的一切

1169
00:52:08,000 --> 00:52:10,130
is visited in that output.
在该输出中被访问。 

1170
00:52:10,130 --> 00:52:14,599
And potentially everything on the path as well.
以及路径上的所有潜在内容。 

1171
00:52:14,599 --> 00:52:19,355
So what's the height of a path in a binary search tree?
那么二叉搜索树中路径的高度是多少？ 

1172
00:52:19,356 --> 00:52:20,480
Regular binary search tree?
常规的二进制搜索树？ 

1173
00:52:20,480 --> 00:52:23,719



1174
00:52:23,719 --> 00:52:25,989
OK, and worst case.
好，最坏的情况。 

1175
00:52:25,989 --> 00:52:31,500
So worst case the height is order n.
因此，最坏的情况是高度为n阶。 

1176
00:52:31,500 --> 00:52:35,159
But we usually call it height because on average, at least,
但是我们通常称其为高度，因为至少

1177
00:52:35,159 --> 00:52:37,739
it's log n.
它是日志n。 

1178
00:52:37,739 --> 00:52:42,009
It's somewhere between n and log n.
它介于n和log n之间。 

1179
00:52:42,010 --> 00:52:45,250
What is the running time for lists in a binary search tree?
二叉搜索树中的列表的运行时间是多少？ 

1180
00:52:45,449 --> 00:52:48,409



1181
00:52:48,409 --> 00:52:50,398
If you buy this argument here.
如果您在这里购买此参数。 

1182
00:52:50,398 --> 00:52:51,440
What is the running time?
几点钟了？ 

1183
00:52:51,440 --> 00:52:55,023



1184
00:52:55,023 --> 00:52:55,940
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

1185
00:52:55,940 --> 00:52:58,519



1186
00:52:58,719 --> 00:53:01,439
PROFESSOR: You could say n plus i and you're perfectly correct.
教授：您可以说n加i，这是完全正确的。 

1187
00:53:01,440 --> 00:53:04,000
But we can make it a bit better.
但是我们可以做得更好。 

1188
00:53:04,199 --> 00:53:06,415
What's the height of this path?
这条路的高度是多少？ 

1189
00:53:06,416 --> 00:53:08,460
AUDIENCE: h.
听众：h。 

1190
00:53:08,659 --> 00:53:13,678
PROFESSOR: H. What's the running time?
教授：H.几点钟了？ 

1191
00:53:13,679 --> 00:53:14,269
AUDIENCE: h plus i.
听众：h加i。 

1192
00:53:14,469 --> 00:53:18,319



1193
00:53:18,320 --> 00:53:19,460
PROFESSOR: OK.
教授：好的。 

1194
00:53:19,460 --> 00:53:20,900
Cool.
凉。 

1195
00:53:20,900 --> 00:53:22,349
Does this make sense at all?
这有道理吗？ 

1196
00:53:22,349 --> 00:53:23,920
Is this too complicated?
这太复杂了吗？ 

1197
00:53:23,920 --> 00:53:25,920
AUDIENCE: That's the running time for what?
听众：那是什么时间？ 

1198
00:53:25,920 --> 00:53:27,635
PROFESSOR: This is the running time for lists.
教授：这是列表的运行时间。 

1199
00:53:27,835 --> 00:53:33,149



1200
00:53:33,150 --> 00:53:36,510
All right so, questions?
好吧，有问题吗？ 

1201
00:53:36,510 --> 00:53:38,574
Is this too far out?
这太远了吗？ 

1202
00:53:38,574 --> 00:53:39,664
Did I lose you guys completely?
我完全失去了你们吗？ 

1203
00:53:39,864 --> 00:53:43,709



1204
00:53:43,710 --> 00:53:45,099
Makes perfect sense.
很有道理。 

1205
00:53:45,099 --> 00:53:46,087
I like that.
我喜欢。 

1206
00:53:46,088 --> 00:53:48,327
AUDIENCE: It's oder n plus i because it
听众：更好，因为我

1207
00:53:48,527 --> 00:53:51,455
could have up to any nodes on it, right?
最多可以有任何节点，对吗？ 

1208
00:53:51,456 --> 00:53:52,067
PROFESSOR: Yup.
教授：是的。 

1209
00:53:52,266 --> 00:53:54,057
AUDIENCE: And then it's order i because you
听众：然后是命令我，因为你

1210
00:53:54,057 --> 00:53:56,335
have to add that [INAUDIBLE] of nodes anyway.
无论如何都必须添加该[INAUDIBLE]节点。 

1211
00:53:56,335 --> 00:53:58,416
It's order h.
订单h。 

1212
00:53:58,416 --> 00:54:01,000
PROFESSOR: I'm saying that it's a binary search tree of height
教授：我是说这是一棵高度很高的二叉搜索树

1213
00:54:01,000 --> 00:54:04,500
h and if h is better than n then I'm
 h，如果h优于n，那么我就是

1214
00:54:04,500 --> 00:54:06,230
going to do much better than n and that's
比n要好得多，那就是

1215
00:54:06,230 --> 00:54:07,496
why I'm putting that h there.
为什么我把那个放在那里。 

1216
00:54:07,496 --> 00:54:08,788
AUDIENCE: OK, that makes sense.
听众：好的，这很有道理。 

1217
00:54:08,788 --> 00:54:09,217
I think it's just a ltitle confusing at that part,
我认为那只是一个令人困惑的标题， 

1218
00:54:09,217 --> 00:54:12,612
but the [INAUDIBLE] makes sense because of course
但是[听不清]是有道理的，因为

1219
00:54:12,612 --> 00:54:14,195
that's a smaller node you're not going
那是一个较小的节点，您不会

1220
00:54:14,195 --> 00:54:15,612
to look at the left portion you're
看你的左边部分

1221
00:54:15,612 --> 00:54:18,090
going to look at the right because it's bigger
要看正确的，因为它更大

1222
00:54:18,090 --> 00:54:20,800
than your smaller [INAUDIBLE], right?
比你的小[听不清]，对吗？ 

1223
00:54:20,800 --> 00:54:24,190
So if you go to the right, that means that--
因此，如果您向右走，那意味着- 

1224
00:54:24,190 --> 00:54:27,210
PROFESSOR: Here I know that l is on the left, right?
教授：我在这里知道我在左边，对不对？ 

1225
00:54:27,210 --> 00:54:30,190
So l is smaller than this key.
所以l小于此键。 

1226
00:54:30,190 --> 00:54:35,630
Everything to the right of this key is between l and LCA.
该键右侧的所有内容都在l和LCA之间。 

1227
00:54:35,630 --> 00:54:38,170
LCA is smaller or equal to h.
 LCA小于或等于h。 

1228
00:54:38,170 --> 00:54:39,780
Everything here is between l and h,
这里的一切都在l和h之间， 

1229
00:54:39,780 --> 00:54:43,539
so all the nodes here are going to be output.
因此这里的所有节点都将被输出。 

1230
00:54:43,739 --> 00:54:46,195
All the nodes here count as i.
这里的所有节点都算作i。 

1231
00:54:46,195 --> 00:54:48,009
AUDIENCE: OK.
听众：好的。 

1232
00:54:48,010 --> 00:54:58,820
PROFESSOR: Now when I turn left here, this is smaller than l.
教授：现在，当我在这里左转时，它比l小。 

1233
00:54:58,820 --> 00:55:02,340
This is smaller than l because l is on the right.
它比l小，因为l在右边。 

1234
00:55:02,340 --> 00:55:05,030
This thing is going to be pruned.
这东西将被修剪。 

1235
00:55:05,030 --> 00:55:07,420
So I will visit the parent, this node, and that's it.
因此，我将访问父节点，该节点，仅此而已。 

1236
00:55:07,420 --> 00:55:09,349
I'm not going to look down.
我不会看不起。 

1237
00:55:09,349 --> 00:55:12,561
And this is how the nodes look like.
这就是节点的样子。 

1238
00:55:12,561 --> 00:55:14,269
Everything that's to the left of the path
路径左侧的所有内容

1239
00:55:14,269 --> 00:55:16,561
is not visited, everything that's to the right it open.
没有被访问，它右边的所有内容都会打开。 

1240
00:55:16,561 --> 00:55:29,170



1241
00:55:29,170 --> 00:55:29,789
Any more questions?
还有其他问题吗？ 

1242
00:55:29,989 --> 00:55:32,888



1243
00:55:32,889 --> 00:55:34,230
I hope you get it right on pset then.
希望您随后在pset上正确使用它。 

1244
00:55:34,429 --> 00:55:37,719



1245
00:55:37,719 --> 00:55:42,719
Thanks guys.
多谢你们。 

