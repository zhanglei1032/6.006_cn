1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,800
The following content is provided
提供以下内容

3
00:00:01,800 --> 00:00:04,030
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,030 --> 00:00:06,679
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,879 --> 00:00:10,740
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,740 --> 00:00:13,359
To make a donation, or view additional materials
捐款或查看其他材料

7
00:00:13,359 --> 00:00:17,256
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,256 --> 00:00:17,881
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,881 --> 00:00:21,184



10
00:00:21,184 --> 00:00:23,600
PROFESSOR: So you guys know the quiz is cumulative, right?
教授：所以你们知道测验是累积的，对吧？ 

11
00:00:23,600 --> 00:00:25,589
Everything all the way back from lecture one,
从第一讲开始的一切， 

12
00:00:25,589 --> 00:00:28,620
so I would look at all the lectures and all the P sets,
所以我会看所有的讲座和所有的P套， 

13
00:00:28,620 --> 00:00:31,390
and look at all the stuff that we taught you,
看看我们教给你的所有东西， 

14
00:00:31,390 --> 00:00:33,590
so data structures, algorithms, everything.
数据结构，算法，一切。 

15
00:00:33,590 --> 00:00:37,420
And at least be able to know, for every one of them,
至少对每个人都知道

16
00:00:37,420 --> 00:00:40,709
what's the name, what it does, and wants the running time.
名称是什么，它的作用是什么，需要运行时间。 

17
00:00:40,909 --> 00:00:43,359
Proofs and how it does it might be harder,
证明及其执行方式可能会更困难， 

18
00:00:43,359 --> 00:00:46,409
but these be able to call it as a black box
但这些人可以将其称为黑匣子

19
00:00:46,409 --> 00:00:49,799
and argue about the running times.
并讨论运行时间。 

20
00:00:49,799 --> 00:00:54,679
So I have a dp problem, and I have a non-dp problem.
所以我有一个dp问题，而我有一个非dp问题。 

21
00:00:54,679 --> 00:00:58,320
Which problem would you like me to start with?
您希望我从哪个问题开始？ 

22
00:00:58,320 --> 00:00:58,820
OK.
好。 

23
00:00:58,820 --> 00:01:03,909



24
00:01:03,909 --> 00:01:06,629
Do you guys know the saying, if a woodchucker would chuck wood,
你们知道吗，如果一个啄木鸟会夹木头， 

25
00:01:06,629 --> 00:01:09,619
how much wood would a woodchucker chuck?
啄木鸟会吸多少木头？ 

26
00:01:09,620 --> 00:01:12,640
Today we're going to chuck wood.
今天我们要去掉木头。 

27
00:01:12,640 --> 00:01:19,200
So you have a piece of wood that is l meters long,
所以你有一块木头，长一米

28
00:01:19,200 --> 00:01:20,390
and they have n markings.
他们有n个标记。 

29
00:01:20,390 --> 00:01:27,359



30
00:01:27,359 --> 00:01:32,560
So say the first mark is at 3 meters,
假设第一个标记位于3米处， 

31
00:01:32,560 --> 00:01:37,620
the second mark is at 5 meters, so on, so forth.
第二个标记位于5米处，依此类推。 

32
00:01:37,620 --> 00:01:44,400
And 3, and 4, all the way up to mn.
和3和4，一直到mn。 

33
00:01:44,400 --> 00:01:50,870
So we want to cut this piece of wood at all the markings.
因此，我们想在所有标记处切这块木头。 

34
00:01:50,870 --> 00:01:55,150
The thing is the woodchucker doesn't work for free.
事情是，土拨鼠不是免费工作的。 

35
00:01:55,150 --> 00:01:59,140
If you give it a piece of wood of length l,
如果给它一块长度为l的木头， 

36
00:01:59,140 --> 00:02:01,709
and you ask it to cut it at some marking,
然后您要求它在某些标记处进行切割， 

37
00:02:01,709 --> 00:02:07,929
you're going to get two pieces of wood, length l1 and l2.
您将得到两块长度分别为l1和l2的木头。 

38
00:02:07,930 --> 00:02:15,530
The price for this is l1 times l2.
价格是l1乘以l2。 

39
00:02:15,729 --> 00:02:18,199
So we like woodchucker, but woodchuckers would also
所以我们喜欢啄木鸟，但是啄木鸟也会

40
00:02:18,199 --> 00:02:19,019
like our wallets.
像我们的钱包。 

41
00:02:19,020 --> 00:02:22,590
So we want to cut this up by paying
所以我们想通过支付来削减

42
00:02:22,590 --> 00:02:23,819
the minimum amount of money.
最低金额。 

43
00:02:23,819 --> 00:02:27,819



44
00:02:27,819 --> 00:02:30,269
Rings a bell?
摇铃？ 

45
00:02:30,270 --> 00:02:32,340
So I'll let you guys think for a minute,
所以我让你们思考一分钟， 

46
00:02:32,539 --> 00:02:35,150
then I'll give you the running time, then we'll start talking.
然后我给您运行时间，然后我们开始讨论。 

47
00:02:35,150 --> 00:02:38,350



48
00:02:38,350 --> 00:02:40,349
So we usually give you running times on quizzes.
因此，我们通常会根据测验为您提供跑步时间。 

49
00:02:40,349 --> 00:02:42,935
The running time is why you should know all the problems
运行时间就是为什么您应该了解所有问题的原因

50
00:02:42,935 --> 00:02:45,560
in their matching running times, because the moment we give you
在他们匹配的运行时间中，因为我们给您的那一刻

51
00:02:45,560 --> 00:02:48,449
a running time you can automatically eliminate all
运行时间可以自动消除所有

52
00:02:48,449 --> 00:02:51,449
the things that don't match, and just focus on a few things.
不匹配的东西，只专注于一些东西。 

53
00:02:51,449 --> 00:02:57,869



54
00:02:57,870 --> 00:03:00,930
So you're going to have to cut it at all the markings,
因此，您将不得不在所有标记处将其切开， 

55
00:03:00,930 --> 00:03:05,120
eventually, but the order in which you cut is important.
最终，但是剪切顺序很重要。 

56
00:03:05,120 --> 00:03:08,550
So if I cut here first, then I'm going to pay three times l
所以，如果我先在这里砍，那我要付三倍

57
00:03:08,550 --> 00:03:11,310
minus 3, whereas if I cut in the middle first,
减3，而如果我先切入中间， 

58
00:03:11,310 --> 00:03:19,120
I'm going to pay whatever this is, and 3 times l minus m3.
我要付这是什么，三倍我减去m3。 

59
00:03:19,120 --> 00:03:23,780



60
00:03:23,780 --> 00:03:27,400
So we're trying to decide the order.
因此，我们正在尝试确定顺序。 

61
00:03:27,400 --> 00:03:29,219
Does this look like any familiar problem?
这看起来像任何熟悉的问题吗？ 

62
00:03:29,219 --> 00:03:33,300



63
00:03:33,300 --> 00:03:37,060
AUDIENCE: [INAUDIBLE] using dp, right?
听众：[听不清]使用dp，对吗？ 

64
00:03:37,259 --> 00:03:38,959
PROFESSOR: dp, that is good.
教授：dp，很好。 

65
00:03:38,960 --> 00:03:41,490
I did say that we're going to start with a dp problem,
我确实说过我们将从dp问题开始， 

66
00:03:41,490 --> 00:03:44,371
so this is dp.
所以这是dp。 

67
00:03:44,371 --> 00:03:45,120
It's a good start.
这是一个好的开始。 

68
00:03:45,120 --> 00:03:54,268



69
00:03:54,467 --> 00:03:55,451
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

70
00:03:55,451 --> 00:03:58,403
PROFESSOR: What?
教授：什么？ 

71
00:03:58,403 --> 00:03:59,879
Not exactly.
不完全是。 

72
00:03:59,879 --> 00:04:01,859
AUDIENCE: Yeah.
听众：是的。 

73
00:04:01,860 --> 00:04:05,680
PROFESSOR: So, it is not like any problems
教授：所以这不是任何问题

74
00:04:05,879 --> 00:04:07,275
on the recitations.
在朗诵中。 

75
00:04:07,275 --> 00:04:11,219



76
00:04:11,419 --> 00:04:13,899
So far recitations did prefixes and suffixes.
到目前为止，背诵都有前缀和后缀。 

77
00:04:13,900 --> 00:04:17,209
We're going to solve this using a running time of n
我们将使用n的运行时间来解决这个问题

78
00:04:17,209 --> 00:04:20,699
cubed, which is like the parenthesis problem.
立方，就像括号问题一样。 

79
00:04:20,699 --> 00:04:23,740



80
00:04:23,740 --> 00:04:26,430
It should be what you said, but I don't know how to spell that,
它应该是您所说的，但我不知道该如何拼写， 

81
00:04:26,430 --> 00:04:27,812
so we're going to go for this instead.
因此，我们将改为这样做。 

82
00:04:28,012 --> 00:04:31,719



83
00:04:31,720 --> 00:04:33,403
So running n cubed-- the moment I
因此，当我运行n立方时

84
00:04:33,603 --> 00:04:35,269
said this you guys should know that this
说这个，你们应该知道

85
00:04:35,269 --> 00:04:37,939
is the n cubed problem that we have in lecture notes.
是我们在讲义中的第n个立方问题。 

86
00:04:37,939 --> 00:04:40,711



87
00:04:40,711 --> 00:04:42,670
So make sure to have those on the cheat sheets,
因此，请确保备忘单上有这些内容， 

88
00:04:42,670 --> 00:04:46,009
and try to understand them, right?
并尝试了解它们，对吗？ 

89
00:04:46,009 --> 00:04:50,039
OK, so given that I've said this,
好的，鉴于我已经说过了， 

90
00:04:50,040 --> 00:04:53,819
you should know the solution now.
您现在应该知道解决方案。 

91
00:04:54,019 --> 00:04:56,329
To make sure everyone is with me,
为了确保每个人都和我在一起， 

92
00:04:56,329 --> 00:04:58,279
we're going to go through the solution, whole.
整个过程，我们将通过解决方案。 

93
00:04:58,279 --> 00:04:59,279
So what is a subproblem?
那么什么是子问题？ 

94
00:04:59,279 --> 00:05:03,902



95
00:05:03,903 --> 00:05:06,300
AUDIENCE:Smaller piece of wood.
听众：一块木头很小。 

96
00:05:06,300 --> 00:05:07,737
PROFESSOR: OK.
教授：好的。 

97
00:05:07,737 --> 00:05:09,959
AUDIENCE: Like how to cut it up.
听众：喜欢怎么剪。 

98
00:05:09,959 --> 00:05:10,680
PROFESSOR: OK.
教授：好的。 

99
00:05:10,680 --> 00:05:12,699
So this is how you think of it informally.
因此，这就是您非正式地考虑的方式。 

100
00:05:12,699 --> 00:05:14,930
When you write it up, I want to see this.
当您写下来时，我想看看。 

101
00:05:14,930 --> 00:05:21,449
I want to see dp of something means something.
我想看到dp代表某种意义。 

102
00:05:21,649 --> 00:05:23,239
So how you fill out your dp table.
那么如何填写dp表。 

103
00:05:23,240 --> 00:05:25,920



104
00:05:25,920 --> 00:05:30,040
It's really useful to write this up on your exam
在考试中写下来真的很有用

105
00:05:30,040 --> 00:05:32,939
before, because one, this will help you write the recursion
以前，因为这可以帮助您编写递归

106
00:05:33,139 --> 00:05:36,240
correctly, and two, if the grader sees this
正确，还有两个，如果平地机看到了

107
00:05:36,240 --> 00:05:38,410
they might skim over the recursion completely.
他们可能会完全浏览递归。 

108
00:05:38,410 --> 00:05:40,040
And then you might have bugs there.
然后，您可能在那里遇到了错误。 

109
00:05:40,040 --> 00:05:40,949
We might not see them.
我们可能看不到它们。 

110
00:05:41,149 --> 00:05:43,250
Good for you.
对你有好处。 

111
00:05:43,250 --> 00:05:45,629
So this says how you're going to fill out the table.
因此，这说明您将如何填写表格。 

112
00:05:45,629 --> 00:05:48,810
Right? dp of something equals something.
对？某物的dp等于某物。 

113
00:05:48,810 --> 00:05:50,149
What's in a dp table?
 dp表中有什么？ 

114
00:05:50,149 --> 00:05:51,459
Numbers.
数字。 

115
00:05:51,459 --> 00:05:53,139
It's never how to do something.
从来没有做某事。 

116
00:05:53,139 --> 00:05:55,569
It's always the numbers, so it's always
总是数字，所以总是

117
00:05:55,569 --> 00:05:58,680
the maximum profit, or the minimum cost,
最大利润或最小成本， 

118
00:05:58,680 --> 00:06:01,290
or the shortest distance, or the longest something.
或最短的距离，或最长的东西。 

119
00:06:01,290 --> 00:06:03,050
So it's always a number.
所以它总是一个数字。 

120
00:06:03,050 --> 00:06:04,759
So what we do here?
那么我们在这里做什么？ 

121
00:06:04,759 --> 00:06:10,036
AUDIENCE: Start and dp, start location to the end location is
听众：开始和dp，开始位置到结束位置为

122
00:06:10,036 --> 00:06:12,620
PROFESSOR: OK, so we're going to get the mean distance, right?
教授：好的，我们将获得平均距离，对吗？ 

123
00:06:12,620 --> 00:06:16,389
We usually do i j k and whatever else it takes.
我们通常会进行ijk以及其他任何操作。 

124
00:06:16,389 --> 00:06:18,620
So start to end is?
那么开始到底是什么？ 

125
00:06:18,620 --> 00:06:21,829
AUDIENCE: The minimum cost of cutting that up.
听众：削减成本的最低成本。 

126
00:06:22,029 --> 00:06:35,019
PROFESSOR: Minimum cost of cutting up the wood board
教授：切木板的最低成本

127
00:06:35,019 --> 00:06:40,459
from marking i, all the way to marking j.
从标记i一直到标记j。 

128
00:06:40,459 --> 00:06:43,250



129
00:06:43,250 --> 00:06:46,560
There's a tiny problem here, that the initial-- there's
这里有一个小问题，最初的- 

130
00:06:46,560 --> 00:06:52,990
no problem for this big piece of wood, right?
这块大木头没问题吧？ 

131
00:06:52,990 --> 00:06:56,379
If I can only consider the board from i to j,
如果我只能考虑从i到j的董事会， 

132
00:06:56,379 --> 00:07:00,980
so if I can only consider the board from marking 1
因此，如果我只能考虑标记1 

133
00:07:00,980 --> 00:07:03,379
to marking n, then I get to this.
标记n，然后我就知道了

134
00:07:03,579 --> 00:07:05,719
So this part and this part get left out.
所以这部分和这部分被忽略了。 

135
00:07:05,720 --> 00:07:11,110



136
00:07:11,110 --> 00:07:13,069
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

137
00:07:13,069 --> 00:07:14,420
PROFESSOR: Exactly.
教授：是的。 

138
00:07:14,420 --> 00:07:15,699
We add fake markings.
我们添加了假标记。 

139
00:07:15,699 --> 00:07:21,170
Then 0 is 0, and mn plus 1 equals l.
那么0是0，并且mn加1等于l。 

140
00:07:21,170 --> 00:07:21,670
Very good.
很好。 

141
00:07:21,670 --> 00:07:23,569
AUDIENCE: [INAUDIBLE] equally spaced?
听众：[听不清]等距？ 

142
00:07:23,769 --> 00:07:24,449
PROFESSOR: No.
教授：不。 

143
00:07:24,449 --> 00:07:27,099
So these are numbers.
这些是数字。 

144
00:07:27,100 --> 00:07:30,250
If they were evenly spaced, I think there's an algorithm.
如果它们均匀分布，我认为有一种算法。 

145
00:07:30,250 --> 00:07:33,180
You might come up with a math and say, you always
您可能想出一个数学说，您总是

146
00:07:33,180 --> 00:07:33,829
cut it up like this.
切成这样

147
00:07:34,029 --> 00:07:40,379



148
00:07:40,379 --> 00:07:42,969
So while we solve this, you guys have candy, right?
所以当我们解决这个问题时，你们有糖果，对吗？ 

149
00:07:42,970 --> 00:07:46,189
You should eat the candy and be energetic and everything.
您应该吃糖果，并且精力充沛。 

150
00:07:46,389 --> 00:07:49,459



151
00:07:49,459 --> 00:07:51,979
So min cost of cutting up the board
所以最小的成本削减董事会

152
00:07:51,980 --> 00:07:53,360
from marking i to marking j.
从标记i到标记j。 

153
00:07:53,360 --> 00:07:54,079
I like this.
我喜欢这个。 

154
00:07:54,279 --> 00:07:55,965
Have this on your exam if possible,
如有可能，请在考试中进行检查， 

155
00:07:55,966 --> 00:07:57,389
because this will make our life easier,
因为这会使我们的生活更轻松， 

156
00:07:57,589 --> 00:07:59,213
and it's going to make your life easier
这将使您的生活更轻松

157
00:07:59,213 --> 00:08:00,719
when you get to the next step, which
当您进行下一步时， 

158
00:08:00,720 --> 00:08:03,389
is how do we compute dp of i j?
如何计算ij的dp？ 

159
00:08:03,589 --> 00:08:06,489



160
00:08:06,490 --> 00:08:11,930
So suppose I'm looking at the subboard from m1 to m4
因此，假设我正在查看从m1到m4的子板

161
00:08:11,930 --> 00:08:16,449
so I'm looking at only this.
所以我只看这个。 

162
00:08:16,649 --> 00:08:20,819
How do I compute the best way to cut the board from m1 to m4?
如何计算将木板从m1切成m4的最佳方法？ 

163
00:08:20,819 --> 00:08:33,147



164
00:08:33,147 --> 00:08:33,980
What are my options?
我有什么选择？ 

165
00:08:33,980 --> 00:08:36,697



166
00:08:36,697 --> 00:08:38,509
AUDIENCE: The locations you can cut it.
听众：您可以剪切的位置。 

167
00:08:38,509 --> 00:08:39,629
PROFESSOR: Exactly.
教授：是的。 

168
00:08:39,629 --> 00:08:42,110
So in order to cut this up, I can either
所以为了削减这个，我可以

169
00:08:42,110 --> 00:08:45,230
make a first cut at m2.
在m2处进行第一次切割。 

170
00:08:45,230 --> 00:08:48,220
So say I make my first cut here, and then I
所以说我先在这里切，然后我

171
00:08:48,220 --> 00:08:52,879
recursively cut this, and cut this.
递归剪切，然后剪切。 

172
00:08:52,879 --> 00:08:59,750
Or the other alternative is take the same guy-- m1,
或者另一个选择是请同一个人-m1， 

173
00:08:59,750 --> 00:09:07,110
m2, m3, m4-- cut it at m3, and then recursively cut this,
 m2，m3，m4--将其剪切为m3，然后递归剪切， 

174
00:09:07,110 --> 00:09:10,730
and recursively cut this.
并递归地削减它。 

175
00:09:10,730 --> 00:09:15,789
So I'm iterating over all the markings inside the board.
因此，我要遍历板上的所有标记。 

176
00:09:15,789 --> 00:09:17,504
Now suppose I'm cutting it-- yes?
现在假设我要剪掉了-是吗？ 

177
00:09:17,504 --> 00:09:21,176
AUDIENCE: [INAUDIBLE] cutting both, or actually, never mind.
听众：[听不清]两者兼而有之，或者没关系。 

178
00:09:21,176 --> 00:09:22,349
PROFESSOR: Yeah, when I recursed,
教授：是的，当我递归时， 

179
00:09:22,549 --> 00:09:24,469
that takes care of it.
照顾它。 

180
00:09:24,470 --> 00:09:27,899
So suppose I'm looking at m1 through m4,
所以假设我正在看m1到m4， 

181
00:09:27,899 --> 00:09:35,470
and I'm cutting it at m2.
我要把它削减到m2 

182
00:09:35,470 --> 00:09:38,220
What's the total cost?
总费用是多少？ 

183
00:09:38,220 --> 00:09:41,469
So what's the best way to cut, given that then I
那么，鉴于这种情况，最好的切割方法是什么

184
00:09:41,669 --> 00:09:43,562
know I'm going to cut there?
知道我要去那里切吗？ 

185
00:09:43,562 --> 00:09:46,470
AUDIENCE: The sum of the dp's.
听众：dp之和。 

186
00:09:46,470 --> 00:09:56,580
PROFESSOR: OK, so it's the best way to cut m1 through m2,
教授：好的，所以这是将m1切成m2的最好方法， 

187
00:09:56,580 --> 00:10:06,849
plus best way to cut m2 through m4,
加上将m2减少到m4的最佳方法， 

188
00:10:07,049 --> 00:10:10,519
plus the price I'm paying for this cut, right?
再加上我要为此减价支付的价格，对吗？ 

189
00:10:10,519 --> 00:10:11,909
Not just the sum of the dp's.
不只是dp的总和。 

190
00:10:11,909 --> 00:10:12,889
One more term.
还有一个学期。 

191
00:10:12,889 --> 00:10:16,105
What's this term?
这是什么意思

192
00:10:16,105 --> 00:10:17,359
AUDIENCE: 4 minus 1?
听众：4减1？ 

193
00:10:17,559 --> 00:10:20,633
Or the location of 4 minus the location of 1.
或4的位置减去1的位置。 

194
00:10:20,634 --> 00:10:23,389



195
00:10:23,389 --> 00:10:27,299
PROFESSOR: So, not quite, almost.
教授：所以，不完全是。 

196
00:10:27,299 --> 00:10:31,339
So if I'm cutting a board into two pieces,
因此，如果我将一块木板切成两块， 

197
00:10:31,340 --> 00:10:33,840
the cost is the product of the length of the two pieces.
成本是两个零件长度的乘积。 

198
00:10:33,840 --> 00:10:38,710



199
00:10:38,710 --> 00:10:45,849
m2 minus m1, times yes.
 m2减去m1，乘以是。 

200
00:10:46,049 --> 00:10:48,579
OK, why did I bother doing this?
好，我为什么要这么做呢？ 

201
00:10:48,580 --> 00:10:51,209
Some people think better with concrete numbers.
有些人认为具体数字会更好。 

202
00:10:51,409 --> 00:10:56,049
If that's the case, then give yourself an example.
如果是这样，请给自己一个例子。 

203
00:10:56,049 --> 00:10:59,309
Write some numbers on your sheet of paper,
在纸上写一些数字， 

204
00:10:59,309 --> 00:11:01,679
then see what letters match to what
然后看什么字母和什么字母匹配

205
00:11:01,679 --> 00:11:03,939
numbers, and copy it up using letters.
数字，然后使用字母复制。 

206
00:11:03,940 --> 00:11:07,220
And there you go, you've solved the problem.
至此，您已经解决了问题。 

207
00:11:07,220 --> 00:11:09,479
So where are i and j here?
那么我和j在哪里？ 

208
00:11:09,679 --> 00:11:12,629



209
00:11:12,629 --> 00:11:14,200
AUDIENCE: i would be 1.
听众：我会是1。 

210
00:11:14,200 --> 00:11:16,237
PROFESSOR: OK, so this is i.
教授：好的，这就是我。 

211
00:11:16,437 --> 00:11:19,129
AUDIENCE: That's j.
听众：是j。 

212
00:11:19,129 --> 00:11:24,399
PROFESSOR: Cool, so let's try to write it up, now.
教授：太好了，现在让我们尝试编写它。 

213
00:11:24,399 --> 00:11:31,039
So in order to cut the board from i to j, what am I doing?
因此，为了将董事会从i削减到j，我在做什么？ 

214
00:11:31,039 --> 00:11:33,009
So what am I computing?
那我在计算什么呢？ 

215
00:11:33,009 --> 00:11:35,669
Usually the first word in your subproblem definition
通常，子问题定义中的第一个单词

216
00:11:35,669 --> 00:11:38,079
is the function that you're going to use.
是您将要使用的功能。 

217
00:11:38,080 --> 00:11:43,008
So it's minimum, and I'm going iterate over something.
因此，这是最低要求，我将迭代某些内容。 

218
00:11:43,008 --> 00:11:50,769
AUDIENCE: dp of i to-- it has to be all of j.
听众：我的dp必须是j的全部。 

219
00:11:50,769 --> 00:11:52,259
dp of i, j, and you're looking to--
 i，j的dp，您正在寻找- 

220
00:11:52,259 --> 00:11:54,379
PROFESSOR: So I'm computing dp of i j.
教授：所以我正在计算i j的dp。 

221
00:11:54,379 --> 00:11:57,379
AUDIENCE: I know, of j minus [INAUDIBLE].
听众：我知道，j减[听不清]。 

222
00:11:57,379 --> 00:12:00,620
AUDIENCE: j minus i, then k j minus [INAUDIBLE].
听众：j减去i，然后kj减去[音频不清晰]。 

223
00:12:00,620 --> 00:12:01,980
PROFESSOR: There's a k, right?
教授：有，对吧？ 

224
00:12:01,980 --> 00:12:05,980
I need a new variable for where I'm going to cut up, right?
我需要在要切入的位置使用新变量，对吗？ 

225
00:12:05,980 --> 00:12:08,479
So fortunately, we have a lot of letters in the alphabet,
幸运的是，我们的字母表中有很多字母， 

226
00:12:08,679 --> 00:12:11,029
i, j, k, so on and so forth, l, m.
 i，j，k，依此类推，l，m。 

227
00:12:11,029 --> 00:12:13,621



228
00:12:13,621 --> 00:12:14,929
AUDIENCE: i plus k.
听众：我加k。 

229
00:12:14,929 --> 00:12:17,208



230
00:12:17,208 --> 00:12:19,250
PROFESSOR: So let's say that k is the place where
教授：那么说k是

231
00:12:19,250 --> 00:12:21,409
we cut, to make our life easy.
我们削减，使我们的生活轻松。 

232
00:12:21,409 --> 00:12:26,269
So I'm going to have dp of
所以我要有dp 

233
00:12:26,269 --> 00:12:28,269
AUDIENCE: Well i is the starting point.
听众：好吧，我是起点。 

234
00:12:28,269 --> 00:12:28,609
PROFESSOR: OK
教授：好的

235
00:12:28,809 --> 00:12:34,279
AUDIENCE: And then, the endpoint is i plus k, right?
听众：然后，端点是i加k，对吗？ 

236
00:12:34,279 --> 00:12:36,266
PROFESSOR: So what's k here?
教授：那这里是什么？ 

237
00:12:36,267 --> 00:12:37,600
AUDIENCE: k is an actual number.
听众：k是实际数字。 

238
00:12:37,600 --> 00:12:40,350
It's not the offset, it's the actual number,
不是偏移量，而是实际数字， 

239
00:12:40,350 --> 00:12:41,840
so it should be i to k.
所以应该是我到k。 

240
00:12:41,840 --> 00:12:43,484
It depends how you define k.
这取决于您如何定义k。 

241
00:12:43,484 --> 00:12:45,699
PROFESSOR: So I'm going to make my life easy, and define k
教授：所以我要让我的生活轻松一点，并定义k 

242
00:12:45,899 --> 00:12:47,735
as exactly the marking at which I cut.
恰好是我切割的标记。 

243
00:12:47,735 --> 00:12:50,940



244
00:12:50,940 --> 00:12:51,479
k is this 2 here.
 k是这里的2。 

245
00:12:51,679 --> 00:12:55,799



246
00:12:55,799 --> 00:12:58,379
And this is easier, trust me.
这更容易，相信我。 

247
00:12:58,379 --> 00:13:01,042
OK, plus?
好，再加上？ 

248
00:13:01,042 --> 00:13:01,625
AUDIENCE: k j?
听众：kj？ 

249
00:13:01,625 --> 00:13:05,029



250
00:13:05,029 --> 00:13:08,865
PROFESSOR: OK, and?
教授：好吧？ 

251
00:13:08,865 --> 00:13:16,155
AUDIENCE: Cost of m--
听众：m的费用- 

252
00:13:16,155 --> 00:13:23,909
AUDIENCE: j minus i, m of k minus m of i times m of j
听众：j减去i，k的m减去i的m乘以j的m 

253
00:13:23,909 --> 00:13:25,469
minus m of k.
减去k。 

254
00:13:25,470 --> 00:13:26,394
PROFESSOR: Cool.
教授：太好了。 

255
00:13:26,394 --> 00:13:27,859
Yeah, other way around-- doesn't matter.
是的，其他方法都没关系。 

256
00:13:28,059 --> 00:13:30,750



257
00:13:30,750 --> 00:13:35,429
So now where does k go?
那么，现在k去哪里？ 

258
00:13:35,429 --> 00:13:38,373
We have to come up with numbers for the loop, right?
我们必须为循环提供数字，对吗？ 

259
00:13:38,374 --> 00:13:40,912



260
00:13:40,912 --> 00:13:41,959
AUDIENCE: Between i and j.
听众：在i和j之间。 

261
00:13:42,159 --> 00:13:44,521
AUDIENCE: j minus i.
听众：j减去i。 

262
00:13:44,522 --> 00:13:48,490
AUDIENCE: Just for k in i to j.
听众：只为从i到j的k个。 

263
00:13:48,490 --> 00:13:52,624
PROFESSOR: So if I have the board from 1 to 4,
教授：如果我的董事会人数从1到4， 

264
00:13:52,624 --> 00:13:54,399
do I cut at 1?
我削减1？ 

265
00:13:54,399 --> 00:13:56,853
I can, but that's kind of weird.
我可以，但这有点奇怪。 

266
00:13:56,854 --> 00:13:59,580
Because I'm recursing on the same subproblem.
因为我要递归相同的子问题。 

267
00:13:59,580 --> 00:14:01,879
By the way, if you recurse to the same subproblem,
顺便说一句，如果递归到相同的子问题， 

268
00:14:01,879 --> 00:14:05,149
what are you going to get as your running time?
您的跑步时间将获得什么？ 

269
00:14:05,149 --> 00:14:07,449
Infinite.
无穷。 

270
00:14:07,450 --> 00:14:09,229
So let's not do that.
因此，我们不要这样做。 

271
00:14:09,429 --> 00:14:11,469
So we're going to go from?
所以我们要去哪里？ 

272
00:14:11,470 --> 00:14:14,014
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

273
00:14:14,014 --> 00:14:15,479
PROFESSOR: So going from i would be bad.
教授：所以从我那里去是不好的。 

274
00:14:15,679 --> 00:14:16,990
So i plus 1.
所以我加1。 

275
00:14:16,990 --> 00:14:17,490
2?
 2？ 

276
00:14:17,490 --> 00:14:19,229
AUDIENCE: j minus 1.
听众：j减1。 

277
00:14:19,429 --> 00:14:20,750
PROFESSOR: Very good.
教授：非常好。 

278
00:14:20,750 --> 00:14:26,480
AUDIENCE: Would it be m over i plus 1, because [INAUDIBLE].
听众：是[我听不清]，所以我等于1。 

279
00:14:26,480 --> 00:14:28,649
PROFESSOR: So k is which marking I'm cutting at.
教授：那么k是我要剪切的标记。 

280
00:14:28,649 --> 00:14:32,019
I never want to cut inside a marking.
我永远都不想在标记内切。 

281
00:14:32,019 --> 00:14:34,759
However, I don't even know these are integers.
但是，我什至不知道这些是整数。 

282
00:14:34,759 --> 00:14:37,889
AUDIENCE: They wouldn't be called [INAUDIBLE].
听众：他们不会被称为[听不清]。 

283
00:14:37,889 --> 00:14:39,975
PROFESSOR: So k is which marking, i, j,
教授：那么k是哪个标记i，j， 

284
00:14:39,975 --> 00:14:41,975
and k are which marking I'm cutting at.
和k是我要剪切的标记。 

285
00:14:41,975 --> 00:14:44,580



286
00:14:44,580 --> 00:14:46,330
These are the only discrete things I have.
这些是我唯一的离散事物。 

287
00:14:46,330 --> 00:14:50,931
This board is all filled with real numbers.
这块木板全都是实数。 

288
00:14:51,131 --> 00:14:52,589
So if I want to cut somewhere here,
所以如果我想在这里切某处， 

289
00:14:52,590 --> 00:14:54,480
that's a real number-- I don't like that.
那是一个真实的数字-我不喜欢那样。 

290
00:14:54,480 --> 00:14:55,899
I want to have integers.
我想要整数。 

291
00:14:55,899 --> 00:15:00,039
So my markings help me get integers.
所以我的标记帮助我获得整数。 

292
00:15:00,039 --> 00:15:01,529
I only want to cut at the marking,
我只想切割标记

293
00:15:01,529 --> 00:15:05,370
so I always look at my problem in terms of which marking I'm
所以我总是看我的问题

294
00:15:05,370 --> 00:15:06,080
cutting it.
削减它。 

295
00:15:06,080 --> 00:15:09,110



296
00:15:09,110 --> 00:15:11,649
So this always iterates over markings.
因此，这总是遍历标记。 

297
00:15:11,649 --> 00:15:16,789
So this looks very much like the parentheses problem, right?
所以这看起来很像括号问题，对吗？ 

298
00:15:16,789 --> 00:15:20,740
Same subproblems, roughly the same recursion.
相同的子问题，大致相同的递归。 

299
00:15:20,740 --> 00:15:22,500
Turns out that these problems, where
原来这些问题，在哪里

300
00:15:22,500 --> 00:15:24,549
you're not considering suffixes or prefixes,
您不考虑后缀或前缀， 

301
00:15:24,549 --> 00:15:27,099
but rather you're considering substrings,
而是您正在考虑子字符串， 

302
00:15:27,100 --> 00:15:30,600
are reasonably hard to come by, and reasonably hard to solve.
相当困难，也很难解决。 

303
00:15:30,600 --> 00:15:32,840
So if we give these to you, chances
因此，如果我们将这些赠予您， 

304
00:15:32,840 --> 00:15:35,889
are they're going to be exactly like the parentheses problem,
它们会完全像括号问题一样吗， 

305
00:15:35,889 --> 00:15:37,990
except for the cost function.
除了成本函数。 

306
00:15:37,990 --> 00:15:42,049
This isn't what we had in the parentheses problem, right?
这不是括号问题中的内容，对吗？ 

307
00:15:42,049 --> 00:15:44,219
So you should be prepared to solve problems
所以你应该准备解决问题

308
00:15:44,220 --> 00:15:46,070
that look exactly like the paren problem,
看起来完全像是paren问题

309
00:15:46,070 --> 00:15:49,579
but might have a different cost function.
但可能具有不同的成本函数。 

310
00:15:49,779 --> 00:15:52,959
And this is how we solve it.
这就是我们解决问题的方式。 

311
00:15:52,960 --> 00:15:53,460
OK.
好。 

312
00:15:53,460 --> 00:15:55,668
AUDIENCE: When you say that the complexity determines
听众：当您说复杂性决定

313
00:15:55,668 --> 00:15:58,245
which type of dp example we use, does
我们使用哪种类型的dp示例

314
00:15:58,245 --> 00:16:03,259
that mean that a problem can be solved
那意味着一个问题可以解决

315
00:16:03,259 --> 00:16:08,514
using any of dp examples?
使用任何dp示例？ 

316
00:16:08,514 --> 00:16:13,759
It's just that the only thing that changes is the complexity.
只是唯一改变的是复杂性。 

317
00:16:13,759 --> 00:16:15,309
PROFESSOR: I don't think you can map
教授：我认为您无法绘制地图

318
00:16:15,309 --> 00:16:16,839
every approach onto every problem.
解决每个问题的每种方法。 

319
00:16:16,840 --> 00:16:20,450
For example, if you tried to map prefixes onto this,
例如，如果您尝试将前缀映射到此地址， 

320
00:16:20,450 --> 00:16:22,849
you'd come up with a solution that
你会想出一个解决方案

321
00:16:23,049 --> 00:16:25,370
doesn't look at all the possible choices,
并没有考虑所有可能的选择， 

322
00:16:25,370 --> 00:16:27,539
so your answer would be sub-optimal.
因此您的答案将不是最理想的。 

323
00:16:27,539 --> 00:16:30,329
So you'd come up with a fast, but incorrect algorithm.
因此，您会想到一种快速但不正确的算法。 

324
00:16:30,330 --> 00:16:35,750
However, if you take the problem of find the longest
但是，如果您遇到寻找时间最长的问题

325
00:16:35,750 --> 00:16:37,899
increasing sub-sequence, you can definitely
增加子序列，您绝对可以

326
00:16:37,899 --> 00:16:39,230
apply this technique to it.
运用这项技术。 

327
00:16:39,230 --> 00:16:41,289
It's more general than suffixes or prefixes.
它比后缀或前缀更通用。 

328
00:16:41,289 --> 00:16:44,199
So it's going to work, but it's going to be slower.
因此它可以工作，但速度会变慢。 

329
00:16:44,200 --> 00:16:46,610
So in theory, what you should do is,
因此，从理论上讲，您应该做的是， 

330
00:16:46,610 --> 00:16:48,509
you have all these techniques.
您拥有所有这些技巧。 

331
00:16:48,509 --> 00:16:51,450
Given a problem, you try all the techniques.
遇到问题，您可以尝试所有技术。 

332
00:16:51,450 --> 00:16:53,720
You see which ones apply, and out of those, you
您会看到哪些适用，而其中哪些适用

333
00:16:53,720 --> 00:16:56,460
see which one gives you the best running time.
看看哪一个给您最佳的运行时间。 

334
00:16:56,460 --> 00:16:59,620
In practice, if we give you the running time,
实际上，如果我们给您运行时间， 

335
00:16:59,620 --> 00:17:03,360
you match it to the techniques that match the running time.
您可以将其与运行时间相匹配的技术进行匹配。 

336
00:17:03,360 --> 00:17:05,700
You start backwards from the stuff that you know.
您从已知的内容开始倒退。 

337
00:17:05,700 --> 00:17:10,630



338
00:17:10,630 --> 00:17:12,668
OK.
好。 

339
00:17:12,868 --> 00:17:15,730
Does this problem make sense?
这个问题有意义吗？ 

340
00:17:15,730 --> 00:17:18,180
Sweet.
甜。 

341
00:17:18,180 --> 00:17:19,680
Now let's do a hard problem.
现在让我们做一个难题。 

342
00:17:19,680 --> 00:17:23,818
Do people remember hashing?
人们还记得哈希吗？ 

343
00:17:23,818 --> 00:17:25,588
You have one minute to remember hashing
你有一分钟​​要记住哈希

344
00:17:25,588 --> 00:17:26,639
while I erase the board.
当我擦除木板时。 

345
00:17:26,640 --> 00:17:28,329
[LAUGHING]
 [笑] 

346
00:17:28,529 --> 00:17:31,940
So suppose we want to implement the set.
因此，假设我们要实现该集合。 

347
00:17:31,940 --> 00:17:36,389
The way we're going to implement the set is, we have n elements.
我们要实现集合的方式是，我们有n个元素。 

348
00:17:36,589 --> 00:17:39,809



349
00:17:39,809 --> 00:17:41,679
We're going to put them into the set,
我们要把它们放进去， 

350
00:17:41,680 --> 00:17:50,019
so for i goes from 1 through n, we're
所以我从1到n 

351
00:17:50,019 --> 00:17:54,700
going to insert element i, so first we're
要插入元素i，所以首先

352
00:17:54,700 --> 00:17:57,730
going to insert all the elements into the set.
将所有元素插入集合。 

353
00:17:57,730 --> 00:18:02,140
And then after that, given a random number, we want to see
然后，给定一个随机数，我们想看看

354
00:18:02,140 --> 00:18:03,609
is it in the set, or not.
是否在集合中。 

355
00:18:03,809 --> 00:18:09,190
So for some other number-- I used n before, so let's
因此，对于其他一些数字，我以前使用过n，所以让我们

356
00:18:09,190 --> 00:18:15,450
use-- for some other number f, we want to see is f in the set,
使用-对于其他一些数字f，我们希望看到集合中的f， 

357
00:18:15,450 --> 00:18:19,067
or is f not in the set?
还是f不在集合中？ 

358
00:18:19,067 --> 00:18:22,139



359
00:18:22,140 --> 00:18:24,400
What data structure would you use normally for this?
您通常会使用什么数据结构？ 

360
00:18:24,400 --> 00:18:27,490



361
00:18:27,490 --> 00:18:28,559
A hash table, right?
哈希表，对不对？ 

362
00:18:28,559 --> 00:18:31,079
You stick everything into a hash table,
您将所有内容粘贴到哈希表中， 

363
00:18:31,079 --> 00:18:32,819
then you try to find the elements.
然后您尝试查找元素。 

364
00:18:32,819 --> 00:18:34,879
If you find them, then you say yes.
如果找到它们，那么您说是。 

365
00:18:34,880 --> 00:18:36,980
If not, then you say no.
如果不是，那么您说不。 

366
00:18:36,980 --> 00:18:38,710
Well, it turns out that this would
好吧，事实证明这会

367
00:18:38,710 --> 00:18:41,160
take more memory than what we have.
占用比我们更多的内存。 

368
00:18:41,160 --> 00:18:44,720
So instead, we're going to do this.
因此，我们将执行此操作。 

369
00:18:44,720 --> 00:18:47,649
We're going to have a hash table of m bits.
我们将有一个m位的哈希表。 

370
00:18:47,849 --> 00:18:53,659



371
00:18:53,660 --> 00:18:54,639
So these are m bits.
所以这些是m位。 

372
00:18:54,839 --> 00:18:58,669
And say we have a hash function that
并说我们有一个哈希函数

373
00:18:58,670 --> 00:19:02,410
satisfies with uniform hashing, so given any element,
满足统一哈希，因此给定任何元素， 

374
00:19:02,410 --> 00:19:07,784
the value is anywhere from 0 to m minus 1,
取值范围是0到m减去1， 

375
00:19:07,784 --> 00:19:08,950
and they're all independent.
他们都是独立的。 

376
00:19:08,950 --> 00:19:12,490



377
00:19:12,490 --> 00:19:14,599
So the way we're going to insert an element
所以我们要插入一个元素的方式

378
00:19:14,599 --> 00:19:23,039
is-- this table is T-- we're going to say that T of h of ai
是-这张表是T-我们要说的是a的h的T 

379
00:19:23,039 --> 00:19:24,690
equals 1.
等于1。 

380
00:19:24,690 --> 00:19:26,399
So this is a table of bits.
这是位表。 

381
00:19:26,599 --> 00:19:28,569
For every element we hash the element,
对于每个元素，我们对元素进行哈希处理， 

382
00:19:28,569 --> 00:19:32,609
and we set the corresponding bit to 1.
然后将相应的位设置为1。 

383
00:19:32,609 --> 00:19:38,229
So we're going to have some 1s, and some zeros in the table.
因此，我们在表中将有一些1和一些0。 

384
00:19:38,230 --> 00:19:43,680
Say if this is ai, it hashes somewhere here.
假设这是ai，它会散列在这里。 

385
00:19:43,680 --> 00:19:46,529
OK so the question is, we inserted
好，问题是，我们插入了

386
00:19:46,529 --> 00:19:49,559
n elements into a table of size n.
将n个元素放入大小为n的表中。 

387
00:19:49,559 --> 00:19:55,109
Given a new element, f, where f stands for false positive-- f
给定一个新元素f，其中f代表假阳性-f 

388
00:19:55,109 --> 00:19:58,394
is not one of the elements that we inserted.
不是我们插入的元素之一。 

389
00:19:58,394 --> 00:20:02,039



390
00:20:02,039 --> 00:20:04,490
I want to know what's the probability that the set will
我想知道布景的可能性是多少

391
00:20:04,490 --> 00:20:08,700
say that the element is in the set, so basically,
说元素在集合中，所以基本上

392
00:20:08,700 --> 00:20:11,673
the probability of a false positive.
误报的概率。 

393
00:20:11,673 --> 00:20:14,660
AUDIENCE: So what are we doing about [INAUDIBLE]?
听众：那么我们对[听不清]怎么办？ 

394
00:20:14,660 --> 00:20:15,595
PROFESSOR: Nothing.
教授：没事。 

395
00:20:15,595 --> 00:20:18,612
AUDIENCE: Is it chaining, is it open addressing?
听众：是链接，是开放地址吗？ 

396
00:20:18,612 --> 00:20:21,604
Does it even matter?
有关系吗

397
00:20:21,604 --> 00:20:23,519
PROFESSOR: So we're not inserting the elements
教授：所以我们不会插入元素

398
00:20:23,519 --> 00:20:25,200
into the table.
进入桌子。 

399
00:20:25,200 --> 00:20:26,890
This table only has bits.
该表只有位。 

400
00:20:26,890 --> 00:20:31,599
The elements are lost completely after we insert them.
插入元素后，这些元素将完全丢失。 

401
00:20:31,799 --> 00:20:34,200
So the tradeoff is uses a lot less memory.
因此，折衷方案是使用更少的内存。 

402
00:20:34,200 --> 00:20:36,049
Instead of having to store entire elements,
不必存储整个元素， 

403
00:20:36,049 --> 00:20:38,049
you just store bits.
你只是存储位。 

404
00:20:38,049 --> 00:20:40,926
On the downside you're going to have false positives.
不利的一面是您会误报。 

405
00:20:40,926 --> 00:20:42,509
Because if I have a different element,
因为如果我有不同的元素， 

406
00:20:42,509 --> 00:20:47,089
say f, if it hashes to the same location,
说f，如果它哈希到相同的位置， 

407
00:20:47,089 --> 00:20:51,359
then the set is going to say, yeah, it's in the set.
然后场景会说，是的，它在场景中。 

408
00:20:51,359 --> 00:20:53,040
So you get false positives.
因此，您会得到误报。 

409
00:20:53,040 --> 00:20:54,289
Would you get false negatives?
您会得到假阴性吗？ 

410
00:20:54,289 --> 00:20:59,230



411
00:20:59,230 --> 00:20:59,730
No, right?
没有权利？ 

412
00:20:59,730 --> 00:21:02,529



413
00:21:02,529 --> 00:21:05,789
Because you start out with a table of 0's,
因为您以0的表格开始， 

414
00:21:05,789 --> 00:21:07,680
and you only set the table to ones
而且您只将表格设置为

415
00:21:07,680 --> 00:21:11,369
for the numbers that match to hashes
匹配哈希的数字

416
00:21:11,569 --> 00:21:13,339
of elements that are in the set.
集合中的元素。 

417
00:21:13,339 --> 00:21:14,953
Did you have a question?
你有问题吗

418
00:21:14,953 --> 00:21:15,452
OK.
好。 

419
00:21:15,452 --> 00:21:19,910



420
00:21:19,910 --> 00:21:21,680
OK, do we understand the problem,
好，我们了解问题了吗

421
00:21:21,680 --> 00:21:23,584
before we attempt to solve it?
在我们尝试解决它之前？ 

422
00:21:23,584 --> 00:21:27,250
AUDIENCE: Is it probably 1/m?
听众：大概是1 / m吗？ 

423
00:21:27,250 --> 00:21:29,880
PROFESSOR: You'd wish, but no.
教授：您希望，但不能。 

424
00:21:29,880 --> 00:21:32,659



425
00:21:32,859 --> 00:21:34,244
AUDIENCE: It's less than n/m.
听众：小于n / m。 

426
00:21:34,244 --> 00:21:37,099



427
00:21:37,099 --> 00:21:38,559
PROFESSOR: OK, I like that.
教授：好的，我喜欢。 

428
00:21:38,559 --> 00:21:41,409
So what are you thinking?
那你在想什么

429
00:21:41,410 --> 00:21:43,410
AUDIENCE: If there are no collisions previously,
观众：如果以前没有碰撞， 

430
00:21:43,410 --> 00:21:48,730
then it would equal to n/m, but there are collisions, probably
那么它等于n / m，但是可能有碰撞

431
00:21:48,730 --> 00:21:50,566
collisions.
碰撞。 

432
00:21:50,566 --> 00:21:52,940
PROFESSOR: OK, I'm going to open up a window in your head
教授：好的，我要在你脑海中打开一个窗口

433
00:21:52,940 --> 00:21:56,769
and tell everyone else the small steps you took to get here.
并告诉其他人您到达这里所采取的小步骤。 

434
00:21:56,769 --> 00:21:58,940
So we have this new number f.
因此，我们有了这个新数字f。 

435
00:21:58,940 --> 00:22:01,200
How are we going to check if it's in the set or not?
我们如何检查它是否在集合中？ 

436
00:22:01,200 --> 00:22:04,299
We're going to compute h of f, and we're
我们将计算f的h， 

437
00:22:04,299 --> 00:22:09,579
going to check if t of h of f is 0 or 1.
将检查f的h中的t是否为0或1。 

438
00:22:09,579 --> 00:22:13,369



439
00:22:13,369 --> 00:22:15,869
f is different from all the other elements.
 f与所有其他元素不同。 

440
00:22:15,869 --> 00:22:19,919
So its hash value is independent from all the other hash values
因此，其哈希值与所有其他哈希值无关

441
00:22:19,920 --> 00:22:20,640
we had before.
我们以前有过。 

442
00:22:20,640 --> 00:22:24,099



443
00:22:24,299 --> 00:22:26,480
We don't really care about this anymore,
我们真的不再关心这个了

444
00:22:26,480 --> 00:22:29,900
after we have the independence assumption.
在我们有独立性假设之后。 

445
00:22:29,900 --> 00:22:34,400
So h of f is just some random position in the table.
因此，f的h只是表中的一些随机位置。 

446
00:22:34,400 --> 00:22:37,879
So the question is, given some random position in the table,
所以问题是，给定表中的一些随机位置， 

447
00:22:38,079 --> 00:22:41,089
will that be a 0 or a 1?
那是0还是1？ 

448
00:22:41,089 --> 00:22:42,569
How do you know?
你怎么知道的？ 

449
00:22:42,569 --> 00:22:44,909
If I knew how many 1's I have in the table--
如果我知道桌上有多少个1- 

450
00:22:44,910 --> 00:22:49,529
if I have k 1's in the table, and automatically this means n
如果我在表中有k 1，这自动意味着n 

451
00:22:49,529 --> 00:22:56,190
minus k 0's-- then what's the probability that h of f will
减去k 0-那么f的h的概率是多少

452
00:22:56,190 --> 00:22:57,059
point to a 1?
指向1？ 

453
00:22:57,059 --> 00:23:06,331



454
00:23:06,332 --> 00:23:08,265
AUDIENCE: k/m.
观众：k / m。 

455
00:23:08,265 --> 00:23:08,890
PROFESSOR: Yes.
教授：是的。 

456
00:23:08,890 --> 00:23:11,379
So the hash takes m possible values.
因此，散列取m个可能的值。 

457
00:23:11,579 --> 00:23:13,089
k of them are 1's.
其中k为1。 

458
00:23:13,089 --> 00:23:18,750
So the probability that the hash is going to guess a 1 is k/m.
因此，哈希猜测为1的概率为k / m。 

459
00:23:18,750 --> 00:23:23,819
So if we knew how many 1's we have, then this is the answer.
因此，如果我们知道我们有多少个1，那么这就是答案。 

460
00:23:23,819 --> 00:23:26,519
We know that we're going to have at most n 1's-- that's what
我们知道我们最多将有n 1个-这就是

461
00:23:26,519 --> 00:23:28,200
you're thinking, right?
你在想吧？ 

462
00:23:28,200 --> 00:23:31,950
So k is definitely smaller or equal to n,
因此，k绝对小于或等于n， 

463
00:23:31,950 --> 00:23:39,900
so the answer definitely has to be smaller or equal than n/m.
因此答案肯定必须小于或等于n / m。 

464
00:23:39,900 --> 00:23:41,930
Now if you're in a rush, you might say,
现在，如果您很着急，您可能会说， 

465
00:23:41,930 --> 00:23:44,960
well, we inserted n elements, so we're definitely
好吧，我们插入了n个元素，所以我们肯定

466
00:23:44,960 --> 00:23:48,029
going to have n 1's here.
这里要有n 1个

467
00:23:48,029 --> 00:23:49,319
That is not true.
那是不对的。 

468
00:23:49,319 --> 00:23:53,059
The hashes of all the elements are independent.
所有元素的哈希都是独立的。 

469
00:23:53,059 --> 00:23:55,440
So there is some probability that two elements will
因此，有两个元素可能会

470
00:23:55,440 --> 00:23:59,210
hash to the same value, and as the number of elements grows,
散列为相同的值，并且随着元素数量的增加， 

471
00:23:59,210 --> 00:24:00,785
that probability also grows.
这种可能性也会增加。 

472
00:24:00,785 --> 00:24:03,970



473
00:24:03,970 --> 00:24:06,509
OK, so now by looking at this, we
好的，所以现在看这个，我们

474
00:24:06,509 --> 00:24:08,650
got rid of this part of the problem.
摆脱了这部分问题。 

475
00:24:08,650 --> 00:24:10,372
We don't care that there's a new element.
我们不在乎有一个新元素。 

476
00:24:10,372 --> 00:24:11,879
We don't care that it's a false positive.
我们不在乎这是一个误报。 

477
00:24:12,079 --> 00:24:14,269
All that we care about is how many
我们只关心多少

478
00:24:14,269 --> 00:24:18,079
1's do we have in the table after inserting n values.
插入n个值后，我们在表中得到1。 

479
00:24:18,079 --> 00:24:23,009



480
00:24:23,009 --> 00:24:23,759
Well, what's that?
恩那是什么

481
00:24:23,759 --> 00:24:41,809
That's m times the probability that a slot in the table is 1.
这是表中插槽为1的概率的m倍。 

482
00:24:41,809 --> 00:24:46,819
Right, the probability that the slot in the table is 1 is k/m.
正确，表格中的广告位为1的概率为k / m。 

483
00:24:46,819 --> 00:24:49,389
So if we know this probability, and we multiply it by m,
因此，如果我们知道这个概率，并将其乘以m， 

484
00:24:49,390 --> 00:24:50,130
then we get k.
那么我们得到k。 

485
00:24:50,130 --> 00:24:57,450



486
00:24:57,450 --> 00:25:00,240
People still with me?
人们还和我在一起吗？ 

487
00:25:00,240 --> 00:25:03,470
AUDIENCE: And what does that variable represent, h?
听众：那个变量代表什么？ 

488
00:25:03,470 --> 00:25:05,049
PROFESSOR: This is k.
教授：这是k。 

489
00:25:05,049 --> 00:25:07,049
Represents that my handwriting sucks, basically.
基本上代表我的笔迹很烂。 

490
00:25:07,049 --> 00:25:10,529
AUDIENCE: I mean, why do we do m times the probability.
听众：我的意思是，为什么我们做概率是m倍。 

491
00:25:10,529 --> 00:25:15,208
That's the the expected number of 1's in the table?
那是表中预期的数字1？ 

492
00:25:15,208 --> 00:25:15,874
PROFESSOR: Yeah.
教授：是的。 

493
00:25:15,874 --> 00:25:19,710



494
00:25:19,710 --> 00:25:24,329
Yeah, this is E of k, I guess.
是的，我猜这是k的E。 

495
00:25:24,329 --> 00:25:30,193
So then our final answer is this thing divided by m.
因此，我们的最终答案是这东西除以m。 

496
00:25:30,193 --> 00:25:34,940



497
00:25:34,940 --> 00:25:40,390
So the answer is the expected value of k,
所以答案是k的期望值

498
00:25:40,390 --> 00:25:43,629
or you can just think of it as the average value of k, divided
或者您可以将其视为k的平均值除以

499
00:25:43,829 --> 00:25:44,395
by m.
按米

500
00:25:44,395 --> 00:25:53,299
So this is m times this probability, divided by m.
因此，这是该概率的m倍除以m。 

501
00:25:53,299 --> 00:25:56,450
So it is exactly this probability.
因此，正是这种可能性。 

502
00:25:56,450 --> 00:25:59,920
So the thing that we want to focus on
所以我们要重点关注的是

503
00:25:59,920 --> 00:26:07,710
is, what's the probability that a random slot in the table
是，表格中的随机广告位的概率是多少

504
00:26:07,710 --> 00:26:08,210
is a 1?
是1？ 

505
00:26:08,210 --> 00:26:16,900



506
00:26:16,900 --> 00:26:18,657
AUDIENCE: It's equal to 1 minus the probability
听众：等于1减去概率

507
00:26:18,857 --> 00:26:21,289
that it was never fixed.
从来没有解决过。 

508
00:26:21,289 --> 00:26:26,089
PROFESSOR: Exactly, the first thing we do.
教授：确实，我们要做的第一件事。 

509
00:26:26,089 --> 00:26:30,569
1 minus the probability that a slot is 0.
 1减去广告位为0的概率。 

510
00:26:30,569 --> 00:26:33,269



511
00:26:33,269 --> 00:26:35,559
This is easy, right, like it looks easy.
这很容易，对，就像看起来很容易。 

512
00:26:35,559 --> 00:26:38,210
But this makes a huge difference,
但这有很大的不同， 

513
00:26:38,210 --> 00:26:42,660
because once we're here, well, a slot is zero
因为一旦我们来到这里，广告位为零

514
00:26:42,660 --> 00:26:46,246
if none of the insertions made it a one.
如果没有一个插入使其成为一个。 

515
00:26:46,246 --> 00:26:47,669
And the insertions are all independent.
并且插入都是独立的。 

516
00:26:47,869 --> 00:26:50,709



517
00:26:50,710 --> 00:26:54,029
So this is like, you're flipping a coin.
就像您要掷硬币一样。 

518
00:26:54,029 --> 00:26:56,379
What's the probability that after you flip it n times,
翻转n次后，出现几率的几率是多少

519
00:26:56,380 --> 00:26:57,470
you never get a head?
你永远不会头脑好吗？ 

520
00:26:57,470 --> 00:27:01,450



521
00:27:01,450 --> 00:27:04,384
So this is 1 minus
所以这是1减

522
00:27:04,384 --> 00:27:07,950
AUDIENCE: 1 over m to the something.
听众：1以上的东西。 

523
00:27:07,950 --> 00:27:11,420
PROFESSOR: That-- So a slot is 0 means
教授：那-插槽为0表示

524
00:27:11,420 --> 00:27:14,259
that no number was inserted in it.
没有插入任何数字。 

525
00:27:14,259 --> 00:27:17,990
We're inserting n numbers, so it's the probability
我们要插入n个数字，这就是概率

526
00:27:17,990 --> 00:27:27,940
that a single number was not necessarily
单数不一定

527
00:27:27,940 --> 00:27:36,149
in the slot, raised to the power of n.
在插槽中，升至n的幂。 

528
00:27:36,349 --> 00:27:38,719
So we have n independent experiments, right?
所以我们有n个独立实验，对不对？ 

529
00:27:38,720 --> 00:27:43,390
Every time you insert a number into the hash function,
每次将数字插入哈希函数时， 

530
00:27:43,390 --> 00:27:45,380
that's one experiment.
那是一个实验。 

531
00:27:45,380 --> 00:27:47,589
The hash function gives you independent values
哈希函数为您提供独立的值

532
00:27:47,789 --> 00:27:50,559
for all the elements.
对于所有元素。 

533
00:27:50,559 --> 00:27:53,529
So all the insertions are independent of each other.
因此，所有插入都彼此独立。 

534
00:27:53,529 --> 00:27:58,139
If, in a single insertion, you've hit that slot,
如果您一次插入该插槽， 

535
00:27:58,140 --> 00:28:00,460
then you've made it a 1-- game over.
那么您已经将其打成1局了。 

536
00:28:00,460 --> 00:28:03,670
So the slot is only a zero if none of the insertions
因此，如果没有插入，则插槽仅是零

537
00:28:03,670 --> 00:28:05,420
make it the 1.
使其成为1。 

538
00:28:05,420 --> 00:28:07,670
So you take the probability that the insertion doesn't
因此，您有可能不会插入

539
00:28:07,670 --> 00:28:09,609
make it a one, and you raise it to the power n,
将其设为1，然后将其提升为n， 

540
00:28:09,809 --> 00:28:12,128
because that has to happen n times in order
因为那必须发生n次

541
00:28:12,128 --> 00:28:13,669
for the whole thing to be successful.
才能使整个事情成功。 

542
00:28:13,670 --> 00:28:24,119



543
00:28:24,319 --> 00:28:26,200
And the probability that the number was not
那个数字不是

544
00:28:26,200 --> 00:28:29,519
inserted in a slot is 1 minus the probability
插入插槽中是1减去概率

545
00:28:29,519 --> 00:28:31,440
that it was inserted.
它被插入。 

546
00:28:31,440 --> 00:28:33,619
Right, we're doing this again.
是的，我们再做一次。 

547
00:28:33,819 --> 00:28:39,710
1 minus probability that a number hit.
 1减数字命中的概率。 

548
00:28:39,710 --> 00:28:43,880



549
00:28:44,080 --> 00:28:45,204
Well what this probability?
那么这个概率是多少？ 

550
00:28:45,204 --> 00:28:47,740



551
00:28:47,740 --> 00:28:48,759
Uniform hashing.
统一哈希。 

552
00:28:48,759 --> 00:28:49,865
AUDIENCE: 1/m
观众：1 / m 

553
00:28:49,865 --> 00:28:50,490
PROFESSOR: 1/m.
教授：1 / m。 

554
00:28:50,490 --> 00:28:53,799



555
00:28:53,799 --> 00:29:01,690
So this whole thing is 1 minus 1 minus 1, over m to the power n.
因此，整件事是1减去1减去1，超过m等于幂n。 

556
00:29:01,690 --> 00:29:07,470
1 minus m minus 1, over m to the power n.
 1减去m减去1，将m乘以n。 

557
00:29:07,470 --> 00:29:13,197



558
00:29:13,397 --> 00:29:15,867
AUDIENCE: Can we go through this again.
听众：我们可以再经历一次。 

559
00:29:15,867 --> 00:29:20,067
From 1 minus probability of a slot is 0, to 1
从1减去槽的概率为0到1 

560
00:29:20,067 --> 00:29:25,259
minus probability of a number was not inserted in a slot?
插槽中未插入数字的可能性是否为负？ 

561
00:29:25,259 --> 00:29:26,200
PROFESSOR: OK.
教授：好的。 

562
00:29:26,200 --> 00:29:27,919
So first off, the point of the problem.
所以首先，问题的重点。 

563
00:29:28,119 --> 00:29:29,569
It's our problem, right?
是我们的问题吧？ 

564
00:29:29,569 --> 00:29:31,283
Don't panic, don't be angry.
不要惊慌，不要生气。 

565
00:29:31,284 --> 00:29:33,450
You're not going to have some this hard on the exam.
您不会在考试中遇到一些困难。 

566
00:29:33,450 --> 00:29:35,783
The point of this is, I want to go through probabilities
重点是，我想通过概率

567
00:29:35,983 --> 00:29:37,899
a little bit, and I want to go through hashing
一点，我想进行散列

568
00:29:37,900 --> 00:29:39,220
and the math behind hashing.
以及哈希背后的数学原理。 

569
00:29:39,220 --> 00:29:43,140
Because remembering that will be useful.
因为记住那会很有用。 

570
00:29:43,140 --> 00:29:48,970
OK, so now you said you're having trouble with this step?
好的，所以现在您说您在执行此步骤时遇到了麻烦？ 

571
00:29:48,970 --> 00:29:53,473



572
00:29:53,473 --> 00:29:55,470
OK, so let's see.
好，让我们看看。 

573
00:29:55,470 --> 00:29:58,899
Let's do this here.
让我们在这里做。 

574
00:29:59,099 --> 00:30:01,539
So we have this table here, right?
所以我们在这里有这张桌子，对吧？ 

575
00:30:01,539 --> 00:30:08,549
And we have n elements-- e1, e2, e3, all the way through en.
我们有n个元素-e1，e2，e3，一直到en。 

576
00:30:08,549 --> 00:30:10,139
How do we put them in the table?
我们如何将它们放在桌子上？ 

577
00:30:10,140 --> 00:30:13,720
We hash each of them, and each of them maps
我们哈希每个，每个映射

578
00:30:13,720 --> 00:30:16,569
to a random slot in the table.
到表格中的随机位置。 

579
00:30:16,569 --> 00:30:22,059
If these are the slots, then e1 might map here,
如果这些是插槽，则e1可能会映射到此处， 

580
00:30:22,059 --> 00:30:26,259
e2 might map here, e3 might map here,
 e2可能会映射到这里，e3可能会映射到这里， 

581
00:30:26,259 --> 00:30:30,220
e4 might map here, so on and so forth.
 e4可能会在此处映射，依此类推。 

582
00:30:30,220 --> 00:30:32,460
So I have arrows, right?
所以我有箭吧？ 

583
00:30:32,460 --> 00:30:38,162
Every time I do a hash, that's going to set something to a 1.
每次我进行哈希运算时，都会将值设置为1。 

584
00:30:38,162 --> 00:30:40,169
The numbers don't necessarily map to different slots,
数字不一定映射到不同的插槽， 

585
00:30:40,369 --> 00:30:44,819
because each number, on its own, maps to a random slot.
因为每个数字都单独映射到一个随机广告位。 

586
00:30:44,819 --> 00:30:48,240
So these are all going to be ones.
所以这些都是。 

587
00:30:48,240 --> 00:30:50,480
And everything else becomes zero.
其他所有东西都变为零。 

588
00:30:50,480 --> 00:30:54,839
If no number maps to a slot, it is 0.
如果没有数字映射到插槽，则为0。 

589
00:30:54,839 --> 00:30:58,490
OK, let's look at one slot, any slot.
好，让我们看一个插槽，任何插槽。 

590
00:30:58,490 --> 00:31:01,589
So let's say I'm looking at this slot over here.
假设我在这里看这个广告位。 

591
00:31:01,589 --> 00:31:03,869
Can you guys see, by the way?
你们可以看到吗？ 

592
00:31:03,869 --> 00:31:06,419
OK, so let's look at this guy here.
好，让我们在这里看看这个家伙。 

593
00:31:06,420 --> 00:31:09,940
What's the probability that it's a 0?
它为0的几率是多少？ 

594
00:31:09,940 --> 00:31:14,934
So the probability that the slot is
因此，该广告位是

595
00:31:14,934 --> 00:31:21,179
a 0 is the probability that the first number didn't
 0是第一个数字没有出现的概率

596
00:31:21,180 --> 00:31:27,359
map to it-- otherwise it would be a 1-- e1
映射到它-否则它将是1-e1 

597
00:31:27,559 --> 00:31:30,490
didn't hash to that slot.
没有哈希到该插槽。 

598
00:31:30,490 --> 00:31:33,410



599
00:31:33,410 --> 00:31:37,950
e2 also couldn't match to that slot, right?
 e2也无法与该插槽匹配，对吗？ 

600
00:31:37,950 --> 00:31:43,180
So it's the probability that e1 didn't hash to the slot,
这就是e1没有散列到插槽的可能性， 

601
00:31:43,180 --> 00:31:54,940
and e2 didn't hash into slot, and e3
和e2没有散列到插槽中，而e3 

602
00:31:54,940 --> 00:31:58,899
didn't hash into the slot, so on so forth, right?
没有散​​列到插槽中，依此类推，对吧？ 

603
00:31:59,099 --> 00:32:04,599
All the way up until en didn't hash to the slot.
一直到en没有散列到该插槽为止。 

604
00:32:04,599 --> 00:32:06,509
This makes sense?
这有道理吗？ 

605
00:32:06,509 --> 00:32:08,240
Now these are all independent events,
现在这些都是独立的事件， 

606
00:32:08,240 --> 00:32:10,440
because all the hashes are independent,
因为所有哈希都是独立的， 

607
00:32:10,440 --> 00:32:12,899
by the uniform hashing assumption.
通过统一的哈希假设。 

608
00:32:13,099 --> 00:32:16,859
So then I can turn ands into products.
这样我便可以将ands变成产品。 

609
00:32:16,859 --> 00:32:20,879
So I can say that this equals to the probability
所以我可以说这等于概率

610
00:32:20,880 --> 00:32:28,500
that e1 didn't hash into the slot, times the probability
 e1没有散列到插槽中，乘以概率

611
00:32:28,500 --> 00:32:34,990
that e2 didn't hash into the slot, times the probability
 e2没有散列到插槽中，乘以概率

612
00:32:34,990 --> 00:32:39,240
that e3 didn't hash into the slot, so on and so forth,
 e3没有散列到插槽中，依此类推， 

613
00:32:39,240 --> 00:32:43,914
all the way to the probability that en didn't hash.
一直到en没有散列的可能性。 

614
00:32:43,914 --> 00:32:51,799



615
00:32:51,799 --> 00:32:53,970
So since I'm dealing with the same hash function,
因此，由于我要处理相同的哈希函数， 

616
00:32:53,970 --> 00:32:56,920
turns out that all the probabilities are the same.
事实证明，所有概率都是相同的。 

617
00:32:56,920 --> 00:33:01,609
So there, the probability that some fixed number
因此，有一些固定数字的概率

618
00:33:01,809 --> 00:33:06,700
didn't hash, to the power n.
没有散​​列到力量n。 

619
00:33:06,700 --> 00:33:11,700



620
00:33:11,700 --> 00:33:15,299
So this is how I got from here to here.
这就是我从这里到这里的方式。 

621
00:33:15,299 --> 00:33:18,899
Probabilities and the properties of hashes and hashing
散列和散列的概率以及性质

622
00:33:18,900 --> 00:33:19,930
assumptions.
假设。 

623
00:33:19,930 --> 00:33:22,700
So you guys should have those on your cheat sheet,
所以你们应该在备忘单上放那些东西， 

624
00:33:22,700 --> 00:33:25,520
and maybe if you have time, review probabilities a bit.
也许如果您有时间，请回顾一下概率。 

625
00:33:25,520 --> 00:33:26,895
AUDIENCE: What is the probability
听众：几率是多少

626
00:33:26,895 --> 00:33:29,539
that any given one doesn't hash, 1/m?
给定的任何一个都不会散列，1 / m？ 

627
00:33:29,539 --> 00:33:32,696



628
00:33:32,696 --> 00:33:34,984
So if e1 doesn't hash in that spot,
因此，如果e1不在该位置进行散列， 

629
00:33:34,984 --> 00:33:37,689
isn't that probability 1/m?
这个概率不是1 / m吗？ 

630
00:33:37,690 --> 00:33:39,389
PROFESSOR: Not quite.
教授：不完全是。 

631
00:33:39,589 --> 00:33:41,519
You're close, but not quite.
您很亲密，但不完全是。 

632
00:33:41,519 --> 00:33:44,549
So you're saying that the probability that e1
所以你说e1的概率

633
00:33:44,549 --> 00:33:47,721
doesn't hash to this slot is 1/m?
不会哈希到这个插槽是1 / m？ 

634
00:33:47,721 --> 00:33:49,180
AUDIENCE: I guess it's 1 minus 1/m.
听众：我猜是1减去1 / m。 

635
00:33:49,180 --> 00:33:50,750
PROFESSOR: Exactly.
教授：是的。 

636
00:33:50,750 --> 00:33:52,589
The probability that it would hash here
它会在此处散列的概率

637
00:33:52,589 --> 00:33:55,480
is 1/m, because it has to pick that one slot out
是1 / m，因为它必须选择一个插槽

638
00:33:55,480 --> 00:33:57,630
of n possible slots.
 N个可能的广告位。 

639
00:33:57,630 --> 00:33:59,470
But if you're just saying, all I want
但是，如果您只是说，我想要的

640
00:33:59,470 --> 00:34:02,920
is that it doesn't hash here, well, it
是它不会在这里散列，嗯，它

641
00:34:02,920 --> 00:34:05,289
means it can hash anywhere else.
表示它可以在其他任何地方散列。 

642
00:34:05,289 --> 00:34:07,680
So it has m minus 1 options.
因此它有m减去1个选项。 

643
00:34:07,680 --> 00:34:09,849
It can go to any of those m minus 1 places,
它可以去那些m减去1的地方， 

644
00:34:09,849 --> 00:34:11,519
just not to that one place.
只是不去那个地方。 

645
00:34:11,519 --> 00:34:13,110
So m minus 1 over m.
所以m减去m减去1。 

646
00:34:13,110 --> 00:34:19,844



647
00:34:19,844 --> 00:34:22,250
AUDIENCE: It's interesting it went the other direction.
听众：有趣的是它朝另一个方向发展。 

648
00:34:22,250 --> 00:34:25,050
Instead of saying, it's 1, it's 1 minus it.
不用说，它是1，是1减去它。 

649
00:34:25,050 --> 00:34:27,387



650
00:34:27,387 --> 00:34:28,853
Wouldn't it have been just as easy to go
难道就这么容易

651
00:34:29,052 --> 00:34:30,409
the other direction, or no?
另一个方向，还是没有？ 

652
00:34:30,409 --> 00:34:32,510
PROFESSOR: No.
教授：不。 

653
00:34:32,510 --> 00:34:34,460
Not doing this makes the problem hard,
不这样做会使问题变得棘手， 

654
00:34:34,460 --> 00:34:36,489
so that's why we're doing it.
这就是我们这样做的原因。 

655
00:34:36,489 --> 00:34:40,099
This kind of flipping is easy to do conceptually,
从概念上讲，这种翻转很容易做到， 

656
00:34:40,099 --> 00:34:43,152
but it might make a hard problem into a really easy problem,
但这可能会使难题变得非常简单， 

657
00:34:43,152 --> 00:34:44,610
or at least into a do-able problem.
或至少成为一个可行的问题。 

658
00:34:44,610 --> 00:34:49,722



659
00:34:49,922 --> 00:34:52,337
AUDIENCE: Isn't it this the same thing?
听众：这不是一回事吗？ 

660
00:34:52,338 --> 00:34:55,474
I guess maybe not totally.
我想可能不是全部。 

661
00:34:55,474 --> 00:34:57,690
PROFESSOR: So it is exactly the same in terms of the math,
教授：在数学上完全一样， 

662
00:34:57,889 --> 00:35:01,875
but computing this without turning it into this
但是计算而不把它变成这个

663
00:35:01,875 --> 00:35:05,239
is really hard.
真的很难

664
00:35:05,239 --> 00:35:07,069
AUDIENCE: Any given slot is 1, isn't it
听众：给定的广告位是1，不是吗

665
00:35:07,070 --> 00:35:10,125
kind of like what we just said, except if the probability
有点像我们刚才说的，除非

666
00:35:10,125 --> 00:35:17,019
of any one mapping is 1/m, mapping to a 1, right?
哪一个映射是1 / m，映射到1，对不对？ 

667
00:35:17,019 --> 00:35:18,550
And then you take 1 over m raised
然后你把米数加1 

668
00:35:18,550 --> 00:35:23,635
to the n, that's the probability of it being a 1
到n，这就是它为1的可能性

669
00:35:23,635 --> 00:35:27,478
at that one place, right?
在那个地方吧？ 

670
00:35:27,478 --> 00:35:28,519
PROFESSOR: No, not quite.
教授：不，不是。 

671
00:35:28,519 --> 00:35:37,304



672
00:35:37,304 --> 00:35:40,250
Yeah.
是的

673
00:35:40,250 --> 00:35:43,610
OK, so are we getting this?
好吧，我们明白了吗？ 

674
00:35:43,610 --> 00:35:46,000
Somewhat?
有些？ 

675
00:35:46,000 --> 00:35:46,554
Yes?
是？ 

676
00:35:46,554 --> 00:35:48,500
AUDIENCE: So the probability of a false positive,
听众：因此，假阳性的可能性， 

677
00:35:48,500 --> 00:35:50,666
you're saying that's what's the probability that you
你是说那是你的几率

678
00:35:50,666 --> 00:35:53,804
get the 1, if you actually should [INAUDIBLE] the 0.
如果您实际上应该[听不清] 0，则得到1。 

679
00:35:54,003 --> 00:35:57,478
It's because multiple things mapped to that one slot, right?
这是因为有多个事物映射到该插槽，对吗？ 

680
00:35:57,478 --> 00:35:59,519
PROFESSOR: So the probability of a false positive
教授：所以误报的可能性

681
00:35:59,519 --> 00:36:04,420
is the probability that, given a new element, when we hash it
是给定一个新元素时我们对其进行哈希处理的概率

682
00:36:04,420 --> 00:36:07,260
we get the 1.
我们得到1。 

683
00:36:07,260 --> 00:36:09,927
The hash of that new element is independent of all
该新元素的哈希值独立于所有

684
00:36:09,927 --> 00:36:10,635
the other hashes.
其他哈希。 

685
00:36:10,635 --> 00:36:12,898



686
00:36:12,898 --> 00:36:14,614
AUDIENCE: Then why is it simple in probability
听众：那么为什么概率如此简单

687
00:36:14,813 --> 00:36:17,876
that you get the 1?
你得到1？ 

688
00:36:17,876 --> 00:36:19,460
PROFESSOR: So if I have a new element,
教授：所以，如果我有一个新要素， 

689
00:36:19,460 --> 00:36:21,349
I'm going to compute its hash, and I'm
我要计算它的哈希值， 

690
00:36:21,349 --> 00:36:22,969
going to look in the table.
去看表。 

691
00:36:22,969 --> 00:36:24,800
If I see a 1, I'm going to say, oh.
如果我看到1，我会说，哦。 

692
00:36:24,800 --> 00:36:26,175
AUDIENCE: Oh, it's a new element.
听众：哦，这是一个新元素。 

693
00:36:26,175 --> 00:36:26,239
OK.
好。 

694
00:36:26,239 --> 00:36:27,655
PROFESSOR: Yeah, so it's something
教授：是的，这就是

695
00:36:27,655 --> 00:36:29,230
that was not in the set.
那不在集合中。 

696
00:36:29,230 --> 00:36:30,713
AUDIENCE: OK.
听众：好的。 

697
00:36:30,713 --> 00:36:31,630
PROFESSOR: Okay, cool.
教授：好的，很酷。 

698
00:36:31,630 --> 00:36:36,940



699
00:36:36,940 --> 00:36:40,079
OK, so let's see if we can do a harder version of this.
好的，让我们看看是否可以对此做一个更硬的版本。 

700
00:36:40,079 --> 00:36:43,000



701
00:36:43,000 --> 00:36:48,030
So this probability isn't great, but if we do one trick,
因此，这种可能性并不大，但如果我们采取了一种技巧， 

702
00:36:48,030 --> 00:36:49,190
we can make this really nice.
我们可以使它变得非常好。 

703
00:36:49,389 --> 00:36:52,429
And this puts together a trick called bloom filters that
这汇集了一个称为Bloom过滤器的技巧

704
00:36:52,429 --> 00:36:54,489
is used in all sorts of situations.
用于各种情况。 

705
00:36:54,489 --> 00:37:01,509



706
00:37:01,510 --> 00:37:07,019
So for Bloom filters, we still have n elements,
因此，对于Bloom过滤器，我们仍然有n个元素， 

707
00:37:07,219 --> 00:37:11,174
and we still have a table of m bits.
我们还有一张m位的表格

708
00:37:11,175 --> 00:37:16,110



709
00:37:16,309 --> 00:37:19,230
What changes this time is instead of having one function,
这次改变的是没有一个功能， 

710
00:37:19,230 --> 00:37:21,510
we have k hash functions.
我们有k个哈希函数。 

711
00:37:21,510 --> 00:37:27,570



712
00:37:27,570 --> 00:37:30,920
So when we take an element and insert it,
因此，当我们采用一个元素并将其插入时， 

713
00:37:31,119 --> 00:37:32,929
we're taking element i.
我们正在考虑元素i。 

714
00:37:32,929 --> 00:37:34,639
The way to insert it is we're going
插入它的方法是我们要

715
00:37:34,639 --> 00:37:43,980
to compute its hash value using all the hash functions,
使用所有哈希函数计算其哈希值， 

716
00:37:43,980 --> 00:37:46,500
and set all the corresponding bits to 1.
并将所有相应的位设置为1。 

717
00:37:46,500 --> 00:37:54,010



718
00:37:54,010 --> 00:38:06,150
So insert ei becomes, for j in 1 through k,
因此，对于在1至k中的j，插入ei变为

719
00:38:06,349 --> 00:38:09,529
the table bit corresponding to the hash function, j,
对应于哈希函数j的表位， 

720
00:38:09,530 --> 00:38:13,769
of the element is 1.
的元素是1。 

721
00:38:13,969 --> 00:38:16,029
So each element sets k bits to 1.
因此，每个元素将k位设置为1。 

722
00:38:16,030 --> 00:38:19,050



723
00:38:19,050 --> 00:38:21,130
Now how do we check if an element is in the table?
现在我们如何检查表中是否有元素？ 

724
00:38:21,329 --> 00:38:26,394



725
00:38:26,394 --> 00:38:27,269
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

726
00:38:27,269 --> 00:38:34,679



727
00:38:34,679 --> 00:38:36,179
PROFESSOR: Since, for every element,
教授：因为，对于每个要素， 

728
00:38:36,179 --> 00:38:38,980
we set all the corresponding k bits to 1, now when
我们将所有对应的k位设置为1，现在

729
00:38:38,980 --> 00:38:40,849
we have a new element, we're going
我们有一个新元素，我们要

730
00:38:40,849 --> 00:38:44,900
to compute to the k positions, and if any of them is a 0,
计算到k个位置，如果其中任何一个为0， 

731
00:38:44,900 --> 00:38:47,539
then we couldn't have possibly put that in the table.
那么我们不可能将其放在桌子上。 

732
00:38:47,539 --> 00:38:52,610



733
00:38:52,610 --> 00:39:03,829
So all T of h j of f have to be 1.
因此f的hj的所有T必须为1。 

734
00:39:03,829 --> 00:39:06,529



735
00:39:06,530 --> 00:39:09,070
So for every element, we hashed it k times,
因此，对于每个元素，我们将其散列k次， 

736
00:39:09,070 --> 00:39:10,789
and set the corresponding bits.
并设置相应的位。 

737
00:39:10,989 --> 00:39:17,729
If we have a new element, and by hashing we get here and here,
如果我们有一个新元素，通过散列，我们可以到达此处和此处， 

738
00:39:17,730 --> 00:39:21,369
but we also get here, and this guy was a zero,
但是我们也到了这里，这个家伙是零， 

739
00:39:21,369 --> 00:39:23,136
we know we definitely didn't put this in.
我们知道我们绝对没有把它放进去。 

740
00:39:23,137 --> 00:39:25,940



741
00:39:25,940 --> 00:39:28,480
So now what's the probability of a false positive?
那么，现在出现误报的概率是多少？ 

742
00:39:28,480 --> 00:39:33,420



743
00:39:33,420 --> 00:39:36,384
AUDIENCE: My first intuition is just raising that to a power.
听众：我的第一个直觉是将其提升为力量。 

744
00:39:36,384 --> 00:39:41,324



745
00:39:41,324 --> 00:39:44,222
AUDIENCE: The probability that when you check--
听众：当您检查- 

746
00:39:44,222 --> 00:39:46,230
PROFESSOR: Oh, I forgot to say something, by the way.
教授：哦，我忘了说些什么。 

747
00:39:46,429 --> 00:39:50,319
The k hash functions-- I think they satisfy simple uniform
 k哈希函数-我认为它们满足简单的统一要求

748
00:39:50,320 --> 00:39:51,085
hashing.
哈希。 

749
00:39:51,284 --> 00:39:52,909
I'm not sure if that's the right thing,
我不确定这是否正确， 

750
00:39:52,909 --> 00:39:55,344
but they all have independent values from each other.
但是它们彼此之间具有独立的价值。 

751
00:39:55,344 --> 00:39:56,469
So they're all independent.
所以他们都是独立的。 

752
00:39:56,469 --> 00:40:02,079



753
00:40:02,079 --> 00:40:05,170
So for any number you give, any hash function
因此，对于您给出的任何数字，任何哈希函数

754
00:40:05,170 --> 00:40:07,000
returns a value that's independent of all
返回一个独立于所有值的值

755
00:40:07,000 --> 00:40:10,550
the other hash functions, and they're all 0
其他哈希函数，它们全为0 

756
00:40:10,550 --> 00:40:11,299
through n minus 1.
到n减1。 

757
00:40:11,300 --> 00:40:18,500



758
00:40:18,500 --> 00:40:20,780
AUDIENCE: Why is not that just raised to something?
听众：为什么不只是提出一些建议？ 

759
00:40:20,780 --> 00:40:22,121
Because we know the probability-- OK,
因为我们知道可能性-好吧， 

760
00:40:22,320 --> 00:40:25,289
actually we need to recalculate that.
实际上我们需要重新计算。 

761
00:40:25,289 --> 00:40:27,581
AUDIENCE: Because it's the probability that all of them
听众：因为这是所有人

762
00:40:27,581 --> 00:40:30,606
are 1, even though you haven't hashed yet.
为1，即使您尚未进行哈希处理。 

763
00:40:30,606 --> 00:40:35,730



764
00:40:35,929 --> 00:40:38,129
PROFESSOR: So the false positive, the probability
教授：所以误报，概率

765
00:40:38,130 --> 00:40:40,280
of false positives is the probability
误报是概率

766
00:40:40,280 --> 00:40:46,795
that all the k slots that correspond to f are 1's, right?
对应于f的所有k个时隙都是1。 

767
00:40:46,994 --> 00:40:54,759



768
00:40:54,760 --> 00:41:01,420
So, since the hash functions are all independent,
因此，由于哈希函数都是独立的， 

769
00:41:01,619 --> 00:41:03,730
this is the probability that one slot
这是一个插槽的概率

770
00:41:03,730 --> 00:41:05,809
is the 1, raised to the power k.
是1，提高到幂k。 

771
00:41:05,809 --> 00:41:08,940
Right, because they're all independent slots.
是的，因为它们都是独立的插槽。 

772
00:41:08,940 --> 00:41:14,159
So it's the probability that one slot
所以这是一个插槽的概率

773
00:41:14,159 --> 00:41:18,739
is a 1, raised to the power k.
是1，提高到幂k。 

774
00:41:18,739 --> 00:41:20,509
OK, so now what's the probability
好，那现在有几率

775
00:41:20,510 --> 00:41:22,500
that one slot is a 1?
一个插槽是1？ 

776
00:41:22,500 --> 00:41:26,170
It looks a lot like this problem, right?
看起来很像这个问题，对吗？ 

777
00:41:26,170 --> 00:41:27,849
Except there's a tweak.
除非有调整。 

778
00:41:27,849 --> 00:41:30,293
How many times did we put the 1 in the table?
我们将1放在表中多少次了？ 

779
00:41:30,293 --> 00:41:33,429



780
00:41:33,429 --> 00:41:38,009
So here, we put a 1 in the table for every element.
因此，在这里，我们为每个元素在表中放置1。 

781
00:41:38,010 --> 00:41:42,920
So we have n sets, right?
所以我们有n套，对吗？ 

782
00:41:42,920 --> 00:41:49,019
So n times we're going to set t of something to 1.
所以n次我们将把t设置为1。 

783
00:41:49,219 --> 00:41:52,219



784
00:41:52,219 --> 00:41:53,159
Right?
对？ 

785
00:41:53,159 --> 00:41:55,690
For every element, we have one set.
对于每个元素，我们都有一套。 

786
00:41:55,690 --> 00:41:57,048
We set one bit to 1.
我们将一位设置为1。 

787
00:41:57,048 --> 00:41:59,340
It might have been said before-- that's something else.
之前可能有人说过-那是另外一回事。 

788
00:41:59,340 --> 00:41:59,840
Yes?
是？ 

789
00:41:59,840 --> 00:42:03,570
AUDIENCE: So here it's raised to the m k?
听众：那么，这里已经提高到mk了吗？ 

790
00:42:03,570 --> 00:42:05,789
PROFESSOR: Yeah, pretty much.
教授：是的，差不多。 

791
00:42:05,789 --> 00:42:08,440
So here, for every element we hash it through all the k
所以在这里，对于每个元素，我们将其遍历所有k 

792
00:42:08,440 --> 00:42:12,210
functions, and set the corresponding bits to 1.
功能，并将相应的位设置为1。 

793
00:42:12,210 --> 00:42:20,369
So one element generates k set operations,
因此，一个元素生成k个set运算， 

794
00:42:20,369 --> 00:42:25,230
and we have n elements, so we set n k bits to 1.
并且我们有n个元素，因此我们将nk位设置为1。 

795
00:42:25,230 --> 00:42:35,059



796
00:42:35,059 --> 00:42:36,273
Does this make sense?
这有意义吗？ 

797
00:42:36,273 --> 00:42:39,753
AUDIENCE: Can two hash functions point to the same slot?
听众：两个哈希函数可以指向同一插槽吗？ 

798
00:42:39,753 --> 00:42:40,420
PROFESSOR: Sure.
教授：当然可以。 

799
00:42:40,420 --> 00:42:43,215



800
00:42:43,215 --> 00:42:44,839
But they're all independent, and that's
但是他们都是独立的，那是

801
00:42:44,840 --> 00:42:46,840
the only thing that matters.
唯一重要的事情。 

802
00:42:46,840 --> 00:42:50,000
So every time we set the bit, which bit was set
因此，每次设置位时，哪个位被设置

803
00:42:50,000 --> 00:42:54,380
is independent of all the other bits we set,
与我们设置的所有其他位无关， 

804
00:42:54,380 --> 00:42:56,500
because all the hash functions are independent,
因为所有哈希函数都是独立的， 

805
00:42:56,500 --> 00:42:58,559
and all the values are independent of each other.
并且所有值彼此独立。 

806
00:42:58,559 --> 00:43:01,829



807
00:43:01,829 --> 00:43:05,409
So this time, the table size is still m, so that didn't change.
因此，这次表的大小仍然是m，因此没有变化。 

808
00:43:05,409 --> 00:43:08,750
This time we set n bits to 1, this time we set n k bits to 1.
这次我们将n位设置为1，这次我们将nk位设置为1。 

809
00:43:08,750 --> 00:43:12,420
So then the right thing to do is copy this answer,
因此，正确的做法是复制此答案， 

810
00:43:12,420 --> 00:43:14,789
and replace n with n k.
并将n替换为n k。 

811
00:43:14,789 --> 00:43:17,329
And if you have to write the proof,
如果您必须写证明， 

812
00:43:17,329 --> 00:43:19,969
you'd copy-paste the proof and replace n with n k.
您将复制粘贴证明并将n替换为n k。 

813
00:43:19,969 --> 00:43:26,460



814
00:43:26,460 --> 00:43:32,900
So this is 1 minus m minus 1, over m, times n k.
因此，这是1减去m减去1，乘以m乘以n k。 

815
00:43:32,900 --> 00:43:35,815



816
00:43:35,815 --> 00:43:37,940
And of course you should go through the whole thing
当然，您应该仔细研究整个过程

817
00:43:37,940 --> 00:43:40,324
in your head and convince yourselves that this is true.
在你的脑海中说服自己，这是真的。 

818
00:43:40,324 --> 00:43:42,289
AUDIENCE: Does that say one of the elements is what?
听众：这是否说明要素之一是什么？ 

819
00:43:42,489 --> 00:43:44,459
k, something?
 k，什么？ 

820
00:43:44,460 --> 00:43:45,460
AUDIENCE: Sets.
观众：集合。 

821
00:43:45,460 --> 00:43:47,269
PROFESSOR: Bit sets.
教授：位设置。 

822
00:43:47,269 --> 00:43:51,920
So one element sets k bits in the table, not necessarily
因此，一个元素在表中设置了k位，不一定

823
00:43:51,920 --> 00:43:54,400
different bits, just independent bits.
不同的位，只是独立的位。 

824
00:43:54,400 --> 00:43:56,349
So if you have n elements altogether,
因此，如果您总共有n个元素， 

825
00:43:56,349 --> 00:43:57,913
they set n times k bits.
他们设置n乘以k位。 

826
00:43:57,913 --> 00:44:09,119



827
00:44:09,119 --> 00:44:14,880
This thing gets run n times k times, whereas here,
这个东西运行了n次k次，而在这里， 

828
00:44:14,880 --> 00:44:20,980
the set operation gets run n times in total.
设置操作总共要运行n次。 

829
00:44:21,179 --> 00:44:22,929
That's the difference in the two problems.
那是两个问题的区别。 

830
00:44:22,929 --> 00:44:30,359



831
00:44:30,360 --> 00:44:32,559
Right here you have one function for each element,
在这里，每个元素都有一个功能， 

832
00:44:32,559 --> 00:44:34,054
here you have k hash functions.
在这里，您有k个哈希函数。 

833
00:44:34,054 --> 00:44:44,239



834
00:44:44,239 --> 00:44:46,500
This is hard, right?
这很难，对吗？ 

835
00:44:46,500 --> 00:44:50,059
Well, it's the hardest hashing problem
好吧，这是最困难的哈希问题

836
00:44:50,059 --> 00:44:51,529
that I could think about and that
我能想到的

837
00:44:51,530 --> 00:44:54,230
makes us go through probabilities and through all
使我们经历概率和所有

838
00:44:54,429 --> 00:44:55,989
the hash stuff.
哈希的东西。 

839
00:44:55,989 --> 00:44:59,199
The problems on the exam will be easier, so one, don't panic.
考试中的问题会更容易，所以不要惊慌。 

840
00:44:59,199 --> 00:45:02,719
Two, review hashing, review probabilities.
二，查看哈希，查看概率。 

841
00:45:02,719 --> 00:45:06,159
When I said, from the theory, this is what you get,
当我说从理论上讲，这就是你所得到的， 

842
00:45:06,159 --> 00:45:09,539
if you didn't understand that then please review the theory.
如果您不了解，请复习一下理论。 

843
00:45:09,539 --> 00:45:11,550
AUDIENCE: Why is it raised to the k?
听众：为什么将它提高到k？ 

844
00:45:11,550 --> 00:45:14,590
Because we did down there, if we replace n with n k,
因为我们在那边做了，如果我们用nk代替n， 

845
00:45:14,590 --> 00:45:18,309
then we'd just get everything except.
然后我们将得到所有东西，除了。 

846
00:45:18,309 --> 00:45:22,509
PROFESSOR: So this thing in here is the answer
教授：所以这是答案

847
00:45:22,510 --> 00:45:28,500
to the previous problem, except you take an n
到前面的问题，除了你拿n 

848
00:45:28,500 --> 00:45:31,639
and you replace it with an n k.
然后将其替换为n k 

849
00:45:31,639 --> 00:45:36,559
So this is the probability that one bit is set to 1.
因此，这就是将一位设置为1的可能性。 

850
00:45:36,559 --> 00:45:38,429
But here, when you're given an element,
但是在这里，当您得到一个元素时， 

851
00:45:38,429 --> 00:45:41,449
you're going to hash it through the k functions-- you take
您将通过k函数对其进行哈希处理- 

852
00:45:41,449 --> 00:45:44,549
this guy-- you're going to hash it through the k functions,
这个家伙-您将通过k函数对其进行哈希处理， 

853
00:45:44,550 --> 00:45:46,380
and you're going to check all the bits.
然后您将检查所有位。 

854
00:45:46,579 --> 00:45:50,449
So you're going to check k bits.
因此，您将要检查k位。 

855
00:45:50,449 --> 00:45:53,129
So as long as any of the k bits is a zero, not
因此，只要k个位中的任何一个为零， 

856
00:45:53,130 --> 00:45:54,940
a false positive.
误报。 

857
00:45:55,139 --> 00:45:58,811
So we need all the k bits to be a 1.
所以我们需要所有的k位都为1。 

858
00:45:58,811 --> 00:45:59,644
AUDIENCE: Oh, I see.
听众：哦，我知道了。 

859
00:45:59,644 --> 00:46:02,579



860
00:46:02,579 --> 00:46:04,777
AUDIENCE: What if the hash functions are dependent?
听众：如果哈希函数是依赖的，该怎么办？ 

861
00:46:04,976 --> 00:46:06,434
PROFESSOR: Then become intractable.
教授：然后变得棘手。 

862
00:46:06,434 --> 00:46:09,139



863
00:46:09,139 --> 00:46:11,529
AUDIENCE: And what if they are?
听众：如果他们呢？ 

864
00:46:11,530 --> 00:46:15,170



865
00:46:15,369 --> 00:46:19,769
I think the in this problem, the way they are being hashed,
我认为在这个问题上，他们被散列的方式， 

866
00:46:19,769 --> 00:46:21,565
that becomes dependent, because I
变得依赖，因为我

867
00:46:21,565 --> 00:46:24,669
think there were some problems where, if something is being
认为有些问题在哪里，如果正在发生

868
00:46:24,670 --> 00:46:27,693
hashed somewhere, then the probability--
散列在某个地方，那么概率- 

869
00:46:27,693 --> 00:46:29,110
there could be hash functions that
可能有哈希函数

870
00:46:29,110 --> 00:46:33,980
would put the other thing in the next slot.
会将其他东西放在下一个广告位中。 

871
00:46:33,980 --> 00:46:36,769
PROFESSOR: Yes, so you want to reduce these problems
教授：是的，所以您想减少这些问题

872
00:46:36,769 --> 00:46:37,869
to independent hashing.
到独立的哈希。 

873
00:46:37,869 --> 00:46:40,049
If you look at the proofs, all the proofs
如果看样张，所有的样张

874
00:46:40,050 --> 00:46:42,690
assume uniform hashing, simple uniform,
假设统一哈希，简单统一， 

875
00:46:42,889 --> 00:46:45,721
whatever it takes to get the math down to independence.
无论如何使数学降至独立。 

876
00:46:45,722 --> 00:46:47,105
Because this is the only thing that we
因为这是我们唯一的事情

877
00:46:47,304 --> 00:46:49,309
know how to solve with probabilities.
知道如何用概率解决。 

878
00:46:49,309 --> 00:46:51,090
If everything is independent, then things
如果一切都是独立的，那么事情

879
00:46:51,090 --> 00:46:54,500
multiply and add up in the right places, and everything is easy.
在正确的地方相乘并相加，一切都很容易。 

880
00:46:54,699 --> 00:46:56,719
If things are dependent, then proofs
如果事情是依赖的，那么证明

881
00:46:56,719 --> 00:46:57,889
become really, really hard.
变得非常非常困难。 

882
00:46:57,889 --> 00:46:59,750
So whenever you have dependent things,
因此，只要您有依赖的东西， 

883
00:46:59,750 --> 00:47:02,396
you want to find a way to reduce that to independent things.
您想找到一种将其简化为独立事物的方法。 

884
00:47:02,396 --> 00:47:15,559



885
00:47:15,559 --> 00:47:17,860
Is everyone tired, or do you guys really
大家都累了吗，还是你们真的

886
00:47:17,860 --> 00:47:19,829
not like this problem?
不喜欢这个问题吗？ 

887
00:47:19,829 --> 00:47:23,179
By the way, really cool trick-- so this
顺便说一句，很酷的技巧-所以这

888
00:47:23,179 --> 00:47:25,259
turns out to be a lot better than that,
事实证明比这要好得多， 

889
00:47:25,260 --> 00:47:27,280
and I think the optimal value of k
我认为k的最优值

890
00:47:27,280 --> 00:47:30,150
is around square roots of log n.
在log n的平方根附近。 

891
00:47:30,150 --> 00:47:34,019
And that gives you some filters with a really low
这为您提供了一些过滤器

892
00:47:34,219 --> 00:47:36,243
false positive rate.
误报率。 

893
00:47:36,244 --> 00:47:38,480
AUDIENCE: What do you mean by optimal?
听众：您所说的最优意味着什么？ 

894
00:47:38,679 --> 00:47:41,079
PROFESSOR: Minimize the false positives.
教授：尽量减少误报。 

895
00:47:41,079 --> 00:47:47,840
So given n and m, pick a case so that this thing is minimized.
因此，给定n和m，请选择一个案例，以使该问题最小化。 

896
00:47:47,840 --> 00:47:50,170
AUDIENCE: What was the answer again?
听众：答案又是什么？ 

897
00:47:50,369 --> 00:47:52,811
Or actually, regardless of that, what's
或实际上，不管怎样，这是什么

898
00:47:52,811 --> 00:47:55,539
the percentage of false positives?
误报的百分比？ 

899
00:47:55,539 --> 00:47:58,269
PROFESSOR: It depends on what your n and m are, right?
教授：这取决于您的n和m，对吗？ 

900
00:47:58,269 --> 00:48:00,039
The more bits you can afford
您可以承受的位数更多

901
00:48:00,039 --> 00:48:01,509
AUDIENCE: But if maximize your k,
听众：但是如果最大化k， 

902
00:48:01,510 --> 00:48:05,900
you said you came up with some k that's maximized
你说你想出了最大的k 

903
00:48:06,099 --> 00:48:07,078
PROFESSOR: I think k is
教授：我认为k是

904
00:48:07,079 --> 00:48:08,170
AUDIENCE: Square root of log n.
听众：日志n的平方根。 

905
00:48:08,369 --> 00:48:10,963



906
00:48:10,963 --> 00:48:12,659
AUDIENCE: So then if you use that.
听众：那么如果您使用它。 

907
00:48:12,659 --> 00:48:14,205
PROFESSOR: Let's not do the math.
教授：我们不做数学。 

908
00:48:14,206 --> 00:48:15,394
[LAUGHTER]
 [笑声] 

909
00:48:15,594 --> 00:48:16,899
It's really, really good.
真的，真的很好。 

910
00:48:16,900 --> 00:48:21,539
So these are used for all sorts of practical problems, all
因此，这些用于各种实际问题， 

911
00:48:21,539 --> 00:48:25,268
the way from branch predictors in processors, to databases.
从处理器中的分支预测变量到数据库的方式。 

912
00:48:25,268 --> 00:48:26,635
AUDIENCE: So is it better than 1%?
听众：那么它是否比1％好？ 

913
00:48:26,835 --> 00:48:27,959
Do you know that, at least?
至少你知道吗？ 

914
00:48:27,960 --> 00:48:33,210
PROFESSOR: Oh yeah, for practical uses, this gets you,
教授：是的，对于实际用途，这可以使您， 

915
00:48:33,210 --> 00:48:36,030
I think to 1% of 1% of 1%.
我认为是1％的1％。 

916
00:48:36,030 --> 00:48:41,480



917
00:48:41,679 --> 00:48:45,109
So usually, put a Bloom filter before a really expensive
因此，通常情况下，将Bloom过滤器放在价格昂贵的

918
00:48:45,110 --> 00:48:48,300
check, and the Bloom filter gets rid of most
检查，Bloom过滤器将摆脱大多数

919
00:48:48,300 --> 00:48:50,264
of the false positives.
误报。 

920
00:48:50,264 --> 00:48:51,480
And then you have a few more where
然后你还有一些地方

921
00:48:51,679 --> 00:48:53,205
you do the more expensive check.
您进行更昂贵的检查。 

922
00:48:53,206 --> 00:49:05,420



923
00:49:05,619 --> 00:49:06,951
Okay, does this make sense?
好吧，这有意义吗？ 

924
00:49:06,952 --> 00:49:11,039



925
00:49:11,239 --> 00:49:11,909
Any questions?
任何问题？ 

926
00:49:11,909 --> 00:49:15,289



927
00:49:15,289 --> 00:49:19,811
AUDIENCE: Do you more optimal if you repeated this Bloom
观众：如果您重复此Bloom，您会更理想吗？ 

928
00:49:19,811 --> 00:49:22,039
filter independently of the other one,
独立于另一个过滤器

929
00:49:22,039 --> 00:49:25,329
with more hash functions in that memory structure?
在该内存结构中具有更多哈希函数？ 

930
00:49:25,329 --> 00:49:31,090
PROFESSOR: I think doubling the memory size is better.
教授：我认为将内存大小加倍会更好。 

931
00:49:31,090 --> 00:49:33,400
So two filters is the same as having two n bits.
因此，两个滤波器等同于具有两个n位。 

932
00:49:33,599 --> 00:49:36,150
I think doubling gives you better results, always.
我认为加倍总是可以为您带来更好的结果。 

933
00:49:36,150 --> 00:49:47,500



934
00:49:47,500 --> 00:49:48,650
OK, so general stuff.
好，一般的东西。 

935
00:49:48,650 --> 00:49:51,610
We're going to have a lot of conceptual questions,
我们将有很多概念性问题， 

936
00:49:51,610 --> 00:49:55,300
so please make sure, again, make sure that for everything
所以请再次确保所有内容

937
00:49:55,300 --> 00:49:57,130
that we did, go through the problem.
我们所做的，解决问题。 

938
00:49:57,130 --> 00:50:00,760
Understand the problem, know that there is a solution.
了解问题，知道有解决方案。 

939
00:50:00,760 --> 00:50:02,230
Know the running time, maybe know
知道运行时间，也许知道

940
00:50:02,429 --> 00:50:03,879
how to implement the solution.
如何实施解决方案。 

941
00:50:03,880 --> 00:50:05,905
Don't worry so much about the proof.
不必太担心证明。 

942
00:50:05,905 --> 00:50:07,530
We're going to have some problems where
我们将在哪里遇到一些问题

943
00:50:07,530 --> 00:50:10,150
you have to come up with new things on your own,
你必须自己想出新的东西， 

944
00:50:10,150 --> 00:50:12,750
so get a good night's sleep before the exam.
因此，考试前要睡个好觉。 

945
00:50:12,949 --> 00:50:14,494
Really, if you have five hours left,
真的，如果您还有五个小时， 

946
00:50:14,494 --> 00:50:16,619
then you have to choose between sleeping five hours
那你必须选择睡五个小时

947
00:50:16,619 --> 00:50:18,984
or reading notes for five hours--
或阅读笔记五个小时

948
00:50:18,985 --> 00:50:21,059
AUDIENCE: Drink caffeine.
听众：喝咖啡因。 

949
00:50:21,059 --> 00:50:22,480
PROFESSOR: It's not going to help,
教授：这无济于事， 

950
00:50:22,480 --> 00:50:24,300
so caffeine actually helps you stay up,
因此咖啡因实际上可以帮助您熬夜， 

951
00:50:24,300 --> 00:50:26,280
but it decreases your performance.
但是会降低您的效果。 

952
00:50:26,280 --> 00:50:30,030
And so if you're on caffeine, you're not going to think.
因此，如果您使用咖啡因，就不会思考。 

953
00:50:30,030 --> 00:50:33,530
You can regurgitate stuff, but you can't think.
您可以反省东西，但您无法考虑。 

954
00:50:33,530 --> 00:50:36,556
So caffeinating yourself is a--
因此，咖啡因是- 

955
00:50:36,556 --> 00:50:39,670
AUDIENCE: I thought it was like it gives you concentration.
听众：我以为这让你专心。 

956
00:50:39,670 --> 00:50:42,460
PROFESSOR: So there's an optimum amount of sleep and caffeine
教授：所以有充足的睡眠和咖啡因

957
00:50:42,460 --> 00:50:43,079
combination.
组合。 

958
00:50:43,079 --> 00:50:45,239
If you don't sleep and caffeinate yourself,
如果你不睡觉就喝咖啡

959
00:50:45,239 --> 00:50:46,719
I guarantee that you will not solve
我保证你不会解决

960
00:50:46,719 --> 00:50:49,245
any of the problems that require new algorithms.
任何需要新算法的问题。 

961
00:50:49,246 --> 00:50:51,619
AUDIENCE: Caffeine just squirts adrenaline in your brain.
听众：咖啡因只会在您的大脑中喷出肾上腺素。 

962
00:50:51,619 --> 00:50:54,869
It doesn't do anything else.
它什么也没做。 

963
00:50:54,869 --> 00:50:57,369
PROFESSOR: So the thing is the memory is going to be better.
教授：所以问题是记忆会更好。 

964
00:50:57,369 --> 00:50:59,269
If all you're doing is memorization stuff,
如果你只是做背诵的东西， 

965
00:50:59,269 --> 00:51:01,230
then it's going to be better.
那就会更好。 

966
00:51:01,230 --> 00:51:03,849
So you're going to do well on the pattern matching stuff.
因此，您将在模式匹配方面做得很好。 

967
00:51:03,849 --> 00:51:05,289
But when your brain is panicking,
但是当你的大脑惊慌时， 

968
00:51:05,289 --> 00:51:07,539
you're not going to come up with new solutions, right?
您不会提出新的解决方案，对吗？ 

969
00:51:07,539 --> 00:51:10,029
Usually, you have a problem, a hard problem.
通常，您有问题，很难解决。 

970
00:51:10,030 --> 00:51:12,170
You're thinking about it, and then at some point
您正在考虑，然后在某个时候

971
00:51:12,369 --> 00:51:14,494
when you're relaxed, like when you're in the shower
当你放松的时候，比如在洗澡的时候

972
00:51:14,494 --> 00:51:18,380
or when you wake up you're like, crap, I found a solution.
或当您醒来时，就像垃圾，我找到了解决方案。 

973
00:51:18,380 --> 00:51:20,269
So the brain finds solutions when it's relaxed,
因此，当大脑放松时，大脑会找到解决方案， 

974
00:51:20,469 --> 00:51:23,159
not when it's like, holy shit, holy shit, holy shit.
不是那样的时候，圣屎，圣屎，圣屎。 

975
00:51:23,159 --> 00:51:26,569
And adrenaline gets it in that mood.
肾上腺素使它充满那种心情。 

976
00:51:26,570 --> 00:51:27,500
That's what it does.
这就是它的作用。 

977
00:51:27,699 --> 00:51:29,919
And that's what caffeine does in the end.
这就是咖啡因最终的作用。 

978
00:51:29,920 --> 00:51:32,769
So a little bit of caffeine might help you get up
所以一点咖啡因可能会帮助你起床

979
00:51:32,969 --> 00:51:35,250
and get you running, but don't caffeinate
让你跑步，但不要咖啡因

980
00:51:35,250 --> 00:51:37,989
yourself to not sleep the entire night.
自己不要整夜睡觉。 

981
00:51:37,989 --> 00:51:40,519
That's probably going to make you bomb the hard questions.
这可能会让您炸开难题。 

982
00:51:40,519 --> 00:51:41,550
Good luck on Friday.
星期五好运。 

983
00:51:41,550 --> 00:51:42,940
Eat candy.
吃糖果。 

984
00:51:43,139 --> 00:51:48,139



