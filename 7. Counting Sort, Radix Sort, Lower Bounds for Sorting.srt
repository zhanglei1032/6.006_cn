1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:21,879



10
00:00:22,079 --> 00:00:24,659
PROFESSOR: Last lecture on sorting.
教授：关于分类的最后一次演讲。 

11
00:00:24,660 --> 00:00:27,350
Yay.
好极了。 

12
00:00:27,350 --> 00:00:29,679
And it's one of the coolest lectures on sorting,
这是有关分类的最酷的演讲之一， 

13
00:00:29,879 --> 00:00:30,869
I would say.
我会说。 

14
00:00:30,870 --> 00:00:33,399
We're going to talk about linear-time sorting, when it's
我们将讨论线性时间排序

15
00:00:33,399 --> 00:00:36,109
possible and when it's not possible,
可能，而当不可能时， 

16
00:00:36,109 --> 00:00:40,369
and this lecture sort of follows the tried and tested
这堂课遵循了久经考验的

17
00:00:40,369 --> 00:00:45,919
mathematical structure which is theorem, proof, counterexample.
定理，证明，反例的数学结构。 

18
00:00:45,920 --> 00:00:48,169
So we're going to start with a theorem which
因此，我们将从一个定理开始

19
00:00:48,369 --> 00:00:53,489
is that sorting requires n lg n time at least in the worst case
至少在最坏的情况下，排序需要n lg n次

20
00:00:53,490 --> 00:00:56,460
and we're going to then prove that in fact, you can get away
然后我们将证明事实是，您可以逃脱

21
00:00:56,460 --> 00:01:00,020
with linear time sometimes.
与线性时间有时。 

22
00:01:00,020 --> 00:01:02,590
Both of these terms are correct, but they're slightly
这两个词都是正确的，但它们略有不同

23
00:01:02,590 --> 00:01:04,159
different models of computation.
不同的计算模型。 

24
00:01:04,159 --> 00:01:06,890
Remember models of computation from lecture two?
还记得第二课的计算模型吗？ 

25
00:01:06,890 --> 00:01:09,799
So we're going to talk about a new model of computation, which
因此，我们将讨论一种新的计算模型

26
00:01:09,799 --> 00:01:13,000
we've sort of been using for most algorithms lately,
我们最近一直在使用大多数算法， 

27
00:01:13,000 --> 00:01:15,030
called the comparison model.
称为比较模型。 

28
00:01:15,030 --> 00:01:16,750
And it's a model of computations that's
这是一个计算模型

29
00:01:16,750 --> 00:01:18,680
really useful for proving lower bounds which
对于证明下界非常有用

30
00:01:18,680 --> 00:01:20,177
we haven't done much of yet.
我们还没有做很多事情。 

31
00:01:20,177 --> 00:01:22,260
We're going to prove two very simple lower bounds.
我们将证明两个非常简单的下界。 

32
00:01:22,260 --> 00:01:24,840
One is that searching requires lg n time.
一种是搜索需要lg n时间。 

33
00:01:24,840 --> 00:01:27,039
This is basically binary search is optimal.
这基本上是二进制搜索的最佳选择。 

34
00:01:27,239 --> 00:01:29,429
And the other is that sorting requires n lg n time.
另一个是排序需要n lg n个时间。 

35
00:01:29,430 --> 00:01:31,950
This is that merge sort is optimal.
这是合并排序是最佳的。 

36
00:01:31,950 --> 00:01:34,549
And then we're going to break outside of that comparison
然后，我们将超出该比较范围

37
00:01:34,549 --> 00:01:36,959
model, work in a different model of computation, our more
模型，在不同的计算模型中工作，我们的更多

38
00:01:36,959 --> 00:01:41,089
usual RAM model, and show that in certain situations,
通常的RAM模型，并表明在某些情况下， 

39
00:01:41,090 --> 00:01:42,420
we can get linear time.
我们可以得到线性时间。 

40
00:01:42,420 --> 00:01:45,439
So that's the plan.
这就是计划。 

41
00:01:45,439 --> 00:01:49,605
Let's start with this comparison model.
让我们从这个比较模型开始。 

42
00:01:49,605 --> 00:01:56,390



43
00:01:56,390 --> 00:01:58,369
So the idea in the comparison model
所以比较模型中的想法

44
00:01:58,569 --> 00:02:00,699
is to restrict what kind of operations
是限制哪种操作

45
00:02:00,700 --> 00:02:03,670
we can do to be comparisons.
我们可以做个比较。 

46
00:02:03,670 --> 00:02:06,090
It's very straightforward.
非常简单。 

47
00:02:06,090 --> 00:02:16,081
All input items are black boxes, you could say,
您可以说所有输入项都是黑匣子， 

48
00:02:16,081 --> 00:02:19,919
in that you don't really know what they are.
因为您真的不知道它们是什么。 

49
00:02:19,919 --> 00:02:22,245
And a formal notion of black boxes
和黑匣子的正式概念

50
00:02:22,246 --> 00:02:23,870
is something we talked about last class
这是我们上课时谈到的

51
00:02:23,870 --> 00:02:25,997
at the end, abstract data type.
最后是抽象数据类型。 

52
00:02:25,997 --> 00:02:27,580
So it's a data structure, if you will.
如果可以的话，这是一个数据结构。 

53
00:02:27,580 --> 00:02:30,860
Every item that you're given is a data structure.
您得到的每个项目都是一个数据结构。 

54
00:02:30,860 --> 00:02:32,430
You want to sort them.
您想对它们进行排序。 

55
00:02:32,629 --> 00:02:34,849
And the data structure supports a single operation
并且数据结构支持单个操作

56
00:02:34,849 --> 00:02:36,280
which is compared to another one.
与另一个相比。 

57
00:02:36,280 --> 00:02:38,849



58
00:02:38,849 --> 00:02:52,419
Only operation allowed-- I guess I should say plural actually--
仅允许操作-我想我应该说复数- 

59
00:02:52,419 --> 00:02:53,144
are comparisons.
是比较。 

60
00:02:53,145 --> 00:02:56,990



61
00:02:56,990 --> 00:03:01,060
I'm going to be nice and I'll let you do less than, less than
我会变得很好，我会让你做不到，做不到

62
00:03:01,060 --> 00:03:04,490
or equal to, greater than, whatever.
等于或大于等于任何东西

63
00:03:04,490 --> 00:03:06,030
I guess there's only one other.
我猜只有一个。 

64
00:03:06,030 --> 00:03:09,550
Well, there's two more, greater than or equal to and equals.
好吧，还有两个，大于或等于和等于。 

65
00:03:09,550 --> 00:03:11,770
So you can do all the usual comparisons.
因此，您可以进行所有常规比较。 

66
00:03:11,770 --> 00:03:13,620
You get a binary answer, yes or no,
您得到一个二进制答案，是或否， 

67
00:03:13,620 --> 00:03:15,620
and those the only operations you're given.
以及您获得的唯一操作。 

68
00:03:15,620 --> 00:03:18,439



69
00:03:18,639 --> 00:03:22,279
And basically the last four lectures
基本上是最后四堂课

70
00:03:22,280 --> 00:03:24,759
have all been about algorithms in this model.
都与该模型中的算法有关。 

71
00:03:24,759 --> 00:03:27,590
So merge sort, it moves items around.
因此，合并排序可以移动项目。 

72
00:03:27,590 --> 00:03:30,789
It's changing pointers to items, but the only way
它正在改变指向项目的指针，但这是唯一的方法

73
00:03:30,789 --> 00:03:33,979
it manipulates items or evaluates them
它操纵或评估项目

74
00:03:33,979 --> 00:03:37,090
is to compare one against the other.
是将一个与另一个进行比较。 

75
00:03:37,090 --> 00:03:40,539
Heaps and heaps sort also only compare.
堆和堆的排序也只能比较。 

76
00:03:40,539 --> 00:03:42,365
Binary search trees only compare.
二进制搜索树仅进行比较。 

77
00:03:42,366 --> 00:03:44,740
Everything we've been seeing so far is about comparisons.
到目前为止，我们所看到的一切都是关于比较的。 

78
00:03:44,740 --> 00:03:47,370



79
00:03:47,569 --> 00:03:50,209
And so all the algorithms we've seen so far are in this model
因此，到目前为止，我们看到的所有算法都在该模型中

80
00:03:50,210 --> 00:03:53,159
and we're going to prove that they are optimal in this model.
我们将证明它们在此模型中是最佳的。 

81
00:03:53,159 --> 00:03:55,539
That's the plan.
那是计划。 

82
00:03:55,539 --> 00:03:58,959
I should also define the cost of an algorithm.
我还应该定义算法的成本。 

83
00:03:58,960 --> 00:04:01,810
Time cost is just going to be the number of comparisons.
时间成本只是比较的次数。 

84
00:04:01,810 --> 00:04:04,050
This is the weird part, I guess, of the model.
我猜这是模型的怪异部分。 

85
00:04:04,050 --> 00:04:06,620



86
00:04:06,819 --> 00:04:11,030
So in everything we've done so far, we've been in, I guess,
因此，到目前为止，在我们所做的所有事情中，我们都参与了

87
00:04:11,030 --> 00:04:14,270
pointer machine or RAM, either way.
指针机或RAM，无论哪种方式。 

88
00:04:14,270 --> 00:04:17,519
We've been showing binary search trees or AVL trees,
我们一直在显示二进制搜索树或AVL树， 

89
00:04:17,519 --> 00:04:21,088
you can do order lg n time, in the regular notion of time.
您可以按照常规的时间顺序对lg n时间进行排序。 

90
00:04:21,088 --> 00:04:24,649
But in particular they do order lg n comparisons.
但尤其是它们确实会进行lg n比较。 

91
00:04:24,649 --> 00:04:26,774
And what we're going to show on the-- this
而我们将要展示的是

92
00:04:26,774 --> 00:04:28,939
is only interesting from a lower bound perspective--
仅从下限的角度来看很有趣- 

93
00:04:28,939 --> 00:04:31,439
we're going to show that even if you just count comparisons,
我们将证明即使您只计算比较， 

94
00:04:31,439 --> 00:04:33,810
you can do whatever other crazy things you want.
您可以做任何您想做的其他疯狂事情。 

95
00:04:33,810 --> 00:04:35,100
You need lg n time to search.
您需要lg n的时间进行搜索。 

96
00:04:35,100 --> 00:04:38,009
You need n lg n time to sort.
您需要n lg n的时间进行排序。 

97
00:04:38,209 --> 00:04:40,219
So that's our goal.
这就是我们的目标。 

98
00:04:40,220 --> 00:04:49,160



99
00:04:49,160 --> 00:04:53,819
So to prove that we're going to introduce
因此，为了证明我们将要介绍

100
00:04:54,019 --> 00:04:55,629
the notion of a decision tree.
决策树的概念。 

101
00:04:55,629 --> 00:05:09,209



102
00:05:09,209 --> 00:05:12,259
So the idea is the following: if we know that our algorithms are
因此，想法如下：如果我们知道我们的算法是

103
00:05:12,259 --> 00:05:17,670
only comparing items, we can actually sort of draw
仅比较项目，我们实际上可以得出

104
00:05:17,670 --> 00:05:22,329
all the possible things that an algorithm could do,
算法可以做的所有可能的事情， 

105
00:05:22,529 --> 00:05:24,399
so any comparison algorithm.
所以任何比较算法。 

106
00:05:24,399 --> 00:05:31,179



107
00:05:31,180 --> 00:05:33,480
So this focusing in on comparisons
因此，本着重于比较

108
00:05:33,480 --> 00:06:09,730
lets us take a tree perspective of what our algorithm does--
让我们从树的角度来了解算法的作用- 

109
00:06:09,730 --> 00:06:25,939
all possible comparisons and their outcomes
所有可能的比较及其结果

110
00:06:26,139 --> 00:06:28,685
and the resulting answer.
以及得到的答案。 

111
00:06:28,685 --> 00:06:32,242



112
00:06:32,242 --> 00:06:33,750
I think this would be a lot clearer if we
我认为如果我们

113
00:06:33,949 --> 00:06:42,500
look at an example-- binary search,
看一个例子-二进制搜索

114
00:06:42,500 --> 00:06:44,394
how you search a simple algorithm.
您如何搜索简单的算法。 

115
00:06:44,394 --> 00:06:46,310
Look at the middle compared to the item you're
看看中间与您所要的项目相比

116
00:06:46,310 --> 00:06:49,889
searching for go left or go right.
搜索向左或向右。 

117
00:06:49,889 --> 00:06:57,819
And our idea-- I didn't write it here--
我们的想法-我没有在这里写- 

118
00:06:57,819 --> 00:07:02,259
is to look at a particular value of n,
是看n的特定值， 

119
00:07:02,259 --> 00:07:05,000
n being the size of your problem, so binary search,
 n是您问题的大小，所以二进制搜索， 

120
00:07:05,000 --> 00:07:09,670
you're searching among n items for another item.
您正在n个项目中搜索另一个项目。 

121
00:07:09,670 --> 00:07:15,319
And I'm going to keep it simple, n equals three.
我将保持简单，n等于3。 

122
00:07:15,519 --> 00:07:22,789
I think I'm going to go a little wide, use the whole board.
我想我要扩大一点，用整个木板。 

123
00:07:22,790 --> 00:07:28,800
So n equals 3 we've got array, say
所以n等于3我们有数组

124
00:07:28,800 --> 00:07:33,569
index turning at zero-- pretty simple binary search-- look
索引为零-非常简单的二进制搜索-外观

125
00:07:33,569 --> 00:07:36,149
in the middle, go left or go right.
在中间，向左或向右走。 

126
00:07:36,149 --> 00:07:39,279
But I'm going to write out this algorithm explicitly to say,
但是我要明确写出这个算法，说： 

127
00:07:39,279 --> 00:07:47,489
all right, first thing I do is compare is A 1 less than x?
好吧，我要做的第一件事就是比较A是否小于x？ 

128
00:07:47,490 --> 00:07:48,995
That's in all cases, no matter what
在所有情况下，无论如何

129
00:07:48,995 --> 00:07:50,620
the array is as long as n equals three,
只要n等于三，数组就可以

130
00:07:50,620 --> 00:07:52,569
this is the first operation you do.
这是您要做的第一项操作。 

131
00:07:52,569 --> 00:07:54,060
The answer is either yes or no.
答案是是或否。 

132
00:07:54,060 --> 00:07:57,970



133
00:07:57,970 --> 00:08:04,250
If the answer is no, that means x is less than or equal to A 1,
如果答案为否，则意味着x小于或等于A 1， 

134
00:08:04,250 --> 00:08:05,670
so it's to the left.
所以在左边

135
00:08:05,670 --> 00:08:07,680
Then we compare with A 0.
然后我们与A 0比较。 

136
00:08:07,680 --> 00:08:11,819
Is A 0 less than x?
 A 0小于x吗？ 

137
00:08:11,819 --> 00:08:13,349
Answer is either yes or no.
答案是是或否。 

138
00:08:13,350 --> 00:08:16,410



139
00:08:16,410 --> 00:08:19,170
If the answer is no, we're kind of done.
如果答案是否定的，那么我们就完成了。 

140
00:08:19,170 --> 00:08:21,480
We know that x is over here or it might actually
我们知道x在这里，或者实际上

141
00:08:21,480 --> 00:08:24,016
be equal to A 0.
等于A 0。 

142
00:08:24,216 --> 00:08:25,800
If you want to figure out whether it's
如果你想弄清楚是否

143
00:08:25,800 --> 00:08:27,920
equal or less than, there will be one more step.
等于或小于，将再有一个步骤。 

144
00:08:27,920 --> 00:08:29,129
But I'll just stop it here.
但是我只是在这里停下来。 

145
00:08:29,329 --> 00:08:33,509
We'll say, well in this case, x is less than or equal to A 0.
我们可以说，在这种情况下，x小于或等于A 0。 

146
00:08:33,509 --> 00:08:35,408
I'm going to put it in a box, say that's done
我要把它放在盒子里，说完了

147
00:08:35,408 --> 00:08:37,970
where the circles are the decisions.
圈子在哪里决定。 

148
00:08:37,970 --> 00:08:38,928
OK?
好？ 

149
00:08:38,928 --> 00:08:42,889
If the answer is yes-- there's no to this question, yes
如果答案是肯定的-这个问题没有答案

150
00:08:42,889 --> 00:08:46,949
to this question-- then you know that x falls in between here.
这个问题-那么您知道x介于此处。 

151
00:08:46,950 --> 00:08:49,440
Probably need a wider box for this.
可能需要一个更大的盒子。 

152
00:08:49,440 --> 00:08:56,070
So we have A 0 is less than x-- that was the yes to this--
所以我们有一个A 0小于x-这是肯定的- 

153
00:08:56,070 --> 00:08:59,579
and the note of this means that x is less than or equal to A 1,
并且注意，这意味着x小于或等于A 1， 

154
00:08:59,779 --> 00:09:02,309
and so we basically identified where x fits.
因此，我们基本上确定了x适合的位置。 

155
00:09:02,309 --> 00:09:03,789
It's in between those two values,
在这两个值之间

156
00:09:03,789 --> 00:09:05,200
possibly equal to this one.
可能等于这个。 

157
00:09:05,201 --> 00:09:07,450
Again, one more comparison, you could figure that out.
同样，再进行一次比较，您可以弄清楚这一点。 

158
00:09:07,450 --> 00:09:10,220



159
00:09:10,220 --> 00:09:15,220
And then if x is to the right of A 1, so this is true,
然后如果x在A 1的右边，那么这是真的， 

160
00:09:15,220 --> 00:09:28,320
then we check x against A 2 and the answer is either no or yes.
然后我们针对A 2来检查x，答案是否定的。 

161
00:09:28,320 --> 00:09:33,250
And in the no case-- well I've conveniently laid things out
而且在任何情况下-我都已经很方便地布置了东西

162
00:09:33,250 --> 00:09:37,539
here, it's sequential-- in the yes case, x is bigger than A 2
这里是顺序的-是的，x大于A 2 

163
00:09:37,539 --> 00:09:39,919
so it's outside the array.
所以它在数组之外

164
00:09:39,919 --> 00:09:41,699
It's to the right.
在右边。 

165
00:09:41,700 --> 00:09:44,110
That's the answer.
那就是答案。 

166
00:09:44,110 --> 00:09:45,860
Set.
组。 

167
00:09:45,860 --> 00:09:48,359
Yeah.
是的

168
00:09:48,559 --> 00:09:50,750
And in the other case, it's in between A 1 and A 2.
在另一种情况下，它介于A 1和A 2之间。 

169
00:09:50,750 --> 00:09:56,639



170
00:09:56,639 --> 00:09:59,819
It's a tedious process to write out an algorithm like this
编写这样的算法是一个繁琐的过程

171
00:09:59,820 --> 00:10:05,230
because a binary search-- it's not so bad-- but if you tried
因为二进制搜索-还不错-但如果您尝试过

172
00:10:05,230 --> 00:10:07,109
to write a sorting algorithm out like this
写出这样的排序算法

173
00:10:07,309 --> 00:10:09,559
where the answers are down the bottom, here's
答案在最底层，这里是

174
00:10:09,559 --> 00:10:13,189
the sorted order, and all the comparisons you do here,
排序的顺序，以及您在此处所做的所有比较， 

175
00:10:13,190 --> 00:10:15,600
the tree will actually be of exponential size.
该树实际上将具有指数大小。 

176
00:10:15,600 --> 00:10:18,070
So you don't actually want to represent an algorithm
所以你实际上并不想代表一个算法

177
00:10:18,070 --> 00:10:21,099
like this unless you're just trying to analyze it.
除非您只是试图对其进行分析，否则不会这样。 

178
00:10:21,299 --> 00:10:23,379
But it's nice to think of an algorithm this way
但是以这种方式想到一个算法真是太好了

179
00:10:23,379 --> 00:10:26,480
because you see all possible executions all at once.
因为您一次看到所有可能的执行。 

180
00:10:26,480 --> 00:10:32,229



181
00:10:32,429 --> 00:10:34,870
Let me talk about some features of this tree
让我说说这棵树的一些特点

182
00:10:34,870 --> 00:10:37,409
versus the algorithm.
与算法。 

183
00:10:37,409 --> 00:10:45,083
So every internal node-- actually,
所以每个内部节点-实际上， 

184
00:10:45,083 --> 00:10:47,019
I'm going to go over here.
我要去这里。 

185
00:10:47,019 --> 00:10:52,340



186
00:10:52,340 --> 00:10:58,639
So we have a decision tree and we
所以我们有一个决策树，我们

187
00:10:58,639 --> 00:11:03,789
have an algorithm that decision tree represents.
有一个决策树代表的算法。 

188
00:11:03,789 --> 00:11:09,870
And so when we have an internal node in the decision tree,
因此，当我们在决策树中有一个内部节点时， 

189
00:11:09,870 --> 00:11:15,740
that corresponds to a binary decision in the algorithm.
对应于算法中的二元决策。 

190
00:11:15,740 --> 00:11:18,835
In this case, we're only looking at comparisons.
在这种情况下，我们只看比较。 

191
00:11:18,835 --> 00:11:22,490



192
00:11:22,490 --> 00:11:24,320
Slight technical detail, decision trees
少量技术细节，决策树

193
00:11:24,320 --> 00:11:26,949
are a little more general than comparisons.
比比较要笼统一些。 

194
00:11:27,149 --> 00:11:29,740
Could be any binary decision here and everything I say
可能是任何二进制决定，我所说的一切

195
00:11:29,740 --> 00:11:33,153
will be true about any binary decision you make.
您所做的任何二元决策都是正确的。 

196
00:11:33,153 --> 00:11:35,070
Comparisons are the ones we kind of care about
比较是我们所关心的

197
00:11:35,070 --> 00:11:38,839
because all of our algorithms are doing that.
因为我们所有的算法都在这样做。 

198
00:11:39,039 --> 00:11:49,219
And then a leaf in this tree corresponds to-- it stores
然后这棵树上的一片叶子对应于-它存储

199
00:11:49,220 --> 00:11:51,754
or it represents that you've found the answer.
或代表您已找到答案。 

200
00:11:51,754 --> 00:11:54,730



201
00:11:54,730 --> 00:11:56,206
Maybe I'll say found.
也许我会说找到。 

202
00:11:56,206 --> 00:12:01,460



203
00:12:01,460 --> 00:12:04,370
When the algorithm terminates, returns some answer
当算法终止时，返回一些答案

204
00:12:04,370 --> 00:12:08,049
to the problem, that's what we write down here.
问题所在，那就是我们在这里写下的内容。 

205
00:12:08,049 --> 00:12:16,615
Here's where x is in this array and, yeah, we're done.
这是x在此数组中的位置，是的，我们完成了。 

206
00:12:16,615 --> 00:12:17,490
What else do we have?
我们还有什么？ 

207
00:12:17,490 --> 00:12:20,120



208
00:12:20,120 --> 00:12:21,529
Here's some puzzles for you.
这是给您的难题。 

209
00:12:21,529 --> 00:12:25,470



210
00:12:25,470 --> 00:12:27,940
If I just wanted to look at a single execution
如果我只想看一次执行

211
00:12:27,940 --> 00:12:31,600
of the algorithm, what does that correspond to in the tree?
的算法，在树中对应什么？ 

212
00:12:31,600 --> 00:12:35,700



213
00:12:35,900 --> 00:12:36,399
Yeah.
是的

214
00:12:36,399 --> 00:12:38,669
AUDIENCE: Going from the root all the way down to the leaf.
听众：从根一直到叶子。 

215
00:12:38,669 --> 00:12:40,586
PROFESSOR: Going from the root down to a leaf.
教授：从根到叶。 

216
00:12:40,586 --> 00:12:43,919
This is what I normally call a root-to-leaf path, technically
从技术上讲，这就是我通常所说的从根到叶的路径

217
00:12:43,919 --> 00:12:48,079
a downward root-to-leaf path.
向下的从根到叶的路径。 

218
00:12:48,080 --> 00:12:52,600
How about the running time of that execution?
该执行的运行时间如何？ 

219
00:12:52,600 --> 00:12:53,610
How long does it take?
多久时间？ 

220
00:12:53,610 --> 00:12:56,649



221
00:12:56,649 --> 00:12:57,514
Keep going?
继续？ 

222
00:12:57,514 --> 00:12:58,730
AUDIENCE: Lg n.
听众：Lg n。 

223
00:12:58,730 --> 00:13:02,754
PROFESSOR: Lg n in binary search, but in general.
教授：在二进制搜索中为Lg n，但一般而言。 

224
00:13:02,754 --> 00:13:03,969
AUDIENCE: The length of that path.
听众：路径的长度。 

225
00:13:04,169 --> 00:13:05,159
PROFESSOR: The length of that path.
教授：该路径的长度。 

226
00:13:05,159 --> 00:13:05,659
Yeah.
是的

227
00:13:05,659 --> 00:13:11,365



228
00:13:11,365 --> 00:13:13,990
Got to make sure we get n cases right but I think it's correct,
要确保我们正确处理n个案件，但我认为这是正确的， 

229
00:13:13,990 --> 00:13:18,629
so if here is an execution of the algorithm, when x happens
因此，如果这是算法的执行，则x发生时

230
00:13:18,629 --> 00:13:22,129
to be between A 0 and A 1, we do one comparison here,
在A 0和A 1之间，我们在这里做一个比较， 

231
00:13:22,129 --> 00:13:24,809
a second comparison here, and then we're done.
在这里进行第二次比较，然后完成。 

232
00:13:24,809 --> 00:13:28,309
So the cost was two and indeed the length of this path is two.
因此，成本为2，而这条路径的长度实际上为2。 

233
00:13:28,309 --> 00:13:33,359
So it works out, no off-by-one errors.
这样就可以解决问题，不会出现一一错误的情况。 

234
00:13:33,360 --> 00:13:36,950
All right, now exciting one for us,
好吧，现在让我们激动不已， 

235
00:13:36,950 --> 00:13:39,879
what we care about all the time in this class
我们在课堂上一直在关心什么

236
00:13:39,879 --> 00:13:43,070
is worst-case running time.
是最坏的运行时间。 

237
00:13:43,070 --> 00:13:45,089
This is a feature of the entire algorithm.
这是整个算法的功能。 

238
00:13:45,289 --> 00:13:50,174
What is the worst-case running time of a given decision tree?
给定决策树的最坏情况下运行时间是多少？ 

239
00:13:50,174 --> 00:13:50,674
Yeah.
是的

240
00:13:50,674 --> 00:13:53,048
AUDIENCE: The height of the root, the height of the tree.
听众：根的高度，树的高度。 

241
00:13:53,048 --> 00:13:55,029
PROFESSOR: The height of the root also called
教授：根的高度也称为

242
00:13:55,029 --> 00:13:55,750
the height of the tree.
树的高度。 

243
00:13:55,750 --> 00:13:56,250
Yep.
是的

244
00:13:56,250 --> 00:14:03,230



245
00:14:03,230 --> 00:14:05,690
Or the depth of the deepest leaf, whatever.
或最深的叶子的深度，随便。 

246
00:14:05,690 --> 00:14:07,870
So in this case all the leaves have the same level,
因此，在这种情况下，所有叶子都具有相同的水平， 

247
00:14:07,870 --> 00:14:10,590
but in general we care about the overall height.
但总的来说，我们关心整体高度。 

248
00:14:10,590 --> 00:14:13,370
How many levels in this tree are there?
这棵树上有多少层？ 

249
00:14:13,370 --> 00:14:16,139
It's the number of levels minus one, technically.
从技术上讲，它是级别数减去一。 

250
00:14:16,139 --> 00:14:19,939
But the length of longest root-to-leaf path
但是最长的根到叶路径的长度

251
00:14:19,940 --> 00:14:21,579
is the definition of height.
是高度的定义。 

252
00:14:21,779 --> 00:14:23,039
Here it's two.
这是两个。 

253
00:14:23,039 --> 00:14:27,379
In general we know for binary search it's lg n,
一般来说，对于二进制搜索，我们知道它是lg n， 

254
00:14:27,379 --> 00:14:29,029
but given an arbitrary decision tree,
但给定任意决策树， 

255
00:14:29,029 --> 00:14:30,779
we just have to figure out what the height of the tree
我们只需要弄清楚树的高度是多少

256
00:14:30,779 --> 00:14:32,946
is and we'll figure out the worst-case running time.
是的，我们将找出最坏情况下的运行时间。 

257
00:14:32,946 --> 00:14:35,509
So this is why decision trees are interesting.
这就是为什么决策树很有趣的原因。 

258
00:14:35,509 --> 00:14:39,860
Not because it means they're pretty I guess, but the reason
我猜不是因为这意味着它们很漂亮，而是原因

259
00:14:39,860 --> 00:14:43,240
they're going to be useful is we have this kind of hard question
他们会很有用，如果我们有这样一个难题

260
00:14:43,240 --> 00:14:46,639
which is how much time do you need to solve a problem?
您需要多少时间解决问题？ 

261
00:14:46,639 --> 00:14:50,389
And we're translating it into how low can you
我们正在将其转化为您能达到的最低水平

262
00:14:50,389 --> 00:14:53,210
make your tree, which is a problem we know a lot about.
做你的树，这是我们非常了解的问题。 

263
00:14:53,210 --> 00:14:54,099
Trees are pretty simple.
树木很简单。 

264
00:14:54,299 --> 00:14:55,909
These are binary trees.
这些是二叉树。 

265
00:14:55,909 --> 00:15:00,529
They're rooted, and so we know lots of good things.
他们扎根，所以我们知道很多好事。 

266
00:15:00,529 --> 00:15:03,419



267
00:15:03,419 --> 00:15:04,934
So let's prove some lower bounds.
因此，让我们证明一些下限。 

268
00:15:04,934 --> 00:15:25,319



269
00:15:25,320 --> 00:15:29,819
So I claim that for searching-- maybe I
所以我声称是为了搜寻-也许我

270
00:15:30,019 --> 00:15:32,199
should define the problem a little more formally--
应该更正式地定义问题- 

271
00:15:32,200 --> 00:15:35,000
I want to claim a lg n lower bound.
我想声明一个lg n下界。 

272
00:15:35,000 --> 00:15:42,355
So let's say for searching I have n preprocessed items.
因此，假设搜索有n个预处理项目。 

273
00:15:42,355 --> 00:15:49,039



274
00:15:49,039 --> 00:16:05,355
Then finding a given item among them in the comparison model,
然后在比较模型中找到其中的给定项目， 

275
00:16:05,355 --> 00:16:09,878
so all you're allowed to do are compare items and other stuff,
所以您所要做的就是比较商品和其他东西， 

276
00:16:10,078 --> 00:16:12,370
but the only things you're allowed to do with the items
但是您唯一可以做的事情

277
00:16:12,370 --> 00:16:13,070
is compare them.
比较它们。 

278
00:16:13,070 --> 00:16:17,979



279
00:16:18,179 --> 00:16:25,296
Requires omega lg n comparisons in the worst case.
在最坏的情况下，需要进行欧米茄lg n比较。 

280
00:16:25,297 --> 00:16:27,379
It's kind of tedious to write down these theorems,
写下这些定理有点繁琐， 

281
00:16:27,379 --> 00:16:29,500
but for our first lower bounds, I
但是对于我们的第一个下界

282
00:16:29,500 --> 00:16:31,090
thought I'd be super explicit.
以为我会超级露骨。 

283
00:16:31,090 --> 00:16:33,990



284
00:16:33,990 --> 00:16:37,091
I mentioned here that the items are preprocessed
我在这里提到这些物品已经过预处理

285
00:16:37,091 --> 00:16:39,340
to mean you could do whatever you want the items ahead
意味着你可以做任何你想做的事

286
00:16:39,340 --> 00:16:40,839
of time, that's for free.
时间是免费的。 

287
00:16:41,039 --> 00:16:42,689
So I can sort them in particular,
所以我可以对它们进行特别排序

288
00:16:42,690 --> 00:16:44,200
which lets me do binary search.
这让我进行二进制搜索。 

289
00:16:44,200 --> 00:16:47,980
I could build them into an AVL tree, could do lots of things,
我可以将它们构建到AVL树中，可以做很多事情， 

290
00:16:47,980 --> 00:16:51,440
but no matter what I do to find another item takes lg n time.
但是无论我怎么做才能找到另一个项目需要lg n的时间。 

291
00:16:51,440 --> 00:16:57,850



292
00:16:57,850 --> 00:16:58,850
Can someone tell me why?
有人可以告诉我为什么吗？ 

293
00:16:58,850 --> 00:17:02,125



294
00:17:02,125 --> 00:17:04,415
Who doesn't have the lecture notes right in front them,
谁没有前面的讲义， 

295
00:17:04,415 --> 00:17:08,059
that would make it easy.
这将使其变得容易。 

296
00:17:08,059 --> 00:17:12,598
This is a little more interesting,
这有点有趣， 

297
00:17:12,598 --> 00:17:15,460
but we had all the tools at our disposal now.
但是我们现在拥有所有工具。 

298
00:17:15,460 --> 00:17:17,519
We want to show that this at least lg n.
我们想证明这至少是lg n。 

299
00:17:17,519 --> 00:17:20,950



300
00:17:20,950 --> 00:17:21,629
Why?
为什么？ 

301
00:17:21,829 --> 00:17:22,329
Yeah.
是的

302
00:17:22,329 --> 00:17:26,578
AUDIENCE: [INAUDIBLE] have a no or yes, right?
听众：[听不清]是或否，对吗？ 

303
00:17:26,578 --> 00:17:27,078
So it's--
所以是 - 

304
00:17:27,078 --> 00:17:27,787
PROFESSOR: Right.
教授：对。 

305
00:17:27,787 --> 00:17:29,116
AUDIENCE: --omega lg n tree.
听众：--omega lg n树。 

306
00:17:29,116 --> 00:17:29,700
PROFESSOR: OK.
教授：好的。 

307
00:17:29,700 --> 00:17:31,559
At each step, we only have a no or yes.
在每一步中，我们只有否或是。 

308
00:17:31,559 --> 00:17:32,559
That's a binary tree.
那是一棵二叉树。 

309
00:17:32,559 --> 00:17:35,309



310
00:17:35,309 --> 00:17:36,869
So that makes you think lg n.
因此，您会想到lg n。 

311
00:17:36,869 --> 00:17:39,178
AUDIENCE: That's possible, it could be lg n.
听众：有可能，lg n。 

312
00:17:39,179 --> 00:17:41,470
PROFESSOR: Maximum actually could be arbitrarily large.
教授：最大值实际上可以任意大。 

313
00:17:41,470 --> 00:17:44,930
You could do a linear search and the height will be m.
您可以进行线性搜索，高度为m。 

314
00:17:44,930 --> 00:17:47,789
We care about the minimum of course.
我们关心最低限度的课程。 

315
00:17:47,789 --> 00:17:50,039
Why does it have to be-- why does the height of a tree
为什么必须-为什么树的高度

316
00:17:50,039 --> 00:17:51,430
have to be at least lg n?
必须至少为lg n？ 

317
00:17:51,430 --> 00:17:52,831
There's one more thing we need to say.
我们还需要说一件事。 

318
00:17:53,031 --> 00:17:53,530
Yeah.
是的

319
00:17:53,530 --> 00:17:56,129
AUDIENCE: The tree has to contain all possible--
听众：树必须包含所有可能的- 

320
00:17:56,130 --> 00:17:57,678
PROFESSOR: Because the tree has to contain
教授：因为树必须包含

321
00:17:57,878 --> 00:18:00,109
all possible-- answers, let's say.
假设一切皆有可能。 

322
00:18:00,109 --> 00:18:02,639
Yeah, exactly.
是的，完全正确。 

323
00:18:02,640 --> 00:18:05,369
I think that's worth a pillow.
我认为这值得一个枕头。 

324
00:18:05,569 --> 00:18:08,879
See if I can do this-- oh!
看看我能不能做-哦！ 

325
00:18:08,880 --> 00:18:09,809
Ouch.
哎哟。 

326
00:18:10,009 --> 00:18:12,089
I knew it was only a matter of time.
我知道这只是时间问题。 

327
00:18:12,089 --> 00:18:14,189
Sorry.
抱歉。 

328
00:18:14,190 --> 00:18:16,664
I'll pay you later.
我待会儿付给你。 

329
00:18:16,664 --> 00:18:17,164
Damages.
损害赔偿。 

330
00:18:17,164 --> 00:18:20,626



331
00:18:20,626 --> 00:18:22,460
At least I didn't hit a laptop or something.
至少我没有打笔记本电脑之类的东西。 

332
00:18:22,460 --> 00:18:26,329



333
00:18:26,329 --> 00:18:34,089
All right, so decision tree is binary--
好吧，决策树是二进制的

334
00:18:34,089 --> 00:18:37,529
that was the first thing-- and it
那是第一件事-而且

335
00:18:37,529 --> 00:18:47,970
must have at least n leaves, one for each answer.
必须至少有n个叶子，每个答案一个。 

336
00:18:47,970 --> 00:18:54,329



337
00:18:54,329 --> 00:18:55,309
At least.
至少。 

338
00:18:55,309 --> 00:18:58,909
Now, at the leaf you have to know what the answer is,
现在，在叶子上，您必须知道答案是什么， 

339
00:18:58,910 --> 00:19:01,349
but there may be many leaves that have the same answer.
但是可能有很多叶子有相同的答案。 

340
00:19:01,549 --> 00:19:03,430
That's possible.
有可能

341
00:19:03,430 --> 00:19:05,629
And indeed that will happen not for binary search
确实，二进制搜索不会发生这种情况

342
00:19:05,829 --> 00:19:07,629
but typical algorithm.
但是典型的算法。 

343
00:19:07,630 --> 00:19:10,960
There's multiple paths to get the same answer,
可以通过多种途径获得相同的答案， 

344
00:19:10,960 --> 00:19:13,990
so there may be more leaves than n.
所以叶子可能比n多。 

345
00:19:13,990 --> 00:19:17,670
And in fact, if you want to know this kind of thing, where
实际上，如果您想知道这种事情， 

346
00:19:17,670 --> 00:19:21,448
x fits in this perspective, there's n plus 1 answers.
 x适合这个观点，有n个加1个答案。 

347
00:19:21,648 --> 00:19:23,189
If you want to know is it equal or is
如果您想知道它是否相等

348
00:19:23,190 --> 00:19:26,169
it strictly between two things there's 2n plus 1 answers.
严格来说，两件事之间是2n加1的答案。 

349
00:19:26,369 --> 00:19:28,859
But in all cases, there's at least n answers
但在所有情况下，至少有n个答案

350
00:19:28,859 --> 00:19:30,859
and that's all I need.
这就是我所需要的。 

351
00:19:30,859 --> 00:19:34,990
In particular there's-- say x exactly matches one
特别是-说x完全匹配一个

352
00:19:34,990 --> 00:19:37,029
of the given items-- there's n items--
给定项目中的n个

353
00:19:37,029 --> 00:19:40,859
so you need to have at least n leaves.
因此您至少需要n个叶子。 

354
00:19:40,859 --> 00:19:42,699
Maybe have more, I don't care.
也许还有更多，我不在乎。 

355
00:19:42,700 --> 00:19:45,389
But it I have a binary tree with at least n leaves,
但是我有一棵至少有n个叶子的二叉树， 

356
00:19:45,589 --> 00:19:47,470
the height has to be at least lg n.
高度必须至少为lg n。 

357
00:19:47,470 --> 00:19:55,159



358
00:19:55,359 --> 00:19:56,159
We're done.
大功告成

359
00:19:56,160 --> 00:19:59,589
The height is the worst-case running time.
高度是最坏情况下的运行时间。 

360
00:19:59,789 --> 00:20:01,940
Super, super easy proof.
超级，超级容易证明。 

361
00:20:01,940 --> 00:20:04,539



362
00:20:04,539 --> 00:20:07,659
So easy, it's never been taught in 006 before.
如此简单，它从未在006中被教导过。 

363
00:20:07,660 --> 00:20:10,765
But I think it's a good warm up for the next one which
但是我认为接下来的那场比赛是一个很好的热身

364
00:20:10,765 --> 00:20:12,150
is sorting.
正在排序。 

365
00:20:12,150 --> 00:20:15,630
Sorting is really the same thing.
排序实际上是同一回事。 

366
00:20:15,630 --> 00:20:21,079
It's not going to be any harder except that it's a little more
除了增加一点点，它不会变得更困难

367
00:20:21,279 --> 00:20:24,109
math but really not much more.
数学，但实际上不多。 

368
00:20:24,109 --> 00:20:27,509



369
00:20:27,509 --> 00:20:31,730
So now we know-- we just proved two useful facts--
所以现在我们知道-我们只证明了两个有用的事实- 

370
00:20:31,730 --> 00:20:35,200
one is that binary search is optimal in a comparison model,
一个是二进制搜索在比较模型中是最佳的， 

371
00:20:35,200 --> 00:20:38,569
the other is that binary search trees are actually a good way
另一个是二进制搜索树实际上是一个好方法

372
00:20:38,569 --> 00:20:40,119
to solve a problem.
解决问题。 

373
00:20:40,119 --> 00:20:42,619
If your goal is to solve search and all you're allowed to do
如果您的目标是解决搜索问题，并且您被允许做的一切

374
00:20:42,619 --> 00:20:46,269
is comparisons, then you need lg n time.
是比较，那么您需要lg n时间。 

375
00:20:46,269 --> 00:20:51,029
And so the search or next larger or next smaller, predecessor,
因此，搜寻或下一个较大或下一个较小的前身， 

376
00:20:51,029 --> 00:20:52,970
successor, in binary search trees
后继项，在二进制搜索树中

377
00:20:52,970 --> 00:20:55,669
need to take at least lg n time.
需要至少花费lg n次。 

378
00:20:55,869 --> 00:20:59,189
No matter how you do it, even if you don't use a tree.
无论您怎么做，即使您不使用树也是如此。 

379
00:20:59,190 --> 00:21:02,149
So this justifies why binary search trees are interesting,
因此，这证明了为什么二进制搜索树很有趣， 

380
00:21:02,349 --> 00:21:04,159
because again the comparison model, that's
因为同样是比较模型

381
00:21:04,160 --> 00:21:07,750
the best you can hope to do.
您所希望做到的最好。 

382
00:21:07,750 --> 00:21:09,069
So that's comforting.
因此令人感到安慰。 

383
00:21:09,069 --> 00:21:12,621
That's why I like lower bounds and theoretical computer
这就是为什么我喜欢下限和理论计算机

384
00:21:12,622 --> 00:21:14,629
science in general because you know when you're done,
科学，因为您知道自己完成的时间， 

385
00:21:14,829 --> 00:21:16,599
at least in a given model.
至少在给定的模型中。 

386
00:21:16,599 --> 00:21:19,119
Whenever-- we're never actually done,
每当-我们从未真正完成过， 

387
00:21:19,119 --> 00:21:22,004
because we can always change the model.
因为我们可以随时更改模型。 

388
00:21:22,005 --> 00:21:24,960
At least we understand the limitations of comparisons.
至少我们了解比较的局限性。 

389
00:21:24,960 --> 00:21:28,988
So for sorting, we claim a lower bound of n lg n.
因此，为了进行排序，我们要求n lg n的下限。 

390
00:21:28,988 --> 00:21:31,401
You've heard n lg n a zillion times.
您已听过无数次。 

391
00:21:31,401 --> 00:21:33,150
You probably know this is true, but now we
您可能知道这是真的，但是现在我们

392
00:21:33,150 --> 00:21:36,420
actually get to prove that it's true.
真正证明这是真的。 

393
00:21:36,420 --> 00:21:38,899
So we just follow the same strategy.
因此，我们只是遵循相同的策略。 

394
00:21:39,099 --> 00:21:40,949
Decision tree is binary.
决策树是二进制的。 

395
00:21:40,950 --> 00:21:45,240
The question is how many leaves does it have to have?
问题是它必须有几片叶子？ 

396
00:21:45,240 --> 00:21:50,909
So for sorting-- I didn't draw up an example--
因此，为了排序-我没有画一个例子- 

397
00:21:50,909 --> 00:21:52,700
I'm not going to draw an example of sorting
我不会举一个排序的例子

398
00:21:52,700 --> 00:21:54,889
because the trees get ginormous.
因为树木变得巨大。 

399
00:21:55,089 --> 00:21:55,589
Right?
对？ 

400
00:21:55,589 --> 00:22:01,609
Because of the depth is n log n, the height is n log n,
由于深度为n log n，高度为n log n， 

401
00:22:01,609 --> 00:22:04,519
then there's binary branching everywhere.
然后到处都有二进制分支。 

402
00:22:04,519 --> 00:22:06,609
That's a lot of nodes.
有很多节点。 

403
00:22:06,609 --> 00:22:10,029
Two to the n lg n is big.
 n lg n是2。 

404
00:22:10,029 --> 00:22:13,139
More than two to the n even, so it's
 n等于2以上，所以

405
00:22:13,140 --> 00:22:15,237
hard to draw a picture even for n equals 3.
即使n等于3也很难画画。 

406
00:22:15,237 --> 00:22:15,619
You can do it.
你能行的。 

407
00:22:15,819 --> 00:22:18,089
People have done it.
人们已经做到了。 

408
00:22:18,089 --> 00:22:19,019
I don't want to.
我不想

409
00:22:19,019 --> 00:22:20,589
I'm lazy.
我很懒。 

410
00:22:20,589 --> 00:22:23,679
But the internal nodes look just the same.
但是内部节点看起来是一样的。 

411
00:22:23,680 --> 00:22:26,440
You're comparing two items, A I verses
您正在比较两个项目，人工智能经文

412
00:22:26,440 --> 00:22:30,160
A J. I'll just draw the generic version.
 J。我只画通用版本。 

413
00:22:30,160 --> 00:22:33,879
You have A I less than A J, question mark.
您的AI小于AJ，问号。 

414
00:22:34,079 --> 00:22:36,109
And then you'll have a no and a yes.
然后，您将得到一个否定和一个是。 

415
00:22:36,109 --> 00:22:38,319
So that's what a typical comparison looks like.
这就是典型的比较。 

416
00:22:38,319 --> 00:22:42,009
Swaps don't appear here, because we're just
掉期没有出现在这里，因为我们只是

417
00:22:42,009 --> 00:22:43,769
looking at the comparisons.
看比较。 

418
00:22:43,769 --> 00:22:46,980
And then when you get down to a leaf, a leaf--
然后当你跌倒一片叶子时，一片叶子- 

419
00:22:46,980 --> 00:22:54,440
this is the interesting part-- the leaf will look like this.
这是有趣的部分-叶子看起来像这样。 

420
00:22:54,440 --> 00:22:57,690
Well I took the original A 5 and that turned out
好吧，我拿了原始的A 5，结果

421
00:22:57,690 --> 00:22:59,200
to be the smallest element.
成为最小的元素。 

422
00:22:59,200 --> 00:23:01,669
Then-- maybe I'll write it this way--
然后-也许我会这样写- 

423
00:23:01,869 --> 00:23:06,019
then I have A 7, that turned out to be the next smallest
然后我有A 7，结果倒数第二

424
00:23:06,019 --> 00:23:13,019
element, then A 1 then A 0, whatever.
元素，然后是A 1然后是A 0，无论如何。 

425
00:23:13,019 --> 00:23:16,609
Hey, right at the end, somehow you know the sorted order
嘿，到最后，以某种方式知道排序顺序

426
00:23:16,609 --> 00:23:18,153
and you can just write it down.
你可以写下来

427
00:23:18,153 --> 00:23:19,319
We're not charging for this.
我们不为此收费。 

428
00:23:19,319 --> 00:23:20,818
We're only charging for comparisons.
我们只收取比较费用。 

429
00:23:20,818 --> 00:23:23,730
So however, maybe you've done swaps,
因此，也许您已经完成了交换， 

430
00:23:23,730 --> 00:23:25,930
in the end you know what the final order is
最后，您知道最终的订单是什么

431
00:23:25,930 --> 00:23:28,149
and so you just write it down.
所以你就把它写下来

432
00:23:28,349 --> 00:23:31,089
And your goal is to make enough comparisons that you figure out
您的目标是进行足够的比较以找出

433
00:23:31,089 --> 00:23:32,579
what the sorted order is.
什么是排序顺序。 

434
00:23:32,579 --> 00:23:34,470
We claim the number of comparisons
我们要求比较的数量

435
00:23:34,470 --> 00:23:35,659
here has to be at least n lg n.
这里必须至少为n lg n。 

436
00:23:35,859 --> 00:23:38,409



437
00:23:38,410 --> 00:23:39,210
OK, why?
好为什么

438
00:23:39,210 --> 00:23:52,650
Because the decision tree is binary and the number of leaves
因为决策树是二进制的，叶子数

439
00:23:52,650 --> 00:23:56,869
has to be at least the number of possible answers.
必须至少是可能答案的数量。 

440
00:23:57,069 --> 00:23:58,990
Could be more because each answer could appear
可能更多，因为每个答案都可能出现

441
00:23:58,990 --> 00:24:01,450
in several leaves and it probably will
用几片叶子，它可能会

442
00:24:01,450 --> 00:24:03,799
in a typical sorting algorithm.
在典型的排序算法中。 

443
00:24:03,799 --> 00:24:05,639
And how many possible answers are there?
有多少可能的答案？ 

444
00:24:05,640 --> 00:24:08,400



445
00:24:08,400 --> 00:24:08,900
Batter?
面糊？ 

446
00:24:08,900 --> 00:24:09,816
AUDIENCE: n factorial.
听众：n阶乘。 

447
00:24:09,816 --> 00:24:12,880
PROFESSOR: n factorial, number of permutations.
教授：n阶乘，排列数。 

448
00:24:12,880 --> 00:24:15,329
This is a permutation of the input sequence
这是输入序列的排列

449
00:24:15,529 --> 00:24:18,200
and if all the items you're given are distinct,
如果所有给您的物品都是不同的， 

450
00:24:18,200 --> 00:24:21,890
there will be n factorial permutations of them.
他们将有n个阶乘排列。 

451
00:24:21,890 --> 00:24:25,149
So that's the worst case.
所以那是最坏的情况。 

452
00:24:25,349 --> 00:24:27,000
So n factorial.
所以n阶乘。 

453
00:24:27,000 --> 00:24:32,869
Now the tricky part is the algebra.
现在最棘手的部分是代数。 

454
00:24:32,869 --> 00:24:35,429
Say, oh, well then the height is at least
说，哦，那么高度至少是

455
00:24:35,430 --> 00:24:37,759
lg base 2 of n factorial-- lg base 2
 n因数的lg基数2-lg基数2 

456
00:24:37,759 --> 00:24:41,469
because it's a binary tree.
因为它是一棵二叉树。 

457
00:24:41,469 --> 00:24:43,259
You can put a parentheses here if you want,
如果需要，可以在此处加上括号， 

458
00:24:43,259 --> 00:24:46,509
they're not necessary.
他们不是必需的。 

459
00:24:46,509 --> 00:24:49,480
So now I want to claim that this is n lg n.
因此，现在我想宣称这是n lg n。 

460
00:24:49,480 --> 00:24:50,269
How do I do that?
我怎么做？ 

461
00:24:50,269 --> 00:24:53,099



462
00:24:53,099 --> 00:24:56,009
Maybe you just know?
也许你只是知道？ 

463
00:24:56,009 --> 00:24:56,509
Yeah.
是的

464
00:24:56,509 --> 00:24:58,675
AUDIENCE: We can either use Stirling's approximation
听众：我们可以使用斯特林近似

465
00:24:58,675 --> 00:25:03,909
or we could write it out as a sum [INAUDIBLE]
或者我们可以将其写成一笔[音频不清晰] 

466
00:25:03,910 --> 00:25:05,150
PROFESSOR: Wow, cool.
教授：哇，好酷。 

467
00:25:05,150 --> 00:25:07,618
All right, you could either use Stirling's approximation
好吧，您可以使用斯特林近似

468
00:25:07,818 --> 00:25:08,859
or write it out as a sum.
或将其写出。 

469
00:25:08,859 --> 00:25:10,150
I've never done it with it sum.
我从来没有这样做过。 

470
00:25:10,151 --> 00:25:12,919
Let's do that, that sounds like fun.
让我们这样做，听起来很有趣。 

471
00:25:13,119 --> 00:25:14,799
So, right?
这样吧

472
00:25:14,799 --> 00:25:17,507
I like that because you know Stirling's-- it's like
我喜欢那是因为你知道斯特林的-就像

473
00:25:17,507 --> 00:25:19,639
you've got to know Stirling and that's kind of annoying.
您必须了解斯特灵，这很烦人。 

474
00:25:19,839 --> 00:25:21,699
What if you don't know Sterling?
如果您不知道英镑怎么办？ 

475
00:25:21,700 --> 00:25:23,650
But we all know the definition of factorial.
但是我们都知道阶乘的定义。 

476
00:25:23,650 --> 00:25:24,940
I mean, we learned in grade school
我的意思是我们在小学学习

477
00:25:24,940 --> 00:25:25,947
just because it's fun, right?
只是因为它很有趣，对不对？ 

478
00:25:26,147 --> 00:25:30,990
Oh, I guess we-- I mean we did because we're geeks.
哦，我想我们-我的意思是我们这样做是因为我们是极客。 

479
00:25:30,990 --> 00:25:35,799
And then we know the lg of our product is the sum of the lg's.
然后我们知道我们产品的lg是lg的总和。 

480
00:25:35,799 --> 00:25:44,379
So this is lg n plus lg n minus 1 plus lg 2 plus lg 1.
因此，这是lg n加lg n减去1加lg 2加上lg 1。 

481
00:25:44,380 --> 00:25:47,599



482
00:25:47,799 --> 00:25:49,230
I think at this point it's easier
我认为在这一点上比较容易

483
00:25:49,230 --> 00:25:52,500
to use summation notation, so sum of lg i.
使用求和符号，所以lg i的总和。 

484
00:25:52,500 --> 00:25:57,950
OK now we've got to do sum, this is 1 to n I guess.
好的，现在我们必须进行求和，我猜是1到n。 

485
00:25:57,950 --> 00:26:00,389
Now we need to know something about lg's, so it's not
现在我们需要了解有关lg的一些知识，所以这不是

486
00:26:00,589 --> 00:26:02,730
so easy.
太简单。 

487
00:26:02,730 --> 00:26:06,630
It's easy to show-- I mean, certainly this is at most n lg
很容易显示-我的意思是，这肯定是最多n lg 

488
00:26:06,630 --> 00:26:09,750
n, but we need show that it's at least n lg n.
 n，但我们需要证明它至少为n lg n。 

489
00:26:09,750 --> 00:26:11,430
That's a little trickier.
有点棘手。 

490
00:26:11,430 --> 00:26:12,555
I happen to know it's true.
我碰巧知道这是真的。 

491
00:26:12,555 --> 00:26:15,240



492
00:26:15,240 --> 00:26:17,630
But I'd know it even in the summation form
但是即使以总和的形式我也知道

493
00:26:17,630 --> 00:26:23,159
because I know that lg-- lg looks like this basically,
因为我知道lg-- lg基本上是这样的， 

494
00:26:23,359 --> 00:26:25,905
and so if you're adding up, you're
所以如果你加起来，你就是

495
00:26:25,905 --> 00:26:27,529
taking the area under this curve right?
取这条曲线下的面积正确吗？ 

496
00:26:27,529 --> 00:26:28,695
Oh, look at these integrals.
哦，看看这些积分。 

497
00:26:28,695 --> 00:26:30,250
Oh, integrals.
哦，积分。 

498
00:26:30,250 --> 00:26:32,009
Brings back memories.
带回回忆。 

499
00:26:32,009 --> 00:26:35,555
This is discrete math class, though, continuous stuff.
但是，这是离散的数学课，是连续的东西。 

500
00:26:35,555 --> 00:26:37,430
So you're adding up all these numbers, right?
所以您要将所有这些数字加起来，对不对？ 

501
00:26:37,430 --> 00:26:40,859
This is lg i over all the i's and basically all of them
这是我所有的lg我，基本上都是

502
00:26:41,059 --> 00:26:42,849
have the same length.
具有相同的长度。 

503
00:26:42,849 --> 00:26:45,579
Like if you look at the last half, that
就像你看最后一半一样

504
00:26:45,579 --> 00:26:47,029
would be one way to prove it.
将是证明它的一种方法。 

505
00:26:47,029 --> 00:26:51,460
Ah, it's fun, haven't done summations in so long.
啊，很有趣，很久没做总结了。 

506
00:26:51,460 --> 00:26:55,950
Good stuff. [? IS042 ?] material but applied to algorithms
好东西。 [？ IS042？]材料，但已应用于算法

507
00:26:55,950 --> 00:26:58,480
and in algorithms it's fun because you could throw away
在算法中，它很有趣，因为您可以扔掉

508
00:26:58,480 --> 00:27:01,690
constant factors and life is good.
不变的因素，生活是美好的。 

509
00:27:01,690 --> 00:27:03,509
We don't need exact answers really.
我们真的不需要确切的答案。 

510
00:27:03,509 --> 00:27:05,660
You can find an exact answer, but let's say
您可以找到确切的答案，但可以说

511
00:27:05,660 --> 00:27:08,279
you look at the last half.
你看看最后一半。 

512
00:27:08,279 --> 00:27:10,889
Those are all going to be basically lg n.
这些基本上都是lg n。 

513
00:27:10,890 --> 00:27:11,984
You can prove that.
您可以证明这一点。 

514
00:27:12,184 --> 00:27:15,119
So this is going to be at least the sum where
所以这至少是总和

515
00:27:15,119 --> 00:27:21,549
i equals n over 2 n of lg i.
我等于lg i的2 n中的n。 

516
00:27:21,549 --> 00:27:24,710
Here I just throw away the first out of our two terms.
在这里，我只是放弃了我们两个任期中的第一个。 

517
00:27:24,710 --> 00:27:28,660
And this is going to be at least sum i equals n over 2
这将至少等于和2 

518
00:27:28,660 --> 00:27:31,720
to n of lg n over 2.
到lg n中的n大于2。 

519
00:27:31,720 --> 00:27:34,650



520
00:27:34,650 --> 00:27:36,740
Each of these terms is bigger than lg n over 2
这些项中的每一项都大于lg n> 2 

521
00:27:36,740 --> 00:27:39,890
so if I just say, well, they're all lg n over 2 that's
所以如果我只是说，嗯，他们都是lg n over 2，那就是

522
00:27:39,890 --> 00:27:41,859
going to give me something even smaller.
会给我更小的东西。 

523
00:27:42,059 --> 00:27:44,369
Now the lg n over 2, that's just lg n minus 1.
现在lg n大于2，也就是lg n减1。 

524
00:27:44,369 --> 00:27:48,759



525
00:27:48,759 --> 00:27:49,379
I love this.
我喜欢这个。 

526
00:27:49,380 --> 00:27:51,930
It's going to give the right answer even.
它甚至可以给出正确的答案。 

527
00:27:51,930 --> 00:27:58,769
So that's an equals and so this equals n lg n minus n.
所以这是一个等于，所以等于n lg n减去n。 

528
00:27:58,769 --> 00:28:00,950
That summation I can do.
我可以做的总结。 

529
00:28:00,950 --> 00:28:05,069
All the terms are the same, sorry n over 2.
所有条款都相同，对不起，请超过2。 

530
00:28:05,069 --> 00:28:06,769
Not quite what I wanted.
不完全是我想要的。 

531
00:28:06,769 --> 00:28:07,359
Close enough.
足够近。 

532
00:28:07,359 --> 00:28:10,343



533
00:28:10,344 --> 00:28:11,759
Sorry there is only n over 2 terms
抱歉，只有n个词超过2个词

534
00:28:11,759 --> 00:28:14,579
here, ignoring floors and ceilings.
在这里，忽略了地板和天花板。 

535
00:28:14,579 --> 00:28:18,309
So I get n lg n divided by 2.
所以我得到n lg n除以2。 

536
00:28:18,309 --> 00:28:22,690
This is omega n lg n because this n term
这是omega n lg n，因为这n个项

537
00:28:22,690 --> 00:28:24,720
is smaller than n lg n.
小于n lg n。 

538
00:28:24,720 --> 00:28:26,019
So this one dominates.
因此，这一主导。 

539
00:28:26,019 --> 00:28:29,549
Doesn't matter if this one's negative, because it's smaller.
否定的也没关系，因为它较小。 

540
00:28:29,549 --> 00:28:31,119
This is omega n lg n.
这是欧米茄。 

541
00:28:31,119 --> 00:28:31,669
We're done.
大功告成

542
00:28:31,670 --> 00:28:33,890
Sorting is omega n lg n.
排序为。 

543
00:28:33,890 --> 00:28:34,440
Very easy.
很容易。 

544
00:28:34,440 --> 00:28:36,889
Who said summations?
谁说总结？ 

545
00:28:37,089 --> 00:28:37,659
All right.
好吧。 

546
00:28:37,660 --> 00:28:39,160
Why don't you come collect a pillow,
你为什么不来收集枕头

547
00:28:39,160 --> 00:28:40,910
I'm not going to throw that far.
我不会扔那么远。 

548
00:28:40,910 --> 00:28:42,509
Afterwards.
然后。 

549
00:28:42,509 --> 00:28:43,440
OK.
好。 

550
00:28:43,440 --> 00:28:44,419
That's one way to do it.
那是做到这一点的一种方法。 

551
00:28:44,619 --> 00:28:46,077
Another way to do it, if you happen
如果发生的话，另一种方法

552
00:28:46,077 --> 00:28:50,539
to know Stirling's formula for n factorial-- n factorial
知道n阶乘n阶乘的斯特林公式

553
00:28:50,539 --> 00:28:56,559
is about n over e to the n times square root of 2 pi n.
在e上大约n等于2 pi n的n平方根。 

554
00:28:56,559 --> 00:28:57,740
Right?
对？ 

555
00:28:57,740 --> 00:29:01,329
If you do Taylor series approximation of n factorial,
如果对n因数进行泰勒级数逼近， 

556
00:29:01,329 --> 00:29:04,000
the first term, which is the most important term for us
第一学期，对我们来说是最重要的学期

557
00:29:04,000 --> 00:29:05,670
because as the asymptotically dominating
因为作为渐近支配

558
00:29:05,670 --> 00:29:09,390
term is square root of 2 pi n times n over e to the n.
项是2 pi n乘以e到n的平方根。 

559
00:29:09,390 --> 00:29:12,200
Hope I got that right.
希望我说对了。 

560
00:29:12,200 --> 00:29:15,399
Yeah, clearly I've been studying.
是的，显然我一直在学习。 

561
00:29:15,599 --> 00:29:18,490
You take lg's of that and you do the same thing of lg
你拿lg的，你做lg的同样的事情

562
00:29:18,490 --> 00:29:21,440
of a product is sum of the lg's and you end up
一个产品的总和就是lg的总和

563
00:29:21,440 --> 00:29:28,150
with-- the right answer is actually n lg n minus order n.
正确的答案实际上是n lg n减去n。 

564
00:29:28,150 --> 00:29:31,980
So I was off by a factor of 2 here.
所以我在这里差了2倍。 

565
00:29:31,980 --> 00:29:34,819
The linear term-- it does appear,
线性项-它确实出现了， 

566
00:29:34,819 --> 00:29:38,041
but it's smaller than this and this is also omega n lg n.
但它比这还小，也是Ωn lg n。 

567
00:29:38,041 --> 00:29:40,250
If you don't care about constants, it doesn't matter.
如果您不关心常量，那就没关系。 

568
00:29:40,250 --> 00:29:43,039
If you care about constants, the constant is 1.
如果您关心常量，则常量为1。 

569
00:29:43,039 --> 00:29:44,349
Kind of nice.
有点不错。 

570
00:29:44,349 --> 00:29:46,359
Easy to prove a one half.
容易证明一半。 

571
00:29:46,359 --> 00:29:49,619
And if you look at the lecture notes it works through that.
而且，如果您看一下讲义，它就可以正常工作。 

572
00:29:49,619 --> 00:29:53,299
But I think we've seen enough of that lower bound.
但是我认为我们已经看到了足够多的下限。 

573
00:29:53,299 --> 00:29:55,579
And that's the end of our lower bound topic.
至此，我们的下限主题结束了。 

574
00:29:55,579 --> 00:29:57,519
Any questions on that?
有什么问题吗？ 

575
00:29:57,519 --> 00:29:59,579
So it's really easy.
因此，这真的很容易。 

576
00:29:59,579 --> 00:30:05,589
Once you set up this framework of comparison trees and now
一旦建立了比较树的框架，现在

577
00:30:05,589 --> 00:30:08,079
it becomes just a question of the height of a comparison
只是比较高度的问题

578
00:30:08,079 --> 00:30:09,809
tree.
树。 

579
00:30:09,809 --> 00:30:11,179
Comparison trees are binary.
比较树是二进制的。 

580
00:30:11,180 --> 00:30:13,140
Just count how many leaves do you have to have,
只要算出你必须有多少叶子， 

581
00:30:13,140 --> 00:30:16,576
take lg of that and you get a lower bound of that.
取lg的那个，就会得到一个下限。 

582
00:30:16,576 --> 00:30:21,539
AUDIENCE: What is meant by n preprocessed items?
听众：n个预处理物品是什么意思？ 

583
00:30:21,539 --> 00:30:22,789
PROFESSOR: Oh, yeah.
教授：哦，是的。 

584
00:30:22,789 --> 00:30:25,710
For searching I was trying to be careful and say, well,
为了进行搜索，我试图小心一点，说， 

585
00:30:25,710 --> 00:30:27,950
if I have n preprocessed items.
如果我有n个预处理项目。 

586
00:30:27,950 --> 00:30:29,900
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

587
00:30:29,900 --> 00:30:32,509
PROFESSOR: It means you can do whatever the heck you want.
教授：这意味着您可以做任何想做的事情。 

588
00:30:32,509 --> 00:30:33,900
So here's the model.
这是模型。 

589
00:30:33,900 --> 00:30:34,890
I give you n items.
我给你n件。 

590
00:30:34,890 --> 00:30:37,919
You can do all pairwise comparisons between those items
您可以在这些项目之间进行所有成对比较

591
00:30:38,119 --> 00:30:41,179
for free and then I give you a new item
免费，然后我给你一个新项目

592
00:30:41,180 --> 00:30:43,259
and then I start charging for comparisons.
然后我开始收费以进行比较。 

593
00:30:43,259 --> 00:30:45,269
So another way to say it is I only
所以另一种说法是我只

594
00:30:45,269 --> 00:30:50,799
charge between for comparisons between x and the other items.
在x和其他项目之间进行比较时收取费用。 

595
00:30:50,799 --> 00:30:53,272
And even then you need lg n.
即使这样，您也需要lg n。 

596
00:30:53,272 --> 00:30:55,674
AUDIENCE: [INAUDIBLE] case for sorting, right?
听众：[听不清]整理箱，对不对？ 

597
00:30:55,674 --> 00:30:57,799
PROFESSOR: With sorting they were not preprocessed.
教授：经过排序，它们没有经过预处理。 

598
00:30:57,799 --> 00:30:59,419
Yeah, I didn't write the theorem.
是的，我没有写定理。 

599
00:30:59,420 --> 00:31:01,670
It's just sorting and given items, no preprocessing.
它只是排序和给定项目，无需预处理。 

600
00:31:01,670 --> 00:31:03,190
AUDIENCE: What if there were preprocessing?
听众：如果进行预处理会怎样？ 

601
00:31:03,190 --> 00:31:04,130
PROFESSOR: If they were preprocessed,
教授：如果他们已经过预处理， 

602
00:31:04,130 --> 00:31:05,650
you'd be done in zero comparisons.
您将完成零比较。 

603
00:31:05,650 --> 00:31:07,640
Yeah, exactly.
是的，完全正确。 

604
00:31:07,640 --> 00:31:11,379
This theorem is also true if I remove preprocessed,
如果我删除预处理，这个定理也成立， 

605
00:31:11,579 --> 00:31:14,243
but in fact then you need n time.
但实际上，您需要n次。 

606
00:31:14,243 --> 00:31:15,659
Unfortunately this proof technique
不幸的是，这种证明技术

607
00:31:15,660 --> 00:31:17,670
will only prove a lower bound of log n,
只会证明log n的下限， 

608
00:31:17,670 --> 00:31:20,869
because even if these items were not preprocessed, then
因为即使这些项目没有经过预处理， 

609
00:31:21,069 --> 00:31:23,104
you have to do linear search basically.
您必须基本上进行线性搜索。 

610
00:31:23,104 --> 00:31:25,019
So if you don't know anything about the items,
因此，如果您对这些物品一无所知， 

611
00:31:25,019 --> 00:31:26,670
you need linear time.
您需要线性时间。 

612
00:31:26,670 --> 00:31:29,950
But this proof will only prove a lower bound of log n.
但是此证明只能证明log n的下限。 

613
00:31:29,950 --> 00:31:32,519
So this technique, while cool and simple,
因此，这项技术虽然简单又酷， 

614
00:31:32,519 --> 00:31:34,269
does not always give you the right answer.
并不总是能给您正确的答案。 

615
00:31:34,269 --> 00:31:36,170
It just gives you a lower bound.
它只是给您一个下限。 

616
00:31:36,170 --> 00:31:39,599
May not be the right lower bound, may not be tight.
可能不是正确的下限，可能不是严格的。 

617
00:31:39,799 --> 00:31:42,869
So searching always requires lg n time and what's interesting
所以搜索总是需要lg n时间，而有趣的是

618
00:31:42,869 --> 00:31:45,979
is it requires it even when you preprocess the items.
即使在预处理项目时也需要它吗？ 

619
00:31:45,980 --> 00:31:49,049
Sorting, if you haven't preprocessed the items,
排序，如果您尚未预处理项目， 

620
00:31:49,049 --> 00:31:51,049
then it takes n lg n.
则需要n lg n。 

621
00:31:51,049 --> 00:31:52,659
Clear?
明确？ 

622
00:31:52,660 --> 00:31:53,509
Good.
好。 

623
00:31:53,509 --> 00:31:55,843
Now we get to the algorithms part of the lecture, always
现在，我们总是去讲课的算法部分

624
00:31:55,843 --> 00:31:56,650
the most fun.
最有趣的。 

625
00:31:56,650 --> 00:31:58,730
The moments you've been waiting for.
您一直在等待的时刻。 

626
00:31:58,730 --> 00:32:00,039
Let me erase comparison trees.
让我删除比较树。 

627
00:32:00,039 --> 00:32:03,950



628
00:32:03,950 --> 00:32:07,769
Henceforth and I mean not only this lecture, but also
从今以后，我的意思不仅是这次演讲， 

629
00:32:07,769 --> 00:32:10,379
the next three lectures which are about hashing,
接下来的三讲是关于散列的

630
00:32:10,380 --> 00:32:13,480
we will not be in the comparison model
我们将不在比较模型中

631
00:32:13,480 --> 00:32:16,759
because for comparison model, we're done.
因为对于比较模型，我们已经完成了。 

632
00:32:16,759 --> 00:32:20,480
We solved search, we solved sorting, n lg n three ways.
我们解决了搜索，我们解决了排序，三种方式。 

633
00:32:20,480 --> 00:32:22,769
I mean, how much more can we do?
我的意思是，我们还能做什么？ 

634
00:32:22,769 --> 00:32:26,349
So it's time to bump it up a notch,
现在是时候把它提高一个档次了， 

635
00:32:26,349 --> 00:32:29,129
increase our model power.
增加我们的模型能力。 

636
00:32:29,130 --> 00:32:32,880
We've talked about the RAM in particular, Random Access
我们特别讨论了RAM，即随机存取

637
00:32:32,880 --> 00:32:35,660
Machine, where memory is in array,
机器，内存在阵列中， 

638
00:32:35,660 --> 00:32:38,230
you can access anything in the array in constant time.
您可以在恒定时间内访问数组中的任何内容。 

639
00:32:38,230 --> 00:32:45,184
We're going to use that power of the RAM to sort in linear time,
我们将使用RAM的功能来按线性时间排序， 

640
00:32:45,184 --> 00:32:45,684
sometimes.
有时。 

641
00:32:45,684 --> 00:32:52,490



642
00:32:52,490 --> 00:32:56,549
A more appropriate title for this section of this lecture
本课本节的更合适的标题

643
00:32:56,549 --> 00:32:57,849
would be integer sorting.
将是整数排序。 

644
00:32:57,849 --> 00:33:01,949



645
00:33:01,950 --> 00:33:03,919
OK, so far we've been talking about comparison
好，到目前为止，我们一直在谈论比较

646
00:33:04,119 --> 00:33:07,139
sorting where the items you're given-- the only thing you
排序您在哪里得到的物品-您唯一的选择

647
00:33:07,140 --> 00:33:10,909
know about them is that you can compare them in constant time.
了解它们是您可以在恒定时间内进行比较。 

648
00:33:11,109 --> 00:33:13,129
But now we're going to think about the situation
但是现在我们要考虑情况

649
00:33:13,130 --> 00:33:16,109
where the things that you're sorting are integers.
您要排序的是整数。 

650
00:33:16,309 --> 00:33:20,559
That's a big assumption but it's a practical assumption a lot
这是一个很大的假设，但实际上是一个实际的假设

651
00:33:20,559 --> 00:33:21,220
of the time.
的时间。 

652
00:33:21,220 --> 00:33:23,720
If you're not sorting integers you can map whatever the heck
如果您不对整数进行排序，则可以映射任何内容

653
00:33:23,720 --> 00:33:25,419
you're sorting into integers.
您正在将整数排序。 

654
00:33:25,619 --> 00:33:27,209
And usually it's already been done
通常已经完成了

655
00:33:27,210 --> 00:33:29,140
because you're representing it on a computer.
因为您是在计算机上表示它。 

656
00:33:29,140 --> 00:33:32,849
You've already represented your thing is an integer of sorts.
您已经表示自己的事情是各种各样的整数。 

657
00:33:33,049 --> 00:33:33,569
Bad pun.
双关语。 

658
00:33:33,569 --> 00:33:36,869



659
00:33:36,869 --> 00:33:38,059
This is an assumption.
这是一个假设。 

660
00:33:38,059 --> 00:33:43,389
So we assume-- going to be a little more precise.
因此，我们假设-会更加精确。 

661
00:33:43,390 --> 00:33:49,200
The keys you're sorting are integers.
您要排序的键是整数。 

662
00:33:49,200 --> 00:33:51,720
There's still-- I'm going to put a little n here,
还有-我要在这里放一点n 

663
00:33:51,720 --> 00:33:52,795
remember there's n keys.
记得有n把钥匙。 

664
00:33:52,795 --> 00:33:57,899



665
00:33:58,099 --> 00:34:01,925
I'm also going to assume that they're in some range.
我还要假设它们在一定范围内。 

666
00:34:01,925 --> 00:34:04,299
And for convenience, I'm going to assume that they're all
为了方便起见，我将假设它们都是

667
00:34:04,299 --> 00:34:07,500
non-negative-- it's not hard to deal with negative numbers,
非负数-处理负数并不难， 

668
00:34:07,500 --> 00:34:09,719
but it's just convenient to think
但是思考起来很方便

669
00:34:09,719 --> 00:34:12,349
about non-negative numbers.
关于非负数。 

670
00:34:12,349 --> 00:34:15,259
So if you start at zero, there's some maximum value,
因此，如果您从零开始，那么会有一些最大值， 

671
00:34:15,260 --> 00:34:16,230
say k minus 1.
说k减1。 

672
00:34:16,230 --> 00:34:18,900
So there's k different values they could be.
因此，它们可能有k个不同的值。 

673
00:34:18,900 --> 00:34:19,800
K could be anything.
 K可以是任何东西。 

674
00:34:19,800 --> 00:34:20,639
It's a parameter.
这是一个参数。 

675
00:34:20,639 --> 00:34:22,139
We've always had n as a parameter,
我们一直都有n作为参数， 

676
00:34:22,139 --> 00:34:23,855
now we're going to also have k as a parameter.
现在我们还将以k为参数。 

677
00:34:24,054 --> 00:34:27,750



678
00:34:27,750 --> 00:34:36,659
And just for completeness-- and each fits in a word.
只是为了完整性-每个词都适合一个词。 

679
00:34:36,659 --> 00:34:42,442
Remember the machine word of your RAM machine?
还记得您的RAM机器的机器字吗？ 

680
00:34:42,442 --> 00:34:43,900
Words were the things that we could
言语是我们可以做的事

681
00:34:43,900 --> 00:34:45,173
manipulate in constant time.
在恒定时间内进行操作。 

682
00:34:45,173 --> 00:34:46,840
Now this is a very reasonable assumption
现在，这是一个非常合理的假设

683
00:34:46,840 --> 00:34:48,280
because we've been assuming so far
因为到目前为止我们一直在假设

684
00:34:48,280 --> 00:34:52,614
you can compare two keys to items in constant time.
您可以在固定时间内将两个键与项目进行比较。 

685
00:34:52,813 --> 00:34:54,230
To get that for integers, you need
要获取整数，您需要

686
00:34:54,230 --> 00:34:56,130
to assume that your integers are fitting in words.
假设您的整数适合单词。 

687
00:34:56,130 --> 00:34:57,755
We usually don't state this assumption,
我们通常不陈述这个假设， 

688
00:34:57,755 --> 00:34:59,744
but I thought I'd throw it in just for kicks.
但是我以为我会踢它。 

689
00:34:59,744 --> 00:35:01,119
So we've got a bunch of integers,
所以我们有一堆整数， 

690
00:35:01,119 --> 00:35:02,118
each one fits in a word.
每个单词都适合。 

691
00:35:02,119 --> 00:35:04,460
I could compare them, that takes constant time,
我可以比较一下，这需要持续的时间， 

692
00:35:04,659 --> 00:35:09,509
or I could add them or subtract them or multiply them or divide
或者我可以将它们相加或相减或相乘或相除

693
00:35:09,510 --> 00:35:12,960
them or do whatever the heck I want.
他们或做我想要的一切。 

694
00:35:13,159 --> 00:35:24,581
It turns out you can do a lot more than comparisons
事实证明，您所要做的不只是比较

695
00:35:24,581 --> 00:35:26,039
and it turns out this will help us.
事实证明，这将对我们有所帮助。 

696
00:35:26,039 --> 00:35:40,949



697
00:35:40,949 --> 00:35:43,149
I don't know if I want to tell you the answer here.
我不知道是否要在这里告诉你答案。 

698
00:35:43,150 --> 00:35:49,940
For k-- not too big-- you can sort in linear time.
对于k-不太大-可以按线性时间排序。 

699
00:35:49,940 --> 00:35:53,510



700
00:35:53,510 --> 00:35:56,500
Believe it or not, this topic, integer sorting,
信不信由你，这个主题，整数排序， 

701
00:35:56,500 --> 00:35:58,280
is still a major area of research.
仍然是主要的研究领域。 

702
00:35:58,280 --> 00:36:01,070
People are still trying to solve this problem.
人们仍在努力解决这个问题。 

703
00:36:01,070 --> 00:36:05,440
One conjecture is that even in all cases,
一个猜想是，即使在所有情况下， 

704
00:36:05,639 --> 00:36:07,460
you can sort in linear time given
您可以按照给定的线性时间进行排序

705
00:36:07,460 --> 00:36:09,505
any integers that fit in words.
任何适合单词的整数。 

706
00:36:09,505 --> 00:36:11,460
This is not yet solved.
这还没有解决。 

707
00:36:11,659 --> 00:36:14,779
Best algorithm is n times square root lg lg
最佳算法是n次平方根lg lg 

708
00:36:14,780 --> 00:36:17,610
n with high probability.
 n的概率很高。 

709
00:36:17,809 --> 00:36:20,420
So it's almost-- almost n.
所以几乎-几乎是n。 

710
00:36:20,420 --> 00:36:22,539
It's a lot better than n lg n.
比n lg n好很多。 

711
00:36:22,539 --> 00:36:28,619
I'll just write that for fun case you can't parse in words.
我只是写一个有趣的例子，你不能用语言来解析。 

712
00:36:28,619 --> 00:36:31,880
This is the best algorithms to date.
这是迄今为止最好的算法。 

713
00:36:31,880 --> 00:36:34,500
I would conjecture you can do linear time in all situations.
我猜想你可以在所有情况下做线性时间。 

714
00:36:34,500 --> 00:36:36,166
We're not going to cover this algorithm.
我们将不讨论该算法。 

715
00:36:36,166 --> 00:36:37,710
That's a little beyond us.
那超出了我们。 

716
00:36:37,710 --> 00:36:42,360
It's in advanced algorithms if you're interested, 6854.
如果您有兴趣，可以使用高级算法6854。 

717
00:36:42,360 --> 00:36:44,960
But we're going to show that for a lot of cases of interest
但是我们将展示很多感兴趣的案例

718
00:36:45,159 --> 00:36:47,429
when k is not ginormous, it's really
当k不是巨大的时候

719
00:36:47,429 --> 00:36:50,600
easy to sort in linear time.
易于按线性时间排序。 

720
00:36:50,601 --> 00:36:51,099
All right?
好吧？ 

721
00:36:51,099 --> 00:36:56,009
And our first algorithm to achieve this is counting sort.
我们实现此目标的第一个算法是计数排序。 

722
00:36:56,010 --> 00:37:01,000



723
00:37:01,000 --> 00:37:03,679
Counting sort does not make any comparisons.
计数排序不做任何比较。 

724
00:37:03,679 --> 00:37:06,980
It only does other stuff.
它只做其他事情。 

725
00:37:06,980 --> 00:37:09,760
And it's going to depend on n.
这将取决于n。 

726
00:37:09,760 --> 00:37:10,710
It's going to depend on k.
这将取决于k。 

727
00:37:10,909 --> 00:37:14,819
We'll get some running times not bad as long as k is not giant.
只要k不大，我们将获得一些不错的运行时间。 

728
00:37:14,820 --> 00:37:17,500
So as the name might suggest, what you
顾名思义，您会

729
00:37:17,500 --> 00:37:21,139
do is count all the items.
要做的就是计算所有项目。 

730
00:37:21,139 --> 00:37:30,569
So imagine I give you a bunch of keys like 3, 5 7, 5, 5, 3, 6,
想象一下，我给你一堆钥匙，例如3、5、7、5、5、3、6 

731
00:37:30,570 --> 00:37:32,324
whatever.
随你。 

732
00:37:32,523 --> 00:37:33,940
I'd like to run through this array
我想遍历这个数组

733
00:37:33,940 --> 00:37:37,440
and say, ah, I see there are two 3's and there
说，啊，我看到有两个3 

734
00:37:37,440 --> 00:37:44,670
are three 5's and there's one 6, and one 7, so how do I sort it?
有3个5，有1个6和1个7，那么如何排序呢？ 

735
00:37:44,670 --> 00:37:46,730
I'd like to say, well 3 is smallest key
我想说，3是最小键

736
00:37:46,929 --> 00:37:49,429
and there's two of them, so I'll write two 3's, then there's
有两个，所以我写两个3，然后有

737
00:37:49,429 --> 00:37:53,019
three 5's so I'll write three 5's, and then there's a 6
三个5，所以我写三个5，然后有一个6 

738
00:37:53,019 --> 00:37:54,809
and then there's a 7.
然后是7 

739
00:37:54,809 --> 00:37:56,029
That's the intuition.
这是直觉。 

740
00:37:56,030 --> 00:38:00,170
Now how do I-- how I do that with an algorithm?
现在我该如何使用算法来做到这一点？ 

741
00:38:00,170 --> 00:38:02,500
Suggestions?
有什么建议吗？ 

742
00:38:02,699 --> 00:38:03,264
Yeah?
是啊

743
00:38:03,264 --> 00:38:04,139
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

744
00:38:04,139 --> 00:38:10,869



745
00:38:10,869 --> 00:38:11,549
PROFESSOR: Yeah.
教授：是的。 

746
00:38:11,550 --> 00:38:13,030
Allocate an array of memory, which
分配一个内存数组， 

747
00:38:13,030 --> 00:38:15,900
is my counters-- I'm going to count each k.
是我的计数器-我要计数每个k。 

748
00:38:15,900 --> 00:38:17,840
I need an array of size k because there
我需要一个大小为k的数组，因为

749
00:38:17,840 --> 00:38:19,789
are k possible keys.
是k个可能的键。 

750
00:38:19,789 --> 00:38:23,460
Convenient those two terms start with the same letter.
方便的是，这两个术语以相同的字母开头。 

751
00:38:23,460 --> 00:38:25,289
And then I'll just-- whenever I see
然后我会-每当我看到

752
00:38:25,289 --> 00:38:27,340
an-- I'm going to run through the items in order,
一个-我将按顺序浏览这些项目， 

753
00:38:27,340 --> 00:38:29,940
when I see an item, I say, OK, well that's key 3.
当我看到一个项目时，我说，好，那是关键3。 

754
00:38:30,139 --> 00:38:35,059
I will look at index 3 of this array, increment that counter.
我将看一下该数组的索引3，增加该计数器。 

755
00:38:35,059 --> 00:38:36,619
Then I see 5, increment that counter.
然后我看到5，增加那个计数器。 

756
00:38:36,619 --> 00:38:39,469
I see 7, I see 5, I see 5, and by the end,
我看到7，我看到5，我看到5，最后， 

757
00:38:39,469 --> 00:38:43,858
I'll know that there are three 5's and two 3's and so on.
我会知道有三个5和两个3，依此类推。 

758
00:38:43,858 --> 00:38:44,650
That's how I count.
我就是这样计算的。 

759
00:38:44,650 --> 00:38:46,184
And then how do output the items?
然后如何输出项目？ 

760
00:38:46,184 --> 00:38:48,889



761
00:38:48,889 --> 00:38:50,059
You want to keep going?
你想继续吗？ 

762
00:38:50,059 --> 00:38:50,934
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

763
00:38:50,934 --> 00:38:56,299



764
00:38:56,300 --> 00:38:58,500
PROFESSOR: Yeah, just traverse the array
教授：是的，只需遍历数组

765
00:38:58,500 --> 00:39:03,250
of counters and the array is already
的计数器和数组已经

766
00:39:03,250 --> 00:39:06,940
written in order by key, so it's really easy.
按键顺序编写，因此非常容易。 

767
00:39:06,940 --> 00:39:10,019
I mean I could draw this array for you if you like at 0, 1,
我的意思是，如果您喜欢0、1，我可以为您绘制此数组

768
00:39:10,219 --> 00:39:10,869
2 3.
 2 3。 

769
00:39:10,869 --> 00:39:15,269
Here's the 3 position, it ends up with the value 2.
这是第3个位置，其最终值为2。 

770
00:39:15,269 --> 00:39:18,360
And if I just go through, a lot of these will have 0's in them,
如果我刚讲完，其中很多将带有0， 

771
00:39:18,360 --> 00:39:19,670
just skip those.
只是跳过那些。 

772
00:39:19,869 --> 00:39:21,489
When I find a non-zero entry, just
当我发现一个非零条目时， 

773
00:39:21,489 --> 00:39:26,096
write-- oh, that means there's two 3's there, so I write 3, 3.
写-哦，那意味着那里有两个3，所以我写3、3。 

774
00:39:26,096 --> 00:39:27,920
OK, that algorithm would work but I'm not
好的，该算法可以工作，但我不能

775
00:39:27,920 --> 00:39:30,789
going to even write it down, not even going to dignify it,
甚至要写下来，甚至不去端庄

776
00:39:30,789 --> 00:39:35,920
because all it does is sort integers.
因为它所做的只是对整数排序。 

777
00:39:35,920 --> 00:39:37,599
But there's a subtlety here which
但是这里有一个微妙之处

778
00:39:37,599 --> 00:39:40,299
we're going to need in a moment, which is why I stress it,
我们很快就会需要，这就是我强调它的原因， 

779
00:39:40,300 --> 00:39:42,750
that really we have n items.
确实我们有n个项目。 

780
00:39:42,750 --> 00:39:45,550
Each of them has a key, but it might have other stuff
他们每个人都有一个钥匙，但可能还有其他东西

781
00:39:45,550 --> 00:39:48,289
too that we'd like to bring along for the ride.
我们也想带他去兜风。 

782
00:39:48,289 --> 00:39:50,469
We'll see why we care about that in a moment.
我们一会儿就会明白为什么我们会在意这一点。 

783
00:39:50,469 --> 00:39:52,689
But it's also a typical situation,
但这也是典型的情况

784
00:39:52,690 --> 00:39:57,440
like you have a spreadsheet and you click sort by this column.
就像您有一个电子表格，然后单击“按此列排序”。 

785
00:39:57,440 --> 00:39:59,789
Well every row has a whole bunch of data
好每一行都有一堆数据

786
00:39:59,989 --> 00:40:02,439
but you're only trying to sort by one of those fields,
但您仅尝试按这些字段之一进行排序， 

787
00:40:02,440 --> 00:40:04,039
that one column.
那一栏。 

788
00:40:04,239 --> 00:40:06,201
And that one field may be an integer,
而且一个字段可以是整数， 

789
00:40:06,202 --> 00:40:08,460
but there's all this other stuff you'd like to bring along.
但是还有其他所有您想带的东西。 

790
00:40:08,659 --> 00:40:11,909
And when you say, oh, there are two 3's,
当你说，哦，有两个3 

791
00:40:11,909 --> 00:40:15,449
you know there's this 3, which you know maybe
你知道这是3，你也许知道

792
00:40:15,449 --> 00:40:17,269
has a cloud around it.
周围有云。 

793
00:40:17,269 --> 00:40:19,320
There's this 3 which maybe has a heart around it.
这3个周围可能有一颗心。 

794
00:40:19,320 --> 00:40:21,840
That's about the limit of my drawing abilities.
那是我绘画能力的极限。 

795
00:40:21,840 --> 00:40:24,592
And now say, oh, there are two 3's but which 3?
现在说，哦，有两个3，但是哪个3？ 

796
00:40:24,791 --> 00:40:27,000
Should the cloud go first, should the heart go first?
云应该先走，心要先走吗？ 

797
00:40:27,000 --> 00:40:28,541
I mean I don't care which goes first,
我的意思是我不在乎哪个先行

798
00:40:28,541 --> 00:40:32,130
maybe-- I do, actually-- but I will in a moment.
也许-实际上，但是-稍后我会。 

799
00:40:32,329 --> 00:40:34,110
That's another topic.
那是另一个话题。 

800
00:40:34,110 --> 00:40:35,884
But I'd like to bring that cloud somewhere.
但是我想把那朵云带到某个地方。 

801
00:40:36,083 --> 00:40:37,500
I want to put the cloud somewhere,
我想把云放在某个地方， 

802
00:40:37,500 --> 00:40:38,969
want to put the heart somewhere.
想把心放在某处。 

803
00:40:38,969 --> 00:40:42,089
All right, so here's a way to do all that.
好的，这是完成所有操作的一种方法。 

804
00:40:42,090 --> 00:40:53,559
Basically the same algorithm but I'm just going to use lists.
基本上是相同的算法，但我将使用列表。 

805
00:40:53,559 --> 00:40:58,110



806
00:40:58,110 --> 00:41:00,500
Still have an array of k things but no longer counters,
仍然有k个东西数组，但不再有计数器， 

807
00:41:00,699 --> 00:41:01,289
now lists.
现在列出。 

808
00:41:01,289 --> 00:41:03,619
They could be linked lists, they could be python lists.
它们可以是链接列表，也可以是python列表。 

809
00:41:03,619 --> 00:41:06,230
It won't matter for my purposes.
对我而言，这无关紧要。 

810
00:41:06,230 --> 00:41:14,940
And then I'll say for j and range of n-- that'd
然后我要说出j和n的范围

811
00:41:14,940 --> 00:41:19,940
be super pythonic here-- I want to look at the list who's
在这里超级pythonic-我想看看谁的名单

812
00:41:19,940 --> 00:41:32,500
at index a of j and append a of j.
在j的索引a处并追加j的a。 

813
00:41:32,500 --> 00:41:39,764
And then the output is going to be an empty list initially.
然后输出最初将是一个空列表。 

814
00:41:39,764 --> 00:41:43,219



815
00:41:43,219 --> 00:41:47,599
And then I iterate through the array their k values for that,
然后我遍历数组中的k值， 

816
00:41:47,599 --> 00:41:58,170
and I just say output, extend, list i.
我只是说输出，扩展，列出我。 

817
00:41:58,170 --> 00:41:58,730
OK.
好。 

818
00:41:58,730 --> 00:42:01,148
This is counting sort or a version of counting sort.
这是计数排序或计数排序的一种版本。 

819
00:42:01,148 --> 00:42:03,440
In your textbook, you'll find a different version which
在教科书中，您会找到其他版本， 

820
00:42:03,440 --> 00:42:06,005
does not use lists, So it's probably more practical
不使用列表，所以它可能更实用

821
00:42:06,005 --> 00:42:07,879
because it uses no data structures whatsoever
因为它不使用任何数据结构

822
00:42:07,880 --> 00:42:10,369
except three arrays.
除了三个数组。 

823
00:42:10,369 --> 00:42:12,109
But it runs in the same amount of time
但是它运行的时间相同

824
00:42:12,110 --> 00:42:14,170
and this is a lot easier I think to think about.
我想这要容易得多。 

825
00:42:14,369 --> 00:42:18,920
This is more modern perspective, if you well.
如果您愿意的话，这是更现代的观点。 

826
00:42:18,920 --> 00:42:20,889
For every item, if you'd look at them
对于每个项目，如果您要看一下

827
00:42:20,889 --> 00:42:22,809
in the given order of your array,
按照数组的给定顺序， 

828
00:42:22,809 --> 00:42:24,409
you see what it's key value is.
您会看到它的关键价值是什么。 

829
00:42:24,409 --> 00:42:26,699
Maybe that's not exactly the same as the item,
可能与商品不完全相同， 

830
00:42:26,699 --> 00:42:29,201
so it could be key of x is just x.
所以可能x的键只是x。 

831
00:42:29,202 --> 00:42:30,710
But you know in python sort, for example,
但是您知道python排序

832
00:42:30,909 --> 00:42:33,445
you're given a key function.
您会获得关键功能。 

833
00:42:33,445 --> 00:42:34,569
So you take that key value.
因此，您可以获取关键价值。 

834
00:42:34,570 --> 00:42:36,630
The key is guaranteed to be an integer between 0
该键保证是0到0之间的整数

835
00:42:36,630 --> 00:42:41,039
and k minus 1, so you look at the list, that numbered list,
和k减1，所以您查看列表，该编号列表， 

836
00:42:41,239 --> 00:42:44,319
and you just add this item to the list.
然后您只需将此项目添加到列表中即可。 

837
00:42:44,320 --> 00:42:44,820
OK.
好。 

838
00:42:44,820 --> 00:42:46,195
But the item is not just the key,
但是，这不仅仅是关键， 

839
00:42:46,195 --> 00:42:49,460
it's everything-- whatever that data structure is--
一切-无论数据结构是什么- 

840
00:42:49,460 --> 00:42:53,420
and then you just go through the list and you concatenate them.
然后您只需浏览列表，然后将它们连接起来。 

841
00:42:53,420 --> 00:42:53,920
OK.
好。 

842
00:42:53,920 --> 00:42:54,730
How long does this take?
这需要多长时间？ 

843
00:42:54,929 --> 00:42:57,480



844
00:42:57,480 --> 00:43:01,139
How long does this step take?
此步骤需要多长时间？ 

845
00:43:01,139 --> 00:43:01,879
N?
不行

846
00:43:01,880 --> 00:43:03,789
Nope.
不。 

847
00:43:03,989 --> 00:43:04,659
Constant?
不变？ 

848
00:43:04,659 --> 00:43:06,109
Nope.
不。 

849
00:43:06,110 --> 00:43:07,144
OK.
好。 

850
00:43:07,344 --> 00:43:08,344
Look at all the actions.
查看所有动作。 

851
00:43:08,344 --> 00:43:09,556
It's order k time.
这是k时间。 

852
00:43:09,556 --> 00:43:11,389
To create an empty list takes constant time.
创建一个空列表需要固定的时间。 

853
00:43:11,389 --> 00:43:12,599
They're k of them.
他们是其中的k。 

854
00:43:12,599 --> 00:43:14,400
OK?
好？ 

855
00:43:14,400 --> 00:43:16,849
How long does this step take, just the append?
仅需追加，此步骤需要多长时间？ 

856
00:43:16,849 --> 00:43:20,329



857
00:43:20,329 --> 00:43:21,130
Constant?
不变？ 

858
00:43:21,130 --> 00:43:22,070
Good.
好。 

859
00:43:22,070 --> 00:43:24,920
Remember, append is constant time from the Python model
请记住，append是Python模型中的固定时间

860
00:43:25,119 --> 00:43:27,670
or your favorite model, anything.
或您最喜欢的模型，任何东西。 

861
00:43:27,670 --> 00:43:29,590
We're assuming the key takes constant time
我们假设密钥需要固定的时间

862
00:43:29,590 --> 00:43:33,170
because that's the word, so that's an assumption,
因为那是单词，所以这是一个假设， 

863
00:43:33,369 --> 00:43:35,900
but in the normal assumption.
但按照正常的假设。 

864
00:43:35,900 --> 00:43:39,639
So total time here is order n.
因此，这里的总时间为n。 

865
00:43:39,639 --> 00:43:43,679
And this thing, well this takes basically the length
而这件事，这基本上需要花费时间

866
00:43:43,679 --> 00:43:46,359
of Li time.
李时间。 

867
00:43:46,360 --> 00:43:50,710
And so when you add it up, maybe plus 1--
因此，当您将其相加时，可能会加上1-- 

868
00:43:50,909 --> 00:43:52,659
because to look at an empty list you still
因为要看一个空清单，你仍然

869
00:43:52,659 --> 00:43:54,949
need to look at it-- so you add it up
需要看看-所以您将其加起来

870
00:43:54,949 --> 00:44:00,661
and you get order sum of all the Li's is all the items.
您会得到所有李氏物品的订单总和。 

871
00:44:00,661 --> 00:44:02,369
And then you get plus 1 for each of them,
然后您每个人加1， 

872
00:44:02,369 --> 00:44:05,380
so you get n plus k. n plus k is the running
所以你得到n加k n加k正在运行

873
00:44:05,380 --> 00:44:08,050
time of this algorithm.
该算法的时间。 

874
00:44:08,050 --> 00:44:10,380
Add those up.
加起来

875
00:44:10,380 --> 00:44:12,610
OK, so counting sort is order n plus k.
好的，所以计数排序是n加上k。 

876
00:44:12,610 --> 00:44:16,670
So if k happens to be order n, this is linear time.
因此，如果k恰好是n阶，则这是线性时间。 

877
00:44:16,869 --> 00:44:19,889
But as soon as it's a little bit bigger, you're in trouble.
但是，只要稍大一点，您就会遇到麻烦。 

878
00:44:19,889 --> 00:44:21,369
So counting sort's a good warm up,
所以算是一个很好的热身， 

879
00:44:21,369 --> 00:44:23,119
but it's not ultimately what we want.
但这并不是我们最终想要的。 

880
00:44:23,119 --> 00:44:31,059



881
00:44:31,059 --> 00:44:40,349
And a much cooler algorithm is called radix sort.
而且更酷的算法称为基数排序。 

882
00:44:40,349 --> 00:44:45,467



883
00:44:45,467 --> 00:44:47,800
It's going to use counting sort as the subroutine, which
它将使用计数排序作为子例程， 

884
00:44:47,800 --> 00:44:52,150
is why spent all this time on a mediocre algorithm.
这就是为什么将所有这些时间都花在平庸的算法上的原因。 

885
00:44:52,150 --> 00:44:56,800
And it's going to get a much larger range of k
而且它将获得更大范围的k 

886
00:44:56,800 --> 00:45:00,539
and it will still be linear time.
而且仍然是线性时间。 

887
00:45:00,739 --> 00:45:01,829
I'll tell you the answer.
我会告诉你答案。 

888
00:45:01,829 --> 00:45:09,039



889
00:45:09,039 --> 00:45:11,849
K can be polynomial in n.
 K可以是n中的多项式。 

890
00:45:11,849 --> 00:45:18,000
So like if all your integers are between 0 and n to the 100,
因此，就像所有整数都在0到n到100之间一样， 

891
00:45:18,000 --> 00:45:20,800
you can sort them in n lg n time.
您可以n n n次对它们进行排序。 

892
00:45:20,800 --> 00:45:22,420
That's a lot bigger.
更大了。 

893
00:45:22,420 --> 00:45:24,190
It's not just like 10 n.
不只是10 n。 

894
00:45:24,190 --> 00:45:27,269
I mean you could do 10 n here as well with counting sort.
我的意思是您也可以在这里进行10 n计数排序。 

895
00:45:27,469 --> 00:45:30,480
And it's not just like n lg n, but they can go all the way
这不仅仅像n lg n，而且他们可以一路走下去

896
00:45:30,480 --> 00:45:34,760
to n to the 100, still be linear time.
到n到100，仍然是线性时间。 

897
00:45:34,760 --> 00:45:38,090
So that's what we're going to achieve.
这就是我们要实现的目标。 

898
00:45:38,289 --> 00:45:41,329
The idea of radix sort is simple.
基数排序的想法很简单。 

899
00:45:41,329 --> 00:45:44,819
It's actually kind of the Excel spreadsheet approach.
实际上，这是一种Excel电子表格方法。 

900
00:45:44,820 --> 00:45:49,730
We're going to imagine we want to break
我们将想象我们要打破

901
00:45:49,730 --> 00:45:51,639
each integer into a bunch of columns.
每个整数变成一列列。 

902
00:45:51,639 --> 00:46:03,529



903
00:46:03,530 --> 00:46:04,710
How do we do that?
我们该怎么做？ 

904
00:46:04,909 --> 00:46:07,049
Well, the way we normally write down numbers,
好吧，我们通常写下数字的方式， 

905
00:46:07,050 --> 00:46:10,039
except not necessarily in decimal, in some arbitrary base
除非不一定是十进制，否则可以是任意基数

906
00:46:10,039 --> 00:46:11,279
b.
 b。 

907
00:46:11,280 --> 00:46:12,960
So I say, oh, an integer in base b.
所以我说，哦，以b为底的整数。 

908
00:46:12,960 --> 00:46:15,010
Well then there's the least significant digit
好吧，那是最不重要的数字

909
00:46:15,010 --> 00:46:16,393
and then the next one and the next one
然后下一个和下一个

910
00:46:16,592 --> 00:46:18,719
and the next one, some sequence of digits.
下一个是一些数字序列。 

911
00:46:18,719 --> 00:46:22,559
And if I know that the maximum value is k,
如果我知道最大值是k 

912
00:46:22,559 --> 00:46:25,489
I know that the number of digits,
我知道位数

913
00:46:25,489 --> 00:46:28,209
which I'm going to call-- for each number which I'm
我要打电话给我的每个号码

914
00:46:28,210 --> 00:46:37,510
going to call d, is just lg base b of k plus one, whatever.
将要呼叫d，只是lg以b为基础的k加1，无论如何。 

915
00:46:37,510 --> 00:46:40,409
We've got to be super precise here
我们必须在这里非常精确

916
00:46:40,409 --> 00:46:44,145
because if I'm in base b then that's what lg is, right?
因为如果我在基地b中，那就是lg，对吗？ 

917
00:46:44,146 --> 00:46:45,519
So normally we think of lg base 2
所以通常我们想到lg base 2 

918
00:46:45,519 --> 00:46:47,460
because we're writing things in binary.
因为我们用二进制编写东西。 

919
00:46:47,460 --> 00:46:50,449
Computer scientists normally think that way.
计算机科学家通常以这种方式思考。 

920
00:46:50,449 --> 00:46:52,948
And fine, so now we decomposed our integer.
很好，所以现在我们分解整数。 

921
00:46:52,949 --> 00:46:54,539
I'm not going to actually compute this base
我不会实际计算这个基数

922
00:46:54,739 --> 00:46:57,729
b representation, because it would take a long time.
 b表示，因为需要很长时间。 

923
00:46:57,730 --> 00:47:01,780
I'd have to spend n times lg k time to do that.
我必须花n倍于lg k的时间来做到这一点。 

924
00:47:01,780 --> 00:47:03,630
I don't want to do that.
我不想那样做。 

925
00:47:03,829 --> 00:47:06,949
OK, but just imagine it that way.
好的，但是就这样想吧。 

926
00:47:06,949 --> 00:47:08,980
And then the algorithm as follows,
然后算法如下

927
00:47:08,980 --> 00:47:15,349
sort the integers, all of them, by the least significant digit.
将所有整数按最低有效位排序。 

928
00:47:15,349 --> 00:47:20,539



929
00:47:20,539 --> 00:47:22,400
Sort by the next least significant digit.
按下一个最低有效数字排序。 

930
00:47:22,400 --> 00:47:29,000
Dot, dot, dot, sort by the most significant digit.
点，点，点按最高有效位排序。 

931
00:47:29,000 --> 00:47:33,460
So there are d iterations here, for d digits.
因此，这里有d个迭代，即d个数字。 

932
00:47:33,460 --> 00:47:35,570
Sort all the integers by the least significant,
将所有整数按最低有效位排序， 

933
00:47:35,570 --> 00:47:39,010
all the integers by the next, and so on.
所有整数乘以下一个，依此类推。 

934
00:47:39,010 --> 00:47:41,670
It's like in your-- this is a useful technique in Excel,
就像在您中，这是Excel中的一项有用技术， 

935
00:47:41,670 --> 00:47:43,739
if you want to sort by several columns--
如果您要按几列进行排序， 

936
00:47:43,739 --> 00:47:46,030
or your favorite spreadsheet, doesn't have to be Excel,
或您最喜欢的电子表格，不必是Excel， 

937
00:47:46,030 --> 00:47:50,480
sorry-- you click on the least significant column first,
抱歉-您先点击最低有效列， 

938
00:47:50,480 --> 00:47:53,130
and then click on all the other columns in increasing order,
然后按升序单击所有其他列， 

939
00:47:53,130 --> 00:47:55,550
you will sort by all of them, it turns out.
事实证明，您将对它们进行排序。 

940
00:47:55,550 --> 00:47:57,425
It's kind of magical that this works.
这种方法有点神奇。 

941
00:47:57,425 --> 00:48:00,512



942
00:48:00,512 --> 00:48:03,030
I don't have a ton of time for an example.
我没有很多时间来举例说明。 

943
00:48:03,030 --> 00:48:04,460
Let me first analyze the algorithm.
首先让我分析一下算法。 

944
00:48:04,659 --> 00:48:07,159
We'll see if we have time for an example.
我们将看看是否有时间举例。 

945
00:48:07,159 --> 00:48:12,239
So there are d digits-- oh, and I'm
所以有d位数字-哦，我

946
00:48:12,239 --> 00:48:18,534
going to sort each of these sorts of using counting sort.
将要使用计数排序对所有这些排序。 

947
00:48:18,534 --> 00:48:27,449



948
00:48:27,449 --> 00:48:33,500
This is I guess sort by digit using counting sort.
我想这是使用计数排序按数字排序。 

949
00:48:33,500 --> 00:48:35,820
So how long does it take to sort using
所以使用排序需要多长时间

950
00:48:35,820 --> 00:48:37,269
counting sort in this setting?
在这种情况下计数排序？ 

951
00:48:37,269 --> 00:48:43,309



952
00:48:43,309 --> 00:48:44,769
Normally, it's n plus k.
通常，它是n加k。 

953
00:48:44,769 --> 00:48:48,509



954
00:48:48,510 --> 00:48:51,750
Here it is, n plus b.
在这里，n加b。 

955
00:48:51,750 --> 00:48:52,250
Good.
好。 

956
00:48:52,250 --> 00:48:57,300



957
00:48:57,300 --> 00:49:01,550
Because all of our digits are between 0 and b minus 1.
因为我们所有的数字都在0到b减去1之间。 

958
00:49:01,550 --> 00:49:03,230
So we're just sorting by digit.
所以我们只是按数字排序。 

959
00:49:03,230 --> 00:49:06,429
Now here is where we're using this idea of a key.
现在，这里是我们使用密钥的想法的地方。 

960
00:49:06,429 --> 00:49:08,710
When we say key, I wanted our integers.
当我们说密钥时，我想要我们的整数。 

961
00:49:08,710 --> 00:49:12,329
What we do is compute the digit we care about.
我们要做的是计算我们关心的数字。 

962
00:49:12,329 --> 00:49:15,349
So if we're in this step, the key function
所以如果我们在这一步，关键功能

963
00:49:15,349 --> 00:49:17,529
will be compute the least significant digit, which
将计算最低有效位，即

964
00:49:17,530 --> 00:49:21,070
is like taking it mod b to compute the most
就像用mod b计算最多

965
00:49:21,070 --> 00:49:26,940
significant digits like dividing by b to the power of d minus 1
有效数字，例如用b除以d的幂减去1 

966
00:49:26,940 --> 00:49:28,250
or so.
或者。 

967
00:49:28,449 --> 00:49:29,669
OK but it's a constant.
好的，但这是一个常数。 

968
00:49:29,670 --> 00:49:32,250
You do one divide and one mod, the constant number
你做一除一模，常数

969
00:49:32,449 --> 00:49:33,569
of operations.
操作。 

970
00:49:33,570 --> 00:49:35,230
You can extract the digit in constant time.
您可以在固定时间内提取数字。 

971
00:49:35,429 --> 00:49:38,629
So the key function is constant time and so this works.
因此关键功能是恒定时间，因此可以正常工作。 

972
00:49:38,630 --> 00:49:41,210
We don't have to actually write them all down,
我们不必把它们全部写下来， 

973
00:49:41,210 --> 00:49:44,929
just compute them as we need them.
只需根据需要计算它们。 

974
00:49:44,929 --> 00:49:46,980
Cool I guess we could compute them ahead of time.
太酷了，我想我们可以提前计算它们。 

975
00:49:46,980 --> 00:49:49,679
It's not a big deal.
没什么大不了的。 

976
00:49:49,679 --> 00:49:51,369
Fine.
精细。 

977
00:49:51,369 --> 00:49:52,889
So that's each digit.
这就是每个数字。 

978
00:49:52,889 --> 00:49:57,139
So the total time is just that times
所以总时间就是那个时间

979
00:49:57,139 --> 00:49:59,400
d because we have d steps.
 d因为我们有d个步骤。 

980
00:49:59,400 --> 00:50:03,094
So it's n plus b times d.
所以它是n加b乘以d。 

981
00:50:03,094 --> 00:50:09,840
Now d was that lg thing, lg base b of n.
现在d是那个lg物，n的lg基b。 

982
00:50:09,840 --> 00:50:11,030
I have this b.
我有这个b。 

983
00:50:11,030 --> 00:50:14,840
What should be b?
 b应该是什么？ 

984
00:50:14,840 --> 00:50:17,039
You gotta love the English language.
你一定喜欢英语。 

985
00:50:17,239 --> 00:50:22,509
What should I choose b to be, or not to be?
我应该选择b作为还是不成为？ 

986
00:50:22,510 --> 00:50:23,900
That's the question.
这就是问题所在。 

987
00:50:23,900 --> 00:50:25,360
Any suggestions?
有什么建议么？ 

988
00:50:25,360 --> 00:50:26,670
I want to minimize this, right?
我想最小化这个，对吗？ 

989
00:50:26,670 --> 00:50:28,760
I want minimum running time.
我想要最短的运行时间。 

990
00:50:28,760 --> 00:50:32,250
So I'd like b to kind of large to make this base large.
因此，我希望b较大以使此基准较大。 

991
00:50:32,449 --> 00:50:35,164
Sorry, this is not n, this is k.
抱歉，这不是n，是k。 

992
00:50:35,164 --> 00:50:37,829
I copied that wrong out of excitement.
我激动地复制了那个错误。 

993
00:50:37,829 --> 00:50:40,429
Just copying this over.
只需将其复制过来。 

994
00:50:40,429 --> 00:50:41,839
OK, I'd like b to be large, but I
好吧，我希望b变大，但是我

995
00:50:41,840 --> 00:50:44,210
don't want it to be so large because I don't want
不想这么大，因为我不想

996
00:50:44,409 --> 00:50:46,889
it to be bigger than n so what should I set b to be?
它大于n，那么我应该将b设置为什么？ 

997
00:50:46,889 --> 00:50:47,710
AUDIENCE: N.
听众：N. 

998
00:50:47,710 --> 00:50:49,510
PROFESSOR: N, good choice.
教授：N，不错的选择。 

999
00:50:49,510 --> 00:50:51,380
It's a good trick whenever you have
每当你有一个好把戏

1000
00:50:51,380 --> 00:50:52,960
a sum of things you want to minimize,
您想减少的总和， 

1001
00:50:52,960 --> 00:50:55,230
usually it's when they're equal.
通常是在他们平等的时候。 

1002
00:50:55,230 --> 00:50:58,699
Occasionally it's the extreme like when b is 0 or something.
有时就像b为0或类似的东西时那样极端。 

1003
00:50:58,699 --> 00:51:00,699
B as 0 not a good plan.
 B设为0并不是一个好计划。 

1004
00:51:00,699 --> 00:51:05,219
Base 0 is pretty slow.
以0为底的速度非常慢。 

1005
00:51:05,219 --> 00:51:08,639
So if I set-- I'll write it here--
因此，如果我设置-我将在这里写下- 

1006
00:51:08,639 --> 00:51:10,969
you can prove it with a derivative or whatever.
您可以用导数或其他方式证明这一点。 

1007
00:51:10,969 --> 00:51:13,989
This is going to be minimized when
这将被最小化

1008
00:51:13,989 --> 00:51:18,979
b is-- I'll be vague-- theta n.
 b是-我会含糊-theta n。 

1009
00:51:18,980 --> 00:51:26,789
So then it's going to come out to n times lg base n of k.
因此，它将以k的n为lg的n倍。 

1010
00:51:26,989 --> 00:51:31,369
And lo and behold, when k is polynomial in n,
瞧，当k是n的多项式时， 

1011
00:51:31,369 --> 00:51:36,920
it's k to some constant, then that will be linear.
它是k到某个常数，那么它将是线性的。 

1012
00:51:36,920 --> 00:51:38,530
So let me write that.
所以，让我写下来。 

1013
00:51:38,530 --> 00:51:46,670
If k equals n to the c, or say is at most n to the c,
如果k等于c的n，或者说c等于n， 

1014
00:51:46,670 --> 00:51:50,659
then this is going to be order n times c.
那么这将是n次c。 

1015
00:51:50,659 --> 00:51:53,069
So if your integers are reasonably small,
因此，如果您的整数相当小， 

1016
00:51:53,070 --> 00:51:54,920
you get a linear time sorting algorithm.
您将获得线性时间排序算法。 

1017
00:51:54,920 --> 00:51:59,550
And reasonably small means polynomial in n, in value.
较小的值表示n中的多项式。 

1018
00:51:59,550 --> 00:52:00,610
That's kind of cool.
太酷了。 

1019
00:52:00,809 --> 00:52:01,824
That's radix sort.
这是基数排序。 

1020
00:52:01,824 --> 00:52:02,539
And we're out of time.
而且我们没时间了。 

1021
00:52:02,739 --> 00:52:04,155
There's an example in the textbook
教科书中有一个例子

1022
00:52:04,155 --> 00:52:05,699
or in the notes how this works.
或在注释中这是如何工作的。 

1023
00:52:05,699 --> 00:52:07,852
You could prove it by a simple induction.
您可以通过简单的归纳证明。 

1024
00:52:07,853 --> 00:52:12,853



