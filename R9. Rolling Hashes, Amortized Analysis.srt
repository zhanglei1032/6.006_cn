1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,339
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,339 --> 00:00:17,225
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,225 --> 00:00:17,850
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,850 --> 00:00:21,570



10
00:00:21,570 --> 00:00:23,800
PROFESSOR: So we're going to do rolling caches then,
教授：那么我们将要滚动缓存， 

11
00:00:23,800 --> 00:00:26,679
we're going to go a little bit over amortized analysis
我们将对摊销分析进行一些讨论

12
00:00:26,879 --> 00:00:28,320
and if we have a lot of time left,
如果我们还有很多时间， 

13
00:00:28,320 --> 00:00:32,590
we're going to talk about good and bad hash functions.
我们将讨论好的和坏的哈希函数。 

14
00:00:32,590 --> 00:00:36,489
So can someone remind me what's the point of rolling hashes?
那么有人可以提醒我滚动哈希的意义是什么？ 

15
00:00:36,689 --> 00:00:38,259
What's the problem?
有什么问题？ 

16
00:00:38,259 --> 00:00:40,131
What are we trying to solve in lectures?
我们要在讲座中解决什么？ 

17
00:00:40,131 --> 00:00:43,979



18
00:00:43,979 --> 00:00:46,054
Be brave.
勇敢起来。 

19
00:00:46,054 --> 00:00:49,380
AUDIENCE: Gets faster, I think, because like--
听众：我觉得更快，因为

20
00:00:49,380 --> 00:00:51,130
PROFESSOR: So what are we trying to solve?
教授：那我们要解决什么？ 

21
00:00:51,130 --> 00:00:52,846
You don't need to go ahead, tell me
你不用说了

22
00:00:53,046 --> 00:00:55,129
what's the big problem that we're trying to solve.
我们要解决的最大问题是什么？ 

23
00:00:55,130 --> 00:01:01,505



24
00:01:01,505 --> 00:01:02,630
AUDIENCE: I don't remember/
听众：我不记得/ 

25
00:01:02,630 --> 00:01:04,510
PROFESSOR: OK, so let's go over that.
教授：好的，让我们解决一下。 

26
00:01:04,510 --> 00:01:08,200
So we have a big document, AKA a long string,
所以我们有一个大文件，又是一个长字符串， 

27
00:01:08,200 --> 00:01:10,969
and we're trying to find a smaller string inside it.
并且我们正在尝试在其中找到一个较小的字符串。 

28
00:01:10,969 --> 00:01:13,209
And we're trying to do that efficiently.
我们正在努力有效地做到这一点。 

29
00:01:13,209 --> 00:01:23,219
So say the big document is-- you might have seen this before.
所以说大文件是-您以前可能已经看过。 

30
00:01:23,219 --> 00:01:29,129
And we're trying to look for the here.
我们正在尝试在这里寻找。 

31
00:01:29,129 --> 00:01:30,780
How do I do that with rolling hashes?
如何使用滚动哈希做到这一点？ 

32
00:01:30,780 --> 00:01:33,909



33
00:01:33,909 --> 00:01:38,140
So the slow, nice solution is I get this the
所以，缓慢，不错的解决方案是

34
00:01:38,140 --> 00:01:41,238
and then I overlap with the beginning of the document,
然后我与文档的开头重叠， 

35
00:01:41,438 --> 00:01:42,479
I do a string comparison.
我进行字符串比较。 

36
00:01:42,480 --> 00:01:44,209
If it matches, I say that it's a match.
如果匹配，我说这是匹配。 

37
00:01:44,409 --> 00:01:46,859
It's not, I overlap it here.
不是，我在这里重叠。 

38
00:01:46,859 --> 00:01:48,859
String match, I overlap it here.
字符串匹配，我在这里重叠。 

39
00:01:48,859 --> 00:01:50,828
String match, so on and so forth.
字符串匹配，依此类推。 

40
00:01:50,828 --> 00:01:53,369
The problem is this does a lot of string matching operations,
问题是这会执行很多字符串匹配操作， 

41
00:01:53,370 --> 00:01:57,290
and the string matching operation is how expensive?
和字符串匹配操作多少钱？ 

42
00:01:57,290 --> 00:01:58,846
What's the running time?
几点钟了？ 

43
00:01:58,846 --> 00:02:00,161
AUDIENCE: Order n.
观众：订单n。 

44
00:02:00,161 --> 00:02:02,409
PROFESSOR: Order n, where n is the size of the string.
教授：n阶，其中n是字符串的大小。 

45
00:02:02,409 --> 00:02:06,689
So if we have a string, say this is the key
所以如果我们有一个字符串，那就说这是关键

46
00:02:06,689 --> 00:02:11,590
that we're looking for and n is the document size then
我们正在寻找的n是文档大小，然后

47
00:02:11,590 --> 00:02:15,210
this is going to be order n times k.
这将是k的n阶。 

48
00:02:15,210 --> 00:02:17,659
We want to get to something better.
我们想要变得更好。 

49
00:02:17,659 --> 00:02:19,379
So how do I do this with rolling hashes?
那么我该如何使用滚动哈希值呢？ 

50
00:02:19,379 --> 00:02:27,060



51
00:02:27,060 --> 00:02:30,444
AUDIENCE: We take the strings up,
观众：我们把线拉起来， 

52
00:02:30,444 --> 00:02:35,039
and you come up with a hash code for it.
然后您想出了一个哈希码。 

53
00:02:35,039 --> 00:02:37,719
PROFESSOR: OK so we're going to hash this.
教授：好的，我们将对此进行哈希处理。 

54
00:02:37,719 --> 00:02:39,949
And let's say this is the key hash.
假设这是关键哈希。 

55
00:02:39,949 --> 00:02:41,786
OK, very good.
好的，棒极了。 

56
00:02:41,787 --> 00:02:44,588
AUDIENCE: And then once you know that, then you'll
听众：然后，一旦你知道了，你就会

57
00:02:44,588 --> 00:02:46,729
need to compute the next letter hash,
需要计算下一个字母哈希， 

58
00:02:46,729 --> 00:02:49,489
or just add it on to that pairing.
或只是将其添加到该配对中。 

59
00:02:49,490 --> 00:02:51,120
PROFESSOR: OK, so next letter for--
教授：好的，下一封信是- 

60
00:02:51,120 --> 00:02:51,745
AUDIENCE: Yeah.
听众：是的。 

61
00:02:51,745 --> 00:02:54,189



62
00:02:54,189 --> 00:03:01,038
So you compute the hash of the entire string, n, capital n--
因此，您需要计算整个字符串的散列n，大写n-- 

63
00:03:01,038 --> 00:03:02,520
PROFESSOR: Let's not do that.
教授：我们不要那样做。 

64
00:03:02,520 --> 00:03:07,852
Let's compute the hash of the first key characters
让我们计算第一个关键字符的哈希值

65
00:03:07,852 --> 00:03:08,435
in the string.
在字符串中。 

66
00:03:08,435 --> 00:03:12,240
AUDIENCE: Are we separating them by space [? inside? ?]
听众：我们是否将它们按空格分开？内？ ？] 

67
00:03:12,240 --> 00:03:14,662
PROFESSOR: Yeah, so this is going to be a character.
教授：是的，所以这将是一个角色。 

68
00:03:14,861 --> 00:03:15,902
AUDIENCE: The space will?
听众：空间会吗？ 

69
00:03:15,902 --> 00:03:16,611
PROFESSOR: Sorry?
教授：对不起？ 

70
00:03:16,611 --> 00:03:18,277
AUDIENCE: The space will be a character?
听众：空格将是一个字符？ 

71
00:03:18,277 --> 00:03:19,069
PROFESSOR: Yeah.
教授：是的。 

72
00:03:19,069 --> 00:03:20,735
So let's take the first three characters
因此，让我们取前三个字符

73
00:03:20,735 --> 00:03:22,869
and compute the hash of that.
并计算其哈希值。 

74
00:03:22,870 --> 00:03:26,530
And let's call this the our sliding window.
我们称其为滑动窗口。 

75
00:03:26,530 --> 00:03:30,169
So we're going to say that window has the
因此，我们要说该窗口具有

76
00:03:30,169 --> 00:03:34,619
and then we're going to compute the hash of the characters
然后我们将计算字符的哈希值

77
00:03:34,620 --> 00:03:36,569
in the window, and we're going to see
在窗口中，我们将看到

78
00:03:36,569 --> 00:03:40,068
that this matches the hash of the key.
匹配密钥的哈希值。 

79
00:03:40,068 --> 00:03:41,609
And then we'll figure out what to do.
然后我们会弄清楚该怎么做。 

80
00:03:41,610 --> 00:03:44,360



81
00:03:44,360 --> 00:03:46,000
That aside, we're going to slide the window
顺便说一句，我们将滑动窗口

82
00:03:46,199 --> 00:03:48,459
to the right by one character so take out
向右移一个字符，所以取出

83
00:03:48,460 --> 00:03:50,860
key and put in the space.
钥匙，放在空间中。 

84
00:03:50,860 --> 00:03:56,060
And now the window has HE space, we're
现在窗户上有他的空间，我们

85
00:03:56,259 --> 00:03:58,560
going to compute the hash of the window,
要计算窗口的哈希值， 

86
00:03:58,560 --> 00:04:03,400
see that it's not the same as this hash of the key.
看到它与密钥的哈希值不同。 

87
00:04:03,400 --> 00:04:04,860
What do we know in this case?
在这种情况下我们知道些什么？ 

88
00:04:04,860 --> 00:04:10,990



89
00:04:11,189 --> 00:04:13,750
Different hashes means--
不同的哈希手段- 

90
00:04:13,750 --> 00:04:15,274
AUDIENCE: Not the same string.
听众：字符串不同。 

91
00:04:15,274 --> 00:04:16,939
PROFESSOR: For sure not the same string.
教授：请确保不是相同的字符串。 

92
00:04:16,939 --> 00:04:21,660
So this is not the.
所以这不是。 

93
00:04:21,660 --> 00:04:23,870
OK, now suppose I'm sliding my window
好吧，现在假设我正在滑动窗口

94
00:04:23,870 --> 00:04:26,259
so after this I will slide my window again,
因此之后，我将再次滑动窗口， 

95
00:04:26,259 --> 00:04:28,810
and I would have e space f.
我会有e空间f。 

96
00:04:28,810 --> 00:04:30,290
Right, so on and so forth.
是的，依此类推。 

97
00:04:30,290 --> 00:04:33,540
Suppose I'm happy sliding my window and then I get here
假设我很高兴滑动窗户然后到达这里

98
00:04:33,540 --> 00:04:39,569
and I have my window be IN space, and the hash the window
我的窗口在空间中，然后将窗口散列

99
00:04:39,569 --> 00:04:43,269
happens to match the hash of the key.
碰巧匹配密钥的哈希值。 

100
00:04:43,269 --> 00:04:45,549
So we're in the same situation as here.
因此，我们处于与这里相同的情况。 

101
00:04:45,550 --> 00:04:47,334
Now what?
怎么办？ 

102
00:04:47,334 --> 00:04:48,250
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

103
00:04:48,250 --> 00:04:51,689



104
00:04:51,689 --> 00:04:52,860
PROFESSOR: Very good.
教授：非常好。 

105
00:04:52,860 --> 00:04:57,120
We have to check if the string inside the window
我们必须检查窗口中的字符串是否

106
00:04:57,120 --> 00:04:59,360
is the same as the string inside the key.
与键中的字符串相同。 

107
00:04:59,360 --> 00:05:02,360
And if it is, we found a match.
如果是这样，我们找到了一个匹配项。 

108
00:05:02,360 --> 00:05:03,754
If it isn't, we keep working.
如果不是，我们会继续努力。 

109
00:05:03,954 --> 00:05:04,526
All right?
好吧？ 

110
00:05:04,526 --> 00:05:06,110
And we have to do the same thing here.
我们必须在这里做同样的事情。 

111
00:05:06,110 --> 00:05:12,139



112
00:05:12,339 --> 00:05:16,984
So this is our string matching algorithm.
这就是我们的字符串匹配算法。 

113
00:05:16,985 --> 00:05:21,814
AUDIENCE: Can we somehow make sure that we make a hash
观众：我们能以某种方式确保我们进行哈希运算吗

114
00:05:21,814 --> 00:05:26,649
function such that it will never [INAUDIBLE]--
功能使其永远不会[听不清]- 

115
00:05:26,649 --> 00:05:27,909
PROFESSOR: Excellent question.
教授：很好的问题。 

116
00:05:27,910 --> 00:05:29,817
Thank you, I like that.
谢谢，我喜欢

117
00:05:30,016 --> 00:05:31,600
Can we make a hash function so that we
我们可以做一个哈希函数，这样我们

118
00:05:31,600 --> 00:05:34,110
don't have any false positives, right?
没有误报吧？ 

119
00:05:34,110 --> 00:05:35,319
Let's see.
让我们来看看。 

120
00:05:35,319 --> 00:05:36,639
How do hash functions work?
哈希函数如何工作？ 

121
00:05:36,639 --> 00:05:38,298
What's the argument to a hash function
哈希函数的参数是什么

122
00:05:38,298 --> 00:05:39,464
and what's the return value?
的返回值是多少？ 

123
00:05:39,464 --> 00:05:43,585



124
00:05:43,586 --> 00:05:44,843
AUDIENCE: The argument is something
听众：论点是什么

125
00:05:45,043 --> 00:05:45,991
that you want to hash.
您想散列。 

126
00:05:45,992 --> 00:05:49,658



127
00:05:49,858 --> 00:05:52,399
PROFESSOR: So in this case we're working with three character
教授：所以在这种情况下，我们使用三个字符

128
00:05:52,399 --> 00:05:52,899
strings.
字符串。 

129
00:05:52,899 --> 00:05:56,269
But let's say we're looking for a one megabyte
但是，假设我们正在寻找一个1 MB的字节

130
00:05:56,269 --> 00:05:58,969
string inside the one gigabyte string.
一个千兆字节字符串中的字符串。 

131
00:05:58,970 --> 00:06:02,430
Say we're a music company and we're
说我们是一家音乐公司， 

132
00:06:02,430 --> 00:06:07,370
looking for our mp3 file inside the big files
在大文件中寻找我们的mp3文件

133
00:06:07,370 --> 00:06:09,550
off a pirate server or something.
关闭海盗服务器之类的东西。 

134
00:06:09,550 --> 00:06:14,218
So this is 1 million character strings,
这是一百万个字符串， 

135
00:06:14,218 --> 00:06:15,509
because that's the window size.
因为那是窗口大小。 

136
00:06:15,509 --> 00:06:19,370



137
00:06:19,370 --> 00:06:20,910
And it's going to return what?
它会返回什么？ 

138
00:06:20,910 --> 00:06:25,629



139
00:06:25,829 --> 00:06:30,500
What do hash functions return for them to be useful?
哈希函数返回什么对它们有用？ 

140
00:06:30,500 --> 00:06:31,069
Integers.
整数。 

141
00:06:31,069 --> 00:06:32,579
Nice small integers, right?
漂亮的小整数，对不对？ 

142
00:06:32,579 --> 00:06:35,500
Ideally, the integer would fit in a word size, where
理想情况下，整数将适合字长，其中

143
00:06:35,500 --> 00:06:39,649
the word is the register size on our computer.
这个词是我们计算机上的寄存器大小。 

144
00:06:39,649 --> 00:06:41,699
What are popular word sizes?
什么是流行字号？ 

145
00:06:41,699 --> 00:06:42,795
Does anyone know?
有人知道吗？ 

146
00:06:42,795 --> 00:06:43,711
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

147
00:06:43,711 --> 00:06:45,896



148
00:06:45,896 --> 00:06:46,730
AUDIENCE: Excellent.
听众：很好。 

149
00:06:46,730 --> 00:06:55,350
32-bits, 64-bits integers.
 32位，64位整数。 

150
00:06:55,350 --> 00:06:57,389
OK, so what's the universe size for this function?
好，那么此函数的Universe大小是多少？ 

151
00:06:57,589 --> 00:06:59,971
How many one million character strings are there?
有几百万个字符串？ 

152
00:06:59,971 --> 00:07:03,533



153
00:07:03,533 --> 00:07:05,199
AUDIENCE: How many characters are there?
听众：有几个字符？ 

154
00:07:05,199 --> 00:07:05,759
PROFESSOR: Excellent.
教授：非常好。 

155
00:07:05,759 --> 00:07:07,500
Let's say we're old school and we're doing [? SG ?].
假设我们是老学校，我们正在[ SG？]。 

156
00:07:07,500 --> 00:07:09,454
We don't care about the rest of the world.
我们不在乎世界其他地方。 

157
00:07:09,454 --> 00:07:12,639
AUDIENCE: 256 characters?
听众：256个字符？ 

158
00:07:12,639 --> 00:07:13,451
PROFESSOR: OK.
教授：好的。 

159
00:07:13,451 --> 00:07:14,992
AUDIENCE: To the one millionth power.
听众：达到百万分之一的权力。 

160
00:07:14,992 --> 00:07:20,473



161
00:07:20,473 --> 00:07:21,139
PROFESSOR: Cool.
教授：太好了。 

162
00:07:21,139 --> 00:07:23,370
Let's say we're working on an old school computer,
假设我们正在使用一台老式计算机， 

163
00:07:23,370 --> 00:07:25,620
since we're old school and we have a 32-bit word size.
由于我们是守旧派，而且字长为32位。 

164
00:07:25,620 --> 00:07:28,694
How many possible values for the hash function?
哈希函数有多少个可能的值？ 

165
00:07:28,694 --> 00:07:30,180
AUDIENCE: 2 to the 32.
听众：2至32。 

166
00:07:30,180 --> 00:07:38,100



167
00:07:38,100 --> 00:07:39,939
PROFESSOR: The [? other ?] is bigger.
教授：[？其他？]更大。 

168
00:07:39,939 --> 00:07:41,439
You're messing with me, right?
你惹我了吧

169
00:07:41,439 --> 00:07:45,540
OK so this is 2 to the 8th.
好的，所以这是2到8。 

170
00:07:45,540 --> 00:07:47,115
AUDIENCE: 2 to the 8 million, right?
听众：800万中的2对吧？ 

171
00:07:47,115 --> 00:07:47,740
PROFESSOR: Yup.
教授：是的。 

172
00:07:47,740 --> 00:07:50,699
So this is a lot bigger than this.
因此，这比这要大得多。 

173
00:07:50,699 --> 00:07:54,060
So if we want to make a hash function that gives us
因此，如果我们要创建一个散列函数

174
00:07:54,060 --> 00:07:56,209
no false positives, then we'd have
没有误报，那么我们将

175
00:07:56,209 --> 00:07:59,539
to be able to-- if we have the universe of possible inputs
能够-如果我们拥有大量可能的投入

176
00:07:59,540 --> 00:08:01,550
and the universe of possible outputs,
以及所有可能的输出， 

177
00:08:01,550 --> 00:08:04,910
draw a line from every input to a different output.
从每个输入到另一个输出画一条线。 

178
00:08:04,910 --> 00:08:09,129
But if we have-- 2 to the 32 by the way is about four billion.
但是如果有的话，顺便说一句，32到2大约是40亿。 

179
00:08:09,329 --> 00:08:14,896
If we have four billion outputs and a lot of inputs
如果我们有40亿个产出和大量投入

180
00:08:14,896 --> 00:08:16,480
as we draw our lines, we're eventually
当我们划清界限时，我们最终

181
00:08:16,480 --> 00:08:18,021
going to run out of outputs and we're
将要用完输出，我们

182
00:08:18,021 --> 00:08:20,689
going to have to use the same output again and again.
将不得不一次又一次使用相同的输出。 

183
00:08:20,689 --> 00:08:23,459
So for a hash function, pretty much always
因此，对于哈希函数，几乎总是

184
00:08:23,459 --> 00:08:26,169
the universe size is bigger than the output size.
 Universe大小大于输出大小。 

185
00:08:26,170 --> 00:08:29,490
So hash functions will always have collisions.
因此，哈希函数将始终存在冲突。 

186
00:08:29,490 --> 00:08:31,610
So a collision for a hash function
所以哈希函数的冲突

187
00:08:31,610 --> 00:08:40,220
is two inputs, x1, x2, so that's x1 is not x2, but h of x1
是两个输入x1，x2，所以x1不是x2，而是x1的h 

188
00:08:40,220 --> 00:08:41,620
equals h of x2.
等于x2的h。 

189
00:08:41,620 --> 00:08:46,865



190
00:08:46,865 --> 00:08:47,990
So this will always happen.
因此，这将永远发生。 

191
00:08:47,990 --> 00:08:50,159
There's no way around it.
没有办法解决。 

192
00:08:50,159 --> 00:08:53,259
What we're hoping for is that the collisions
我们希望的是碰撞

193
00:08:53,259 --> 00:08:55,330
aren't something dumb.
没什么傻

194
00:08:55,330 --> 00:08:57,589
So we're hoping that the hash function acts
所以我们希望哈希函数起作用

195
00:08:57,789 --> 00:09:02,370
in a reasonably randomly and we talked about ideal hash
在合理的随机范围内，我们讨论了理想的哈希

196
00:09:02,370 --> 00:09:06,940
functions that would pretty much look like they would get
看起来很像的功能

197
00:09:06,940 --> 00:09:10,008
a random output for every input.
每个输入的随机输出。 

198
00:09:10,208 --> 00:09:12,250
And we're not going to worry too much about that.
我们不会为此担心太多。 

199
00:09:12,250 --> 00:09:15,230
What matters is that as long as the hash function is reasonably
重要的是，只要哈希函数合理

200
00:09:15,230 --> 00:09:19,470
good, we're not going to have too many false positives.
好，我们不会有太多误报。 

201
00:09:19,470 --> 00:09:28,080
So say the output set is O, so O is 2 to the 32.
假设输出集是O，所以O是32的2。 

202
00:09:28,080 --> 00:09:31,830
Then we're hoping to have false positives about one
然后，我们希望对某人产生误报

203
00:09:31,830 --> 00:09:37,480
every O times.
每O次。 

204
00:09:37,480 --> 00:09:40,389
So 1 out of 2 to the 32 false positives.
因此，在32个误报中有2分之1。 

205
00:09:40,389 --> 00:09:43,360



206
00:09:43,360 --> 00:09:48,720
So what's the running time for when you slide the window
那么滑动窗口的时间是多少

207
00:09:48,720 --> 00:09:50,609
and we're doing this logic here.
我们在这里做这个逻辑。 

208
00:09:50,809 --> 00:09:55,256
What's the running time if the hashes aren't the same?
如果哈希值不同，那么运行时间是多少？ 

209
00:09:55,256 --> 00:09:57,589
AUDIENCE: What's the running time of the hash function--
听众：哈希函数的运行时间是多少？ 

210
00:09:57,590 --> 00:09:59,822
PROFESSOR: Of the whole matching algorithm.
教授：整个匹配算法中。 

211
00:09:59,822 --> 00:10:02,682
AUDIENCE: No, no no, of the hash function itself.
听众：不，不，不，哈希函数本身。 

212
00:10:02,682 --> 00:10:05,929
Can we make any assumptions about that?
我们可以对此做出任何假设吗？ 

213
00:10:05,929 --> 00:10:07,269
Very good.
很好。 

214
00:10:07,269 --> 00:10:10,169
What's the running time of the hash function?
哈希函数的运行时间是多少？ 

215
00:10:10,169 --> 00:10:11,860
So we're going to have to implement--
所以我们将不得不实施

216
00:10:11,860 --> 00:10:13,610
if we implement the hash function naively,
如果我们天真的实现哈希函数， 

217
00:10:13,610 --> 00:10:17,229
then the running time for hashing a key character string
然后散列关键字符串的运行时间

218
00:10:17,429 --> 00:10:19,329
is order key.
是订单密钥。 

219
00:10:19,330 --> 00:10:22,339
But we're going to come up with magic way of doing it
但是，我们将提出一种神奇的方法

220
00:10:22,539 --> 00:10:24,740
in order one time.
为了一次。 

221
00:10:24,740 --> 00:10:28,419
So assume hashing is order 1.
因此，假设哈希为阶数1。 

222
00:10:28,419 --> 00:10:30,500
What's the running time for everything else?
其他一切的运行时间是多少？ 

223
00:10:30,500 --> 00:10:34,471
So if the hashes don't match, we know it's not a candidate.
因此，如果哈希值不匹配，我们就知道它不是候选对象。 

224
00:10:34,471 --> 00:10:35,679
So we're going to keep going.
因此，我们将继续前进。 

225
00:10:35,679 --> 00:10:39,399
So this is order 1.
所以这是命令1。 

226
00:10:39,399 --> 00:10:41,819
What if the hashes do match?
如果哈希匹配，该怎么办？ 

227
00:10:41,820 --> 00:10:44,700
AUDIENCE: [INAUDIBLE] characters.
观众：[音频不清晰]个字符。 

228
00:10:44,700 --> 00:10:45,450
PROFESSOR: Order--
教授：命令- 

229
00:10:45,450 --> 00:10:47,133
AUDIENCE: I mean, but it depends on how many ones match,
听众：我的意思是，但这取决于匹配的数量， 

230
00:10:47,333 --> 00:10:48,241
but it will be--
但它将是- 

231
00:10:48,241 --> 00:10:49,699
PROFESSOR: So for one match, what's
教授：那么一场比赛是什么

232
00:10:49,700 --> 00:10:52,118
the running time for one match?
一场比赛的时间？ 

233
00:10:52,118 --> 00:10:54,980
AUDIENCE: Order k--
听众：订单k-- 

234
00:10:54,980 --> 00:10:56,840
PROFESSOR: Order k.
教授：命令k。 

235
00:10:56,840 --> 00:10:57,649
Excellent.
优秀的。 

236
00:10:57,649 --> 00:11:03,090
So the total running time is the number of matches times
因此，总运行时间就是匹配次数

237
00:11:03,090 --> 00:11:07,229
order k plus the number of non matches times order 1.
顺序k加上不匹配数乘以顺序1。 

238
00:11:07,429 --> 00:11:10,120
So as long as the number of false positives
所以只要误报数量

239
00:11:10,120 --> 00:11:14,240
here is really tiny, the math is going
这真的很小，数学将进行

240
00:11:14,240 --> 00:11:16,854
to come out to be roughly order 1 per character.
大约是每个字符1。 

241
00:11:17,054 --> 00:11:20,588



242
00:11:20,589 --> 00:11:22,884
AUDIENCE: So the whole thing is order in.
听众：所以整个过程都在整理之中。 

243
00:11:22,884 --> 00:11:24,599
PROFESSOR: Everything should be order n, yeah,
教授：一切都应为n，是的， 

244
00:11:24,799 --> 00:11:26,007
that's what we're hoping for.
这就是我们所希望的。 

245
00:11:26,008 --> 00:11:32,070



246
00:11:32,070 --> 00:11:34,665
OK so let's talk about the magic because you asked me
好吧，让我们谈谈魔术，因为你问我

247
00:11:34,865 --> 00:11:36,740
what's the running time for the hash function
哈希函数的运行时间是多少

248
00:11:36,740 --> 00:11:38,649
and this is the interesting part.
这是有趣的部分。 

249
00:11:38,649 --> 00:11:41,110
How do I get to compute these hashes
我如何计算这些哈希

250
00:11:41,110 --> 00:11:43,600
and order 1 instead of order k?
和顺序1而不是顺序k？ 

251
00:11:43,600 --> 00:11:47,120
We have this data structure called rolling hash.
我们有一个称为滚动哈希的数据结构。 

252
00:11:47,120 --> 00:11:52,679



253
00:11:52,679 --> 00:11:54,859
So rolling hash-- does anyone remember
所以滚动哈希-有谁记得

254
00:11:54,860 --> 00:11:56,730
from lecture what it is?
从讲座是什么？ 

255
00:11:56,730 --> 00:11:58,730
AUDIENCE: Isn't that what we're doing right now?
听众：这不是我们现在正在做的吗？ 

256
00:11:58,730 --> 00:12:01,359



257
00:12:01,559 --> 00:12:04,389
PROFESSOR: So this is a sliding window.
教授：这是一个滑动窗口。 

258
00:12:04,389 --> 00:12:08,449
And the data structure will compute fast hashes
数据结构将计算快速哈希

259
00:12:08,450 --> 00:12:10,700
for the strings inside the sliding window.
用于滑动窗口内的字符串。 

260
00:12:10,700 --> 00:12:12,709
So how does it work?
那么它是怎样工作的？ 

261
00:12:12,909 --> 00:12:16,389
I mean not how does it work functionally, what
我的意思是说它不是如何工作的， 

262
00:12:16,389 --> 00:12:19,855
are the operations for a rolling hash, let's try that.
是滚动哈希的操作，请尝试一下。 

263
00:12:19,855 --> 00:12:23,547
AUDIENCE: Oh [INAUDIBLE].
听众：哦[听不清]。 

264
00:12:23,547 --> 00:12:25,129
PROFESSOR: OK, so we have two updates.
教授：好的，我们进行了两次更新。 

265
00:12:25,129 --> 00:12:26,250
One of them is pop.
其中之一是流行音乐。 

266
00:12:26,250 --> 00:12:28,730
For some reason, our notes call it skip,
由于某些原因，我们的注释将其称为“跳过”， 

267
00:12:28,730 --> 00:12:30,899
but I like pop better, so I'm going
但我更喜欢流行音乐，所以我要

268
00:12:30,899 --> 00:12:34,360
to write skip and think pop.
写跳过和思考流行。 

269
00:12:34,360 --> 00:12:35,855
And the other one is?
而另一个是？ 

270
00:12:35,855 --> 00:12:37,720
AUDIENCE: Always [INAUDIBLE].
听众：始终[听不清]。 

271
00:12:37,720 --> 00:12:41,460



272
00:12:41,460 --> 00:12:45,200
PROFESSOR: A pen with a new character, OK?
教授：一支新字符的笔，好吗？ 

273
00:12:45,200 --> 00:12:45,820
Cool.
凉。 

274
00:12:45,820 --> 00:12:46,690
So these are the updates.
这些是更新。 

275
00:12:46,690 --> 00:12:48,273
Now what's the point of those updates?
现在这些更新的意义是什么？ 

276
00:12:48,273 --> 00:12:50,561
What's the query for a rolling hash?
对滚动哈希的查询是什么？ 

277
00:12:50,761 --> 00:12:52,729
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

278
00:12:52,730 --> 00:12:54,909
You just grab the next character,
你只要抓住下一个角色， 

279
00:12:54,909 --> 00:12:57,579
append that, and then skip [INAUDIBLE].
追加，然后跳过[听不清]。 

280
00:12:57,580 --> 00:13:00,840
PROFESSOR: OK, so this is how I update the rolling hash
教授：好的，这就是我更新滚动哈希的方法

281
00:13:00,840 --> 00:13:04,389
to contain to reflect the contents of my sliding window.
包含以反映我滑动窗口的内容。 

282
00:13:04,389 --> 00:13:05,480
And what I do after that?
那之后我该怎么办？ 

283
00:13:05,480 --> 00:13:08,600
What's the reason for that?
是什么原因呢？ 

284
00:13:08,600 --> 00:13:10,433
AUDIENCE: You skip your [INAUDIBLE].
听众：您跳过了[听不清]。 

285
00:13:10,433 --> 00:13:12,100
PROFESSOR: So don't think too hard, it's
教授：所以不要太刻苦，这是

286
00:13:12,100 --> 00:13:13,589
a really easy question.
一个非常简单的问题。 

287
00:13:13,789 --> 00:13:15,889
I moved a sliding window here.
我在这里移动了一个滑动窗口。 

288
00:13:15,889 --> 00:13:17,598
What do I want to get?
我想得到什么？ 

289
00:13:17,599 --> 00:13:19,689
AUDIENCE: You want to get the hash of those characters.
听众：您想获得这些字符的哈希值。 

290
00:13:19,889 --> 00:13:23,809
PROFESSOR: The hash of those characters, very good.
教授：这些字符的哈希值非常好。 

291
00:13:23,809 --> 00:13:25,629
So this is the query.
这就是查询。 

292
00:13:25,629 --> 00:13:29,409
So a rolling hash has a sequence of characters in it, right?
因此滚动哈希表中包含一系列字符，对吗？ 

293
00:13:29,409 --> 00:13:30,889
Say t, h, e.
说t，h，e。 

294
00:13:30,889 --> 00:13:35,210



295
00:13:35,210 --> 00:13:42,250
And it allows us to append the character and pop a character.
它允许我们追加角色并弹出角色。 

296
00:13:42,250 --> 00:13:46,580
Append a character, pop a character.
追加一个字符，弹出一个字符。 

297
00:13:46,580 --> 00:13:48,389
And then it promises that it's going
然后承诺会

298
00:13:48,389 --> 00:13:50,919
to compute the hash of whatever's inside
计算里面的哈希值

299
00:13:50,919 --> 00:13:52,929
the rolling hash really fast.
滚动哈希非常快。 

300
00:13:52,929 --> 00:13:56,370



301
00:13:56,370 --> 00:13:58,475
Append goes here, skip goes here.
追加到这里，跳过到这里。 

302
00:13:58,475 --> 00:14:01,500



303
00:14:01,500 --> 00:14:02,912
How fast do these operations need
这些操作需要多快

304
00:14:02,912 --> 00:14:04,620
to be for my algorithm to work correctly?
为我的算法正常工作？ 

305
00:14:04,620 --> 00:14:08,611



306
00:14:08,611 --> 00:14:10,873
AUDIENCE: Order 1.
受众：订单1。 

307
00:14:10,874 --> 00:14:12,339
PROFESSOR: I promised you that computing
教授：我答应过你

308
00:14:12,539 --> 00:14:14,289
hash there is order 1, right?
哈希有顺序1，对吗？ 

309
00:14:14,289 --> 00:14:19,589
So I have to-- OK.
所以我必须-好。 

310
00:14:19,590 --> 00:14:21,879
Let's see how we're going to make this happen.
让我们看看如何实现这一目标。 

311
00:14:21,879 --> 00:14:22,909
So these are letters.
这些是字母。 

312
00:14:22,909 --> 00:14:24,870
These make sense when we're trying
这些在我们尝试时很有意义

313
00:14:24,870 --> 00:14:27,419
to understand string matching.
了解字符串匹配。 

314
00:14:27,419 --> 00:14:30,360
But now we're going to switch the numbers, because after all,
但是现在我们要切换数字，因为毕竟

315
00:14:30,360 --> 00:14:32,250
strings are sequences of characters,
字符串是字符序列， 

316
00:14:32,250 --> 00:14:33,820
and characters are numbers.
和字符是数字。 

317
00:14:33,820 --> 00:14:36,339
And because I know how to do math on numbers,
而且因为我知道如何对数字进行数学运算， 

318
00:14:36,539 --> 00:14:38,759
I don't know how to do math on characters.
我不知道如何对角色进行数学运算。 

319
00:14:38,759 --> 00:14:41,639
So let's use this list.
因此，让我们使用此列表。 

320
00:14:41,639 --> 00:14:44,080
Let's say that instead of having numbers in base 256
假设不是以256为底的数字

321
00:14:44,080 --> 00:14:45,500
which is [INAUDIBLE], we're going
这是[听不清]，我们要

322
00:14:45,500 --> 00:14:49,019
to have numbers in base 100, because it's really easy to do
以100为基数，因为这很容易做到

323
00:14:49,019 --> 00:14:53,049
operations in base 100 on paper.
在纸上以100为基础的操作

324
00:14:53,049 --> 00:15:09,500
So 3, 14, 15, 92, 55, 35, 89, 79, 31.
所以3、14、15、92、55、35、89、79、31。 

325
00:15:09,500 --> 00:15:12,269
So these are all base 100 numbers.
这些都是以100为基数的数字。 

326
00:15:12,269 --> 00:15:16,279
And say my rolling window is size 5.
并说我的滚动窗口是5号。 

327
00:15:16,279 --> 00:15:17,824
One, two, three, four, five.
一二三四五。 

328
00:15:17,825 --> 00:15:21,980



329
00:15:21,980 --> 00:15:27,009
So I want to come up with a way so that I have the hash of this
所以我想出一种方法让我知道这个

330
00:15:27,009 --> 00:15:32,689
and then when I slide my window, I will get the hash of this.
然后，当我滑动窗口时，我会得到它的哈希值。 

331
00:15:32,690 --> 00:15:35,079



332
00:15:35,279 --> 00:15:39,370
What hashing method do we use for rolling hashes?
我们使用哪种哈希方法来滚动哈希？ 

333
00:15:39,370 --> 00:15:41,134
Does anyone remember?
有人记得吗？ 

334
00:15:41,134 --> 00:15:43,022
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

335
00:15:43,022 --> 00:15:47,590
PROFESSOR: Mod, you said-- I heard mod something.
教授：Mod，你说过-我听过Mod的话。 

336
00:15:47,590 --> 00:15:48,859
AUDIENCE: Yeah, that's what I said.
听众：是的，我就是这么说的。 

337
00:15:49,059 --> 00:15:51,019
PROFESSOR: OK, so?
教授：好吧？ 

338
00:15:51,019 --> 00:15:51,970
So?
所以？ 

339
00:15:51,970 --> 00:15:55,740
So the hash is?
哈希是吗？ 

340
00:15:55,740 --> 00:15:58,009
The hash of a key is?
密钥的哈希是？ 

341
00:15:58,009 --> 00:16:00,303
AUDIENCE: It's k mod m or m k.
听众：是k mod m或m k。 

342
00:16:00,303 --> 00:16:01,059
[INAUDIBLE]
 [听不清] 

343
00:16:01,059 --> 00:16:01,642
PROFESSOR: OK.
教授：好的。 

344
00:16:01,643 --> 00:16:09,240



345
00:16:09,240 --> 00:16:10,759
I'm going to say k mod something,
我要说的是k mod 

346
00:16:10,759 --> 00:16:12,720
and I'm going to say that something
我要说的是

347
00:16:12,720 --> 00:16:17,649
has to be a prime number and we'll see why in a bit.
必须是素数，稍后我们将说明原因。 

348
00:16:17,649 --> 00:16:19,500
Let's say our prime number is 23.
假设我们的素数是23。 

349
00:16:19,500 --> 00:16:22,850



350
00:16:22,850 --> 00:16:27,339
So let's compute the value of the hash for the sliding window
因此，让我们计算滑动窗口的哈希值

351
00:16:27,539 --> 00:16:29,289
of the first sliding window and then we'll
的第一个滑动窗口，然后我们将

352
00:16:29,289 --> 00:16:32,879
compute the hash for the second sliding window.
计算第二个滑动窗口的哈希值。 

353
00:16:32,879 --> 00:16:35,899
Oh, there is some at the computer, sweet.
哦，计算机上有些东西，很贴心。 

354
00:16:35,899 --> 00:16:52,353
314159265 modulo 23 is how much?
 314159265模23是多少？ 

355
00:16:52,354 --> 00:16:53,819
OK, while you're doing that, can someone
好吧，当你这样做的时候，有人可以

356
00:16:54,019 --> 00:16:55,610
tell me what computation will he need
告诉我他需要什么计算

357
00:16:55,610 --> 00:16:58,998
to do for the second sliding window?
做第二个滑动窗口？ 

358
00:16:59,198 --> 00:17:03,839
AUDIENCE: 1519265359.
观众：1519265359。 

359
00:17:03,840 --> 00:17:07,920
PROFESSOR: 159265359.
教授：159265359。 

360
00:17:07,920 --> 00:17:09,404
AUDIENCE: That's a third sign.
听众：这是第三个信号。 

361
00:17:09,404 --> 00:17:11,384
AUDIENCE: There's a 1-4 before that.
听众：在那之前是1-4。 

362
00:17:11,384 --> 00:17:12,869
AUDIENCE: The first one is 11.
听众：第一个是11。 

363
00:17:12,869 --> 00:17:16,348



364
00:17:16,348 --> 00:17:18,509
PROFESSOR: OK.
教授：好的。 

365
00:17:18,509 --> 00:17:19,593
And what's the second one?
第二个是什么？ 

366
00:17:19,593 --> 00:17:25,529
AUDIENCE: [INAUDIBLE] adding--
观众：[听不清]添加- 

367
00:17:25,529 --> 00:17:30,068
PROFESSOR: 1415926335 modulo 23.
教授：1415926335模23 

368
00:17:30,068 --> 00:17:30,568
AUDIENCE: 5.
听众：5。 

369
00:17:30,568 --> 00:17:34,055



370
00:17:34,055 --> 00:17:36,400
PROFESSOR: I heard a 5 and a 7.
教授：我听到了5和7。 

371
00:17:36,400 --> 00:17:37,115
OK.
好。 

372
00:17:37,115 --> 00:17:38,240
AUDIENCE: Hold on, hold on.
听众：等一下，等一下。 

373
00:17:38,240 --> 00:17:41,615



374
00:17:41,615 --> 00:17:43,490
PROFESSOR: I'll take the average of those two
教授：我取这两个的平均值

375
00:17:43,490 --> 00:17:44,862
and we can move on, right?
我们可以继续吧？ 

376
00:17:44,862 --> 00:17:49,089
AUDIENCE: Three five, and arguably 6.
听众：三五，可以说是六。 

377
00:17:49,289 --> 00:17:53,139
PROFESSOR: All right, so let's implement
教授：好的，让我们实施

378
00:17:53,140 --> 00:17:54,204
an operation called slide.
称为幻灯片的操作。 

379
00:17:54,404 --> 00:17:58,859



380
00:17:58,859 --> 00:18:03,059
And slide will take the new number that I'm sliding in.
幻灯片将采用我要输入的新数字。 

381
00:18:03,059 --> 00:18:05,629



382
00:18:05,630 --> 00:18:07,809
And the old number that I'm sliding out,
还有我要滑出的旧号码， 

383
00:18:08,009 --> 00:18:11,259
making my life really easy.
使我的生活变得非常轻松。 

384
00:18:11,259 --> 00:18:15,625
So in this case, the numbers would be--
因此，在这种情况下，数字将是- 

385
00:18:15,625 --> 00:18:18,880
AUDIENCE: The new one is 35.
听众：新的是35。 

386
00:18:18,880 --> 00:18:20,494
PROFESSOR: And the old one?
教授：那是旧的？ 

387
00:18:20,694 --> 00:18:21,194
AUDIENCE: 3.
听众：3。 

388
00:18:21,194 --> 00:18:26,125



389
00:18:26,125 --> 00:18:27,000
PROFESSOR: Excellent.
教授：非常好。 

390
00:18:27,000 --> 00:18:34,940
And I want to have an internal state called hash that has 11
我想要一个内部状态称为hash的哈希值为11 

391
00:18:34,940 --> 00:18:40,640
and I want to get 6 after I'm done running slide.
我想在完成幻灯片播放后获得6分。 

392
00:18:40,640 --> 00:18:43,259
This is still too hard for me, so before we figure out hash,
这对我来说仍然太难了，所以在弄清楚哈希之前， 

393
00:18:43,259 --> 00:18:47,319
let's say that we have an internal state called n.
假设我们有一个称为n的内部状态。 

394
00:18:47,319 --> 00:18:51,819
And n is this big number here.
 n在这里是这个大数字。 

395
00:18:51,819 --> 00:18:54,970
So I want to get from this big number to this big number.
所以我想从这个大数字变成这个大数字。 

396
00:18:54,970 --> 00:18:55,960
What am I going to do?
我要怎么办

397
00:18:55,960 --> 00:18:58,852



398
00:18:58,852 --> 00:19:06,379
AUDIENCE: Mod 3,000 [INAUDIBLE].
观众：模组3,000 [听不清]。 

399
00:19:06,579 --> 00:19:16,139
PROFESSOR: OK, so you want to take the big number 159265
教授：好的，所以您想取大数159265 

400
00:19:16,140 --> 00:19:19,660
and mod it.
并修改它。 

401
00:19:19,660 --> 00:19:20,535
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

402
00:19:20,535 --> 00:19:27,005



403
00:19:27,205 --> 00:19:29,079
PROFESSOR: So if I mod it to by a big number,
教授：所以，如果我将其大量修改， 

404
00:19:29,079 --> 00:19:30,569
that's going to be too slow.
那太慢了。 

405
00:19:30,569 --> 00:19:31,859
So I can't mod it.
所以我不能修改它。 

406
00:19:31,859 --> 00:19:34,644
AUDIENCE: Can't you just divide it?
听众：你不能分开吗？ 

407
00:19:34,644 --> 00:19:36,019
PROFESSOR: Division is also slow,
教授：划分也很慢， 

408
00:19:36,019 --> 00:19:37,103
I don't like the division.
我不喜欢这个部门。 

409
00:19:37,103 --> 00:19:39,670
I like subtraction, someone said subtraction.
我喜欢减法，有人说减法。 

410
00:19:39,670 --> 00:19:44,119
So what I want to do is I want to get from here to a number
所以我想做的就是从这里得到一个数字

411
00:19:44,319 --> 00:19:45,929
that-- to this number, right?
 -这个数字，对不对？ 

412
00:19:45,930 --> 00:19:47,519
So I want to get rid of the 3 and I
所以我想摆脱3，我

413
00:19:47,519 --> 00:19:50,410
want to add 35 at the end.
想要在末尾添加35。 

414
00:19:50,410 --> 00:19:53,399
To get rid of the 3, what do I subtract?
要摆脱3，我要减去什么？ 

415
00:19:53,599 --> 00:19:54,946
AUDIENCE: 3 with a bunch of 0s.
听众：3，一堆0。 

416
00:19:54,946 --> 00:19:56,279
PROFESSOR: 3 with a bunch of 0s.
教授：3，一堆0。 

417
00:19:56,279 --> 00:19:56,779
Excellent.
优秀的。 

418
00:19:56,779 --> 00:19:59,879
1, 2, 3, 4, 5, 6, 7, 8.
 1、2、3、4、5、6、7、8 

419
00:19:59,880 --> 00:20:01,565
How many of them are there?
有多少个？ 

420
00:20:01,565 --> 00:20:02,990
AUDIENCE: 8.
听众：8。 

421
00:20:02,990 --> 00:20:05,801
PROFESSOR: OK, how many digits conveys 100?
教授：好的，多少位数字表示100？ 

422
00:20:05,801 --> 00:20:09,309
AUDIENCE: Oh, 2 right?
听众：哦，对2吗？ 

423
00:20:09,309 --> 00:20:10,839
AUDIENCE: 4.
听众：4。 

424
00:20:10,839 --> 00:20:12,549
AUDIENCE: Oh, oh.
听众：哦，哦。 

425
00:20:12,549 --> 00:20:14,501
PROFESSOR: 4.
教授：4。 

426
00:20:14,501 --> 00:20:16,434
So base 100, so two numbers--
所以以100为底，所以有两个数字- 

427
00:20:16,434 --> 00:20:18,971
AUDIENCE: One base 100 number is two digits.
听众：一个以100为基数的数字是两位数。 

428
00:20:18,971 --> 00:20:19,470
Yep.
是的

429
00:20:19,470 --> 00:20:20,819
PROFESSOR: So 8.
教授：所以8。 

430
00:20:20,819 --> 00:20:22,809
yeah, OK, 4.
是的，好的4。 

431
00:20:22,809 --> 00:20:25,000
Cool.
凉。 

432
00:20:25,000 --> 00:20:29,940
So let's try to write this in a more abstract way.
因此，让我们尝试以一种更抽象的方式编写此代码。 

433
00:20:29,940 --> 00:20:38,160
So n is the old n minus old, right,
所以n是旧的n减去旧的，对， 

434
00:20:38,160 --> 00:20:43,920
so that 3 is old times what do I have to multiply it by
所以3是旧时代，我必须乘以

435
00:20:43,920 --> 00:20:48,844
to get all those zeros?
得到所有那些零？ 

436
00:20:48,844 --> 00:20:52,419
k minus 1?
 k减1？ 

437
00:20:52,619 --> 00:20:55,709
[INAUDIBLE] to that base whatever.
 [听不清]以此为基础。 

438
00:20:55,710 --> 00:21:01,980
PROFESSOR: OK, so-- base to the size to something.
教授：好的，所以-根据大小来决定。 

439
00:21:01,980 --> 00:21:04,420
K minus 1.
 K减1。 

440
00:21:04,420 --> 00:21:05,940
So K is 5 in this case, right?
所以在这种情况下K是5，对吗？ 

441
00:21:05,940 --> 00:21:07,750
My window is 5.
我的窗口是5。 

442
00:21:07,750 --> 00:21:10,740
And I see a 4 there, so I'm going to add the minus 1
我在那里看到一个4，所以我要加上负1 

443
00:21:10,740 --> 00:21:13,419
just because that's what I need to do.
只是因为那是我需要做的。 

444
00:21:13,619 --> 00:21:19,029
OK, so then I get 14159265.
好，那么我得到14159265。 

445
00:21:19,029 --> 00:21:23,488
What do I do to tack on a 35 at the end?
我该怎么做才能在35时结束？ 

446
00:21:23,488 --> 00:21:25,203
AUDIENCE: [INAUDIBLE] 35.
观众：[听不清] 35。 

447
00:21:25,203 --> 00:21:26,869
PROFESSOR: OK, times the base, so that's
教授：好的，乘以基数，所以

448
00:21:26,869 --> 00:21:28,719
going to give me the zeroes.
要给我零。 

449
00:21:28,720 --> 00:21:31,140
And then this is a minus here.
然后这是一个负号。 

450
00:21:31,140 --> 00:21:33,910
And then I'm going to add 35.
然后我要添加35。 

451
00:21:33,910 --> 00:21:35,369
Right?
对？ 

452
00:21:35,569 --> 00:21:40,419
1415926535.
 1415926535。 

453
00:21:40,420 --> 00:21:42,119
Look, it's right.
看，是对的。 

454
00:21:42,319 --> 00:21:45,769
So what do I write here?
那我在这里写什么呢？ 

455
00:21:45,769 --> 00:21:48,244
AUDIENCE: The base first.
听众：基础第一。 

456
00:21:48,244 --> 00:21:49,234
PROFESSOR: Good point.
教授：很好。 

457
00:21:49,234 --> 00:21:56,010



458
00:21:56,010 --> 00:21:56,509
OK.
好。 

459
00:21:56,509 --> 00:21:59,317



460
00:21:59,317 --> 00:22:01,650
Let me play with this a little bit before we go further.
在继续之前，让我玩一点。 

461
00:22:01,650 --> 00:22:04,317



462
00:22:04,317 --> 00:22:05,900
I'm going to distribute the base here.
我要在这里分配基地。 

463
00:22:05,900 --> 00:22:12,109
So this is n times base minus old times
所以这是n乘以基础减去以前

464
00:22:12,309 --> 00:22:17,339
base to the k plus mu.
以k加亩为基数。 

465
00:22:17,339 --> 00:22:20,909
And let's rename base to size to be the size of the window,
让我们将base重命名为大小，使其等于窗口的大小， 

466
00:22:20,910 --> 00:22:23,649
I don't like k.
我不喜欢k。 

467
00:22:23,849 --> 00:22:26,059
And I'm renaming it because later on we're
我正在重命名，因为稍后

468
00:22:26,059 --> 00:22:30,559
going to break our slide into appends and skip
要将幻灯片分成附录并跳过

469
00:22:30,559 --> 00:22:32,399
and the size won't be constant anymore.
并且大小将不再恒定。 

470
00:22:32,400 --> 00:22:35,349



471
00:22:35,549 --> 00:22:37,750
OK so does this make sense?
好的，这有意义吗？ 

472
00:22:37,750 --> 00:22:38,359
It's all math.
这都是数学。 

473
00:22:38,359 --> 00:22:41,329
So this math here becomes abstract math here.
因此，这里的数学变成了抽象数学。 

474
00:22:41,329 --> 00:22:42,379
But nothing else changes.
但是没有其他改变。 

475
00:22:42,380 --> 00:22:47,409



476
00:22:47,609 --> 00:22:51,379
OK, so now I want to get hash-- I
好吧，现在我想获取哈希值-我

477
00:22:51,380 --> 00:22:55,960
want to get hash out of n, how do I do that?
想要从n中获取哈希，我该怎么做？ 

478
00:22:55,960 --> 00:22:58,279
AUDIENCE: Mod 23.
听众：Mod 23。 

479
00:22:58,279 --> 00:22:59,879
PROFESSOR: Mod 23, very good.
教授：Mod 23，非常好。 

480
00:22:59,880 --> 00:23:04,130
So in a general way, I would say mod p.
因此，总的来说，我会说mod p。 

481
00:23:04,130 --> 00:23:06,839



482
00:23:07,039 --> 00:23:18,450
OK so hash is n times base minus old times
 OK，所以哈希是n乘以n减去以前的乘积

483
00:23:18,450 --> 00:23:26,227
base to the size plus new mod p.
根据大小加上新的mod p。 

484
00:23:26,227 --> 00:23:27,109
Now let's distribute this.
现在让我们分发它。 

485
00:23:27,309 --> 00:23:29,490
I know I can distribute modulo across addition
我知道我可以跨加法分配模

486
00:23:29,490 --> 00:23:42,789
and subtraction, so I have n mod p times base minus old times
加减，所以我有n mod p乘以基础减去以前的乘积

487
00:23:42,789 --> 00:23:48,549
base to the size mod p plus new.
以mod p加上新大小为基础。 

488
00:23:48,549 --> 00:23:50,537
And everything still has to be a mod p.
一切仍然必须是mod p。 

489
00:23:50,537 --> 00:23:53,670



490
00:23:53,670 --> 00:24:00,268
So can someone tell me where did I add the mod p?
那么有人可以告诉我我在哪里添加了mod p吗？ 

491
00:24:00,268 --> 00:24:03,200



492
00:24:03,200 --> 00:24:06,005
Why did I put it here and here?
我为什么把它放在这里和这里？ 

493
00:24:06,005 --> 00:24:10,726



494
00:24:10,926 --> 00:24:14,379
AUDIENCE: [INAUDIBLE] the original?
听众：[听不清]原件？ 

495
00:24:14,380 --> 00:24:17,224
PROFESSOR: OK, nmodp is hash, let's do that.
教授：好的，nmodp是哈希，让我们开始吧。 

496
00:24:17,424 --> 00:24:23,149



497
00:24:23,150 --> 00:24:27,596
So what's true about both n and base to the size?
那么，n和以大小为基的情况如何呢？ 

498
00:24:27,596 --> 00:24:29,369
AUDIENCE: Constant.
听众：不变。 

499
00:24:29,369 --> 00:24:31,951
PROFESSOR: Constant?
教授：恒定吗？ 

500
00:24:31,951 --> 00:24:34,849
AUDIENCE: Like can you please repeat it?
听众：就像你能重复一遍吗？ 

501
00:24:34,849 --> 00:24:37,442
AUDIENCE: You could [INAUDIBLE] base to the size but you
听众：您可以[听不清]根据大小，但是

502
00:24:37,442 --> 00:24:39,599
can't [INAUDIBLE] hash, I mean [INAUDIBLE]--
不能[听不清]哈希，我的意思是[听不清]- 

503
00:24:39,599 --> 00:24:39,769
PROFESSOR: Hm.
教授：嗯。 

504
00:24:39,769 --> 00:24:41,853
OK, so keep this in mind that we can compute this,
好的，请记住这一点，我们可以进行计算， 

505
00:24:41,853 --> 00:24:43,730
because we're going to want to do that later.
因为我们要稍后再做。 

506
00:24:43,730 --> 00:24:45,990
But what I had in mind is the opposite of constant,
但是我想到的是常数的反面， 

507
00:24:45,990 --> 00:24:48,130
because n is huge.
因为n很大

508
00:24:48,130 --> 00:24:48,890
Right?
对？ 

509
00:24:48,890 --> 00:24:53,369
And base to the size is also huge, right?
而且底座的尺寸也很大吧？ 

510
00:24:53,569 --> 00:24:57,079
N is this number.
 N是这个数字。 

511
00:24:57,079 --> 00:24:59,669
Base to the size is this number here.
基于大小的是此数字。 

512
00:24:59,670 --> 00:25:02,910
1 followed by this many zeros, so these numbers are big.
 1后面跟着这么多的零，所以这些数字很大。 

513
00:25:02,910 --> 00:25:04,859
All the other numbers are small.
所有其他数字都很小。 

514
00:25:05,059 --> 00:25:10,284
Base is small, old is small, new is small, p is small.
基数小，旧的小，新的小，p小。 

515
00:25:10,285 --> 00:25:12,410
PROFESSOR: So I want to get rid of the big numbers,
教授：所以我想摆脱大数字， 

516
00:25:12,410 --> 00:25:16,169
because math with big numbers is slow.
因为大数的数学运算很慢。 

517
00:25:16,369 --> 00:25:18,269
So unless I get rid of the big numbers,
因此，除非我摆脱了大数字， 

518
00:25:18,269 --> 00:25:21,389
I'm not going to get to order 1 operation.
我不会去订购1号手术。 

519
00:25:21,390 --> 00:25:24,140
So we already got rid of this one because it's hash
所以我们已经摆脱了这个，因为它是哈希

520
00:25:24,140 --> 00:25:26,515
and how do I get rid of this one?
以及我该如何摆脱呢？ 

521
00:25:26,515 --> 00:25:27,390
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

522
00:25:27,390 --> 00:25:34,041



523
00:25:34,241 --> 00:25:36,720
AUDIENCE: There's some 6042 algorithm
听众：有一些6042算法

524
00:25:36,720 --> 00:25:37,740
that does that quickly.
很快就能做到。 

525
00:25:37,740 --> 00:25:40,156
AUDIENCE: Well, we definitely just went over this in class
听众：好吧，我们绝对是在上课时

526
00:25:40,156 --> 00:25:41,464
today.
今天。 

527
00:25:41,464 --> 00:25:45,705
AUDIENCE: Which is why you needed the prime number, right?
听众：这就是为什么您需要素数，对吗？ 

528
00:25:45,705 --> 00:25:46,579
PROFESSOR: Not quite.
教授：不完全是。 

529
00:25:46,579 --> 00:25:48,419
There is an algorithm that does it quickly.
有一种算法可以快速完成。 

530
00:25:48,420 --> 00:25:50,609
That algorithm is called repeated squaring
该算法称为重复平方

531
00:25:50,809 --> 00:25:55,639
and the quickest-- wait, I'm not done, I promise I'm not done.
最快-等待，我还没有完成，我保证我还没有完成。 

532
00:25:55,640 --> 00:25:57,909
So the quickest that this guy can
所以这家伙可以最快

533
00:25:58,109 --> 00:26:05,519
run if you do everything right is order of [? log ?] size.
如果一切正确，请运行[？ log？]大小。 

534
00:26:05,519 --> 00:26:07,970
If the window size is 1 megabyte,
如果视窗大小为1 MB， 

535
00:26:07,970 --> 00:26:11,130
10 megabytes, if the window size keeps growing,
 10 MB，如果窗口大小持续增长， 

536
00:26:11,130 --> 00:26:13,650
if the window size is part of the input size,
如果窗口大小是输入大小的一部分， 

537
00:26:13,650 --> 00:26:15,329
is this constant?
这个常数吗？ 

538
00:26:15,529 --> 00:26:16,089
Nope.
不。 

539
00:26:16,089 --> 00:26:17,609
So I can't do that.
所以我不能那样做。 

540
00:26:17,609 --> 00:26:19,849
Someone else gave me the right answer before.
之前有人给我正确的答案。 

541
00:26:19,849 --> 00:26:24,750



542
00:26:24,750 --> 00:26:26,648
What did you say before?
你刚才说什么

543
00:26:26,648 --> 00:26:27,689
AUDIENCE: Pre-compute it?
听众：预先计算吗？ 

544
00:26:27,690 --> 00:26:28,279
PROFESSOR: OK.
教授：好的。 

545
00:26:28,279 --> 00:26:30,700
It's a constant, so why don't we pre-compute it?
这是一个常数，所以为什么不预先计算呢？ 

546
00:26:30,700 --> 00:26:35,069
Take it out of here, compute it once,
从这里取出，计算一次， 

547
00:26:35,069 --> 00:26:37,730
and after that, we can use it all the time.
之后，我们可以一直使用它。 

548
00:26:37,730 --> 00:26:40,559
And unless someone has a better name for it,
除非有人对此有更好的名字， 

549
00:26:40,559 --> 00:26:41,835
I'm going to call this magic.
我将称之为魔术。 

550
00:26:41,835 --> 00:26:44,679



551
00:26:44,679 --> 00:26:46,220
The name has to be short, by the way,
顺便说一下，这个名字必须简短

552
00:26:46,220 --> 00:26:47,928
because I'll be writing this a few times.
因为我会写几次。 

553
00:26:47,928 --> 00:26:50,250



554
00:26:50,250 --> 00:26:53,519
OK, so now we have hash equals hash times base
好，现在我们的哈希等于哈希乘以基数

555
00:26:53,519 --> 00:26:56,854
minus old times magic plus new modulo p.
减去旧时代的魔法加上新的模数p。 

556
00:26:56,854 --> 00:26:58,019
Doesn't look too bad, right?
看起来还不错吧？ 

557
00:26:58,019 --> 00:26:59,869
Pretty constant time.
相当恒定的时间。 

558
00:26:59,869 --> 00:27:02,719
Now let's write the pseudo code for the rolling hash,
现在让我们为滚动哈希编写伪代码， 

559
00:27:02,720 --> 00:27:05,980
and let's break this out into an append
让我们将其分解为一个附录

560
00:27:05,980 --> 00:27:08,362
and a skip at the same time.
并同时跳过

561
00:27:08,362 --> 00:27:12,891
AUDIENCE: What if hash is bigger than your word size?
听众：如果哈希大于您的单词大小怎么办？ 

562
00:27:12,891 --> 00:27:15,390
PROFESSOR: So hash is always going to be something modulo p.
教授：因此，哈希始终是p的模。 

563
00:27:15,390 --> 00:27:16,669
AUDIENCE: Oh that's true, OK.
听众：哦，是的，好的。 

564
00:27:16,869 --> 00:27:18,889
PROFESSOR: So as long as p is decent,
教授：只要p像样， 

565
00:27:18,890 --> 00:27:20,217
it's not going to get too big.
它不会变得太大。 

566
00:27:20,217 --> 00:27:20,849
AUDIENCE: All right.
听众：好的。 

567
00:27:21,049 --> 00:27:25,065
What if old and new [INAUDIBLE]--
如果新旧[听不清] 

568
00:27:25,065 --> 00:27:26,190
PROFESSOR: So old and new--
教授：如此古老又崭新- 

569
00:27:26,190 --> 00:27:27,672
AUDIENCE: P is a big number .
听众：P是一个大数字。 

570
00:27:27,672 --> 00:27:32,493
314159269 is possibly bigger than your word size, right?
 314159269可能大于您的单词大小，对吗？ 

571
00:27:32,493 --> 00:27:33,409
PROFESSOR: Definitely.
教授：当然可以。 

572
00:27:33,410 --> 00:27:37,025
So that's why we're getting rid of it.
这就是为什么我们要摆脱它。 

573
00:27:37,025 --> 00:27:39,000
AUDIENCE: That is true. [INAUDIBLE]
听众：是的。 [听不清] 

574
00:27:39,000 --> 00:27:42,809
PROFESSOR: So this is k digits in base b.
教授：所以这是基数b的k位数字。 

575
00:27:42,809 --> 00:27:43,389
Too much.
太多了。 

576
00:27:43,390 --> 00:27:44,880
Not going to deal with it.
不打算处理它。 

577
00:27:44,880 --> 00:27:49,409
Hash is one digit in base p, because we're doing it mod p.
哈希是基数p中的一位数字，因为我们在mod p中进行操作。 

578
00:27:49,609 --> 00:27:53,269
Old and new are one digit base b.
新旧都是一位数字基数b。 

579
00:27:53,269 --> 00:27:56,170
So hopefully small numbers.
希望人数少。 

580
00:27:56,170 --> 00:27:58,240
OK, I haven't seen a constructor in CLRS,
好的，我没有在CLRS中看到构造函数， 

581
00:27:58,240 --> 00:28:00,589
so I'm going to say that when you write pseudocode,
所以我要说的是，当您编写伪代码时， 

582
00:28:00,589 --> 00:28:02,329
the method name for a constructor
构造函数的方法名称

583
00:28:02,329 --> 00:28:05,098
is in it because we've seen this before.
之所以在其中是因为我们之前已经看过这个。 

584
00:28:05,098 --> 00:28:07,139
And let's say our constructor for a rolling cache
假设我们的滚动缓存的构造函数

585
00:28:07,140 --> 00:28:10,680
starts with the base that we're going to use.
从我们将要使用的基础开始。 

586
00:28:10,680 --> 00:28:13,209
And it builds an empty rolling hash,
它建立了一个空的滚动哈希， 

587
00:28:13,209 --> 00:28:14,500
so first there's nothing in it.
首先，它什么都没有。 

588
00:28:14,500 --> 00:28:16,823
And then you append and you skip and you can get the hash.
然后追加并跳过，就可以得到哈希值。 

589
00:28:16,823 --> 00:28:17,580
AUDIENCE: What about p?
听众：p呢？ 

590
00:28:17,780 --> 00:28:18,859
Shouldn't you also do p?
你不也应该做p吗？ 

591
00:28:18,859 --> 00:28:20,683
PROFESSOR: Sure.
教授：当然可以。 

592
00:28:20,683 --> 00:28:22,680
Do that.
去做。 

593
00:28:22,680 --> 00:28:28,899
So let's say base and p are set, so somethings sets base and p.
假设设置了base和p，那么有些东西设置了base和p。 

594
00:28:29,099 --> 00:28:30,969
And we need to compute the initial values
我们需要计算初始值

595
00:28:30,970 --> 00:28:31,970
for hash and magic.
哈希和魔术。 

596
00:28:31,970 --> 00:28:38,049



597
00:28:38,049 --> 00:28:40,289
What's hash?
什么是哈希？ 

598
00:28:40,289 --> 00:28:40,930
Zero.
零。 

599
00:28:40,930 --> 00:28:42,062
There's nothing in there, right?
那里什么都没有，对不对？ 

600
00:28:42,262 --> 00:28:43,019
The number is 0.
数字是0。 

601
00:28:43,019 --> 00:28:45,180
What's magic?
魔术是什么？ 

602
00:28:45,180 --> 00:28:47,180
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

603
00:28:47,180 --> 00:28:49,680
Well, I mean, you can calculate it, right?
好吧，我的意思是，您可以计算出来，对吧？ 

604
00:28:49,680 --> 00:28:52,259
PROFESSOR: So magic is based to the size mod p.
教授：魔术是基于mod p的大小。 

605
00:28:52,259 --> 00:28:53,894
What size?
什么尺寸？ 

606
00:28:53,894 --> 00:28:56,253
AUDIENCE: [INAUDIBLE] 0.
观众：[听不清] 0。 

607
00:28:56,253 --> 00:28:58,075
Just one mod p.
仅一个mod p。 

608
00:28:58,076 --> 00:28:58,700
PROFESSOR: Yep.
教授：是的。 

609
00:28:58,700 --> 00:29:02,139
So when I start, I have an empty sliding window.
因此，当我开始时，我有一个空的滑动窗口。 

610
00:29:02,339 --> 00:29:05,159
Nothing in there, size is 0, base to the size
那里什么都没有，大小为0，以大小为基础

611
00:29:05,160 --> 00:29:08,490
is 1, whatever the size is.
是1，无论大小是多少。 

612
00:29:08,490 --> 00:29:09,599
Very good.
很好。 

613
00:29:09,599 --> 00:29:10,409
Let's write append.
让我们写一个追加。 

614
00:29:10,410 --> 00:29:17,390



615
00:29:17,390 --> 00:29:20,109
Hash is?
哈希是？ 

616
00:29:20,309 --> 00:29:23,720
So here, we're doing both an append and the skip.
因此，在这里，我们同时执行附加操作和跳过操作。 

617
00:29:23,720 --> 00:29:26,056
We have to figure out which operation belongs
我们必须弄清楚哪个操作属于

618
00:29:26,056 --> 00:29:28,180
to the append, which operations belong to the skip.
到追加，哪些操作属于跳过。 

619
00:29:28,180 --> 00:29:29,967
So someone help me out.
所以有人帮我。 

620
00:29:29,967 --> 00:29:33,630



621
00:29:33,630 --> 00:29:35,909
AUDIENCE: We know subtraction would [INAUDIBLE]--
听众：我们知道减法会[听不清]- 

622
00:29:36,109 --> 00:29:39,609
AUDIENCE: Multiply mod base [INAUDIBLE].
听众：乘以mod base [听不清]。 

623
00:29:39,609 --> 00:29:40,309
PROFESSOR: Yup.
教授：是的。 

624
00:29:40,309 --> 00:29:41,942
So this is the append, right?
这是附加项，对不对？ 

625
00:29:41,942 --> 00:29:45,329



626
00:29:45,329 --> 00:29:47,299
And this is the skip.
这就是跳过。 

627
00:29:47,299 --> 00:29:51,009



628
00:29:51,009 --> 00:29:53,819
So hash equals hash.
因此，哈希等于哈希。 

629
00:29:53,819 --> 00:29:57,500



630
00:29:57,500 --> 00:30:04,900
Times base plus new mod p.
时基加上新的mod p。 

631
00:30:04,900 --> 00:30:05,400
Very good.
很好。 

632
00:30:05,400 --> 00:30:06,099
This is important.
这个很重要。 

633
00:30:06,299 --> 00:30:08,399
If you don't put this in, Python knows
如果不输入，Python就会知道

634
00:30:08,400 --> 00:30:10,759
how to deal with big numbers.
如何处理大数字。 

635
00:30:10,759 --> 00:30:12,990
So it will take your code and it'll run it,
因此，它将使用您的代码并运行它， 

636
00:30:12,990 --> 00:30:14,819
and you'll get the correct output.
您将获得正确的输出。 

637
00:30:14,819 --> 00:30:17,059
But hash will keep growing and growing and growing
但是哈希将不断增长

638
00:30:17,059 --> 00:30:19,829
because you're computing n instead of hash.
因为您要计算n而不是哈希。 

639
00:30:19,829 --> 00:30:22,710
And you'll wonder why the code is so slow.
您会想知道为什么代码这么慢。 

640
00:30:22,710 --> 00:30:24,230
So don't forget this.
所以不要忘记这一点。 

641
00:30:24,230 --> 00:30:25,480
What else do I need to update?
我还需要更新什么？ 

642
00:30:25,480 --> 00:30:29,720



643
00:30:29,720 --> 00:30:32,009
OK, I don't have a constant for that,
好吧，我没有一个常数

644
00:30:32,009 --> 00:30:36,359
but I have a constant I for something else.
但是我有一个不变的自我。 

645
00:30:36,359 --> 00:30:38,459
Magic.
魔法。 

646
00:30:38,460 --> 00:30:40,980
So magic is base to the size mod p.
因此，魔术是大小mod p的基础。 

647
00:30:40,980 --> 00:30:42,548
So what happened to the window size?
那么窗口大小发生了什么？ 

648
00:30:42,548 --> 00:30:43,089
AUDIENCE: Oh.
听众：哦。 

649
00:30:43,089 --> 00:30:44,544
Times base [INAUDIBLE].
时基[音频不清晰]。 

650
00:30:44,545 --> 00:30:45,420
PROFESSOR: Excellent.
教授：非常好。 

651
00:30:45,420 --> 00:30:47,210
The window size grows by 1, therefore,
窗口大小增加1，因此， 

652
00:30:47,210 --> 00:30:50,670
I have to multiply this by base.
我必须将此乘以基数。 

653
00:30:50,670 --> 00:30:55,909
Magic times base mod p.
魔法时代基础MOD p。 

654
00:30:56,109 --> 00:30:58,841
AUDIENCE: Does p always have to be less then the base,
听众：p是否必须总是小于基数， 

655
00:30:58,842 --> 00:31:01,740
or can it be anything?
或者可以是什么？ 

656
00:31:01,740 --> 00:31:03,559
PROFESSOR: It can be bigger than the base.
教授：它可以比基数大。 

657
00:31:03,559 --> 00:31:08,079
So if I want to not have a lot of false positives,
因此，如果我不想有很多误报， 

658
00:31:08,079 --> 00:31:10,599
then suppose my base is 256, because that's
然后假设我的底数是256，因为那是

659
00:31:10,599 --> 00:31:11,649
an extra character.
一个额外的字符。 

660
00:31:11,650 --> 00:31:14,149



661
00:31:14,349 --> 00:31:16,750
I was arguing earlier that the number of false positives
我之前说过，误报的数量

662
00:31:16,750 --> 00:31:20,619
that I have is 1/P basically.
我拥有的基本上是1 / P。 

663
00:31:20,619 --> 00:31:23,309
So I want p to be as close to the word size as possible.
所以我希望p尽可能接近字长。 

664
00:31:23,309 --> 00:31:28,669
So p will be around 2 to the 4 billion.
因此p将在2到40亿之间。 

665
00:31:28,670 --> 00:31:29,920
So definitely bigger.
所以绝对更大。 

666
00:31:29,920 --> 00:31:31,480
It can work either way.
它可以以任何一种方式工作。 

667
00:31:31,480 --> 00:31:33,849
It's better if it's bigger for the algorithm
算法越大越好

668
00:31:33,849 --> 00:31:35,509
that we're using there.
我们在那里使用。 

669
00:31:35,509 --> 00:31:38,690
All right, good question, thank you.
好的，好的问题，谢谢。 

670
00:31:38,690 --> 00:31:39,909
Skip.
跳跃。 

671
00:31:40,109 --> 00:31:40,990
Let's implement skip.
让我们实现跳过。 

672
00:31:40,990 --> 00:31:44,519



673
00:31:44,519 --> 00:31:46,556
Hash is?
哈希是？ 

674
00:31:46,556 --> 00:31:56,016
AUDIENCE: Hash minus old [INAUDIBLE] then comes magic
听众：哈希减去旧的[听不清]然后变魔术

675
00:31:56,016 --> 00:31:56,516
[INAUDIBLE].
 [听不清]。 

676
00:31:56,516 --> 00:32:05,509



677
00:32:05,509 --> 00:32:07,400
PROFESSOR: OK, can I write this in Python?
教授：好的，我可以用Python编写吗？ 

678
00:32:07,400 --> 00:32:10,130
What happens if I write this?
如果我写这个怎么办？ 

679
00:32:10,130 --> 00:32:16,929
AUDIENCE: [INAUDIBLE] magic is, [INAUDIBLE] We
听众：[听不清]魔术是[听不清]我们

680
00:32:16,929 --> 00:32:17,970
won't be able to find it.
将找不到它。 

681
00:32:17,970 --> 00:32:20,559
PROFESSOR: OK so-- sorry, not in Python.
教授：好的，对不起，不是Python。 

682
00:32:20,559 --> 00:32:23,519
So assume all these are instance variables done the right way,
因此，假设所有这些都是正确执行的实例变量， 

683
00:32:23,519 --> 00:32:26,960
but what happens if old times magic is bigger than hash?
但是，如果以前的魔术比哈希大，会发生什么？ 

684
00:32:26,960 --> 00:32:29,399



685
00:32:29,599 --> 00:32:30,899
I get a negative number.
我得到一个负数。 

686
00:32:30,900 --> 00:32:33,889
And in math, people assume that if you
在数学上，人们认为如果

687
00:32:34,089 --> 00:32:40,149
do something like minus 3 modulo 23, you're going to get 20.
做类似负3模23的事情，您将得到20。 

688
00:32:40,150 --> 00:32:43,139



689
00:32:43,339 --> 00:32:49,189
So modulo is always positive in modular arithmetic,
所以模在模算术中总是正的， 

690
00:32:49,190 --> 00:32:54,779
but in a programming language, if you do minus 3 modulo 20,
但是用一种编程语言，如果您做负3模20 

691
00:32:54,779 --> 00:32:59,500
I'm pretty sure you're going to get minus 3.
我很确定您会得到减3。 

692
00:32:59,500 --> 00:33:00,579
And things will go back.
事情会回到过去。 

693
00:33:00,579 --> 00:33:02,529
So we want to get to a positive number
所以我们想得到一个正数

694
00:33:02,529 --> 00:33:06,210
here so that the arithmetic modulo
在这里这样算术模

695
00:33:06,210 --> 00:33:09,049
p will work just like in math.
 p会像在数学上一样工作。 

696
00:33:09,049 --> 00:33:12,686
So we want to add something to make this whole thing positive.
因此，我们想添加一些东西来使整个事情变得积极。 

697
00:33:12,686 --> 00:33:15,819
AUDIENCE: That's something times [INAUDIBLE].
听众：有时候[听不清]。 

698
00:33:15,819 --> 00:33:18,099
PROFESSOR: OK, so if we're working modulo p
教授：好的，所以如果我们以p为模

699
00:33:18,099 --> 00:33:22,189
then we can add anything to our number, any multiple of p,
那么我们可以将任何东西加到p的任何倍数上

700
00:33:22,190 --> 00:33:24,769
and the result modulo p doesn't change.
结果，模p不变。 

701
00:33:24,769 --> 00:33:29,220
For example, here to get from minus 3 to 20, I added 23.
例如，这里是从负3到20，我加了23。 

702
00:33:29,220 --> 00:33:31,680
Right?
对？ 

703
00:33:31,680 --> 00:33:35,279
OK, so I want to add a correction
好，所以我想添加一个更正

704
00:33:35,279 --> 00:33:37,920
factor of p times something.
 p倍的东西。 

705
00:33:37,920 --> 00:33:38,900
So what should that be?
那应该是什么？ 

706
00:33:38,900 --> 00:33:41,721



707
00:33:41,721 --> 00:33:43,970
I want to make sure that this whole thing is positive.
我想确保整个事情都是积极的。 

708
00:33:43,970 --> 00:33:52,855



709
00:33:52,855 --> 00:33:53,730
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

710
00:33:53,730 --> 00:33:59,289



711
00:33:59,289 --> 00:34:00,289
PROFESSOR: So let's see.
教授：那么，让我们看看。 

712
00:34:00,289 --> 00:34:01,748
How big are these guys, by the way?
这些家伙有多大？ 

713
00:34:01,748 --> 00:34:04,220
Magic is something mod p, right?
魔术是mod p的东西，对不对？ 

714
00:34:04,220 --> 00:34:07,009
So it's definitely smaller or equal to p.
因此，它肯定小于或等于p。 

715
00:34:07,009 --> 00:34:07,839
How about old?
老了吗？ 

716
00:34:07,839 --> 00:34:10,822



717
00:34:10,822 --> 00:34:12,320
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

718
00:34:12,320 --> 00:34:13,760
PROFESSOR: OK.
教授：好的。 

719
00:34:13,760 --> 00:34:16,083
So smaller or equal than?
小于或等于？ 

720
00:34:16,083 --> 00:34:16,949
AUDIENCE: Base.
听众：基础。 

721
00:34:16,949 --> 00:34:19,650
PROFESSOR: Base.
教授：基地。 

722
00:34:19,650 --> 00:34:20,394
Very good.
很好。 

723
00:34:20,394 --> 00:34:21,769
So this whole thing is definitely
所以这件事绝对是

724
00:34:21,769 --> 00:34:25,552
going to be smaller than [INAUDIBLE].
会比[音频不清晰]小。 

725
00:34:25,552 --> 00:34:28,010
So this is definitely going to be smaller than base time p,
因此，这肯定会小于基准时间p， 

726
00:34:28,010 --> 00:34:28,500
right?
对？ 

727
00:34:28,500 --> 00:34:29,583
So let's put that in here.
因此，我们将其放在这里。 

728
00:34:29,583 --> 00:34:32,619



729
00:34:32,619 --> 00:34:34,949
You can get fancy and say hey, this is smaller than p,
您可以幻想说，这比p小， 

730
00:34:34,949 --> 00:34:37,989
and this is old, so you can put old here instead, same thing.
这是旧的，所以您可以在同一位置放旧。 

731
00:34:37,989 --> 00:34:41,119



732
00:34:41,119 --> 00:34:43,710
OK so we have hash.
好，所以我们有哈希。 

733
00:34:43,710 --> 00:34:44,818
Now what do we do to magic?
现在我们该怎么做魔术？ 

734
00:34:45,018 --> 00:34:48,879



735
00:34:48,880 --> 00:35:00,219
AUDIENCE: [INAUDIBLE] divide it by the base and mod p.
听众：[听不清]将其除以基数和mod p。 

736
00:35:00,219 --> 00:35:04,163
It seems base [? and p ?] don't share factors.
看来基础[？和p？]不共享因素。 

737
00:35:04,163 --> 00:35:05,641
You're allowed to do that?
你被允许这样做吗？ 

738
00:35:05,641 --> 00:35:08,149



739
00:35:08,150 --> 00:35:09,820
PROFESSOR: OK, so skip part two.
教授：好的，所以跳过第二部分。 

740
00:35:09,820 --> 00:35:14,710



741
00:35:14,909 --> 00:35:33,940
Magic equals-- So what if my magic is something like 5
魔法等于-如果我的魔法是5 

742
00:35:33,940 --> 00:35:35,480
and my base is 100?
我的底数是100？ 

743
00:35:35,480 --> 00:35:36,789
How is this going to work?
这如何运作？ 

744
00:35:36,989 --> 00:35:42,579



745
00:35:42,579 --> 00:35:45,259
This is where we use fancy math.
这是我们使用奇特数学的地方。 

746
00:35:45,260 --> 00:35:47,670
And I call it fancy math because I
我称它为奇特数学，因为我

747
00:35:47,670 --> 00:35:49,230
didn't learn it in high school.
在高中没学过

748
00:35:49,429 --> 00:35:53,190
So I'm assuming at least some of you do not know how this works.
因此，我假设至少有些人不知道这是如何工作的。 

749
00:35:53,190 --> 00:35:56,135
So if we're working modulo p, you
因此，如果我们以p为模，则您

750
00:35:56,335 --> 00:35:58,750
can think 23 if you prefer concrete numbers instead.
如果您更喜欢具体数字，可以考虑23。 

751
00:35:58,750 --> 00:36:03,070



752
00:36:03,070 --> 00:36:10,269
For any number between 1 and p minus 1,
对于1到p减去1之间的任何数字

753
00:36:10,269 --> 00:36:13,710
there's something called the multiplicative inverse,
有一种叫做乘法逆的东西

754
00:36:13,710 --> 00:36:17,260
a to the minus 1, that also happens
 a到负1，也会发生

755
00:36:17,260 --> 00:36:20,070
to be an integer between 1 and p minus 1.
为1到p减1之间的整数。 

756
00:36:20,269 --> 00:36:26,509
And if you multiply, say, a times b, that's another number.
如果乘以b，则这是另一个数字。 

757
00:36:26,510 --> 00:36:29,550
And then you multiply this by a minus 1,
然后将其乘以减1， 

758
00:36:29,550 --> 00:36:34,170
you're going to get to b modulo p.
您将获得b模p。 

759
00:36:34,369 --> 00:36:38,201
So a minus 1 cancels a in a multiplication.
因此，负1会取消乘法。 

760
00:36:38,202 --> 00:36:39,960
Now let's see if you guys are paying attention.
现在让我们看看你们是否在关注。 

761
00:36:40,159 --> 00:36:43,106
What's a times a to the minus 1 modulo p?
负1模p乘a的倍数是多少？ 

762
00:36:43,106 --> 00:36:44,539
AUDIENCE: 1.
听众：1。 

763
00:36:44,539 --> 00:36:45,170
PROFESSOR: OK.
教授：好的。 

764
00:36:45,170 --> 00:36:45,668
Sweet.
甜。 

765
00:36:45,668 --> 00:36:48,460



766
00:36:48,460 --> 00:36:53,769
So suppose I want to find the multiplicative inverse of 6.
因此，假设我想找到6的乘法逆。 

767
00:36:53,769 --> 00:36:54,826
What is it?
它是什么？ 

768
00:36:54,826 --> 00:36:57,010
AUDIENCE: Is that the mod 23?
听众：是mod 23吗？ 

769
00:36:57,010 --> 00:36:59,186
PROFESSOR: Yeah.
教授：是的。 

770
00:36:59,186 --> 00:37:00,880
Can someone think of what it should be?
有人能想到它应该是什么吗？ 

771
00:37:00,880 --> 00:37:01,480
AUDIENCE: 4.
听众：4。 

772
00:37:01,679 --> 00:37:04,559
PROFESSOR: 4, wow, fast.
教授：4，哇，快。 

773
00:37:04,559 --> 00:37:12,230
So 6 times 4 equals 24, which is 1 modulo 23.
因此6乘以4等于24，即1为模23。 

774
00:37:12,230 --> 00:37:16,519
Now let's see if this magic really works, this math magic.
现在，让我们看看这种魔术是否真的有效，这种数学魔术。 

775
00:37:16,519 --> 00:37:19,967
So 6 times 7 equals?
那么6乘以7等于？ 

776
00:37:19,967 --> 00:37:21,329
AUDIENCE: 42.
听众：42。 

777
00:37:21,329 --> 00:37:24,699
PROFESSOR: Which is what mod 23?
教授：哪个是mod 23？ 

778
00:37:24,699 --> 00:37:25,795
Computer guys.
电脑家伙。 

779
00:37:25,795 --> 00:37:26,989
AUDIENCE: Negative 4, so 5.
观众：负面4，所以5。 

780
00:37:26,989 --> 00:37:29,814
Ah, just kidding.
啊，开玩笑。 

781
00:37:29,815 --> 00:37:30,315
Yeah.
是的

782
00:37:30,315 --> 00:37:35,070



783
00:37:35,070 --> 00:37:38,980
PROFESSOR: OK now let's multiply 19 by 4.
教授：好的，现在我们将19乘以4。 

784
00:37:39,179 --> 00:37:41,176
What is this?
这是什么？ 

785
00:37:41,177 --> 00:37:41,518
AUDIENCE: 76.
观众：76。 

786
00:37:41,717 --> 00:37:44,639



787
00:37:44,639 --> 00:37:46,190
PROFESSOR: All right, 76 modulo 23?
教授：好的，以23为模数吗？ 

788
00:37:46,190 --> 00:37:49,983



789
00:37:49,983 --> 00:37:54,210
AUDIENCE: 7 maybe.
听众：也许7。 

790
00:37:54,210 --> 00:37:55,925
PROFESSOR: Are you kidding?
教授：你在开玩笑吗？ 

791
00:37:55,925 --> 00:37:57,735
Did you compute it, or did you use--
您是计算出来的，还是使用了- 

792
00:37:57,735 --> 00:38:01,039
AUDIENCE: 69 [INAUDIBLE]
观众：69 [听不清] 

793
00:38:01,039 --> 00:38:02,239
PROFESSOR: OK.
教授：好的。 

794
00:38:02,239 --> 00:38:05,659
Started with 7, ended with 7.
以7开头，以7结束。 

795
00:38:05,659 --> 00:38:06,414
So this works.
所以这可行。 

796
00:38:06,414 --> 00:38:10,639



797
00:38:10,639 --> 00:38:13,650
So as long we're working modulo a prime number,
因此，只要我们以质数为模， 

798
00:38:13,650 --> 00:38:17,250
we can always compute multiplicative inverses.
我们总是可以计算乘法逆。 

799
00:38:17,449 --> 00:38:19,489
And Python has a function for that,
 Python为此提供了一个功能， 

800
00:38:19,489 --> 00:38:21,769
so I'll let you Google its standard library
所以我会让你Google的标准库

801
00:38:21,769 --> 00:38:23,126
to find out what it is.
找出它是什么。 

802
00:38:23,126 --> 00:38:24,750
But it can be done, that's what matters
但是可以做到的，那才是最重要的

803
00:38:24,750 --> 00:38:27,929
as far as we're concerned.
就我们而言。 

804
00:38:27,929 --> 00:38:35,879
So we're going to say that magic is magic times base minus 1 mod
所以我们要说魔法是魔法乘以基础减去1 mod 

805
00:38:35,880 --> 00:38:41,230
p, which is the multiplicative inverse everything mod p.
 p，它是所有乘数逆模p。 

806
00:38:41,230 --> 00:38:43,690
Now suppose this base minus 1 modulo p,
现在假设这个基数减去1模p 

807
00:38:43,690 --> 00:38:48,090
this multiplicative inverse algorithm is really slow.
这种乘法逆算法确实很慢。 

808
00:38:48,090 --> 00:38:54,820
What do we do to stay order 1?
我们如何保持订单1？ 

809
00:38:54,820 --> 00:38:55,730
Pre compute it.
预先计算。 

810
00:38:55,730 --> 00:38:58,809
Base is not going to change.
基础不会改变。 

811
00:38:58,809 --> 00:38:59,989
Very good.
很好。 

812
00:38:59,989 --> 00:39:07,899
So the inverse of base, I base, is base minus 1 mod p.
因此，底数的倒数I base为底数减去1 mod p。 

813
00:39:07,900 --> 00:39:11,039



814
00:39:11,039 --> 00:39:15,579
So here I replace this with I base.
所以在这里我用我的基地代替。 

815
00:39:15,579 --> 00:39:18,179



816
00:39:18,179 --> 00:39:20,809
OK so skip part one is there, skip part two is here.
确定，所以跳过第一部分，这里跳过第二部分。 

817
00:39:20,809 --> 00:39:23,349



818
00:39:23,349 --> 00:39:24,579
Does this make sense so far?
到目前为止，这有意义吗？ 

819
00:39:24,579 --> 00:39:29,049



820
00:39:29,050 --> 00:39:30,519
I see some confusion.
我有些困惑。 

821
00:39:30,719 --> 00:39:32,909
AUDIENCE: A lot.
听众：很多。 

822
00:39:32,909 --> 00:39:34,409
PROFESSOR: A lot to take in at once?
教授：一次可以吸收很多东西吗？ 

823
00:39:34,409 --> 00:39:35,480
AUDIENCE: Yes.
听众：是的。 

824
00:39:35,480 --> 00:39:37,119
PROFESSOR: OK.
教授：好的。 

825
00:39:37,119 --> 00:39:41,670
So remember this concept.
所以请记住这个概念。 

826
00:39:41,670 --> 00:39:43,639
So this is where we started from.
这就是我们的起点。 

827
00:39:43,639 --> 00:39:46,019
Then we computed n, then after n, we
然后我们计算n，然后在n之后，我们

828
00:39:46,019 --> 00:39:49,309
worked modulo p to gets to hashes.
用模p运算得到哈希值。 

829
00:39:49,309 --> 00:39:52,913
So by working module p, we're able to get rid
所以通过工作模块p，我们可以摆脱

830
00:39:52,914 --> 00:39:54,130
of all the big numbers and we only
在所有大数字中，我们只

831
00:39:54,329 --> 00:39:58,069
have small numbers in our rolling hash.
在滚动哈希中有少量数字。 

832
00:39:58,070 --> 00:40:01,050
And there's that curveball there, there
那里有曲线球

833
00:40:01,050 --> 00:40:03,090
is that inverse, multiplicative inverse,
是逆，乘法逆， 

834
00:40:03,090 --> 00:40:04,920
but Python computes it for you, so
但Python会为您进行计算，因此

835
00:40:05,119 --> 00:40:06,936
as long as it's in the initializer,
只要在初始化程序中

836
00:40:06,936 --> 00:40:08,519
here you don't need to worry about it,
在这里，您不必担心， 

837
00:40:08,519 --> 00:40:12,530
because it's not part of the rolling hash operations.
因为它不是滚动哈希操作的一部分。 

838
00:40:12,530 --> 00:40:15,269
By the way, what's the cost of the rolling hash operations?
顺便说一下，滚动哈希运算的成本是多少？ 

839
00:40:15,269 --> 00:40:16,471
What's the cost of new?
新产品的成本是多少？ 

840
00:40:16,471 --> 00:40:20,226



841
00:40:20,226 --> 00:40:21,599
Sorry, what's the cost of append?
抱歉，追加费用是多少？ 

842
00:40:21,599 --> 00:40:22,480
Not thinking here.
不在这里思考。 

843
00:40:22,480 --> 00:40:26,750



844
00:40:26,750 --> 00:40:27,380
Constant.
不变。 

845
00:40:27,380 --> 00:40:29,460
All these are small numbers, so the arithmetic
这些都是小数字，所以算术

846
00:40:29,460 --> 00:40:31,880
is constant, right?
是恒定的，对吗？ 

847
00:40:31,880 --> 00:40:34,965
What's the cost of skip?
跳过的费用是多少？ 

848
00:40:34,965 --> 00:40:36,860
Skip part 1 here, skip part two there.
在此处跳过第1部分，在此处跳过第2部分。 

849
00:40:36,860 --> 00:40:39,440
What's the cost of skip?
跳过的费用是多少？ 

850
00:40:39,440 --> 00:40:40,210
Constant. .
不变。 。 

851
00:40:40,210 --> 00:40:41,436
All the numbers are small.
所有数字都很小。 

852
00:40:41,436 --> 00:40:43,269
We went through a lot of effort to get that,
我们为此付出了很多努力， 

853
00:40:43,269 --> 00:40:46,739
so skip is order 1.
所以跳过是订单1。 

854
00:40:46,739 --> 00:40:47,769
We're missing hash.
我们缺少哈希。 

855
00:40:47,769 --> 00:40:49,849
How would we implement the hash operation?
我们将如何实现哈希运算？ 

856
00:40:49,849 --> 00:40:50,849
A hash query.
哈希查询。 

857
00:40:50,849 --> 00:40:55,610



858
00:40:55,610 --> 00:40:57,030
It's easy.
这很容易。 

859
00:40:57,030 --> 00:40:57,851
Sorry?
抱歉？ 

860
00:40:57,851 --> 00:41:01,539
AUDIENCE: [INAUDIBLE] lookup [INAUDIBLE].
听众：[听不清]查找[听不清]。 

861
00:41:01,539 --> 00:41:05,650
PROFESSOR: So a rolling hash has append, skip, and hash.
教授：因此，滚动哈希具有附加，跳过和哈希。 

862
00:41:05,650 --> 00:41:09,889
I want to implement that hash function.
我想实现该哈希函数。 

863
00:41:09,889 --> 00:41:11,609
Hash.
哈希。 

864
00:41:11,610 --> 00:41:15,269
We're computing hash all the time.
我们一直在计算哈希。 

865
00:41:15,469 --> 00:41:16,079
Return.
返回。 

866
00:41:16,079 --> 00:41:19,119
Sorry, I didn't understand what you meant by lookup.
抱歉，我不明白您的查询含义。 

867
00:41:19,119 --> 00:41:20,980
AUDIENCE: It's one of our states.
听众：这是我们的州之一。 

868
00:41:20,980 --> 00:41:21,650
PROFESSOR: Yeah.
教授：是的。 

869
00:41:21,650 --> 00:41:22,150
Exactly.
究竟。 

870
00:41:22,150 --> 00:41:25,690
So the hash function returns hash, right?
所以hash函数返回hash，对不对？ 

871
00:41:25,690 --> 00:41:26,500
What's the cost of that?
费用是多少？ 

872
00:41:26,699 --> 00:41:29,289



873
00:41:29,289 --> 00:41:32,239
Constant.
不变。 

874
00:41:32,239 --> 00:41:37,289
So append is constant time, yes?
因此，append是固定时间的，是吗？ 

875
00:41:37,289 --> 00:41:38,739
Skip is constant time.
跳过是固定时间。 

876
00:41:38,739 --> 00:41:40,139
Hash is constant time.
哈希是固定时间。 

877
00:41:40,139 --> 00:41:40,879
We're done.
大功告成

878
00:41:40,880 --> 00:41:41,730
This works.
这可行。 

879
00:41:41,730 --> 00:41:43,510
Any questions on rolling hashes before you
在滚动哈希之前有任何疑问

880
00:41:43,510 --> 00:41:46,804
have to implement one of your own?
必须实施自己的一种？ 

881
00:41:46,804 --> 00:41:49,750
AUDIENCE: [INAUDIBLE] wouldn't it
听众：[听不清] 

882
00:41:49,750 --> 00:41:53,186
be easier to use a shift function?
更容易使用移位功能？ 

883
00:41:53,186 --> 00:41:56,088
Then you don't have to think about plus and minus.
然后，您不必考虑加号和减号。 

884
00:41:56,088 --> 00:41:57,255
PROFESSOR: A shift function.
教授：移位功能。 

885
00:41:57,255 --> 00:42:01,769
AUDIENCE: Well I mean like, you can shift bit-wise, right?
听众：我的意思是，你可以按位转移，对吗？ 

886
00:42:01,969 --> 00:42:02,876
PROFESSOR: OK.
教授：好的。 

887
00:42:02,876 --> 00:42:04,864
AUDIENCE: So you can just use shift
听众：所以你可以使用shift 

888
00:42:04,864 --> 00:42:06,852
instead of thinking about where to add this,
而不是考虑将其添加到何处， 

889
00:42:06,853 --> 00:42:08,840
where to subtract this.
在哪里减去这个。 

890
00:42:08,840 --> 00:42:10,679
PROFESSOR: Well so I do bit operations
教授：好吧，我来做位手术

891
00:42:10,679 --> 00:42:13,027
if I'm willing to work with these big numbers.
如果我愿意处理这些大数字。 

892
00:42:13,027 --> 00:42:14,610
AUDIENCE: But then you have to compute
听众：但是那你得计算一下

893
00:42:14,610 --> 00:42:16,797
the mod of some big number, right?
一些大数的mod，对吗？ 

894
00:42:16,797 --> 00:42:18,741
Like just like that.
就像那样。 

895
00:42:18,742 --> 00:42:21,134
For this one, you don't have to, because you
对于这个，您不必这样做，因为您

896
00:42:21,333 --> 00:42:23,115
have the original hash [INAUDIBLE].
具有原始哈希值[INAUDIBLE]。 

897
00:42:23,115 --> 00:42:27,429



898
00:42:27,429 --> 00:42:28,769
AUDIENCE: Oh, you mean the big number
听众：哦，你的意思是很大

899
00:42:28,969 --> 00:42:31,969
being the actual word you're looking at?
是您正在查看的实际单词？ 

900
00:42:31,969 --> 00:42:33,079
AUDIENCE: Yeah.
听众：是的。 

901
00:42:33,079 --> 00:42:35,389
PROFESSOR: So doing shift is equivalent to maintaining
教授：所以换班等于维持

902
00:42:35,389 --> 00:42:39,869
a list and pushing and popping things into the list.
列表，然后将内容推送到列表中。 

903
00:42:39,869 --> 00:42:41,769
And then you have to do a hash, it's
然后你必须做一个哈希， 

904
00:42:41,769 --> 00:42:44,019
equivalent to looking over the entire list
相当于查看整个列表

905
00:42:44,019 --> 00:42:45,559
and computing the hash function.
并计算哈希函数。 

906
00:42:45,559 --> 00:42:47,726
Because you'd have a big number and you have to take
因为你人数很多，你必须带走

907
00:42:47,726 --> 00:42:49,000
it modulo 23.
它的模数为23 

908
00:42:49,000 --> 00:42:51,885
And that's order of the size of the big number.
这就是大数字的顺序。 

909
00:42:51,885 --> 00:42:53,259
But we're not allowed to do that.
但是我们不允许这样做。 

910
00:42:53,260 --> 00:42:56,230
Hash has to be constant time, otherwise this thing is slow.
哈希必须是固定的时间，否则这个东西很慢。 

911
00:42:56,429 --> 00:43:00,704



912
00:43:00,704 --> 00:43:03,411
AUDIENCE: Why do we compute magic numbers then?
听众：为什么我们要计算魔术数呢？ 

913
00:43:03,411 --> 00:43:04,869
PROFESSOR: Why do we compute magic?
教授：为什么我们要计算魔术？ 

914
00:43:04,869 --> 00:43:09,769
We compute magic because somewhere here, we
我们计算魔术是因为在这里

915
00:43:09,769 --> 00:43:14,199
had this base to the size mod p and this could get big.
这个基数的大小为mod p，这可能会变大。 

916
00:43:14,199 --> 00:43:16,750



917
00:43:16,750 --> 00:43:18,889
So I can't afford to keep it around and do math
所以我负担不起去做数学

918
00:43:18,889 --> 00:43:20,019
with it all the time.
一直都有。 

919
00:43:20,019 --> 00:43:21,579
So I can't compute base to the size
所以我无法计算出基本尺寸

920
00:43:21,579 --> 00:43:25,346
every time I want to do append.
每次我想附加。 

921
00:43:25,346 --> 00:43:31,114



922
00:43:31,114 --> 00:43:33,364
AUDIENCE: Would it be worth it if you're computing 100
观众：如果您计算100，那值得吗

923
00:43:33,364 --> 00:43:37,495
different values for matching and [INAUDIBLE],
匹配和[音频不清晰]的值不同， 

924
00:43:37,496 --> 00:43:41,644
so all you'd have to do is, when reassigning magic,
所以您要做的就是在重新分配魔术时， 

925
00:43:41,644 --> 00:43:42,336
just look up--
抬头- 

926
00:43:42,336 --> 00:43:43,920
PROFESSOR: So if you do that, then you
教授：所以，如果您这样做，那么您

927
00:43:43,920 --> 00:43:49,860
have to compute values for all the sizes, right?
必须计算所有尺寸的值，对不对？ 

928
00:43:49,860 --> 00:43:51,039
For all the window sizes.
对于所有窗口大小。 

929
00:43:51,039 --> 00:43:52,460
AUDIENCE: Right.
听众：对。 

930
00:43:52,460 --> 00:43:55,237
So if we assume that window sizes will be less than 100,
因此，如果我们假设窗口大小小于100， 

931
00:43:55,237 --> 00:43:56,320
it doesn't take very long.
不需要很长时间。 

932
00:43:56,320 --> 00:43:58,327
PROFESSOR: Well what if the window size is 1 million?
教授：那么如果窗口大小为100万怎么办？ 

933
00:43:58,527 --> 00:44:00,809



934
00:44:00,809 --> 00:44:02,349
What if I'm looking for a 1 million
如果我要寻找一百万

935
00:44:02,349 --> 00:44:05,217
character in a 1 gigabyte string?
 1 GB字符串中的字符？ 

936
00:44:05,217 --> 00:44:07,550
AUDIENCE: But wouldn't after all, wouldn't the size just
听众：但是毕竟不会，大小不会

937
00:44:07,550 --> 00:44:11,971
be around the string, like plus or minus the size of the base?
是围绕字符串，如正负号的大小？ 

938
00:44:11,971 --> 00:44:12,471
So--
所以 - 

939
00:44:12,471 --> 00:44:13,920
AUDIENCE: Only if [INAUDIBLE]
听众：仅当[听不清] 

940
00:44:13,920 --> 00:44:16,335
So why would the size change again?
那么，为什么尺寸会再次改变？ 

941
00:44:16,335 --> 00:44:17,894
Why wouldn't it just be-- I mean,
为什么不是-我的意思是， 

942
00:44:17,894 --> 00:44:19,824
if you're looking at one character.
如果您正在看一个字符。 

943
00:44:19,824 --> 00:44:21,949
PROFESSOR: So if I have a sliding window like this,
教授：所以，如果我有一个这样的滑动窗口， 

944
00:44:21,949 --> 00:44:22,907
then it doesn't change.
那么它不会改变。 

945
00:44:22,907 --> 00:44:24,789
But if I want to implement a rolling hash,
但是如果我想实现滚动哈希， 

946
00:44:24,789 --> 00:44:28,960
that's a bit more general and that supports append and skip.
这有点通用，并且支持追加和跳过。 

947
00:44:28,960 --> 00:44:30,856
Whenever I append, the size increases.
每当我追加时，大小都会增加。 

948
00:44:30,856 --> 00:44:32,355
Whenever I skip, the size decreases.
每当我跳过时，大小都会减小。 

949
00:44:32,355 --> 00:44:34,688
AUDIENCE: Oh, you're not doing those at every time step.
听众：哦，您不是在每个步骤中都这样做。 

950
00:44:34,688 --> 00:44:37,088
You're doing them as needed.
您正在根据需要进行操作。 

951
00:44:37,088 --> 00:44:38,630
PROFESSOR: So I'm trying to implement
教授：所以我正在尝试实施

952
00:44:38,630 --> 00:44:40,730
that, that can do them in any sequence.
那可以按任何顺序完成

953
00:44:40,730 --> 00:44:41,858
AUDIENCE: Oh.
听众：哦。 

954
00:44:41,858 --> 00:44:42,400
AUDIENCE: OK.
听众：好的。 

955
00:44:42,400 --> 00:44:45,039
I thought we were just doing sliding window.
我以为我们只是在做滑动窗。 

956
00:44:45,239 --> 00:44:47,859
PROFESSOR: So if we're just doing sliding window, you can--
教授：所以，如果我们只是做滑动窗，您可以- 

957
00:44:47,860 --> 00:44:50,355
AUDIENCE: This is really more caterpillar hash instead
观众：这实际上是更多的毛毛虫哈希

958
00:44:50,554 --> 00:44:53,123
of rolling hash, like it's more general.
滚动哈希，就像它更通用一样。 

959
00:44:53,123 --> 00:44:53,789
PROFESSOR: Yeah.
教授：是的。 

960
00:44:53,789 --> 00:44:55,070
It's a bit more general.
比较一般。 

961
00:44:55,070 --> 00:44:57,190
So let's look at rolling hash for the window.
因此，让我们来看一下窗口的滚动哈希。 

962
00:44:57,389 --> 00:45:00,269
And what you're saying is, hey, the window size
你的意思是，窗口大小

963
00:45:00,269 --> 00:45:02,150
is constant, so--
是恒定的，所以- 

964
00:45:02,150 --> 00:45:06,480
AUDIENCE: Why do we repeat magic [INAUDIBLE]?
听众：我们为什么要重复魔术[听不清]？ 

965
00:45:06,480 --> 00:45:08,650
PROFESSOR: Yeah, if the window size is constant,
教授：是的，如果窗口大小不变， 

966
00:45:08,650 --> 00:45:10,039
then we wouldn't re compute it.
那么我们就不会重新计算它。 

967
00:45:10,039 --> 00:45:10,831
It wouldn't change.
它不会改变。 

968
00:45:10,831 --> 00:45:14,039



969
00:45:14,039 --> 00:45:17,079
But with this thing, it's not.
但事实并非如此。 

970
00:45:17,079 --> 00:45:18,719
OK.
好。 

971
00:45:18,719 --> 00:45:21,501
AUDIENCE: But I guess it doesn't really matter,
听众：但是我想这并不重要， 

972
00:45:21,501 --> 00:45:27,237
but even if you call these in the same order,
但是即使您以相同的顺序调用它们， 

973
00:45:27,237 --> 00:45:30,625
then isn't that wasting a lot of computing cycles
那不是浪费很多计算周期

974
00:45:30,626 --> 00:45:36,250
because just shrinking and then growing every single operation?
因为只是缩小然后增加每个操作？ 

975
00:45:36,449 --> 00:45:39,399
PROFESSOR: Oh, well it turns out that a lot of computing cycles
教授：哦，事实证明，很多计算周期

976
00:45:39,400 --> 00:45:40,519
is still order one, right?
还是一号吧？ 

977
00:45:40,719 --> 00:45:41,719
Everything is order one.
一切都是第一。 

978
00:45:41,719 --> 00:45:45,089
So as algorithms people, we don't care.
因此，作为算法人员，我们不在乎。 

979
00:45:45,090 --> 00:45:47,380
If you're doing it in a system and you actually
如果您是在系统中进行操作，而实际上

980
00:45:47,380 --> 00:45:49,222
care about that, then OK.
关心那个，然后确定。 

981
00:45:49,222 --> 00:45:50,730
But you're still going to have to compute
但是您仍然需要计算

982
00:45:50,929 --> 00:45:53,135
the initial value at some point.
某个时候的初始值。 

983
00:45:53,135 --> 00:45:55,302
AUDIENCE: But if you know window's staying the same,
听众：但是，如果您知道窗户保持不变， 

984
00:45:55,302 --> 00:45:58,320
you don't need to that computation every time?
您不需要每次都进行该计算吗？ 

985
00:45:58,320 --> 00:45:59,485
PROFESSOR: If you-- sorry?
教授：对不起？ 

986
00:45:59,485 --> 00:46:00,826
AUDIENCE: If you know you're actually
听众：如果您知道自己实际上是

987
00:46:01,025 --> 00:46:02,730
just doing a window rolling hash--
只是做一个窗口滚动哈希- 

988
00:46:02,730 --> 00:46:03,355
PROFESSOR: Yup.
教授：是的。 

989
00:46:03,355 --> 00:46:05,400
So then you would initialize magic here
因此，您将在此处初始化魔术

990
00:46:05,400 --> 00:46:09,690
to be whatever you want it to be, right?
成为你想要的东西吧？ 

991
00:46:09,690 --> 00:46:12,780
But then when you add the first few characters to the window,
但是，当您将前几个字符添加到窗口时， 

992
00:46:12,780 --> 00:46:16,630
you have to figure out how to add them.
您必须弄清楚如何添加它们。 

993
00:46:16,630 --> 00:46:17,840
So the code gets more messy.
因此，代码变得更加混乱。 

994
00:46:17,840 --> 00:46:19,750
It turns out that this is actually
原来，这实际上是

995
00:46:19,750 --> 00:46:24,070
simpler than doing it that way.
比那样做更简单。 

996
00:46:24,070 --> 00:46:26,882
AUDIENCE: [INAUDIBLE] magic I guess
听众：我猜是[听不清]魔术

997
00:46:27,081 --> 00:46:29,539
I'm just confused because it seems like we're still working
我很困惑，因为好像我们还在工作

998
00:46:29,539 --> 00:46:32,686
with the large numbers every time [INAUDIBLE].
每次[听不清]时都有大量数字。 

999
00:46:32,686 --> 00:46:33,269
PROFESSOR: Oh.
教授：哦。 

1000
00:46:33,269 --> 00:46:35,019
Let's see.
让我们来看看。 

1001
00:46:35,019 --> 00:46:37,547
Mod p, mod p.
 Mod p，mod p。 

1002
00:46:37,547 --> 00:46:40,130
AUDIENCE: That's not-- so even though you're still multiplying
听众：并非如此-即使您仍在繁殖

1003
00:46:40,130 --> 00:46:43,960
magic times base, it doesn't matter.
魔术时代的基础，没关系。 

1004
00:46:43,960 --> 00:46:46,960
PROFESSOR: After I'm going that, I'm reducing it modulo p.
教授：之后，我将其以p为模降低。 

1005
00:46:46,960 --> 00:46:47,619
Yeah.
是的

1006
00:46:47,619 --> 00:46:48,960
AUDIENCE: And then because we're only
听众：然后因为我们只是

1007
00:46:49,159 --> 00:46:51,079
working with the smaller values.
使用较小的值。 

1008
00:46:51,079 --> 00:46:51,759
PROFESSOR: Yup.
教授：是的。 

1009
00:46:51,760 --> 00:46:56,760
So everything here stays between 0 and base or 0 and p.
因此，这里的所有内容都保持在0到base或0到p之间。 

1010
00:46:56,760 --> 00:47:02,313
Actually hash is between 0 and p and magic is between 0 and p.
实际上，哈希值介于0和p之间，而魔术值介于0和p之间。 

1011
00:47:02,512 --> 00:47:03,011
OK.
好。 

1012
00:47:03,012 --> 00:47:05,826
AUDIENCE: How big does p usually get?
听众：p通常能变多大？ 

1013
00:47:06,025 --> 00:47:08,449
PROFESSOR: How big does p usually get.
教授：p通常会变大。 

1014
00:47:08,449 --> 00:47:11,444
So And let me get back to this.
所以，让我回到这一点。 

1015
00:47:11,445 --> 00:47:14,250



1016
00:47:14,449 --> 00:47:16,859
So I was arguing that the number of false positives
所以我在争论误报的数量

1017
00:47:16,860 --> 00:47:18,809
here is one over O, right?
这是O之上的一个，对吧？ 

1018
00:47:18,809 --> 00:47:23,389



1019
00:47:23,389 --> 00:47:26,489
is the number of values that the hash function can output.
是哈希函数可以输出的值的数量。 

1020
00:47:26,489 --> 00:47:29,359
How many hash functions can we output using a rolling hash?
我们可以使用滚动散列输出多少个散列函数？ 

1021
00:47:29,360 --> 00:47:32,057



1022
00:47:32,257 --> 00:47:33,223
AUDIENCE: P.
听众：P. 

1023
00:47:33,224 --> 00:47:33,769
PROFESSOR: P. OK.
教授：好的。 

1024
00:47:33,969 --> 00:47:37,099
So the number of false positives is
所以误报的数量是

1025
00:47:37,099 --> 00:47:39,231
1/P. So what do we want for p?
 1 / P。那么我们想要p呢？ 

1026
00:47:39,231 --> 00:47:41,690
AUDIENCE: We want p to be the word size, because but if p's
观众：我们希望p为字长，因为如果p为

1027
00:47:41,690 --> 00:47:43,726
the word size, then--
字号，然后- 

1028
00:47:43,726 --> 00:47:45,349
PROFESSOR: So p can't be the word size,
教授：所以p不能是字长， 

1029
00:47:45,349 --> 00:47:46,929
because it has to be prime, right?
因为它必须是素数，对吗？ 

1030
00:47:46,929 --> 00:47:49,699
But we want it to be big, because as p becomes bigger,
但是我们希望它更大，因为随着p变大， 

1031
00:47:49,699 --> 00:47:51,799
1/P becomes smaller.
 1 / P变小。 

1032
00:47:51,800 --> 00:47:55,840
So there are two constraints.
因此有两个约束。 

1033
00:47:55,840 --> 00:47:57,440
We want p to be big so that we don't
我们希望p很大，这样我们就不会

1034
00:47:57,440 --> 00:47:59,130
have a lot of false positives.
有很多误报。 

1035
00:47:59,130 --> 00:48:03,230
And we want p to be small so that operations
而且我们希望p较小，以便运算

1036
00:48:03,230 --> 00:48:05,070
don't take a lot of time.
不需要很多时间。 

1037
00:48:05,070 --> 00:48:07,460
So in engineering, this is how things work.
因此，在工程中，这就是工作原理。 

1038
00:48:07,659 --> 00:48:09,409
We call it a tradeoff because there
我们称其为权衡，因为那里

1039
00:48:09,409 --> 00:48:11,639
are forces pushing in opposite directions,
是朝相反方向推动的力量， 

1040
00:48:11,639 --> 00:48:14,170
and it turns out that a reasonable answer to the trade
事实证明，对交易的合理回答

1041
00:48:14,170 --> 00:48:18,119
off is you make p fit in a word so that all those operations
你是说p使p合适，以便所有这些操作

1042
00:48:18,119 --> 00:48:22,581
are still implementable by one CPU instruction.
仍然可以由一条CPU指令实现。 

1043
00:48:22,581 --> 00:48:24,039
You can't have it be the word size.
您不能拥有字号。 

1044
00:48:24,039 --> 00:48:26,239
So if we're working on a 32-bit computer,
因此，如果我们在32位计算机上工作， 

1045
00:48:26,239 --> 00:48:29,389
I can't have this be 2 to the 32.
我不能让这个数字等于32。 

1046
00:48:29,389 --> 00:48:33,329
But I can have a prime number that's just a little bit
但是我可以有一个质数

1047
00:48:33,329 --> 00:48:34,639
smaller than 2 to the 32.
小于2到32。 

1048
00:48:34,639 --> 00:48:38,887
AUDIENCE: Wait, why can't it be the word size?
听众：等等，为什么不能是字号？ 

1049
00:48:38,887 --> 00:48:41,250
Or why can't it be 2 to the 32?
或者为什么它不能是32的2？ 

1050
00:48:41,250 --> 00:48:43,610
PROFESSOR: So if p would be this instead of a prime,
教授：所以如果p是这个而不是质数， 

1051
00:48:43,610 --> 00:48:45,047
then I can't do this.
那我就做不到

1052
00:48:45,047 --> 00:48:47,130
AUDIENCE: Oh, right right right, yeah I knew that.
听众：哦，对，对，对，我知道。 

1053
00:48:47,130 --> 00:48:48,329
PROFESSOR: There are a lot of moving parts here
教授：这里有很多活动部件

1054
00:48:48,329 --> 00:48:49,777
and they're all interconnected.
他们都是相互联系的。 

1055
00:48:49,777 --> 00:48:52,110
AUDIENCE: You could do that for any prime number, right?
听众：你可以用任何素数来做，对吗？ 

1056
00:48:52,110 --> 00:48:52,644
PROFESSOR: Yup.
教授：是的。 

1057
00:48:52,844 --> 00:48:54,469
So this works for prime numbers, but it
所以这适用于素数，但是

1058
00:48:54,469 --> 00:48:57,185
doesn't work for non prime numbers.
对非素数不起作用。 

1059
00:48:57,186 --> 00:48:59,309
AUDIENCE: You could find the multiplicative inverse
听众：您可以找到乘法逆

1060
00:48:59,309 --> 00:49:03,713
for any prime number in base 32.
以32为底的任何质数

1061
00:49:03,713 --> 00:49:04,545
Is that true?
真的吗？ 

1062
00:49:04,545 --> 00:49:06,885
I mean any odd number is what I'm trying to say.
我的意思是我要说的是奇数。 

1063
00:49:06,885 --> 00:49:08,106
No, that's not true.
不，那不是真的。 

1064
00:49:08,106 --> 00:49:10,190
PROFESSOR: I refuse to answer hard math questions.
教授：我拒绝回答数学难题。 

1065
00:49:10,190 --> 00:49:11,981
AUDIENCE: They need to be relatively prime.
听众：他们需要相对重要。 

1066
00:49:11,981 --> 00:49:13,610
They need to share no factors.
他们无需分享任何因素。 

1067
00:49:13,809 --> 00:49:15,840
PROFESSOR: Yes, it might be true.
教授：是的，可能是事实。 

1068
00:49:15,840 --> 00:49:19,144
AUDIENCE: So an odd will not share a factor with 2
观众：所以奇数不会与2共享一个因数

1069
00:49:19,344 --> 00:49:21,039
to the 32?
到32？ 

1070
00:49:21,039 --> 00:49:23,164
PROFESSOR: You're forcing me to remember hard math.
教授：您在逼我记住硬数学。 

1071
00:49:23,164 --> 00:49:25,206
AUDIENCE: Yeah, I totally just thought about this
听众：是的，我完全想到了

1072
00:49:25,206 --> 00:49:26,880
as [INAUDIBLE] number.
作为[音频不清晰]号。 

1073
00:49:26,880 --> 00:49:29,690
PROFESSOR: So, no, it turns out that there's
教授：所以，不，事实证明

1074
00:49:29,889 --> 00:49:33,619
no-- if you're working modulo and non prime base, then
否-如果您使用的是模数和非素数基数，则

1075
00:49:33,619 --> 00:49:35,619
there's no multiplicity inverses.
没有多重逆。 

1076
00:49:35,619 --> 00:49:38,389
So some numbers have no multiplicative inverses,
所以有些数字没有乘法逆， 

1077
00:49:38,389 --> 00:49:42,730
and other numbers have more than one multiplicative inverse.
其他数字有一个以上的乘法逆。 

1078
00:49:42,730 --> 00:49:44,869
And then the whole thing doesn't work.
然后整个事情就不起作用了。 

1079
00:49:44,869 --> 00:49:47,969
So let me see if I can make this work
所以让我看看我是否可以做这项工作

1080
00:49:47,969 --> 00:49:50,019
without having an example by hand.
没有手举一个例子。 

1081
00:49:50,019 --> 00:49:53,289
Let's say we're working mod 8, right?
假设我们正在使用mod 8，对吗？ 

1082
00:49:53,289 --> 00:49:53,789
Mod 8.
 Mod 8。 

1083
00:49:53,789 --> 00:49:58,389
So 2 to the minus 1 mod 8 is not going to exist, right?
所以2减1 mod 8将不存在，对吗？ 

1084
00:49:58,389 --> 00:49:59,650
AUDIENCE: Right, but 3 will.
听众：是的，但3个会。 

1085
00:49:59,650 --> 00:49:59,990
PROFESSOR: 3.
教授：3。 

1086
00:50:00,190 --> 00:50:02,429
Let's see what do we use?
让我们看看我们用什么？ 

1087
00:50:02,429 --> 00:50:04,669
3 times 3 is 9, right?
 3乘3等于9，对不对？ 

1088
00:50:04,670 --> 00:50:06,579
So this is 1.
所以这是1。 

1089
00:50:06,579 --> 00:50:08,179
How about 3 times 5?
 3乘5怎么样？ 

1090
00:50:08,179 --> 00:50:13,039



1091
00:50:13,039 --> 00:50:16,539
15 mod 8 is 7.
 15 mod 8是7。 

1092
00:50:16,539 --> 00:50:19,050
So 3 and 5, and then--
所以3和5，然后- 

1093
00:50:19,050 --> 00:50:19,592
AUDIENCE: 11.
听众：11。 

1094
00:50:19,592 --> 00:50:24,206



1095
00:50:24,206 --> 00:50:24,789
PROFESSOR: OK.
教授：好的。 

1096
00:50:24,789 --> 00:50:27,779



1097
00:50:27,780 --> 00:50:30,250
So 3 times 7 would be 21, 5.
所以7的3乘以21，5。 

1098
00:50:30,250 --> 00:50:34,030



1099
00:50:34,030 --> 00:50:40,190
OK so 3 and-- 3 is the multiplicative inverse
好吧3和-3是乘法逆

1100
00:50:40,389 --> 00:50:43,280
of itself, and 5 and 7 are-- yeah.
本身，而5和7是-是的。 

1101
00:50:43,280 --> 00:50:45,690
I have to build a more complicated example,
我必须建立一个更复杂的例子

1102
00:50:45,690 --> 00:50:48,887
but this breaks down in some cases.
但这在某些情况下会失败。 

1103
00:50:48,887 --> 00:50:52,099



1104
00:50:52,099 --> 00:50:53,690
I'll have to get back to you.
我得回覆你。 

1105
00:50:53,690 --> 00:50:56,074
I will look at my notes for modular arithmetic
我将看一下有关模块化算术的笔记

1106
00:50:56,074 --> 00:50:57,539
and I'll get back to you guys over email
我会通过电子邮件回复你们

1107
00:50:57,739 --> 00:50:59,559
for why and how that breaks.
为什么会这样以及如何打破。 

1108
00:50:59,559 --> 00:51:00,224
Yes.
是。 

1109
00:51:00,224 --> 00:51:01,807
AUDIENCE: Sorry, can you tell me again
听众：对不起，你能再告诉我吗

1110
00:51:01,807 --> 00:51:03,239
why we did the part 2 in skip?
为什么我们跳过了第2部分？ 

1111
00:51:03,239 --> 00:51:06,577
Like why did we do that?
就像我们为什么要这样做？ 

1112
00:51:06,577 --> 00:51:10,289
I'm not really sure [INAUDIBLE].
我不确定[音频不清晰]。 

1113
00:51:10,289 --> 00:51:13,119
PROFESSOR: So we started with magic 1
教授：所以我们从魔术1开始

1114
00:51:13,119 --> 00:51:16,839
and then we-- in order for this to work,
然后我们-为了使它起作用， 

1115
00:51:16,840 --> 00:51:20,278
we agree that magic will be base to the size modulo p
我们同意魔术将成为模数p的基础

1116
00:51:20,278 --> 00:51:20,820
all the time.
每时每刻。 

1117
00:51:20,820 --> 00:51:23,900
So this has to be [INAUDIBLE] invariant for my rolling hash.
因此，对于我的滚动哈希，这必须是[音频不可变]。 

1118
00:51:23,900 --> 00:51:27,769
When I do an append, the size increases by 1.
当我执行追加操作时，大小增加1。 

1119
00:51:27,769 --> 00:51:31,009
And then I multiply by base to modulo p.
然后我乘以基数以求模p。 

1120
00:51:31,010 --> 00:51:35,610
When I do a skip, the size decreases by 1.
当我跳过时，大小减小1。 

1121
00:51:35,610 --> 00:51:39,360
So I have to change magic, because magic is always
所以我必须改变魔术，因为魔术总是

1122
00:51:39,360 --> 00:51:43,099
base times size, so I have to update it.
基本时间大小，因此我必须对其进行更新。 

1123
00:51:43,099 --> 00:51:44,739
So this is why this happened.
这就是为什么发生这种情况。 

1124
00:51:44,739 --> 00:51:47,199
Because initially, I wanted to update
因为最初我想更新

1125
00:51:47,199 --> 00:51:49,579
by dividing it by base, right?
将其除以基数，对吗？ 

1126
00:51:49,579 --> 00:51:51,750
Magic divided by base.
魔术除以基础。 

1127
00:51:51,750 --> 00:51:54,079
But if magic is 5 and base is 100,
但是如果魔术是5，底数是100， 

1128
00:51:54,079 --> 00:51:56,449
we're not going to get an integer.
我们不会得到一个整数。 

1129
00:51:56,449 --> 00:51:58,629
And we want to stay within integers,
我们希望保持在整数范围内， 

1130
00:51:58,630 --> 00:52:02,539
so that's when I pulled out fancy math and-- OK.
所以那时候我拿出了花哨的数学，而且-好。 

1131
00:52:02,739 --> 00:52:05,559



1132
00:52:05,559 --> 00:52:06,670
OK.
好。 

1133
00:52:06,670 --> 00:52:08,800
So how are we doing with rolling hashes?
那么，如何处理哈希值呢？ 

1134
00:52:08,800 --> 00:52:10,764
Good?
好？ 

1135
00:52:10,764 --> 00:52:12,730
AUDIENCE: All this math will be in the notes, right?
听众：所有这些数学都在笔记中，对吗？ 

1136
00:52:12,929 --> 00:52:13,846
PROFESSOR: Everything.
教授：一切。 

1137
00:52:13,846 --> 00:52:16,920
Oh, yeah, everything else will be in the notes.
哦，是的，其他所有内容都将在笔记中。 

1138
00:52:16,920 --> 00:52:22,880
Before we close out, I want to show you one cute thing.
在结束之前，我想向您展示一件可爱的东西。 

1139
00:52:22,880 --> 00:52:24,463
Who remembers amortized analysis?
谁还记得摊销分析？ 

1140
00:52:24,463 --> 00:52:26,630
I know there's one person that said they understood.
我知道有人说他们了解。 

1141
00:52:26,630 --> 00:52:30,289



1142
00:52:30,489 --> 00:52:31,924
All
所有

1143
00:52:31,925 --> 00:52:33,550
PROFESSOR: The growing, shrinking thing
教授：不断缩小的东西

1144
00:52:33,550 --> 00:52:34,432
is what we did in lecture.
这是我们在讲座中所做的。 

1145
00:52:34,632 --> 00:52:36,289
I want to show something else.
我想展示些别的东西。 

1146
00:52:36,289 --> 00:52:37,954
I want to show you a binary tree.
我想给你看一棵二叉树。 

1147
00:52:37,954 --> 00:52:40,170
A binary search tree, because you've seen this on the PSAT
二进制搜索树，因为您已经在PSAT上看到了

1148
00:52:40,369 --> 00:52:43,299
and you already hate it.
你已经讨厌它了

1149
00:52:43,300 --> 00:52:44,980
AUDIENCE: Why'd they call it amortization?
听众：他们为什么称其为摊销？ 

1150
00:52:45,179 --> 00:52:47,639
Because I looked it up online, it means to kill,
因为我在网上查了一下，所以意味着要杀人， 

1151
00:52:47,639 --> 00:52:51,759
and so I'm like, why not say like, attrition or something
所以我想，为什么不说减员之类的

1152
00:52:51,760 --> 00:52:53,070
else that's a little bit less--
否则要少一些

1153
00:52:53,269 --> 00:52:58,409
PROFESSOR: Amortization is also used in accounting to mean
教授：摊销在会计中也用来表示

1154
00:52:58,409 --> 00:52:59,259
you're--
你是 - 

1155
00:52:59,260 --> 00:52:59,893
[INTERPOSING VOICES]
 [插入语音] 

1156
00:53:00,092 --> 00:53:05,594



1157
00:53:05,594 --> 00:53:07,510
PROFESSOR: Let's use the growing hash example,
教授：让我们使用不断增长的哈希示例， 

1158
00:53:07,510 --> 00:53:10,300
because that's good for why this is the case.
因为那对为什么会这样是有好处的。 

1159
00:53:10,300 --> 00:53:13,269
So when you're growing your table, you're inserting.
因此，当您扩大桌子时，就在插入。 

1160
00:53:13,469 --> 00:53:15,230
If you still have space, that's order one.
如果您还有空间，那是第一个。 

1161
00:53:15,230 --> 00:53:18,539
If not, you have to grow your table to insert.
如果不是，则必须扩大表才能插入。 

1162
00:53:18,539 --> 00:53:20,710
And that is more expensive.
而且那更昂贵。 

1163
00:53:20,710 --> 00:53:24,019
That's order n where n is how many elements you had before.
那是n阶，其中n是您之前有多少个元素。 

1164
00:53:24,219 --> 00:53:27,699
So if you graph this costs, if you start off
因此，如果您以图形方式表示此成本， 

1165
00:53:27,699 --> 00:53:30,559
with a table of size one, you can insert the first element
表格大小为1时，您可以插入第一个元素

1166
00:53:30,559 --> 00:53:32,481
for a cost of one.
只需一个。 

1167
00:53:32,481 --> 00:53:34,690
For the second element, you have to resize the table,
对于第二个元素，您必须调整表的大小， 

1168
00:53:34,690 --> 00:53:35,519
so it's a cost of two.
所以要花两个钱

1169
00:53:35,719 --> 00:53:38,494



1170
00:53:38,494 --> 00:53:40,619
Now when you're trying to insert the third element,
现在，当您尝试插入第三个元素时， 

1171
00:53:40,619 --> 00:53:43,599
you have to resize the table again to a size of 4.
您必须再次将表格的大小调整为4。 

1172
00:53:43,599 --> 00:53:46,460
But when you insert the fourth element, it's free.
但是，当您插入第四个元素时，它是免费的。 

1173
00:53:46,460 --> 00:53:48,400
Well, cost of one.
好吧，一本钱。 

1174
00:53:48,400 --> 00:53:50,690
When you insert the fifth element,
当您插入第五个元素时， 

1175
00:53:50,690 --> 00:53:53,289
you have to resize a table to the size of eight, right?
您必须将一张桌子的大小调整为八个，对不对？ 

1176
00:53:53,489 --> 00:53:57,539
So The table size is one, two, four, four, and now it's eight.
所以表的大小是1、2、4、4，现在是8。 

1177
00:53:57,539 --> 00:53:59,559
But because they resized this to eight,
但是由于他们将尺寸调整为八个， 

1178
00:53:59,559 --> 00:54:02,730
the next three assertions are going to be order one.
接下来的三个断言将成为第一。 

1179
00:54:02,730 --> 00:54:07,349
And then the one after that is going to make the table be 16.
然后，后面的一个将使该表为16。 

1180
00:54:07,349 --> 00:54:11,764
So I can do seven insertions for free
所以我可以免费做七个插入

1181
00:54:11,764 --> 00:54:13,139
and then I'm going to have to pay
然后我要付钱

1182
00:54:13,139 --> 00:54:17,449
a lot more for the next one.
下一个要多得多。 

1183
00:54:17,449 --> 00:54:18,519
Someone said dampening.
有人说阻尼。 

1184
00:54:18,519 --> 00:54:21,170
I like dampening because the idea behind amortization
我喜欢减价，因为摊销背后的想法

1185
00:54:21,170 --> 00:54:25,159
is that you can take-- you have these big costs
是你可以承担的-你有这么大的代价

1186
00:54:25,159 --> 00:54:27,029
and they don't occur very often.
而且它们不经常发生。 

1187
00:54:27,030 --> 00:54:30,190
So you can think of it as taking these big costs
因此，您可以将其视为承担这些巨大的成本

1188
00:54:30,190 --> 00:54:31,690
and chopping them up.
切碎

1189
00:54:31,690 --> 00:54:35,170
For example, I'm going to chop this up into four
例如，我将把它分成四个部分

1190
00:54:35,170 --> 00:54:38,010
and I'm going to take this piece and put it here.
我要把这块放到这里。 

1191
00:54:38,010 --> 00:54:39,940
This piece and put it here.
这一块，放在这里。 

1192
00:54:39,940 --> 00:54:42,000
This piece and put it here.
这一块，放在这里。 

1193
00:54:42,000 --> 00:54:43,932
And then I'm going to chop this guy into two,
然后我要把这个人切成两半， 

1194
00:54:43,932 --> 00:54:46,925
and then take this piece and put it here.
然后把这块放到这里

1195
00:54:46,925 --> 00:54:48,550
And the beginning's a little bit weird,
开始有点奇怪

1196
00:54:48,550 --> 00:54:51,130
let's not worry about that but this guy,
让我们不用担心，但是这个人， 

1197
00:54:51,130 --> 00:54:55,349
if I chop this guy up into eight, it's going to happen,
如果我把这个人切成八块，那将会发生， 

1198
00:54:55,349 --> 00:54:57,599
is it?
是吗？ 

1199
00:54:57,599 --> 00:55:04,179
Well we can put-- so this guy grows exponentially, right?
好吧，我们可以这样说-这个家伙成倍增长，对吧？ 

1200
00:55:04,179 --> 00:55:06,069
Every time it's multiplied by 2.
每次乘以2。 

1201
00:55:06,070 --> 00:55:09,480
But the gap size here also is multiplied by 2.
但是这里的间隙大小也要乘以2。 

1202
00:55:09,679 --> 00:55:13,230
So when I chop this up and I re distribute the pieces,
因此，当我将其切碎并重新分配时， 

1203
00:55:13,230 --> 00:55:17,039
it turns out that the pieces are the same size.
事实证明，碎片是相同的大小。 

1204
00:55:17,039 --> 00:55:21,253
So if I apply a dampening function that does this,
因此，如果我应用阻尼功能来做到这一点， 

1205
00:55:21,253 --> 00:55:23,170
then the costs are going to look-- they're not
那么成本会看起来-他们不是

1206
00:55:23,170 --> 00:55:24,280
going to be on one, they there are
将会合而为一，他们在那里

1207
00:55:24,280 --> 00:55:25,371
going to be three or something.
将会是三岁左右。 

1208
00:55:25,570 --> 00:55:28,690



1209
00:55:28,690 --> 00:55:30,896
And they look like this.
他们看起来像这样。 

1210
00:55:30,896 --> 00:55:33,019
Now, my CPU time is going to look like this, right?
现在，我的CPU时间看起来像这样，对吧？ 

1211
00:55:33,019 --> 00:55:34,769
That's not going to change, because that's
那不会改变，因为那是

1212
00:55:34,769 --> 00:55:36,369
what's really happening.
到底发生了什么

1213
00:55:36,369 --> 00:55:38,380
But what I can argue for is that if I
但是我可以主张的是，如果我

1214
00:55:38,380 --> 00:55:44,059
look for a bunch of operations, say if I look at the first 16
寻找一堆操作，如果我看一下前16个

1215
00:55:44,059 --> 00:55:50,829
insertions, the cost of those is the sum of these guys.
插入，这些的成本是这些家伙的总和。 

1216
00:55:50,829 --> 00:55:52,769
So it's not been squared, which is
所以它不是平方的，这是

1217
00:55:52,769 --> 00:55:55,519
what you would get if you look at the worst cases here,
如果看这里最坏的情况，你会得到什么， 

1218
00:55:55,519 --> 00:55:56,900
but it's order n.
但这是命令n 

1219
00:55:56,900 --> 00:55:58,389
So this is what's being dampened,
所以这就是被抑制的东西， 

1220
00:55:58,389 --> 00:56:00,692
the amount of time an operation takes.
一项操作花费的时间。 

1221
00:56:00,692 --> 00:56:04,856



1222
00:56:04,856 --> 00:56:05,940
Does this make some sense?
这有意义吗？ 

1223
00:56:05,940 --> 00:56:09,429



1224
00:56:09,429 --> 00:56:12,869
All right, I want to show you a cute example for amortization.
好吧，我想向您展示一个可爱的摊销示例。 

1225
00:56:12,869 --> 00:56:14,559
And I'll try to make it quick.
而且我会尽力使其快速。 

1226
00:56:14,559 --> 00:56:18,307
So how do you list the keys in a binary search tree in order?
那么，如何在二进制搜索树中按顺序列出关键字？ 

1227
00:56:18,307 --> 00:56:20,940
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

1228
00:56:20,940 --> 00:56:23,000
PROFESSOR: In order traversal, right?
教授：为了遍历，对不对？ 

1229
00:56:23,199 --> 00:56:25,169
OK, there's another way of doing it
好，还有另一种方法

1230
00:56:25,170 --> 00:56:27,630
that makes perfect intuitive sense.
这具有完美的直观意义。 

1231
00:56:27,630 --> 00:56:30,769
Get the minimum key, right?
得到最小的钥匙吧？ 

1232
00:56:30,969 --> 00:56:35,980
And then output the minimum key, then
然后输出最小键，然后

1233
00:56:35,980 --> 00:56:39,282
while you can get the next largest, which
而您可以获得下一个最大的

1234
00:56:39,282 --> 00:56:44,460
is the successor-- so while this is not,
是继任者-所以虽然不是， 

1235
00:56:44,659 --> 00:56:48,378
now output that key, right?
现在输出该密钥，对吗？ 

1236
00:56:48,378 --> 00:56:50,170
If you do the thing within order traversal,
如果您在订单遍历范围内进行操作， 

1237
00:56:50,170 --> 00:56:51,579
you get order end running time.
您将获得订单结束运行时间。 

1238
00:56:51,579 --> 00:56:54,351
What's the running time for this?
这是什么时间？ 

1239
00:56:54,351 --> 00:56:55,018
AUDIENCE: For n.
听众：对于n。 

1240
00:56:55,018 --> 00:56:58,005



1241
00:56:58,005 --> 00:57:00,451
You're going through all the keys, too.
您也正在浏览所有键。 

1242
00:57:00,452 --> 00:57:01,710
PROFESSOR: Yeah, but next largest--
教授：是的，但是第二大

1243
00:57:01,909 --> 00:57:04,500
what's the running time for next largest?
下一个最大的运行时间是多少？ 

1244
00:57:04,500 --> 00:57:06,000
AUDIENCE: Log n.
听众：登录n。 

1245
00:57:06,000 --> 00:57:07,659
PROFESSOR: So this guy's log in, right?
教授：那么这个人的登录对吗？ 

1246
00:57:07,659 --> 00:57:10,239



1247
00:57:10,239 --> 00:57:17,639
So I have n keys, so this whole thing is O of n logn.
所以我有n个键，所以整个事情是n logn的O。 

1248
00:57:17,639 --> 00:57:21,139
So it's definitely not bigger than n logn.
因此，它绝对不大于n logn。 

1249
00:57:21,139 --> 00:57:24,629
But now, let's look at what happens using the tree.
但是现在，让我们看看使用树会发生什么。 

1250
00:57:24,630 --> 00:57:29,190
When I call min, I go down on each edge.
当我打电话给min时，我在每条边上走下去。 

1251
00:57:29,190 --> 00:57:32,599
And then I call successor and it outputs this guy.
然后我称呼后继者，它输出了这个家伙。 

1252
00:57:32,599 --> 00:57:35,460
Then I call successor and it goes here.
然后我称呼后继者，它就在这里。 

1253
00:57:35,460 --> 00:57:38,190
Than I call successor and it goes up here and here
比我称呼继任者更是如此

1254
00:57:38,190 --> 00:57:39,369
and outputs this guy.
并输出这个家伙。 

1255
00:57:39,369 --> 00:57:41,230
Successor goes here.
继任者去这里。 

1256
00:57:41,230 --> 00:57:44,849
Successor goes here.
继任者去这里。 

1257
00:57:44,849 --> 00:57:51,009
Successor goes all the way down here, successor goes up here,
继任者一直走到这里，继任者往上走， 

1258
00:57:51,010 --> 00:57:54,280
successor goes here, and then successor
继任者去这里，然后继任者

1259
00:57:54,280 --> 00:57:59,045
goes all the way up to the roots and gives up.
一直扎根，放弃。 

1260
00:57:59,045 --> 00:57:59,920
AUDIENCE: [INAUDIBLE]
观众：[听不清] 

1261
00:57:59,920 --> 00:58:03,480



1262
00:58:03,679 --> 00:58:07,719
PROFESSOR: So how many times do I traverse each edge?
教授：那么我要遍历每个边缘多少次？ 

1263
00:58:07,719 --> 00:58:08,739
Exactly twice, right?
正好两次，对不对？ 

1264
00:58:08,739 --> 00:58:11,519
How many edges in the tree?
树上有多少条边？ 

1265
00:58:11,519 --> 00:58:15,659
If I have n nodes, how many lines do I use to connect them?
如果我有n个节点，我要用几条线连接它们？ 

1266
00:58:15,659 --> 00:58:17,210
[INAUDIBLE]
 [听不清] 

1267
00:58:17,210 --> 00:58:20,019
So 1 node, zero lines.
所以1个节点，零行。 

1268
00:58:20,019 --> 00:58:21,369
2 nodes, one line.
 2个节点，一行。 

1269
00:58:21,369 --> 00:58:22,859
Three nodes, two lines.
三个节点，两行。 

1270
00:58:22,860 --> 00:58:25,963
So n nodes, n minus one.
所以n个节点，n减1。 

1271
00:58:25,963 --> 00:58:27,394
N asymptotically, good.
渐近地，N好。 

1272
00:58:27,394 --> 00:58:28,440
Good answer.
好答案。 

1273
00:58:28,440 --> 00:58:30,250
Order, n, edges.
顺序n个边。 

1274
00:58:30,250 --> 00:58:33,840
Right, each edge gets traversed exactly twice.
正确，每个边缘正好遍历两次。 

1275
00:58:33,840 --> 00:58:41,760
So amortized cost for n next largest operations is order n.
因此，n个下一个最大操作的摊销成本为订单n。 

1276
00:58:41,760 --> 00:58:44,230
So you can do this instead.
因此，您可以改为执行此操作。 

1277
00:58:44,230 --> 00:58:48,440
This code makes a lot more sense than in order traversal.
该代码比遍历顺序更有意义。 

1278
00:58:48,440 --> 00:58:51,876
OK, and the last part is remember that list
好，最后一部分就是那个清单

1279
00:58:51,876 --> 00:58:53,000
query that was on the PSAT?
在PSAT上查询？ 

1280
00:58:53,000 --> 00:58:58,139



1281
00:58:58,139 --> 00:59:01,839
Turns out you can do a find for the lowest element
原来你可以找到最低的元素

1282
00:59:01,840 --> 00:59:03,960
and then call successor until you see the highest
然后呼叫后继，直到看到最高的

1283
00:59:04,159 --> 00:59:11,069
element for the same argument.
相同参数的元素。 

1284
00:59:11,070 --> 00:59:12,900
Well, I couldn't tell you this for the PSAT
好吧，我无法告诉您有关PSAT的信息

1285
00:59:13,099 --> 00:59:14,974
because we hadn't learned amortized analysis,
因为我们还没有学会摊销分析， 

1286
00:59:14,974 --> 00:59:18,429
so you wouldn't be able to prove that your code is fast.
因此您将无法证明自己的代码是快速的。 

1287
00:59:18,429 --> 00:59:19,949
But now if you get the intuition,
但是现在如果你有了直觉， 

1288
00:59:19,949 --> 00:59:21,909
you can write it that way.
你可以这样写。 

1289
00:59:21,909 --> 00:59:23,649
And your code will still be fast.
而且您的代码仍然会很快。 

1290
00:59:23,650 --> 00:59:25,090
Same running time.
相同的运行时间。 

1291
00:59:25,090 --> 00:59:27,769



1292
00:59:27,969 --> 00:59:30,619
So the intuition for that is a bit more complicated.
所以直觉有点复杂。 

1293
00:59:30,619 --> 00:59:31,960
The proof is more complicated.
证明更为复杂。 

1294
00:59:31,960 --> 00:59:36,280
But the intuition is that say this is l and this is h.
但是直觉是说这是l，这是h。 

1295
00:59:36,280 --> 00:59:39,519
Then I'm going to go in this tree here.
然后我要去这棵树。 

1296
00:59:39,719 --> 00:59:42,459
So the same edge magic is going to happen,
所以同样的边缘魔法将会发生， 

1297
00:59:42,460 --> 00:59:46,059
except there will be logn edges that are unmatched here
除非这里有不匹配的登录边缘

1298
00:59:46,059 --> 00:59:48,789
and logn edges that aren't unmatched here.
和此处未匹配的登录边缘。 

1299
00:59:48,789 --> 00:59:50,980
Because once I find the node that's next to h,
因为一旦找到h旁边的节点， 

1300
00:59:50,980 --> 00:59:51,969
I'll stop, right?
我会停下来吧？ 

1301
00:59:51,969 --> 00:59:55,139
So some edges will not be matched.
因此某些边缘将不匹配。 

1302
00:59:55,139 --> 00:59:59,429
So then I'll say that the total running time is logn plus a.
因此，我将说总运行时间为logn加a。 

1303
00:59:59,429 --> 01:00:01,668



1304
01:00:01,668 --> 01:00:04,210
AUDIENCE: i being the number of elements you pull out, right?
听众：我是你要抽出的元素数量，对吗？ 

1305
01:00:04,210 --> 01:00:06,409
PROFESSOR: Yup.
教授：是的。 

1306
01:00:06,409 --> 01:00:07,659
So this is amortized analysis.
因此，这是摊销分析。 

1307
01:00:07,659 --> 01:00:10,329



1308
01:00:10,329 --> 01:00:11,960
The list is hard.
清单很难。 

1309
01:00:11,960 --> 01:00:13,059
The traversal is easy.
遍历很容易。 

1310
01:00:13,059 --> 01:00:15,730
Remember the traversal.
记住遍历。 

1311
01:00:15,730 --> 01:00:17,980
That's easy to reason about, so that's good.
这很容易推理，所以很好。 

1312
01:00:17,980 --> 01:00:18,793
OK.
好。 

1313
01:00:18,793 --> 01:00:20,291
Any questions on amortized analysis?
对摊销分析有任何疑问吗？ 

1314
01:00:20,291 --> 01:00:23,460



1315
01:00:23,460 --> 01:00:25,659
So the idea is that you look at all the operations,
因此，想法是您查看所有操作， 

1316
01:00:25,659 --> 01:00:27,809
you don't look at one operation at a time.
您不会一次查看一项操作。 

1317
01:00:27,809 --> 01:00:31,309
And you're trying to see if I look at everything,
而且您正在尝试查看我是否查看了所有内容， 

1318
01:00:31,309 --> 01:00:33,779
is it the case that I have some really fast operations
我真的有一些快速操作的情况吗

1319
01:00:33,780 --> 01:00:35,289
and the slow operations don't happen
而且慢的操作不会发生

1320
01:00:35,489 --> 01:00:37,579
too much, because if that's the case,
太多，因为如果是这样， 

1321
01:00:37,579 --> 01:00:40,989
then I can make an argument for the average cost, which
那么我可以对平均成本进行论证

1322
01:00:40,989 --> 01:00:44,779
is better than the argument that says this is the worst
比说这是最坏的说法更好

1323
01:00:44,780 --> 01:00:46,820
case of an operation, I'm doing an operation,
手术的情况下，我正在做手术， 

1324
01:00:46,820 --> 01:00:49,054
the total cost is n times the worst cost.
总成本是最差成本的n倍。 

1325
01:00:49,253 --> 01:00:52,739



1326
01:00:52,739 --> 01:00:54,909
Make some sense?
有道理吗？ 

1327
01:00:54,909 --> 01:00:55,579
OK.
好。 

1328
01:00:55,579 --> 01:00:57,630
Cool.
凉。 

1329
01:00:57,630 --> 01:00:58,130
All right.
好吧。 

1330
01:00:58,130 --> 01:01:03,130
Have fun at the next p set.
在下一个p集玩得开心。 

