1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,000
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,000 --> 00:00:06,849
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,849 --> 00:00:10,709
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,710 --> 00:00:13,320
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,320 --> 00:00:17,187
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,187 --> 00:00:17,812
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,812 --> 00:00:22,300



10
00:00:22,300 --> 00:00:27,160
PROFESSOR: One more exacting lecture on hashing.
教授：关于哈希的另一门严谨的演讲。 

11
00:00:27,160 --> 00:00:29,010
And a couple reminders.
还有一些提醒。 

12
00:00:29,010 --> 00:00:32,960
I don't want to start out saying unpopular things,
我不想开始说不受欢迎的话， 

13
00:00:32,960 --> 00:00:37,209
but we do have a quiz coming up next week on Tuesday.
但是下周二我们确实有一个测验。 

14
00:00:37,409 --> 00:00:41,429
There will not be a lecture next Tuesday,
下周二将不会有演讲， 

15
00:00:41,429 --> 00:00:43,109
but there will be a quiz.
但是会有一个测验。 

16
00:00:43,109 --> 00:00:47,689
7:30 to 9:30 Tuesday evening.
周二晚上7:30至9:30。 

17
00:00:47,689 --> 00:00:49,140
I will send announcement.
我将发送公告。 

18
00:00:49,140 --> 00:00:51,279
There's going to be a couple rooms.
将有几个房间。 

19
00:00:51,479 --> 00:00:52,929
Some of you will be in this room.
你们当中有些人会在这个房间里。 

20
00:00:52,929 --> 00:00:54,929
Some of you will have to go to a different room,
你们中有些人必须去另一个房间， 

21
00:00:54,929 --> 00:00:56,890
since this room really can't hold
因为这个房间真的不能容纳

22
00:00:56,890 --> 00:01:00,070
180 students taking a quiz.
 180名学生参加测验。 

23
00:01:00,070 --> 00:01:01,399
All right?
好吧？ 

24
00:01:01,399 --> 00:01:04,046
So hashing.
所以哈希。 

25
00:01:04,046 --> 00:01:05,629
I'm pretty excited about this lecture,
我对这次演讲感到非常兴奋， 

26
00:01:05,629 --> 00:01:09,280
because I think as I was talking with Victor just
因为我认为当我与Victor交谈时

27
00:01:09,280 --> 00:01:12,659
before this, if there's one thing you want to remember
在此之前，如果您想记住一件事

28
00:01:12,659 --> 00:01:16,700
about hashing and you want to go implement a hash table,
关于哈希，您想去实现哈希表， 

29
00:01:16,700 --> 00:01:18,409
it's open addressing.
它是开放地址。 

30
00:01:18,409 --> 00:01:20,679
It's the simplest way that you can possibly
这是最简单的方法

31
00:01:20,680 --> 00:01:22,519
implement a hash table.
实现哈希表。 

32
00:01:22,719 --> 00:01:26,030
You can implement a hash table using an array.
您可以使用数组实现哈希表。 

33
00:01:26,030 --> 00:01:30,000
We've obviously talked about link lists
我们显然已经在谈论链接列表

34
00:01:30,000 --> 00:01:35,359
and chaining to implement hash tables in previous lectures,
和链接以实现以前的讲座中的哈希表， 

35
00:01:35,359 --> 00:01:38,929
but we're going to actually get rid of pointers and link lists,
但实际上我们将摆脱指针和链接列表， 

36
00:01:38,930 --> 00:01:42,890
and implement a hash table using a single array data structure,
并使用单个数组数据结构实现哈希表， 

37
00:01:42,890 --> 00:01:46,829
and that's the notion of open addressing.
这就是开放寻址的概念。 

38
00:01:46,829 --> 00:01:49,359
Now in order to get open addressing to work,
现在，为了获得公开的地址， 

39
00:01:49,359 --> 00:01:50,659
there's no free lunch, right?
没有免费的午餐吧？ 

40
00:01:50,659 --> 00:01:52,560
So you have a simple implementation.
因此，您有一个简单的实现。 

41
00:01:52,560 --> 00:01:56,039
It turns out that in order to make open addressing efficient,
事实证明，为了提高公开寻址的效率， 

42
00:01:56,239 --> 00:01:58,799
you have to be a little more careful than if you're
您必须比自己更小心一点

43
00:01:58,799 --> 00:02:02,390
using the hash tables with chaining.
将哈希表与链接一起使用。 

44
00:02:02,390 --> 00:02:04,869
And we're going to have to make an assumption
我们将不得不做一个假设

45
00:02:05,069 --> 00:02:06,705
about uniform hashing.
关于统一哈希。 

46
00:02:06,706 --> 00:02:08,088
I'll say a little bit more about that.
我会说更多。 

47
00:02:08,288 --> 00:02:11,780
But it's a different assumption from simple uniform hashing
但这是与简单的统一哈希不同的假设

48
00:02:11,780 --> 00:02:13,479
that Eric talked about.
埃里克谈到的。 

49
00:02:13,479 --> 00:02:16,159
And we'll state this uniform hashing assumption.
我们将陈述这种统一的哈希假设。 

50
00:02:16,159 --> 00:02:20,990
And we look at what the performance is of open
我们看一下开放的表现

51
00:02:20,990 --> 00:02:23,189
addressing under this assumption.
在这种假设下解决。 

52
00:02:23,389 --> 00:02:26,329
And this is assumption is going to give us
这是假设将给我们

53
00:02:26,330 --> 00:02:30,469
a sense of what good hash functions are
了解什么是好的哈希函数

54
00:02:30,469 --> 00:02:33,349
for open addressing applications or for open addressing
用于开放式寻址应用程序或用于开放式寻址

55
00:02:33,349 --> 00:02:34,769
hash tables.
哈希表。 

56
00:02:34,770 --> 00:02:39,330
And finally we'll talk about cryptographic hashing.
最后，我们将讨论密码哈希。 

57
00:02:39,330 --> 00:02:41,900
This is not really 6006 material,
这不是真正的6006材料， 

58
00:02:42,099 --> 00:02:44,289
but it's kind of cool material.
但这是一种很酷的材料。 

59
00:02:44,289 --> 00:02:47,889
It has a lot of applications in computer security
它在计算机安全方面有很多应用

60
00:02:47,889 --> 00:02:49,099
and cryptography.
和密码学。 

61
00:02:49,099 --> 00:02:53,710
And so as we'll describe the notion of a cryptographic hash,
因此，当我们描述密码哈希的概念时， 

62
00:02:53,710 --> 00:02:57,969
and we'll talk about a couple of real simple and pervasive
我们将讨论几个真正简单而普遍的方法

63
00:02:57,969 --> 00:03:00,560
applications like password storage
密码存储等应用

64
00:03:00,560 --> 00:03:05,240
and file corruption detectors that you can implement
和可以实现的文件损坏检测器

65
00:03:05,240 --> 00:03:07,250
using cryptographic hash functions, which
使用加密散列函数

66
00:03:07,449 --> 00:03:10,439
are quite different from the regular hash functions
与常规哈希函数有很大不同

67
00:03:10,439 --> 00:03:13,060
that we're using in hash tables.
我们在哈希表中使用的

68
00:03:13,060 --> 00:03:18,460
Be it chaining hash tables or open addressing hash tables.
是链接哈希表还是打开寻址哈希表。 

69
00:03:18,460 --> 00:03:19,689
All right?
好吧？ 

70
00:03:19,689 --> 00:03:23,120
So let's get started and talk about open addressing.
因此，让我们开始讨论开放式寻址。 

71
00:03:23,120 --> 00:03:30,080



72
00:03:30,080 --> 00:03:33,709
This is another approach to dealing with collisions.
这是处理冲突的另一种方法。 

73
00:03:33,908 --> 00:03:35,949
If you didn't have collisions, obviously an array
如果没有碰撞，显然是一个数组

74
00:03:35,949 --> 00:03:37,189
would work, right?
会起作用，对吧？ 

75
00:03:37,189 --> 00:03:39,734
If you could somehow guarantee that there were no collisions.
如果您能以某种方式保证没有碰撞。 

76
00:03:39,734 --> 00:03:41,150
When you have collisions, you have
发生碰撞时

77
00:03:41,150 --> 00:03:44,250
to worry about the chaining and ensuring
担心链接和确保

78
00:03:44,449 --> 00:03:46,689
that you can still find the keys even though you
即使您仍然可以找到钥匙

79
00:03:46,689 --> 00:03:50,800
had two keys that collided into the same slot.
有两个撞到同一个插槽的钥匙。 

80
00:03:50,800 --> 00:03:54,090
And we don't want to use chaining.
而且我们不想使用链接。 

81
00:03:54,090 --> 00:03:56,819



82
00:03:56,819 --> 00:03:59,909
The simplest data structure that we can possibly use are arrays.
我们可能使用的最简单的数据结构是数组。 

83
00:03:59,909 --> 00:04:04,430
Back when I was a grad student, I went through and got a PhD
当我还是研究生时，我通过了博士学位

84
00:04:04,430 --> 00:04:08,939
writing programs in C, never using any other structure
用C编写程序，从不使用任何其他结构

85
00:04:08,939 --> 00:04:12,370
than arrays, because I didn't like pointers.
比数组，因为我不喜欢指针。 

86
00:04:12,370 --> 00:04:15,530
And so open addressing is a way that you
因此，开放式寻址是您

87
00:04:15,530 --> 00:04:18,810
can implement hash tables doing exactly this.
可以实现哈希表正是这样做的。 

88
00:04:18,810 --> 00:04:22,300
And in particular, what we're going to do
特别是我们要做的是

89
00:04:22,300 --> 00:04:25,055
is assume an array structure with items.
假定包含项的数组结构。 

90
00:04:25,055 --> 00:04:31,810



91
00:04:31,810 --> 00:04:37,389
And we're going to assume that this one item-- at most
我们将假设这一项目-最多

92
00:04:37,389 --> 00:04:38,629
one item per slot.
每个插槽一个物品。 

93
00:04:38,629 --> 00:04:41,579



94
00:04:41,579 --> 00:04:44,969
So m has to be greater than or equal to n, right?
所以m必须大于或等于n，对吗？ 

95
00:04:44,970 --> 00:04:48,240
So this is important because we don't have link lists.
所以这很重要，因为我们没有链接列表。 

96
00:04:48,240 --> 00:04:51,759
We can't arbitrarily increase the storage
我们不能随意增加存储量

97
00:04:51,959 --> 00:04:56,859
of a slot using a chain, and have
使用链条的插槽，并具有

98
00:04:56,860 --> 00:04:59,060
n, which is the number of elements,
 n，即元素数， 

99
00:04:59,060 --> 00:05:01,040
be greater than m, right?
大于m，对不对？ 

100
00:05:01,040 --> 00:05:06,290
Which you could in the link list table with chaining.
您可以在链接列表表中进行链接。 

101
00:05:06,290 --> 00:05:09,100
But here you only have these area locations,
但是这里您只有这些区域位置， 

102
00:05:09,100 --> 00:05:11,310
these indices that you can put items into.
这些可以放入项目的索引。 

103
00:05:11,509 --> 00:05:16,620
So it's pretty much guaranteed that if you want a working open
因此，几乎可以保证，如果您想工作的话

104
00:05:16,620 --> 00:05:23,990
addressing hash table that m, which is the number of slots
寻址哈希表m，即槽数

105
00:05:23,990 --> 00:05:29,079
in the table, should be greater than or equal to the number
在表格中，应大于或等于数字

106
00:05:29,079 --> 00:05:31,659
of elements, all right?
元素，好吗？ 

107
00:05:31,660 --> 00:05:34,379
That's important.
那很重要

108
00:05:34,579 --> 00:05:36,509
Now how does this work.
现在这是如何工作的。 

109
00:05:36,509 --> 00:05:38,990
Well, we're going to have this notion of probing.
好吧，我们将拥有这种探测概念。 

110
00:05:38,990 --> 00:05:44,250



111
00:05:44,250 --> 00:05:48,160
And the notion of probing is that we're
探测的概念是我们

112
00:05:48,160 --> 00:05:53,160
going to try to see if we can insert something
尝试看看我们是否可以插入一些东西

113
00:05:53,160 --> 00:05:56,016
into this hash table, and if you fail
进入这个哈希表，如果失败

114
00:05:56,016 --> 00:05:57,189
we're actually going to recompute
我们实际上将要重新计算

115
00:05:57,389 --> 00:06:00,409
a slightly different hash for the key
密钥的哈希值略有不同

116
00:06:00,410 --> 00:06:02,160
that we're trying to insert, the key value
我们试图插入的键值

117
00:06:02,160 --> 00:06:03,535
pair that we're trying to insert.
我们试图插入的一对。 

118
00:06:03,535 --> 00:06:03,834
All right?
好吧？ 

119
00:06:04,033 --> 00:06:05,959
So this is an iterative process, and we're
这是一个反复的过程， 

120
00:06:05,959 --> 00:06:09,919
going to continually probe until we find an empty slot
将不断进行探测，直到找到一个空插槽

121
00:06:09,920 --> 00:06:13,560
into which we can insert this key value pair.
我们可以在其中插入该键值对。 

122
00:06:13,560 --> 00:06:15,750
The key should index into it.
密钥应该索引到其中。 

123
00:06:15,750 --> 00:06:19,569
So you do have different hashes that
所以你有不同的哈希值

124
00:06:19,569 --> 00:06:22,189
are going to be computed based on this probing
将基于此探测进行计算

125
00:06:22,189 --> 00:06:24,480
notion for a given key.
给定密钥的概念。 

126
00:06:24,480 --> 00:06:27,050
All right?
好吧？ 

127
00:06:27,050 --> 00:06:31,389
And so what we need now is a hash function
因此，我们现在需要的是哈希函数

128
00:06:31,389 --> 00:06:35,370
that's different from the standard hash functions
与标准哈希函数不同

129
00:06:35,370 --> 00:06:42,470
that we've talked about so far, which specifies
到目前为止我们已经讨论过的

130
00:06:42,470 --> 00:06:51,009
the order of slots to probe, which is basically
要探测的插槽的顺序，基本上是

131
00:06:51,209 --> 00:06:52,349
to try for a key.
尝试一把钥匙。 

132
00:06:52,350 --> 00:06:58,370



133
00:06:58,569 --> 00:07:06,079
And this is going to be true for insert, search, and delete,
这对于插入，搜索和删除都是正确的， 

134
00:07:06,079 --> 00:07:08,189
which are three basic operations.
这是三个基本操作。 

135
00:07:08,189 --> 00:07:10,819
And they're a little bit different, all right?
它们有些不同，好吗？ 

136
00:07:10,819 --> 00:07:14,223
Just like they were different for the chaining hash table,
就像它们在链接哈希表方面有所不同一样， 

137
00:07:14,223 --> 00:07:16,639
they're different here, but they're kind of more different
它们在这里是不同的，但是它们却有所不同

138
00:07:16,639 --> 00:07:17,189
here.
这里。 

139
00:07:17,189 --> 00:07:19,620
And you'll see what I mean when we go through this.
当我们经历这个过程时，您会明白我的意思。 

140
00:07:19,620 --> 00:07:22,660



141
00:07:22,660 --> 00:07:25,069
And this is not just for one slot.
这不仅是针对一个插槽。 

142
00:07:25,269 --> 00:07:28,189
It's going to specify an order of slots.
将指定插槽的顺序。 

143
00:07:28,189 --> 00:07:32,180
And so our hash function h is going
因此，我们的哈希函数h将继续

144
00:07:32,180 --> 00:07:49,889
to take the universe of keys and also take
拿钥匙的宇宙，也拿

145
00:07:49,889 --> 00:07:53,120
what we're going to call the trial count.
我们将其称为试用计数。 

146
00:07:53,120 --> 00:07:57,660
So if you're lucky-- well, you get lucky in your first trial.
因此，如果您很幸运，那么您在第一次审判中会很幸运。 

147
00:07:57,660 --> 00:08:01,120
And if you're not, you hope to get lucky in your second trial,
如果不是，您希望在第二次审判中会很幸运， 

148
00:08:01,319 --> 00:08:02,709
and so on and so forth.
等等等等。 

149
00:08:02,709 --> 00:08:08,089
But the hash function is going to take two arguments.
但是hash函数将接受两个参数。 

150
00:08:08,089 --> 00:08:12,579
It's going to take the key as an argument,
它将把键作为参数， 

151
00:08:12,579 --> 00:08:17,109
and it's going to take a trial, which is an integer between 0
并且要进行试用，它是0到0之间的整数

152
00:08:17,110 --> 00:08:19,439
to n minus 1, all right?
到n减1，好吗？ 

153
00:08:19,439 --> 00:08:23,959
And it's going to produce-- just like the chaining hash function
就像链哈希函数一样，它将产生

154
00:08:23,959 --> 00:08:31,659
it's going to produce a number between 0 and m minus 1, right?
它会产生一个介于0和m减1之间的数字，对吗？ 

155
00:08:31,660 --> 00:08:34,029
Where m is the number of slots in the table.
其中，m是表中的插槽数。 

156
00:08:34,029 --> 00:08:35,918
All right.
好吧。 

157
00:08:35,918 --> 00:08:39,149
So that's the story.
这就是故事。 

158
00:08:39,149 --> 00:08:48,360
In order to ensure that you are using the hash table
为了确保您正在使用哈希表

159
00:08:48,360 --> 00:08:54,769
corresponding to open addressing properly, what you want
对应于正确打开地址，您想要什么

160
00:08:54,769 --> 00:09:01,679
is-- and this is an important property-- that h k 1,
是-这是一个重要的特性-hk 1， 

161
00:09:01,679 --> 00:09:03,639
so that's a key that you're given.
所以这是给你的钥匙。 

162
00:09:03,639 --> 00:09:08,360
And this could be an arbitrary key, mind you.
请注意，这可以是任意键。 

163
00:09:08,360 --> 00:09:17,769
So arbitrary key k.
因此，任意密钥k。 

164
00:09:17,769 --> 00:09:20,429
And what you have in terms of the slots that
以及您所拥有的广告位

165
00:09:20,429 --> 00:09:27,879
are being computed is this, h k 1, h k 2,
正在计算的是hk 1，hk 2 

166
00:09:27,879 --> 00:09:33,519
and so on and so forth to h k n minus 1.
依此类推，直到hkn减1。 

167
00:09:33,519 --> 00:09:40,990
And what you want is for this vector
而你想要的就是这个向量

168
00:09:40,990 --> 00:09:54,509
to be a permutation of 0 1 and so on to n minus 1.
是0 1的排列，依此类推直到n减1。 

169
00:09:54,509 --> 00:09:57,319
And the reason for this hopefully is clear.
希望这样做的原因很明确。 

170
00:09:57,320 --> 00:10:01,699
It's because you want to be able to use
这是因为您希望能够使用

171
00:10:01,899 --> 00:10:04,659
the entirety of your hash table.
整个哈希表。 

172
00:10:04,659 --> 00:10:07,809
You don't want particular slots to go unused.
您不希望使用特定的插槽。 

173
00:10:07,809 --> 00:10:13,919
And when you get to the point where the number of elements n
而当您到达元素数量n 

174
00:10:13,919 --> 00:10:20,029
is pretty close to m, and maybe there's just one slot left, OK?
非常接近m，也许只剩下一个插槽，好吗？ 

175
00:10:20,029 --> 00:10:25,279
And you want to fill up this last slot with this key k
您想用此键k填充最后一个插槽

176
00:10:25,279 --> 00:10:27,740
that you want to put in there, and what
你想放在那里，还有什么

177
00:10:27,740 --> 00:10:30,460
you want to be able to say is that for this arbitrary key k
您想说的是，对于这个任意密钥k 

178
00:10:30,460 --> 00:10:34,259
that you want to put in there that the one slot that's free--
您想要放在那里的那一个免费插槽- 

179
00:10:34,259 --> 00:10:35,730
and it could be that first slot.
可能是第一个插槽。 

180
00:10:35,730 --> 00:10:37,399
It could be the 17th slot.
它可能是第17个广告位。 

181
00:10:37,399 --> 00:10:40,340
Whatever-- That eventually the sequence of probes
无论如何-最终的探查顺序

182
00:10:40,340 --> 00:10:43,719
is going to be able to allow you to insert into that slot.
将能够允许您插入该插槽。 

183
00:10:43,919 --> 00:10:45,229
All right?
好吧？ 

184
00:10:45,230 --> 00:10:47,450
And we generalize this notion into
我们将这个概念概括为

185
00:10:47,450 --> 00:10:50,979
the uniform hashing assumption in a few minutes,
几分钟后统一哈希假设， 

186
00:10:51,179 --> 00:10:53,649
but hopefully this makes sense from a standpoint
但希望从角度来看这是有道理的

187
00:10:53,649 --> 00:10:57,149
of really load balancing the table
真正平衡表的负载

188
00:10:57,149 --> 00:11:00,590
and ensuring that all slots in the table
并确保表格中的所有插槽

189
00:11:00,590 --> 00:11:02,600
are sort of equal opportunity slots.
是机会均等的机会。 

190
00:11:02,600 --> 00:11:08,269
That you're going to be able to put keys in them as long as you
只要您能够将钥匙放入其中

191
00:11:08,269 --> 00:11:11,669
probe long enough that you're going to be able to get there.
探测足够长的时间，您将能够到达那里。 

192
00:11:11,669 --> 00:11:14,149
Now of course the fact that you're
现在，当然，事实是

193
00:11:14,149 --> 00:11:16,649
using one particular slot for one particular key
为一个特定的键使用一个特定的插槽

194
00:11:16,649 --> 00:11:18,579
depends on the order of keys that you're
取决于您的按键顺序

195
00:11:18,580 --> 00:11:20,099
inserting into this table.
插入此表。 

196
00:11:20,299 --> 00:11:24,139
Again, you'll see that as we go through an example, all right?
再次，您将看到我们通过一个示例，对吗？ 

197
00:11:24,139 --> 00:11:25,259
So that's the set up.
这就是设置。 

198
00:11:25,259 --> 00:11:27,799
That's the open addressing notion.
这是开放的寻址概念。 

199
00:11:27,799 --> 00:11:30,669
And that as you can see, we're just
如您所见，我们只是

200
00:11:30,669 --> 00:11:34,079
going to go through a sequence of probes
将经历一系列的探究

201
00:11:34,080 --> 00:11:36,200
and our hash function is going to tell us
我们的哈希函数将告诉我们

202
00:11:36,200 --> 00:11:38,950
what the sequences is, and so we don't need any pointers
序列是什么，所以我们不需要任何指针

203
00:11:38,950 --> 00:11:41,350
or anything like that.
或类似的东西。 

204
00:11:41,350 --> 00:11:50,340
So let's take a look at how this might work in practice.
因此，让我们看一下这在实践中如何工作。 

205
00:11:50,340 --> 00:11:55,889
So maybe the easiest thing to do is to run through an example,
因此，也许最容易做的就是通过一个例子， 

206
00:11:55,889 --> 00:11:57,870
and then I'll show you some pseudocode.
然后我将向您展示一些伪代码。 

207
00:11:57,870 --> 00:12:01,799
But let's say that I have a table here,
但是，假设我在这里有一张桌子， 

208
00:12:01,799 --> 00:12:07,059
and I'm going to concentrate on the insert operation.
我将专注于插入操作。 

209
00:12:07,059 --> 00:12:10,529
And I'm going to start inserting things into this table.
我将开始在此表中插入内容。 

210
00:12:10,529 --> 00:12:17,129



211
00:12:17,129 --> 00:12:19,689
And right here I have seven slots up there.
在这里，我在那里有七个插槽。 

212
00:12:19,690 --> 00:12:27,840
So let's say that I want to insert 586 into the table,
假设我要在表格中插入586， 

213
00:12:27,840 --> 00:12:35,019
and I compute h of 586 comma 1, and that gives me 1.
我计算出h为586逗号1，即得出1。 

214
00:12:35,019 --> 00:12:35,759
OK?
好？ 

215
00:12:35,759 --> 00:12:37,220
This is the first insert.
这是第一个插入。 

216
00:12:37,220 --> 00:12:42,649
So I'm going to go ahead and stick 586 in here, all right?
所以我继续将586插入此处，好吗？ 

217
00:12:42,649 --> 00:12:47,730
And then I insert, for argument's sake, 133.
然后，为了论证，我插入133。 

218
00:12:47,730 --> 00:12:50,600
I insert 204 out here.
我在这里插入204。 

219
00:12:50,600 --> 00:12:54,490
And these are all things because the hash table is empty.
这些都是因为哈希表为空。 

220
00:12:54,490 --> 00:12:57,899
481 out here and so on.
 481在这里等等。 

221
00:12:57,899 --> 00:12:59,799
And because the hash table is empty,
而且由于哈希表为空， 

222
00:12:59,799 --> 00:13:03,799
my very first trial is successful, all right?
我的第一次审判成功了，好吗？ 

223
00:13:03,799 --> 00:13:11,189
So h of 481-- I'm not going to write this all out, but h 481 1
所以481的h-我不会全部写出来，但是h 481 1 

224
00:13:11,190 --> 00:13:15,079
happens to be 6 and so on.
碰巧是6，依此类推。 

225
00:13:15,279 --> 00:13:15,819
All right?
好吧？ 

226
00:13:15,820 --> 00:13:24,709
Now I get to the point where I want to insert 496.
现在我要插入496。 

227
00:13:24,909 --> 00:13:40,699
And when I try to insert 496, I have h 496 1.
当我尝试插入496时，我有496 1。 

228
00:13:40,700 --> 00:13:43,490
It happens to be 4.
碰巧是4。 

229
00:13:43,490 --> 00:13:44,450
OK?
好？ 

230
00:13:44,450 --> 00:13:48,230
So the first thing that happens is I go in here,
所以发生的第一件事就是我进入这里

231
00:13:48,230 --> 00:13:50,070
and I say oops.
我说哦

232
00:13:50,070 --> 00:13:54,990
This slot is occupied, because this-- I'm
这个插槽已被占用，因为- 

233
00:13:54,990 --> 00:14:00,470
going to have a special flag associated with an empty slot,
将有一个与空插槽相关的特殊标志， 

234
00:14:00,470 --> 00:14:03,830
and we can say it's none.
我们可以说不是。 

235
00:14:03,830 --> 00:14:05,819
And if it's not none, then it's occupied.
如果不是全无，那它就会被占用。 

236
00:14:06,019 --> 00:14:08,079
And 204 is not equal to none.
 204不等于无。 

237
00:14:08,080 --> 00:14:14,509
So I look at this, and I say the first probe actually failed.
所以我看了一下，我说第一个探测实际上失败了。 

238
00:14:14,509 --> 00:14:15,159
OK?
好？ 

239
00:14:15,159 --> 00:14:30,149
And so h 496 1 equals 4 fails, so I need to go do h 496 2.
因此，h 496 1等于4失败，所以我需要执行h 496 2。 

240
00:14:30,149 --> 00:14:36,179
And h 496 2 may also fail.
并且h 496 2也可能失败。 

241
00:14:36,179 --> 00:14:45,909
You might be in a situation where h 496 2 gives you 586.
您可能处于h 496 2给您586的情况。 

242
00:14:45,909 --> 00:14:56,850
So this was h 496 1 h 496 2 might give you 586.
因此，这是h 496 1 h 496 2可能会给您586。 

243
00:14:56,850 --> 00:15:03,649
And finally it may be that h 496 3, which is your third attempt,
最后可能是h 496 3，这是您的第三次尝试， 

244
00:15:03,649 --> 00:15:05,129
equals 3.
等于3。 

245
00:15:05,129 --> 00:15:07,559
So you go in, and you say great.
所以你进去，你说的很好。 

246
00:15:07,559 --> 00:15:10,209
I can insert 496.
我可以插入496。 

247
00:15:10,210 --> 00:15:11,769
And let me write that in bold here.
让我在这里用黑体字写出来。 

248
00:15:11,769 --> 00:15:14,829



249
00:15:14,830 --> 00:15:16,190
Out there.
在那里。 

250
00:15:16,190 --> 00:15:16,579
All right?
好吧？ 

251
00:15:16,779 --> 00:15:18,750
So pretty straightforward.
非常简单。 

252
00:15:18,750 --> 00:15:23,620
In this case, you've gone through three trials in order
在这种情况下，您已经按顺序进行了三个试验

253
00:15:23,620 --> 00:15:25,490
to find an empty slot.
查找一个空插槽。 

254
00:15:25,490 --> 00:15:28,359
And so the big question really here is
所以真正的最大问题是

255
00:15:28,559 --> 00:15:32,579
other than taking care of search and delete, how long is
除了照顾搜索和删除，还有多长时间

256
00:15:32,580 --> 00:15:33,859
this process going to take?
这个过程要走吗？ 

257
00:15:34,059 --> 00:15:34,989
All right?
好吧？ 

258
00:15:34,990 --> 00:15:37,799
And I'm talking about that in a few minutes,
我过几分钟再说

259
00:15:37,799 --> 00:15:41,349
but let me explain, now that you've
但让我解释一下，既然您已经

260
00:15:41,350 --> 00:15:45,820
seen insert, how search would work, right?
看到插入，搜索将如何工作，对吗？ 

261
00:15:45,820 --> 00:15:50,309
Or maybe I get one of you guys to explain to me
或者也许我让你们一个人向我解释

262
00:15:50,509 --> 00:15:55,230
once you have insert, how would search work?
插入后，搜索将如何工作？ 

263
00:15:55,230 --> 00:15:55,730
Someone?
有人吗

264
00:15:55,730 --> 00:15:58,349



265
00:15:58,549 --> 00:15:59,937
Someone from the back?
有人从后面吗？ 

266
00:15:59,937 --> 00:16:03,289



267
00:16:03,289 --> 00:16:04,799
No one.
没有人。 

268
00:16:04,799 --> 00:16:08,449
You guys are always answering questions.
你们总是在回答问题。 

269
00:16:08,450 --> 00:16:09,599
Yeah, all the way in the back.
是的，一直在后面

270
00:16:09,799 --> 00:16:11,959
AUDIENCE: Would you just do the same kind
听众：你会做同样的事情吗

271
00:16:11,960 --> 00:16:18,022
of probing [INAUDIBLE] where you find it or you don't find it?
探测[音频不清晰]在哪里找到还是找不到的？ 

272
00:16:18,022 --> 00:16:18,730
PROFESSOR: Right.
教授：对。 

273
00:16:18,730 --> 00:16:19,359
So you do exactly.
因此，您完全可以。 

274
00:16:19,559 --> 00:16:20,789
It's very similar to insert.
插入非常相似。 

275
00:16:20,789 --> 00:16:23,809



276
00:16:23,809 --> 00:16:26,379
You have a situation where you're
您遇到的情况是

277
00:16:26,379 --> 00:16:33,840
going to none would indicate an empty slot.
如果全都不做，则表示插槽为空。 

278
00:16:33,840 --> 00:16:37,459
And you can think of this as being a flag.
您可以将其视为一个标志。 

279
00:16:37,659 --> 00:16:45,449
And in the case of insert, what you did was you--
在插入的情况下，您所做的就是- 

280
00:16:45,450 --> 00:16:53,120
insert k v would say keep probing.
插入kv表示继续探测。 

281
00:16:53,120 --> 00:16:56,019
I'm not going to write the pseudocode for it.
我不会为它编写伪代码。 

282
00:16:56,019 --> 00:17:03,980
Keep probing until an empty slot is found.
继续进行探测，直到找到一个空插槽。 

283
00:17:03,980 --> 00:17:06,630



284
00:17:06,630 --> 00:17:08,480
And then when it's found, insert item.
然后找到它，插入项目。 

285
00:17:08,480 --> 00:17:16,559



286
00:17:16,559 --> 00:17:19,929
And as long as you have the permutation property
并且只要您具有置换属性

287
00:17:19,930 --> 00:17:23,150
that we have up there, and given that m is greater than
我们在那里，并且考虑到m大于

288
00:17:23,150 --> 00:17:26,259
or equal to n, you're guaranteed that insert
或等于n，则可以确保插入

289
00:17:26,259 --> 00:17:28,059
is going to find a slot.
将要找到一个插槽。 

290
00:17:28,059 --> 00:17:28,559
OK?
好？ 

291
00:17:28,559 --> 00:17:29,869
That's the good news.
那是个好消息。 

292
00:17:29,869 --> 00:17:31,419
Now it might take awhile, and so we
现在可能需要一段时间，所以我们

293
00:17:31,420 --> 00:17:35,970
have a talk about performance a bit later, but it'll work.
稍后再讨论性能，但它会起作用。 

294
00:17:35,970 --> 00:17:36,799
OK?
好？ 

295
00:17:36,799 --> 00:17:39,109
Now search is a little bit different.
现在搜索有点不同。 

296
00:17:39,109 --> 00:17:42,490



297
00:17:42,490 --> 00:17:50,705
You're searching for a key k, and you essentially
您正在寻找密钥k，并且本质上来说

298
00:17:50,705 --> 00:17:52,079
say you're going to keep probing.
说你要继续探测。 

299
00:17:52,079 --> 00:18:04,289
And you say as long as the slots encountered
你说只要遇到槽

300
00:18:04,289 --> 00:18:14,159
are occupied by keys not equal to k.
被不等于k的键占用。 

301
00:18:14,160 --> 00:18:16,440
So every time you probe, you go in there
因此，每次探测时，您都会进入

302
00:18:16,440 --> 00:18:18,440
and you say I got a key.
你说我有一把钥匙

303
00:18:18,440 --> 00:18:20,629
I found a hash for it.
我为此找到了一个哈希。 

304
00:18:20,829 --> 00:18:22,500
I go to this particular slot.
我去这个特定的位置。 

305
00:18:22,500 --> 00:18:25,269
I look inside of it, and I check to see
我看里面，我检查看看

306
00:18:25,269 --> 00:18:28,000
whether the key that's stored inside of it
是否存储在其中的密钥

307
00:18:28,000 --> 00:18:31,170
is the same as the key I'm searching for.
与我要搜索的键相同。 

308
00:18:31,170 --> 00:18:34,990
If not, I go to the next trial.
如果没有，我去下一次审判。 

309
00:18:34,990 --> 00:18:37,130
If it is, then I return it.
如果是，那么我将其退回。 

310
00:18:37,130 --> 00:18:37,630
Right?
对？ 

311
00:18:37,630 --> 00:18:41,440
So that's pretty much it.
就是这样。 

312
00:18:41,440 --> 00:19:00,690
And we keep probing until you either encounter k or find
我们一直在探索，直到您遇到k或找到

313
00:19:00,690 --> 00:19:01,420
an empty slot.
一个空插槽。 

314
00:19:01,420 --> 00:19:04,930



315
00:19:04,930 --> 00:19:05,920
And this is the key.
这就是关键。 

316
00:19:05,920 --> 00:19:08,513



317
00:19:08,713 --> 00:19:09,379
No pun intended.
无双关语。 

318
00:19:09,380 --> 00:19:12,230



319
00:19:12,230 --> 00:19:16,680
A notion which is that when you find an empty slot,
一个想法是，当您发现一个空插槽时， 

320
00:19:16,680 --> 00:19:21,639
it means that you have failed to discover this key.
这表示您未能找到此密钥。 

321
00:19:21,839 --> 00:19:24,271
You fail to-- yeah, question back there?
您没有-是的，回到那里问吗？ 

322
00:19:24,271 --> 00:19:27,169
AUDIENCE: What happens if you were to delete a key though?
听众：但是，如果您要删除密钥会怎样？ 

323
00:19:27,170 --> 00:19:29,670
PROFESSOR: I'll make you answer that question for a cushion.
教授：我让你回答一下这个问题。 

324
00:19:29,670 --> 00:19:32,200



325
00:19:32,200 --> 00:19:34,543
So we'll get to delete in a minute.
因此，我们将在一分钟之内删除。 

326
00:19:34,743 --> 00:19:36,159
But I want to make sure you're all
但是我想确保你们都

327
00:19:36,160 --> 00:19:39,170
on board with insert and search.
在船上进行插入和搜索。 

328
00:19:39,170 --> 00:19:39,920
OK?
好？ 

329
00:19:39,920 --> 00:19:43,279
So these are actually fairly straightforward in comparison
因此，相比之下，这些实际上非常简单

330
00:19:43,279 --> 00:19:43,779
to delete.
删除。 

331
00:19:43,779 --> 00:19:45,849
It's not like delete is much more complicated,
并不是说删除要复杂得多， 

332
00:19:45,849 --> 00:19:48,853
but there is a subtlety there.
但那里有一个微妙之处。 

333
00:19:48,854 --> 00:19:50,269
And so that's kind of neat, right?
这很整洁吧？ 

334
00:19:50,269 --> 00:19:52,629
I mean this actually works.
我的意思是这确实有效。 

335
00:19:52,630 --> 00:19:58,700
So if you had a situation where you were just accumulating
因此，如果您遇到的情况只是在积累

336
00:19:58,700 --> 00:20:02,920
keys, and you're looking for the number of distinct elements
键，并且您正在寻找不同元素的数量

337
00:20:02,920 --> 00:20:05,159
in the stream of data that was coming in,
在传入的数据流中， 

338
00:20:05,359 --> 00:20:08,089
and that was pretty much it with respect to your program,
就您的程序而言，就差不多了

339
00:20:08,089 --> 00:20:11,939
you'd never have to delete keys, and this would be all
您将不必删除密钥，仅此而已

340
00:20:11,940 --> 00:20:13,410
that you'd have to implement.
您必须实施。 

341
00:20:13,410 --> 00:20:14,279
Right?
对？ 

342
00:20:14,279 --> 00:20:17,690
But let's talk about delete.
但是，让我们谈谈删除。 

343
00:20:17,690 --> 00:20:19,669
Every once in awhile we'd want to delete a key?
我们偶尔想删除一个密钥吗？ 

344
00:20:19,869 --> 00:20:20,569
Yeah, you had a question?
是的，您有问题吗？ 

345
00:20:20,569 --> 00:20:22,278
AUDIENCE: I have a question about search.
听众：我有一个关于搜索的问题。 

346
00:20:22,278 --> 00:20:25,349
Why do you stop searching once you find an empty slot?
找到空插槽后为什么停止搜索？ 

347
00:20:25,349 --> 00:20:27,069
PROFESSOR: Because you're searching.
教授：因为您在搜索。 

348
00:20:27,069 --> 00:20:30,009
So what that means is that you're
所以那意味着你是

349
00:20:30,009 --> 00:20:34,119
looking to see if this key were already in the table.
查看该键是否已在表中。 

350
00:20:34,119 --> 00:20:37,149
And if key were already in the table,
如果键已经在表中， 

351
00:20:37,150 --> 00:20:39,669
you want to return the value associated with that key.
您想要返回与该键关联的值。 

352
00:20:39,869 --> 00:20:42,259
If you find an empty slot, since you're
如果您发现一个空位，因为

353
00:20:42,259 --> 00:20:47,539
using the same deterministic sequence of probes
使用相同的确定性探针序列

354
00:20:47,539 --> 00:20:50,220
that you would have if you had inserted it,
如果您将其插入的话， 

355
00:20:50,220 --> 00:20:52,210
then-- that make sense?
那么-有意义吗？ 

356
00:20:52,210 --> 00:20:53,319
Good.
好。 

357
00:20:53,319 --> 00:20:54,079
All right.
好吧。 

358
00:20:54,079 --> 00:20:56,500
So so far so good?
到目前为止到目前为止还好吗？ 

359
00:20:56,500 --> 00:21:00,549
That's what works for insert and search.
这就是插入和搜索的原理。 

360
00:21:00,549 --> 00:21:01,529
Let's talk delete.
让我们谈谈删除。 

361
00:21:01,529 --> 00:21:04,215
So back there.
所以回到那里。 

362
00:21:04,215 --> 00:21:05,209
How does delete work?
删除如何工作？ 

363
00:21:05,210 --> 00:21:09,069



364
00:21:09,069 --> 00:21:12,427
AUDIENCE: Well [INAUDIBLE] if you
观众：好吧[听不清] 

365
00:21:12,428 --> 00:21:16,412
search until you find the none and assume
搜索，直到找到一个都没有并假设

366
00:21:16,412 --> 00:21:20,395
that the key you're searching for was not put in there.
您要搜索的密钥没有放在此处。 

367
00:21:20,395 --> 00:21:25,210
But let's say you had one that was in that slot before
但是，假设您之前有一个插槽

368
00:21:25,210 --> 00:21:26,710
and it got put back in, but then you
然后放回去，但是然后你

369
00:21:26,710 --> 00:21:28,500
delete the one that was in the slot before.
删除以前在插槽中的那个。 

370
00:21:28,500 --> 00:21:29,747
PROFESSOR: Great, great.
教授：太好了。 

371
00:21:29,747 --> 00:21:31,129
You haven't told me how to fix it yet,
您还没有告诉我如何解决它， 

372
00:21:31,329 --> 00:21:35,339
but do you have the guts for this?
但是你对此有胆量吗？ 

373
00:21:35,339 --> 00:21:37,039
No.
没有。 

374
00:21:37,039 --> 00:21:39,460
OK, I think this veers to the right.
好吧，我认为这是对的。 

375
00:21:39,460 --> 00:21:41,905
I always wanted to do this to somebody in the back.
我一直想对后面的人这样做。 

376
00:21:41,905 --> 00:21:44,235
All right.
好吧。 

377
00:21:44,236 --> 00:21:45,170
Whoa.
哇

378
00:21:45,170 --> 00:21:48,379
All right, good catch.
好的，很好。 

379
00:21:48,579 --> 00:21:49,230
All right.
好吧。 

380
00:21:49,230 --> 00:21:49,819
OK.
好。 

381
00:21:49,819 --> 00:21:51,829
So you pointed out the problem, and I'm
所以你指出了问题，我

382
00:21:51,829 --> 00:21:53,799
going to ask somebody else for a solution.
要问别人一个解决方案。 

383
00:21:53,799 --> 00:21:55,799
All right?
好吧？ 

384
00:21:55,799 --> 00:21:57,569
But here's the problem.
但这就是问题所在。 

385
00:21:57,569 --> 00:21:59,099
Here's the problem, and we can look
这是问题所在，我们可以看一下

386
00:21:59,099 --> 00:22:04,559
at it from a standpoint of that example right there.
从那里的那个例子的角度来看。 

387
00:22:04,559 --> 00:22:08,700
Let's say for argument's sake that I'm searching-- now
出于争论的原因，我现在正在搜索

388
00:22:08,700 --> 00:22:11,639
I've done all of the inserts that I have up there, OK?
我已经完成了所有在那里的插入，好吗？ 

389
00:22:11,839 --> 00:22:14,199
So I've inserted 496.
所以我插入了496。 

390
00:22:14,200 --> 00:22:14,659
All right?
好吧？ 

391
00:22:14,859 --> 00:22:21,839
Then I delete 586 from the table, OK?
然后我从表中删除586，好吗？ 

392
00:22:21,839 --> 00:22:24,500
I delete 586 from the table.
我从表中删除586。 

393
00:22:24,500 --> 00:22:30,079
So let's just say that what I end up
所以我们只说我的结局

394
00:22:30,079 --> 00:22:38,909
doing-- I have 586, 133, 496, and then
在做-我有586、133、496，然后

395
00:22:38,910 --> 00:22:42,779
I have 204, and then a 481.
我有204，然后是481。 

396
00:22:42,779 --> 00:22:47,769
And this is 0, 1, 2, et cetera.
这是0、1、2等。 

397
00:22:47,769 --> 00:22:52,269
So I'm deleting 586, and let's say I replace it with none.
所以我要删除586，假设我将其替换为无。 

398
00:22:52,269 --> 00:22:53,299
OK?
好？ 

399
00:22:53,299 --> 00:22:55,129
Let's just say I replace it with none.
可以说我什么也没有替换。 

400
00:22:55,130 --> 00:23:03,670
Now what happens is that when I search for 496, according
现在发生的是，当我搜索496时， 

401
00:23:03,670 --> 00:23:09,940
to this search algorithm what am I going to get?
这种搜索算法我将得到什么？ 

402
00:23:09,940 --> 00:23:12,039
AUDIENCE: None.
听众：没有。 

403
00:23:12,039 --> 00:23:15,690
PROFESSOR: Well the first slot I'm going to look at is 1,
教授：我要看的第一个广告位是1 

404
00:23:15,690 --> 00:23:18,139
and according to this search algorithm,
然后根据这种搜索算法

405
00:23:18,339 --> 00:23:21,029
I find an empty slot, right?
我发现一个空插槽，对吗？ 

406
00:23:21,029 --> 00:23:23,269
And when I find an empty slot, I'm
当我发现一个空位时，我

407
00:23:23,269 --> 00:23:26,700
going to say I failed in the search.
会说我搜索失败。 

408
00:23:26,700 --> 00:23:33,819
If you encounter k, you succeed and return the key value pair,
如果遇到k，则成功，并返回键值对， 

409
00:23:33,819 --> 00:23:34,319
right?
对？ 

410
00:23:34,319 --> 00:23:36,509
Success means you return the value.
成功意味着您返回价值。 

411
00:23:36,509 --> 00:23:38,789
And if you encounter an empty slot,
如果您遇到一个空插槽， 

412
00:23:38,789 --> 00:23:41,690
it means that you've decided that this key is not
这意味着您已经确定此密钥不是

413
00:23:41,690 --> 00:23:43,630
in the table.
在桌子上。 

414
00:23:43,630 --> 00:23:46,309
And you say couldn't find it, right?
你说找不到，对不对？ 

415
00:23:46,509 --> 00:23:47,980
That make sense?
有道理？ 

416
00:23:47,980 --> 00:23:49,970
So this is obviously wrong, right?
所以这显然是错误的，对吧？ 

417
00:23:49,970 --> 00:23:54,200
Because I just inserted 496 into the table.
因为我刚刚在表中插入了496。 

418
00:23:54,200 --> 00:23:56,519
So this would fail incorrectly.
因此，这将错误地失败。 

419
00:23:56,519 --> 00:24:00,559



420
00:24:00,559 --> 00:24:02,990
So failed to find the key, which is OK.
所以找不到密钥，没关系。 

421
00:24:02,990 --> 00:24:05,200
I mean failure is OK if the key isn't there.
我的意思是，如果钥匙不在那儿，失败就可以了。 

422
00:24:05,200 --> 00:24:07,151
But you don't want to fail incorrectly.
但是您不想错误地失败。 

423
00:24:07,151 --> 00:24:07,650
Right?
对？ 

424
00:24:07,650 --> 00:24:09,389
Everyone buy that?
每个人都买吗？ 

425
00:24:09,589 --> 00:24:10,649
Everyone buy that?
每个人都买吗？ 

426
00:24:10,650 --> 00:24:11,500
Good.
好。 

427
00:24:11,500 --> 00:24:12,000
All right.
好吧。 

428
00:24:12,000 --> 00:24:14,170
So how do I fix it.
那么我该如何解决。 

429
00:24:14,170 --> 00:24:15,460
Someone else?
其他人？ 

430
00:24:15,460 --> 00:24:16,960
How do I fix this?
我该如何解决？ 

431
00:24:16,960 --> 00:24:18,563
Someone who doesn't have a cushion.
没有坐垫的人。 

432
00:24:18,563 --> 00:24:20,485
All right, you.
好吧，你。 

433
00:24:20,685 --> 00:24:30,109
AUDIENCE: [INAUDIBLE] you can mark that spot by a, and when
听众：[听不清]您可以用a标记该点，以及何时

434
00:24:30,109 --> 00:24:34,579
search comes across a, you just [INAUDIBLE].
搜索遇到一个，你只是[听不清]。 

435
00:24:34,579 --> 00:24:38,019
PROFESSOR: Right, great answer.
教授：对，很好的答案。 

436
00:24:38,019 --> 00:24:40,480
We're now going to have to do a couple of different things
我们现在将不得不做一些不同的事情

437
00:24:40,480 --> 00:24:42,339
for insert and search, OK?
进行插入和搜索，好吗？ 

438
00:24:42,339 --> 00:24:44,019
It's going to be subtly different,
情况会有所不同， 

439
00:24:44,019 --> 00:24:45,559
but the first thing we're going to do
但是我们要做的第一件事

440
00:24:45,559 --> 00:24:46,933
is we're going to have this flag,
是我们要有这个标志

441
00:24:46,933 --> 00:24:48,920
and I'll just call it delete me flag.
我将其称为“删除我”标志。 

442
00:24:48,920 --> 00:24:50,419
OK?
好？ 

443
00:24:50,619 --> 00:25:00,349
And we're going to say that when I delete something,
我们要说的是，当我删除某些内容时， 

444
00:25:00,349 --> 00:25:09,959
replace deleted item with not the non flag,
用非标记替换已删除的项目， 

445
00:25:09,960 --> 00:25:15,200
but a different flag that we'll call delete me.
但是我们将其称为“删除我” 

446
00:25:15,200 --> 00:25:20,140
Is different from none.
与众不同。 

447
00:25:20,140 --> 00:25:24,230



448
00:25:24,230 --> 00:25:26,039
And that's going to be important,
这将很重要， 

449
00:25:26,039 --> 00:25:28,599
because now that you have a different flag,
因为现在您有了一个不同的标志， 

450
00:25:28,599 --> 00:25:35,529
and you replace 586 with delete me,
然后您将586替换为删除我， 

451
00:25:35,529 --> 00:25:40,899
you can now do different things in insert versus search, right?
您现在可以在插入和搜索中执行不同的操作，对吗？ 

452
00:25:40,900 --> 00:25:43,900
So in particular, what you would do
所以特别是你会怎么做

453
00:25:43,900 --> 00:25:51,122
is you'd have to modify this slightly,
您是否需要对此稍作修改， 

454
00:25:51,122 --> 00:25:52,379
because the notion of an empty slot
因为空插槽的概念

455
00:25:52,579 --> 00:25:55,379
means that you're looking for none, right?
表示您什么都不找，对吧？ 

456
00:25:55,380 --> 00:26:00,650
And all it means is that-- well actually in some sense,
它的全部意思是-实际上在某种意义上， 

457
00:26:00,650 --> 00:26:02,500
the pseudo code doesn't really change
伪代码并没有真正改变

458
00:26:02,500 --> 00:26:08,160
because if you say you either encounter k
因为如果你说你遇到k 

459
00:26:08,160 --> 00:26:14,509
or you would-- even if you encounter a delete me,
否则，即使您遇到删除我的情况， 

460
00:26:14,509 --> 00:26:15,720
you keep going.
你继续前进。 

461
00:26:15,720 --> 00:26:16,220
All right?
好吧？ 

462
00:26:16,220 --> 00:26:18,650
That's the important thing.
那很重要。 

463
00:26:18,650 --> 00:26:20,369
So I guess it does change, because I assume
所以我想它确实会改变，因为我假设

464
00:26:20,569 --> 00:26:23,169
that you have only two cases here,
你这里只有两种情况

465
00:26:23,170 --> 00:26:26,075
but what you really have now are three cases.
但是您现在真正拥有的是三种情况。 

466
00:26:26,075 --> 00:26:28,150
The three cases are when you're doing
这三种情况是您在做的时候

467
00:26:28,150 --> 00:26:30,659
the search is that you encounter the key, which
搜索是您遇到钥匙， 

468
00:26:30,859 --> 00:26:31,959
is the easy case.
很简单。 

469
00:26:31,960 --> 00:26:32,690
You return it.
您退还。 

470
00:26:32,690 --> 00:26:34,440
You return the value.
您返回值。 

471
00:26:34,440 --> 00:26:38,529
Or you can encounter a delete me flag, in which case
否则您可能会遇到“删除我”标志

472
00:26:38,529 --> 00:26:40,240
you keep going.
你继续前进。 

473
00:26:40,240 --> 00:26:42,140
OK?
好？ 

474
00:26:42,140 --> 00:26:44,930
And if you encounter an empty slot, which
如果您遇到一个空插槽， 

475
00:26:44,930 --> 00:26:46,811
corresponds to none, at that point you know
对应于无，那时候你知道

476
00:26:47,011 --> 00:26:49,629
you failed and the key doesn't exist in the table.
您失败了，并且表中不存在密钥。 

477
00:26:49,630 --> 00:26:50,369
All right?
好吧？ 

478
00:26:50,569 --> 00:26:54,309
So let me just write that out.
所以让我把它写出来。 

479
00:26:54,309 --> 00:27:03,039
Insert treats delete me the same as none.
插入对待删除我就像没有。 

480
00:27:03,039 --> 00:27:07,250



481
00:27:07,250 --> 00:27:21,069
But search keeps going and treats it differently.
但是搜索一直在进行，并以不同的方式对待它。 

482
00:27:21,069 --> 00:27:32,116



483
00:27:32,116 --> 00:27:33,200
And that's pretty much it.
就是这样。 

484
00:27:33,200 --> 00:27:35,259
So what would happen in our example?
那么在我们的例子中会发生什么呢？ 

485
00:27:35,259 --> 00:27:39,839
Well, going through exactly the same example,
好吧，通过完全相同的示例， 

486
00:27:39,839 --> 00:27:43,750
we started from here, and then we decided to delete 586.
我们从这里开始，然后我们决定删除586。 

487
00:27:43,750 --> 00:27:51,579
And so if we replaced 586 not with none, but with delete me,
因此，如果我们不将586替换为无，而是删除我， 

488
00:27:51,579 --> 00:27:55,259
and the next time around when you search for 496,
下次您搜索496时， 

489
00:27:55,259 --> 00:27:57,359
you're searching for 496.
您正在搜索496。 

490
00:27:57,359 --> 00:27:58,869
And what would happen is that you
然后会发生的是你

491
00:27:58,869 --> 00:28:04,009
would go look at 586-- the slot that contained 586,
会去看586-包含586的插槽

492
00:28:04,009 --> 00:28:06,359
and you see that there's a delete me flag in there.
并且您看到那里有一个Delete me标志。 

493
00:28:06,359 --> 00:28:08,399
And so you go to the next trial.
因此，您可以进行下一次审判。 

494
00:28:08,400 --> 00:28:14,599
And then in the next trial, you discover that, in this case,
然后在下一个试验中，您发现在这种情况下， 

495
00:28:14,799 --> 00:28:19,210
you have-- I'm sorry.
你有-对不起。 

496
00:28:19,210 --> 00:28:22,329
I had 204 first as the first trial,
我第一次测试有204个

497
00:28:22,329 --> 00:28:26,109
and then in the second trial I had 586.
然后在第二次审判中我有586。 

498
00:28:26,109 --> 00:28:28,789
And I would continue beyond the second trial
我将继续进行第二次审判

499
00:28:28,789 --> 00:28:36,079
and get to third trial, and in fact return 496 in this case.
并进行第三次审判，实际上在这种情况下返回了496。 

500
00:28:36,079 --> 00:28:39,751
I would get to returning 496 in my third trial, which
我将在第三次审判中返回496，这是

501
00:28:39,751 --> 00:28:40,710
is exactly what I want.
正是我想要的

502
00:28:40,710 --> 00:28:43,779



503
00:28:43,779 --> 00:28:46,809
The interesting thing here is that you can reuse storage.
有趣的是，您可以重用存储。 

504
00:28:46,809 --> 00:28:48,849
I mean the whole point of deleting
我的意思是删除的重点

505
00:28:48,849 --> 00:28:53,879
is that you can take the storage and insert other keys in there.
就是您可以拿起存储并在其中插入其他密钥。 

506
00:28:53,880 --> 00:28:56,140
Once you've freed up the storage.
释放存储空间后。 

507
00:28:56,140 --> 00:29:01,579
And you can do that by making insert treat delete me
你可以通过使插入对待删除我来做到这一点

508
00:29:01,779 --> 00:29:03,565
the same as the none.
和没有一样。 

509
00:29:03,565 --> 00:29:05,190
So the next time you want to insert you
所以下次您要插入

510
00:29:05,190 --> 00:29:09,419
could-- if you happen to index into the index corresponding
可能-如果您碰巧索引到对应的索引中

511
00:29:09,619 --> 00:29:12,649
to 586, you can override that.
到586，您可以覆盖它。 

512
00:29:12,650 --> 00:29:15,920
The delete me flag goes away, and some other key--
 Delete me标志消失，其他一些键- 

513
00:29:15,920 --> 00:29:20,740
call it 999 or something-- would get in there.
称为999之类的东西-就会进入那里。 

514
00:29:20,740 --> 00:29:23,700
And you're all set with that.
所有人都为此设定。 

515
00:29:23,700 --> 00:29:24,539
OK?
好？ 

516
00:29:24,539 --> 00:29:26,379
Any questions?
任何问题？ 

517
00:29:26,380 --> 00:29:28,329
This all makes sense?
这一切有意义吗？ 

518
00:29:28,529 --> 00:29:33,049
So you could imagine coding this up with an array structure
因此，您可以想象使用数组结构对此进行编码

519
00:29:33,049 --> 00:29:35,099
is fairly straightforward.
非常简单。 

520
00:29:35,099 --> 00:29:38,889
What remains here to be discussed
这里还有什么要讨论

521
00:29:38,890 --> 00:29:42,170
is how well does this work, right?
效果如何？对吗？ 

522
00:29:42,170 --> 00:29:46,269
You have this extra requirement on the hash function
您对散列函数有此额外要求

523
00:29:46,269 --> 00:29:50,930
corresponding to creating an extra argument
对应于创建一个额外的参数

524
00:29:50,930 --> 00:29:53,950
as an input to it, which is this trial count.
作为输入，这就是该试用计数。 

525
00:29:53,950 --> 00:29:57,200
And you'd like to have this nice property of corresponding
而且您想拥有对应的这个不错的属性

526
00:29:57,200 --> 00:29:58,139
to a permutation.
排列。 

527
00:29:58,339 --> 00:30:01,149
Can we actually design hash functions like this?
我们真的可以设计这样的哈希函数吗？ 

528
00:30:01,150 --> 00:30:03,380
And we'll take a look at a bad hash function,
我们来看一个错误的哈希函数， 

529
00:30:03,380 --> 00:30:05,399
and then at a better one.
然后再做一个更好的。 

530
00:30:05,599 --> 00:30:08,259
So let's talk about probing strategies, which
因此，让我们谈谈探测策略， 

531
00:30:08,259 --> 00:30:15,910
is essentially the same as taking a hash function
本质上与采用哈希函数相同

532
00:30:15,910 --> 00:30:18,369
and changing it so it is actually
并更改它，以便实际上

533
00:30:18,569 --> 00:30:21,240
applicable to open addressing.
适用于开放式寻址。 

534
00:30:21,240 --> 00:30:30,480
So the notion of linear probing is
因此，线性探测的概念是

535
00:30:30,480 --> 00:30:40,920
that you do h k i equals h prime k, which
你做hki等于h素数k， 

536
00:30:40,920 --> 00:30:43,220
is some hash function that you've chosen,
是您选择的一些哈希函数， 

537
00:30:43,220 --> 00:30:49,585
plus i mod m, where this is an ordinary hash function.
加上i mod m，这是一个普通的哈希函数。 

538
00:30:49,585 --> 00:30:54,419



539
00:30:54,619 --> 00:30:55,459
OK?
好？ 

540
00:30:55,460 --> 00:30:57,000
So that looks pretty straightforward.
因此，这看起来非常简单。 

541
00:30:57,000 --> 00:31:01,279



542
00:31:01,279 --> 00:31:02,099
What happens here?
这里会发生什么？ 

543
00:31:02,099 --> 00:31:05,219
Does this satisfy the permutation argument?
这是否满足置换参数？ 

544
00:31:05,220 --> 00:31:08,785



545
00:31:08,785 --> 00:31:10,500
Before I forget.
在我忘记之前。 

546
00:31:10,500 --> 00:31:13,680
Does it satisfy the permutation property
它是否满足置换属性

547
00:31:13,680 --> 00:31:19,799
that I want h k 1, h k 2, h k m minus 1 to be a permutation?
我想让hk 1，hk 2，hk m减1是一个排列？ 

548
00:31:19,799 --> 00:31:20,579
That make sense?
有道理？ 

549
00:31:20,579 --> 00:31:21,379
Yep, yep.
是的，是的

550
00:31:21,380 --> 00:31:23,240
Because I then I start adding.
因为然后我开始添加。 

551
00:31:23,240 --> 00:31:26,779
The mod is precisely kind of this round robin cycle,
 Mod正是这种循环循环的一种， 

552
00:31:26,779 --> 00:31:28,779
so it's going to satisfy the permutation.
因此它将满足排列要求。 

553
00:31:28,779 --> 00:31:29,319
That's good.
那很好。 

554
00:31:29,319 --> 00:31:34,119



555
00:31:34,119 --> 00:31:37,169
What's wrong with this?
这怎么了

556
00:31:37,170 --> 00:31:39,419
What's wrong with this?
这怎么了

557
00:31:39,619 --> 00:31:40,119
Someone?
有人吗

558
00:31:40,119 --> 00:31:43,119



559
00:31:43,119 --> 00:31:47,619
AUDIENCE: The fact that [INAUDIBLE] keys, which they're
听众：[音频不清晰]键是

560
00:31:47,619 --> 00:31:50,619
all filled, then if you hit anywhere in here [INAUDIBLE]
全部填满，那么如果您在此处的任何地方点击[听不清] 

561
00:31:50,619 --> 00:31:51,973
list of consecutive keys.
连续键的列表。 

562
00:31:51,973 --> 00:31:52,639
AUDIENCE: Right.
听众：对。 

563
00:31:52,640 --> 00:31:53,390
That's excellent.
太好了

564
00:31:53,390 --> 00:31:54,740
Excellent, excellent answer.
很好，很好的答案。 

565
00:31:54,740 --> 00:31:59,390
So this notion of clustering is basically
所以这个聚类的概念基本上是

566
00:31:59,390 --> 00:32:01,169
what's wrong with this probing strategy.
这种探测策略有什么问题。 

567
00:32:01,369 --> 00:32:05,429
And in fact, I'm not going to do this particular analysis,
实际上，我将不进行此特定分析， 

568
00:32:05,430 --> 00:32:10,619
but I'll give you a sense of why the statement I'm going to make
但我会告诉您为什么我要发表的声明

569
00:32:10,819 --> 00:32:11,759
is true.
是真的。 

570
00:32:11,759 --> 00:32:13,839
But the notion of clustering is that you
但是集群的概念是

571
00:32:13,839 --> 00:32:18,529
start getting consecutive groups of occupied slots, OK?
开始获得连续的占用插槽组，好吗？ 

572
00:32:18,529 --> 00:32:27,849



573
00:32:27,849 --> 00:32:28,779
Which keep growing.
哪些保持增长。 

574
00:32:28,779 --> 00:32:32,819



575
00:32:32,819 --> 00:32:36,779
And so these clusters get longer and longer.
因此，这些集群变得越来越长。 

576
00:32:36,779 --> 00:32:38,950
And if you have a big cluster, it's
如果您有一个大型集群，那就是

577
00:32:38,950 --> 00:32:41,019
more likely to grow bigger, right?
变得更大的可能性更大吧？ 

578
00:32:41,019 --> 00:32:41,839
Which is bad.
不好

579
00:32:41,839 --> 00:32:44,878
This is exactly the wrong thing for load balancing, right?
这对于负载均衡而言确实是错误的，对吗？ 

580
00:32:44,878 --> 00:32:47,169
And clustering is the reverse of load balancing, right?
集群是负载平衡的逆向，对吗？ 

581
00:32:47,170 --> 00:32:48,970
If you have a bunch of clumps and you
如果你有一堆团块，你

582
00:32:48,970 --> 00:32:52,101
have a bunch of empty space in your table, that's bad.
桌子上有一堆空的空间，这很糟糕。 

583
00:32:52,101 --> 00:32:52,399
Right?
对？ 

584
00:32:52,599 --> 00:32:54,099
The problem with linear probing is
线性探测的问题是

585
00:32:54,099 --> 00:32:57,939
that once you start getting a cluster, given the, let's say,
假设您开始建立集群后， 

586
00:32:57,940 --> 00:32:59,909
the randomness in the hash function, and h prime k
哈希函数的随机性，以及h素数k 

587
00:33:00,109 --> 00:33:03,469
is a pretty good hash function and can randomly go anywhere.
是一个非常不错的哈希函数，可以随机访问任何地方。 

588
00:33:03,470 --> 00:33:07,140
Well, if you have 100 slots and you have a cluster of size 4,
好吧，如果您有100个插槽，并且集群大小为4， 

589
00:33:07,140 --> 00:33:10,900
well there's a for 4/100 chance, which is obviously
好，有4/100的机会，这很明显

590
00:33:10,900 --> 00:33:14,849
four times greater than 1/100, even I can do that,
是1/100的四倍，即使我可以做到， 

591
00:33:15,049 --> 00:33:17,759
to go into those four slots.
进入这四个插槽。 

592
00:33:17,759 --> 00:33:19,480
And if you going into those four slots
如果您进入这四个位置

593
00:33:19,480 --> 00:33:22,440
you're going to keep going down to the bottom,
您将继续走到底

594
00:33:22,440 --> 00:33:27,500
and you're going to make that a cluster of size five, right?
然后将要组成一个大小为5的簇，对吗？ 

595
00:33:27,500 --> 00:33:30,519
So that's the problem the linear probing,
这就是线性探测的问题， 

596
00:33:30,519 --> 00:33:34,289
and you can essentially argue through making
而且您基本上可以通过

597
00:33:34,289 --> 00:33:40,250
some probabilistic assumptions that if, in fact, you
一些概率假设，实际上，如果您

598
00:33:40,250 --> 00:33:47,039
use linear probing that you lose your average constant time
使用线性探测会浪费平均时间

599
00:33:47,039 --> 00:33:51,759
look up in your hash table for most load factors.
在哈希表中查找大多数负载因子。 

600
00:33:51,759 --> 00:33:54,900
So what's happening out here pictorially really
所以这真的发生在图片上

601
00:33:54,900 --> 00:33:57,669
is that you have a table and let's say you have a cluster.
是您有一张桌子，假设您有一个集群。 

602
00:33:57,869 --> 00:34:02,059



603
00:34:02,059 --> 00:34:03,460
And this is your cluster.
这就是您的集群。 

604
00:34:03,460 --> 00:34:06,220



605
00:34:06,220 --> 00:34:10,440
So if your h k 1-- it doesn't really
因此，如果您的港币1 –不是

606
00:34:10,440 --> 00:34:15,679
matter what it is-- but h k i maps to this cluster,
不管它是什么-但是h ki映射到该群集， 

607
00:34:15,679 --> 00:34:18,679
then you're going to-- linear probing
那么您将要-线性探测

608
00:34:18,679 --> 00:34:21,239
says that the next thing you're going to try
说你要尝试的下一件事

609
00:34:21,239 --> 00:34:24,543
is if you map to 42 in the cluster,
如果您在集群中映射到42， 

610
00:34:24,543 --> 00:34:25,960
the next thing you're going to try
接下来你要尝试的

611
00:34:25,960 --> 00:34:32,369
is 43, 44, until you get maybe to this slot here, which is 57,
是43、44，直到您可能到达此处的这个插槽，即57， 

612
00:34:32,369 --> 00:34:34,019
for argument's sake.
为了论证。 

613
00:34:34,019 --> 00:34:34,519
Right?
对？ 

614
00:34:34,519 --> 00:34:36,228
So you're going to keep going, and you're
所以你要继续前进，而你

615
00:34:36,228 --> 00:34:41,300
going to try 15 times in this relatively dumb fashion
将以这种相对愚蠢的方式尝试15次

616
00:34:41,300 --> 00:34:45,730
to go down to get to the open slot, which is 57.
下到空位，即57。 

617
00:34:45,730 --> 00:34:47,840
And oh, by the way, at the end of this you
哦，顺便说一句

618
00:34:47,840 --> 00:34:51,159
just increased your cluster length by one.
只是将群集长度增加了一个。 

619
00:34:51,159 --> 00:34:51,969
All right?
好吧？ 

620
00:34:51,969 --> 00:34:53,820
So it doesn't really work.
因此，它实际上不起作用。 

621
00:34:53,820 --> 00:34:58,789
And in fact, under reasonable probabilistic assumptions
实际上，在合理的概率假设下

622
00:34:58,789 --> 00:35:01,779
in terms of what your hash functions are,
就您的哈希函数而言， 

623
00:35:01,780 --> 00:35:07,650
you can say that when you have alpha, which is essentially
你可以说当你有阿尔法时

624
00:35:07,849 --> 00:35:15,612
your load factor, which is n over m less than 0.99,
您的负载系数，即m小于0.99的n倍， 

625
00:35:15,612 --> 00:35:24,839
you see clusters of size log n, OK?
您看到大小为log n的簇，好吗？ 

626
00:35:24,840 --> 00:35:25,269
Right.
对。 

627
00:35:25,469 --> 00:35:28,519
So this is a probabilistic argument,
所以这是一个概率论证， 

628
00:35:28,519 --> 00:35:30,878
and you're assuming that you have a hash function that's
并且假设您有一个哈希函数

629
00:35:30,878 --> 00:35:32,045
a pretty good hash function.
一个相当不错的哈希函数。 

630
00:35:32,045 --> 00:35:36,480
So h prime k can be this perfect hash function, all right?
那么h素数k可以是这个完美的哈希函数，好吗？ 

631
00:35:36,679 --> 00:35:39,059
So there's a problem here beyond the choice of h
所以这里的问题超出了h的选择

632
00:35:39,059 --> 00:35:42,009
prime k, which is this hash function that worked really
素数k，这是真正起作用的哈希函数

633
00:35:42,010 --> 00:35:43,880
well for chaining.
适合链接。 

634
00:35:44,079 --> 00:35:44,630
All right?
好吧？ 

635
00:35:44,630 --> 00:35:49,210
And the problem here is the linear probing aspect of it.
这里的问题是它的线性探测方面。 

636
00:35:49,409 --> 00:35:50,569
So what does that mean?
那是什么意思呢？ 

637
00:35:50,570 --> 00:35:53,590
If you have clusters of theta log n,
如果您有theta log n的簇， 

638
00:35:53,590 --> 00:35:56,829
then your search and your insert are not
那么您的搜索和插入都不是

639
00:35:56,829 --> 00:35:58,349
going to be constant time anymore.
将不再是恒定的时间。 

640
00:35:58,349 --> 00:35:58,849
Right?
对？ 

641
00:35:58,849 --> 00:36:02,179
Which is bad in a probabilistic sense.
从概率的角度来看，这是不好的。 

642
00:36:02,179 --> 00:36:04,079
OK?
好？ 

643
00:36:04,079 --> 00:36:06,009
So how do we fix that?
那么我们该如何解决呢？ 

644
00:36:06,010 --> 00:36:14,590
Well, one strategy that works reasonably well
好吧，一种有效的策略

645
00:36:14,590 --> 00:36:15,460
is called double hashing.
称为双重哈希。 

646
00:36:15,659 --> 00:36:18,589



647
00:36:18,590 --> 00:36:22,920
And it literally means what it says.
它的字面意思就是它所说的。 

648
00:36:23,119 --> 00:36:26,969
You have to run a couple of hashes.
您必须运行几个哈希。 

649
00:36:26,969 --> 00:36:37,269
And so the notion of double hashing is that you have h k i
因此，双重哈希的概念是

650
00:36:37,269 --> 00:36:47,909
equals h1 k plus i h2 k mod m.
等于h1 k加i h2 k mod m。 

651
00:36:47,909 --> 00:36:51,309
And h1 and h2 are just ordinary hash functions.
 h1和h2只是普通的哈希函数。 

652
00:36:51,309 --> 00:36:53,139
OK?
好？ 

653
00:36:53,139 --> 00:36:56,000
Now the first thing that we need to do
现在我们要做的第一件事

654
00:36:56,000 --> 00:37:01,885
is figure out how we can guarantee a permutation, right?
弄清楚我们如何保证排列，对吗？ 

655
00:37:01,885 --> 00:37:03,509
Because we still have that requirement,
因为我们仍然有这个要求， 

656
00:37:03,510 --> 00:37:05,570
and it was OK for the linear probing part,
线性探测部分还可以， 

657
00:37:05,570 --> 00:37:07,269
but you still have this requirement
但您仍然有此要求

658
00:37:07,269 --> 00:37:09,769
that you need a permutation.
您需要排列。 

659
00:37:09,769 --> 00:37:15,769
And so those of you who are into number theory,
所以你们那些从事数论的人， 

660
00:37:15,769 --> 00:37:24,559
can you tell me what property, what neat property of h2 and m
你能告诉我h2和m的什么性质

661
00:37:24,559 --> 00:37:28,150
can we ask for to guarantee a permutation?
我们可以要求保证排列吗？ 

662
00:37:28,150 --> 00:37:29,923
Do you have a question?
你有问题吗？ 

663
00:37:30,123 --> 00:37:31,309
You already do.
你已经做过了

664
00:37:31,309 --> 00:37:34,519
Do you have a question?
你有问题吗？ 

665
00:37:34,519 --> 00:37:35,980
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

666
00:37:35,980 --> 00:37:36,719
PROFESSOR: [INAUDIBLE] relatively prime.
教授：[听不清]相对素数。 

667
00:37:36,719 --> 00:37:37,459
OK, good.
好好

668
00:37:37,460 --> 00:37:39,320
So I figured some of you knew the answer,
所以我想你们当中有些人知道答案， 

669
00:37:39,320 --> 00:37:42,010
but I've seen you before.
但我以前见过你

670
00:37:42,010 --> 00:37:42,710
Right.
对。 

671
00:37:42,710 --> 00:37:43,300
Exactly right.
非常正确。 

672
00:37:43,300 --> 00:37:45,300
Relatively prime.
相对素数。 

673
00:37:45,300 --> 00:37:47,750
Just hand it to Victor.
只需将它交给维克多。 

674
00:37:47,949 --> 00:37:52,599
So h2 k and m being relatively prime,
所以h2 k和m是相对素数的

675
00:37:52,599 --> 00:38:05,714
if that implies a permutation.
如果这意味着排列。 

676
00:38:05,715 --> 00:38:08,592



677
00:38:08,592 --> 00:38:10,050
It's similar to what we had before.
它与我们以前的相似。 

678
00:38:10,050 --> 00:38:13,217
You're multiplying this by i. i keeps increasing,
你乘以我。我一直在增加， 

679
00:38:13,217 --> 00:38:14,550
and you're going to roll around.
然后你会滚来滚去。 

680
00:38:14,550 --> 00:38:14,900
All right?
好吧？ 

681
00:38:14,900 --> 00:38:16,115
I mean you could do a proof of it,
我的意思是你可以证明这一点， 

682
00:38:16,315 --> 00:38:18,219
but I'm not going to bother.
但我不会打扰。 

683
00:38:18,219 --> 00:38:20,719
The important thing here is that you can now
重要的是您现在可以

684
00:38:20,719 --> 00:38:24,759
do something as simple as m equals 2 raised to r,
做简单的事情，例如m等于2升到r， 

685
00:38:24,760 --> 00:38:33,420
and h2 k for all k is odd, and now you're in great shape.
 h2 k对于所有k都是奇数，现在您的状态很好。 

686
00:38:33,619 --> 00:38:36,250
You can have your array to be 2 raised
您可以将阵列提高2 

687
00:38:36,250 --> 00:38:39,090
to something, which is what you really want.
某种东西，这是您真正想要的。 

688
00:38:39,090 --> 00:38:41,360
And you just use h2 k.
而您只使用h2 k。 

689
00:38:41,360 --> 00:38:43,190
You could even take a regular hash function
您甚至可以使用常规的哈希函数

690
00:38:43,389 --> 00:38:48,799
and truncate it to make sure it's odd.
并截断它以确保它是奇数。 

691
00:38:48,800 --> 00:38:49,940
You can do a bunch of things.
您可以做很多事情。 

692
00:38:50,139 --> 00:38:52,980
There's hash functions that produce odd values,
散列函数会产生奇数值， 

693
00:38:52,980 --> 00:38:54,380
and you can use that.
您可以使用它。 

694
00:38:54,380 --> 00:38:54,980
All right?
好吧？ 

695
00:38:55,179 --> 00:38:58,559
And so double hashing works fairly well in practice.
因此，双哈希在实践中效果很好。 

696
00:38:58,559 --> 00:39:05,289
It's a good way of getting open addressing to work.
这是一种开放式地址工作的好方法。 

697
00:39:05,289 --> 00:39:08,809
And in order to prove that open addressing actually
并且为了证明开放地址实际上

698
00:39:08,809 --> 00:39:14,199
works to the level at which chaining works,
在链接工作的水平上工作， 

699
00:39:14,199 --> 00:39:18,379
we have to make an assumption corresponding
我们必须做出一个对应的假设

700
00:39:18,380 --> 00:39:20,960
to uniform hashing.
统一哈希。 

701
00:39:20,960 --> 00:39:25,389
And I'm not going to actually do a proof,
而且我实际上不会做证明， 

702
00:39:25,389 --> 00:39:27,319
but it'll be in the notes.
但会在笔记中。 

703
00:39:27,320 --> 00:39:33,519
But I do want to talk about the theorem and the result
但是我确实想谈一谈定理和结果

704
00:39:33,719 --> 00:39:38,319
that the theorem implies, assuming
定理所隐含的

705
00:39:38,320 --> 00:39:40,500
you have the uniform hashing assumption.
您有统一的哈希假设。 

706
00:39:40,699 --> 00:39:43,579
And let me first say that this is not
首先让我说这不是

707
00:39:43,579 --> 00:39:49,920
the same as simple uniform happening, which
就像发生简单的制服一样

708
00:39:49,920 --> 00:39:54,409
talks about the independence of keys in terms of their mapping
讨论键映射的独立性

709
00:39:54,409 --> 00:39:55,649
to slots.
到插槽。 

710
00:39:55,650 --> 00:39:57,980
The uniform hashing assumption says
统一哈希假设说

711
00:39:57,980 --> 00:40:11,230
that each key is equally likely to have
每个键都具有相同的可能性

712
00:40:11,230 --> 00:40:19,250
any one of the m factorial permutations--
 m个阶乘置换中的任何一个- 

713
00:40:19,250 --> 00:40:21,019
so we're talking about random permutations
所以我们在谈论随机排列

714
00:40:21,019 --> 00:40:24,780
here-- as its probe sequence.
此处-作为其探测序列。 

715
00:40:24,780 --> 00:40:30,880



716
00:40:31,079 --> 00:40:31,650
All right?
好吧？ 

717
00:40:31,650 --> 00:40:33,730
This is very hard to get in practice.
这很难付诸实践。 

718
00:40:33,929 --> 00:40:38,109
You can get pretty close using double hashing.
您可以使用双散列获得相当接近的效果。 

719
00:40:38,110 --> 00:40:40,920
But nobody's discovered a perfect hash function,
但是没有人发现完美的哈希函数， 

720
00:40:41,119 --> 00:40:44,572
deterministic hash function that satisfies this property.
满足此属性的确定性哈希函数。 

721
00:40:44,572 --> 00:40:45,780
At least not that I know off.
至少不是我知道。 

722
00:40:45,780 --> 00:40:48,090



723
00:40:48,289 --> 00:40:49,380
So what does this imply?
那么，这意味着什么呢？ 

724
00:40:49,380 --> 00:40:53,340
Assuming that you have this and double hatching
假设您有这个并且有双重阴影

725
00:40:53,340 --> 00:40:58,980
gives you this property, to a large extent what this means is
赋予您此属性，这在很大程度上意味着

726
00:40:59,179 --> 00:41:03,169
that if alpha is n over m, you can
如果alpha在m上是n，则可以

727
00:41:03,170 --> 00:41:18,280
show that the cost of operations such as search, insert, delete,
表明诸如搜索，插入，删除， 

728
00:41:18,280 --> 00:41:19,690
et cetera.
等等。 

729
00:41:19,690 --> 00:41:22,539
And in particular we talk about insert
特别是我们谈论插入

730
00:41:22,739 --> 00:41:27,209
is less than or equal to 1 divided by 1 minus alpha.
小于或等于1除以1减去alpha。 

731
00:41:27,210 --> 00:41:29,150
OK?
好？ 

732
00:41:29,150 --> 00:41:33,650
So obviously this goes as alpha tends to 1.
因此很明显，随着alpha趋向于1。 

733
00:41:33,650 --> 00:41:40,789
As alpha tends to 1, the load factor in the table gets large,
随着alpha趋于1，表中的负载因子变大， 

734
00:41:40,989 --> 00:41:44,179
and the number of expected probes
以及预期的探测数量

735
00:41:44,179 --> 00:41:47,919
that you need to do when you get an insert grows.
插入插入后需要执行的操作会增加。 

736
00:41:47,920 --> 00:41:52,130
And if alpha is 0.99, you're going, on average,
如果alpha为0.99，则平均而言， 

737
00:41:52,130 --> 00:41:54,000
require 100 probes.
需要100个探针。 

738
00:41:54,199 --> 00:41:56,960
It's a constant number, but it's a pretty bad constant.
这是一个常数，但它是一个非常糟糕的常数。 

739
00:41:56,960 --> 00:41:57,460
Right?
对？ 

740
00:41:57,460 --> 00:42:01,050
So you really want alpha to be fairly small.
因此，您确实希望alpha很小。 

741
00:42:01,050 --> 00:42:03,130
And in practice it turns out that you
实际上，您发现

742
00:42:03,130 --> 00:42:05,519
have to re-size you're open addressing table
必须重新调整您要打开的地址表的大小

743
00:42:05,719 --> 00:42:10,189
when alpha gets beyond about 0.5, 0.6 or so,
当alpha超过约0.5、0.6左右时， 

744
00:42:10,190 --> 00:42:13,132
because by then you're really in trouble.
因为那时你真的很麻烦。 

745
00:42:13,132 --> 00:42:15,340
Remember this is an average case we're talking about.
请记住，这是我们正在谈论的平均情况。 

746
00:42:15,340 --> 00:42:18,250
All of this is using a probabilistic assumption.
所有这些都是使用概率假设。 

747
00:42:18,250 --> 00:42:21,780
But as you get to high alphas, suddenly
但是当您达到高Alpha值时，突然

748
00:42:21,780 --> 00:42:24,519
by the time you get to 0.7, open addressing
到0.7时，打开寻址

749
00:42:24,719 --> 00:42:28,929
doesn't work well in relation to an equivalent table
相对于等效表而言效果不佳

750
00:42:28,929 --> 00:42:32,460
with the overall number of slots that
与插槽总数

751
00:42:32,460 --> 00:42:35,190
correspond to a changing table, OK?
对应一张换尿布台好不好

752
00:42:35,190 --> 00:42:39,019
So open addressing is easy to implement.
因此，开放寻址很容易实现。 

753
00:42:39,019 --> 00:42:42,170
It uses less memory because you don't need pointers.
它使用较少的内存，因为您不需要指针。 

754
00:42:42,170 --> 00:42:47,369
But you better be careful that your alpha stays around 0.5
但是您最好注意您的alpha值保持在0.5左右

755
00:42:47,369 --> 00:42:48,480
and no more.
仅此而已。 

756
00:42:48,480 --> 00:42:50,880
So all that means is you can still use it.
因此，这意味着您仍然可以使用它。 

757
00:42:50,880 --> 00:42:52,547
You just have to re-size your table.
您只需要调整桌子的大小即可。 

758
00:42:52,547 --> 00:42:54,130
You have slightly different strategies
您的策略略有不同

759
00:42:54,130 --> 00:42:56,230
for resizing your table when you use open
在使用open时调整表的大小

760
00:42:56,429 --> 00:43:03,579
addressing as opposed to chaining hash tables.
寻址而不是链接哈希表。 

761
00:43:03,579 --> 00:43:04,349
All right?
好吧？ 

762
00:43:04,349 --> 00:43:06,130
So that's a summary of open addressing.
这就是开放地址的摘要。 

763
00:43:06,130 --> 00:43:09,192
I want to spend some time on cryptographic hashes
我想花一些时间在加密散列上

764
00:43:09,391 --> 00:43:10,599
in the time that I have left.
在我离开的时候

765
00:43:10,599 --> 00:43:12,380
I guess I have a few minutes left.
我想我还剩几分钟。 

766
00:43:12,380 --> 00:43:15,940
But any questions about open addressing?
但是对开放式寻址有任何疑问吗？ 

767
00:43:15,940 --> 00:43:17,114
Yep?
是的

768
00:43:17,114 --> 00:43:18,875
AUDIENCE: On this delete part, what's
听众：在这个删除部分，什么是

769
00:43:18,875 --> 00:43:21,570
going to happen if, say, you fill the table up and then
例如，如果您填满桌子，然后发生

770
00:43:21,570 --> 00:43:24,019
delete everything, and then you start searching.
删除所有内容，然后开始搜索。 

771
00:43:24,019 --> 00:43:26,143
Isn't that going to be bad because it's
那不是很糟糕，因为

772
00:43:26,143 --> 00:43:27,601
going to search through everything?
要搜索所有内容？ 

773
00:43:27,601 --> 00:43:29,480
PROFESSOR: So that's right.
教授：没错。 

774
00:43:29,679 --> 00:43:31,210
The bad thing about open addressing
开放式寻址的坏处

775
00:43:31,210 --> 00:43:34,789
is that delete isn't instantaneous, right?
是删除不是瞬时的，对吗？ 

776
00:43:34,989 --> 00:43:37,889
In the sense that if you deleted something from the link list
从某种意义上说，如果您从链接列表中删除了某些内容

777
00:43:37,889 --> 00:43:40,000
in your chaining table, then even
在您的链接表中，然后甚至

778
00:43:40,000 --> 00:43:43,469
if you went to that same thing, the chain got smaller,
如果你去做同样的事情，连锁店会变小， 

779
00:43:43,469 --> 00:43:46,849
and that helps you, because your table now has lower load.
这对您有所帮助，因为您的表现在具有较低的负载。 

780
00:43:46,849 --> 00:43:49,989
But there's a delay associated with load
但是与负载有关的延迟

781
00:43:49,989 --> 00:43:52,129
when you have the delete me flag.
当您有Delete me标志时。 

782
00:43:52,130 --> 00:43:52,630
OK?
好？ 

783
00:43:52,630 --> 00:43:56,610
So in some sense the alpha that you want to think about,
因此，从某种意义上讲，您要考虑的Alpha， 

784
00:43:56,610 --> 00:43:59,615
you should be careful as to how you define alpha.
您应该谨慎定义Alpha。 

785
00:43:59,815 --> 00:44:01,189
And that's one of the reasons why
这就是为什么

786
00:44:01,190 --> 00:44:03,673
when you get alpha being 0.5, 0.6
当您得到的alpha为0.5、0.6 

787
00:44:03,873 --> 00:44:06,289
you get into trouble, because if you have all these delete
您会遇到麻烦，因为如果您将所有这些删除

788
00:44:06,289 --> 00:44:09,079
me flags, they're still hurting you.
我的旗帜，他们仍然在伤害你。 

789
00:44:09,079 --> 00:44:10,699
AUDIENCE: And when you resize do those
观众：当您调整大小时， 

790
00:44:10,699 --> 00:44:12,668
delete me flags get deleted?
删除我的标志会被删除吗？ 

791
00:44:12,668 --> 00:44:14,210
PROFESSOR: When you completely resize
教授：完全调整大小后

792
00:44:14,210 --> 00:44:15,519
and you redo the whole thing, then you
然后重做整个事情，然后

793
00:44:15,719 --> 00:44:17,927
can clean up the delete me's and turn them into nones
可以清理删除我的东西并将它们变成无

794
00:44:17,927 --> 00:44:22,210
because you're rehashing it.
因为您正在重新哈希它。 

795
00:44:22,210 --> 00:44:22,849
All right.
好吧。 

796
00:44:22,849 --> 00:44:24,339
So yeah, back there.
是的，回到那里。 

797
00:44:24,340 --> 00:44:24,840
Question?
题？ 

798
00:44:24,840 --> 00:44:26,530
AUDIENCE: Yes, can you explain how you got the equation
听众：是的，您能解释一下如何得出方程式吗？ 

799
00:44:26,530 --> 00:44:28,547
that the cost of operation insert is less than
插入的操作成本小于

800
00:44:28,746 --> 00:44:30,993
or equal to 1 over [INAUDIBLE].
或等于[听不清]的1。 

801
00:44:30,994 --> 00:44:32,210
PROFESSOR: That's a longish proof,
教授：这是一个长期的证明， 

802
00:44:32,409 --> 00:44:36,629
but let me explain to you how that comes out.
但让我向您解释结果如何。 

803
00:44:36,630 --> 00:44:39,369
Basically the intuition behind the proof
基本上是证明背后的直觉

804
00:44:39,369 --> 00:44:45,079
is that we're going to assume some probability p.
我们将假设某个概率p。 

805
00:44:45,079 --> 00:44:48,409
And initially you're going to say something
首先，您要说些什么

806
00:44:48,409 --> 00:44:58,079
like if the table, your p-- I'll just write this out here--
就像桌子一样，您的p--我会在这里写出来- 

807
00:44:58,079 --> 00:45:02,299
is m minus n divided by m.
是m减去n除以m。 

808
00:45:02,300 --> 00:45:03,150
So what is that?
那是什么

809
00:45:03,349 --> 00:45:06,619
Right now I have n elements in the table,
现在我在表中有n个元素， 

810
00:45:06,619 --> 00:45:12,389
and I have m slots, OK?
我有m个插槽，好吗？ 

811
00:45:12,389 --> 00:45:17,529
So the probability that my very first trial is going to succeed
所以我的第一次审判会成功的可能性

812
00:45:17,530 --> 00:45:22,360
is going to be m minus n divided by m, because these
将是m减去n除以m，因为这些

813
00:45:22,360 --> 00:45:24,250
are the number of empty slots.
是空插槽的数量。 

814
00:45:24,250 --> 00:45:26,579
And assuming my permutation argument,
并假设我的排列参数

815
00:45:26,579 --> 00:45:28,239
I could go into one of them.
我可以进入其中之一。 

816
00:45:28,239 --> 00:45:30,259
And so that's what I have here.
这就是我在这里所拥有的。 

817
00:45:30,260 --> 00:45:36,010
And if you look at what this is, this is 1 minus alpha, OK?
如果您看这是什么，这是1减去alpha，好吗？ 

818
00:45:36,010 --> 00:45:38,269
And so then you run off and you remember
所以你逃跑了，你记得

819
00:45:38,469 --> 00:45:41,164
6041 or the high school probability course
 6041或高中概率课程

820
00:45:41,164 --> 00:45:44,380
that you take, and you say generally speaking,
您所接受的，通常来说， 

821
00:45:44,380 --> 00:45:47,269
you're going to be no worse than p for every trial.
每次试用都不会比p差。 

822
00:45:47,469 --> 00:45:49,839
And so if you assume the worst and say
因此，如果您假设最坏的情况并说

823
00:45:49,840 --> 00:45:52,190
every trial has a probability of success of p,
每个审判都有成功的概率p， 

824
00:45:52,389 --> 00:45:56,039
the expected number of trials is 1/p, OK?
预期的试验次数是1 / p，好吗？ 

825
00:45:56,039 --> 00:46:00,079
And that's how you got the 1 over 1 minus alpha.
这就是您获得1比1减去alpha的方式。 

826
00:46:00,079 --> 00:46:04,029
So you'll see that written in gory detail in the notes.
因此，您会在注释中看到详细内容。 

827
00:46:04,030 --> 00:46:05,030
All right?
好吧？ 

828
00:46:05,030 --> 00:46:06,269
OK.
好。 

829
00:46:06,269 --> 00:46:08,369
Expected to have a little more time
预计会有更多时间

830
00:46:08,369 --> 00:46:11,380
in terms of talking about cryptographic hashes,
在谈论加密哈希时， 

831
00:46:11,380 --> 00:46:15,039
but cryptographic hashes are not going to be on the quiz.
但是加密哈希将不再是测验。 

832
00:46:15,039 --> 00:46:19,920
This is purely material FYI.
仅供参考。 

833
00:46:19,920 --> 00:46:22,159
For your interest only.
仅出于您的兴趣。 

834
00:46:22,159 --> 00:46:24,579
And again I have some notes on it,
再说一遍， 

835
00:46:24,579 --> 00:46:28,389
but I want to give you a sense of the other kinds of hashes
但我想让您了解其他类型的哈希

836
00:46:28,389 --> 00:46:34,369
that exist in the world, I guess.
我猜这是存在的。 

837
00:46:34,369 --> 00:46:39,849
And hashes that are used for many different applications.
以及用于许多不同应用程序的哈希。 

838
00:46:39,849 --> 00:46:42,069
So maybe the best way of motivating this
所以也许是激发这一点的最好方法

839
00:46:42,070 --> 00:46:43,789
is through an example.
通过一个例子。 

840
00:46:43,989 --> 00:46:46,879
So let's talk about an example that
所以我们来谈一个例子

841
00:46:46,880 --> 00:46:51,280
is near and dear to every security person's heart
在每个安全人员的心中都是亲爱的

842
00:46:51,280 --> 00:46:55,050
and probably to people who aren't interested in security
可能对那些对安全性不感兴趣的人

843
00:46:55,050 --> 00:46:58,420
as well, which is password storage.
以及密码存储。 

844
00:46:58,619 --> 00:47:01,750
So think about how, let's say, Unix systems
因此，考虑一下Unix系统如何

845
00:47:01,750 --> 00:47:04,650
work when you type in your password.
当您输入密码时可以正常工作。 

846
00:47:04,650 --> 00:47:06,650
You're typing in your password [INAUDIBLE],
您正在输入密码[音频不清晰]， 

847
00:47:06,650 --> 00:47:09,460
and this is true for other systems as well,
其他系统也是如此

848
00:47:09,460 --> 00:47:11,650
but you have a password.
但是您有密码。 

849
00:47:11,650 --> 00:47:16,269
And my password is a permutation of my first daughters
我的密码是我第一个女儿的排列

850
00:47:16,469 --> 00:47:18,909
first name.
名字。 

851
00:47:18,909 --> 00:47:21,039
[LAUGHTER]
 [笑声] 

852
00:47:21,039 --> 00:47:24,880
Yeah, but haven't given it away, right?
是的，但是还没有放弃，对吧？ 

853
00:47:24,880 --> 00:47:27,289
Haven't given it away.
还没有放弃。 

854
00:47:27,289 --> 00:47:29,509
And so this password is something
所以这个密码就是

855
00:47:29,510 --> 00:47:33,230
that I'm typing in every day, right?
我每天都在输入，对吗？ 

856
00:47:33,429 --> 00:47:36,759
Now the sum check that needs to happen
现在需要进行总和检查

857
00:47:36,760 --> 00:47:40,460
to ensure that I'm typing in the right password.
确保输入正确的密码。 

858
00:47:40,659 --> 00:47:43,609
So what is a dumb way of doing things.
那么什么是愚蠢的做事方式。 

859
00:47:43,610 --> 00:47:46,210
What's a dumb way of building systems?
什么是愚蠢的构建系统方式？ 

860
00:47:46,210 --> 00:47:49,510
AUDIENCE: Storing [INAUDIBLE].
听众：存储[音频不清晰]。 

861
00:47:49,510 --> 00:47:52,322
PROFESSOR: This is kind of a freebie.
教授：这是一种免费赠品。 

862
00:47:52,521 --> 00:47:54,235
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

863
00:47:54,235 --> 00:47:55,360
PROFESSOR: In situ hashing.
教授：原位哈希。 

864
00:47:55,360 --> 00:47:58,710
That's better.
这样更好

865
00:47:58,710 --> 00:48:00,010
So you'd store it.
所以你要存储它。 

866
00:48:00,010 --> 00:48:01,070
I offered the dumb way.
我提供了愚蠢的方式。 

867
00:48:01,070 --> 00:48:03,230
So there's a perfectly valid answer.
因此，有一个完全正确的答案。 

868
00:48:03,230 --> 00:48:06,449
So you could clearly store this in plain text in some file
因此，您可以清楚地将其以纯文本格式存储在某个文件中

869
00:48:06,449 --> 00:48:09,719
and you could call it slash etc slaw password.
您可以将其称为斜线等色拉密码。 

870
00:48:09,719 --> 00:48:14,199
And you could make it read for the work, right?
您可以将其读为工作，对吗？ 

871
00:48:14,199 --> 00:48:17,289
And that'd be great, and people do that, right?
那会很棒，人们会这样做，对吗？ 

872
00:48:17,289 --> 00:48:19,769
But what you would rather do is you
但是你宁愿做的是你

873
00:48:19,769 --> 00:48:24,579
want to make sure that even the sysadmin doesn't know
想要确保即使系统管理员也不知道

874
00:48:24,579 --> 00:48:27,630
my password or your password, right?
我的密码或您的密码，对不对？ 

875
00:48:27,630 --> 00:48:28,940
So how do you do that?
那你怎么做呢？ 

876
00:48:29,139 --> 00:48:32,109
Well you do that using a cryptographic hash that
好吧，您可以使用加密哈希来实现

877
00:48:32,110 --> 00:48:36,400
has this interesting property that is one way, OK?
有这个有趣的属性是一种方法，好吗？ 

878
00:48:36,400 --> 00:48:42,369
And what that means is that given h of x-- OK,
这意味着给定x的h-好吧， 

879
00:48:42,369 --> 00:48:45,460
this is the value of the hash-- it
这是哈希值- 

880
00:48:45,460 --> 00:48:55,619
is very hard to find the x such that x basically
很难找到这样的x 

881
00:48:55,619 --> 00:48:56,789
hashes to this value.
哈希值。 

882
00:48:56,789 --> 00:49:02,380
So if h of x equals let's call it q,
因此，如果x的h等于q， 

883
00:49:02,380 --> 00:49:08,710
then you're only given h of x.
那么您只得到x的h。 

884
00:49:08,909 --> 00:49:11,750
And so what do you do now?
那你现在怎么办？ 

885
00:49:11,750 --> 00:49:13,360
Well, it's beautiful.
好吧，很漂亮。 

886
00:49:13,360 --> 00:49:16,710
Assuming you have this one way hash, this cryptographic hash,
假设您有这种单向哈希，这种密码哈希， 

887
00:49:16,710 --> 00:49:23,110
in your etc slash password file, you
在您的等斜杠密码文件中，您

888
00:49:23,110 --> 00:49:31,780
have something like login name, [INAUDIBLE],
具有类似登录名，[音频不清晰]， 

889
00:49:31,780 --> 00:49:35,250
which happens to be the hash of my daughter's first name,
碰巧是我女儿名字的哈希， 

890
00:49:35,449 --> 00:49:36,529
or something.
或者其他的东西。 

891
00:49:36,530 --> 00:49:41,000
But this is what's stored in there and the same thing
但这是存储在其中的东西

892
00:49:41,000 --> 00:49:43,139
for a bunch of different users, right?
对很多不同的用户吧？ 

893
00:49:43,139 --> 00:49:46,969
So when I log in and I type in the actual password,
因此，当我登录并输入实际密码时， 

894
00:49:46,969 --> 00:49:48,669
what does the system do?
该系统做什么？ 

895
00:49:48,670 --> 00:49:51,119
What does the system do?
该系统做什么？ 

896
00:49:51,119 --> 00:49:52,130
It hashes it.
它哈希它。 

897
00:49:52,130 --> 00:50:00,300
It takes x prime, which is the typed in password, which
它需要x个质数，这是输入的密码， 

898
00:50:00,300 --> 00:50:04,106
may or may not be equal to my password,
可能等于或可能不等于我的密码， 

899
00:50:04,306 --> 00:50:06,389
because somebody else might be trying to break in,
因为可能有人试图闯入， 

900
00:50:06,389 --> 00:50:11,519
or I just mistyped, or forgot my daughter's first name,
或者我只是输错了字，或者忘记了我女儿的名字， 

901
00:50:11,519 --> 00:50:13,250
which would be bad.
那就不好了

902
00:50:13,250 --> 00:50:18,699
And it will just check to see-- it doesn't need x, because it's
它只会检查-不需要x，因为它是

903
00:50:18,699 --> 00:50:23,649
stored h of x in the system, so it doesn't need x.
将x的h存储在系统中，因此不需要x。 

904
00:50:23,650 --> 00:50:27,300
So if we just compare against what I typed in,
因此，如果我们将其与我输入的内容进行比较， 

905
00:50:27,300 --> 00:50:28,630
it would compute the hash again.
它将再次计算哈希。 

906
00:50:28,829 --> 00:50:33,699
And then would let me in assuming that these things
然后让我假设这些事情

907
00:50:33,699 --> 00:50:36,529
matched and would not let me in if it didn't.
匹配，如果不匹配，不会让我进入。 

908
00:50:36,530 --> 00:50:38,860
So now we can talk about-- and I don't have time for this,
所以现在我们可以谈论-我没有时间

909
00:50:39,059 --> 00:50:41,835
but you can certainly read up on it on Wikipedia
但您当然可以在Wikipedia上阅读它

910
00:50:41,835 --> 00:50:43,344
and a bunch in the notes.
和一堆笔记。 

911
00:50:43,344 --> 00:50:44,760
You can talk about what properties
你可以说说什么属性

912
00:50:44,760 --> 00:50:48,039
should this hash function have, namely one way collision
该散列函数应具有的功能，即单向冲突

913
00:50:48,239 --> 00:50:50,949
resistance, in order to solve these problems
抵抗，以解决这些问题

914
00:50:50,949 --> 00:50:52,019
and other problems.
和其他问题。 

915
00:50:52,019 --> 00:50:57,019
I'm happy to stick around and answer questions.
我很乐意坚持并回答问题。 

