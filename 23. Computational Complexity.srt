1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,225
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,225 --> 00:00:17,850
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,850 --> 00:00:22,719



10
00:00:22,719 --> 00:00:26,269
PROFESSOR: Today, we are going to do computational complexity.
教授：今天，我们要进行计算的复杂性。 

11
00:00:26,269 --> 00:00:28,989
This is rather different from every other thing
这与其他事物有很大的不同

12
00:00:28,989 --> 00:00:30,030
we've seen in this class.
我们在这堂课上见过

13
00:00:30,030 --> 00:00:32,728



14
00:00:32,728 --> 00:00:36,119
This class is basically about polynomial time algorithms
此类基本上是关于多项式时间算法的

15
00:00:36,119 --> 00:00:38,579
and problems where we can solve your problem
和问题，我们可以解决您的问题

16
00:00:38,579 --> 00:00:40,289
in polynomial time.
在多项式时间内

17
00:00:40,289 --> 00:00:43,129
And today, it's about when you can't do that.
而今天，这是您什么时候做不到的。 

18
00:00:43,130 --> 00:00:44,880
Sometimes, we can prove you can't do that.
有时，我们可以证明您无法做到这一点。 

19
00:00:44,880 --> 00:00:47,020
Sometimes, we're pretty sure you can't do that.
有时候，我们很确定您不能这样做。 

20
00:00:47,020 --> 00:00:49,140
But it's all about negative results
但这全都是负面的结果

21
00:00:49,140 --> 00:00:52,850
when your problems are really complex.
当您的问题真的很复杂时。 

22
00:00:52,850 --> 00:00:55,039
And there's a lot of fun topics, here.
这里有很多有趣的话题。 

23
00:00:55,039 --> 00:00:59,280
This is the topic of entire classes, like 6045.
这是整个课程的主题，例如6045。 

24
00:00:59,280 --> 00:01:02,950
We're just going to get a 1 hour flavor of it.
我们将得到一个1小时的味道。 

25
00:01:02,950 --> 00:01:04,519
So think of it as a high level intro.
因此，可以将其视为高级介绍。 

26
00:01:04,519 --> 00:01:06,893
But we're going to prove real theorems and do real things
但是我们将证明真实定理并做真实的事情

27
00:01:06,893 --> 00:01:09,579
and you'll get a sense of how all this works.
您将了解所有这些工作原理。 

28
00:01:09,579 --> 00:01:13,679
So I'm going to start out with three complexity classes--
所以我将从三个复杂度类开始

29
00:01:13,680 --> 00:01:21,390
P, EXP, and R. How many people know what P is?
 P，EXP和R。有多少人知道P是什么？ 

30
00:01:21,390 --> 00:01:23,760
And it is?
是吗

31
00:01:23,760 --> 00:01:25,789
Polynomial time.
多项式时间。 

32
00:01:25,989 --> 00:01:28,509
More precisely, it's the set of all problems
更确切地说，这是所有问题的集合

33
00:01:28,510 --> 00:01:30,060
you can solve in polynomial time.
您可以在多项式时间内求解。 

34
00:01:30,060 --> 00:01:35,590



35
00:01:35,590 --> 00:01:37,090
This is what the class is all about.
这就是课程的全部内容。 

36
00:01:37,090 --> 00:01:39,736



37
00:01:39,736 --> 00:01:41,109
Almost every problem we have seen
我们几乎看到的每个问题

38
00:01:41,109 --> 00:01:44,409
in this class-- there's one exception-- is
在这一堂课中-有一个例外- 

39
00:01:44,409 --> 00:01:48,959
in P. Does anyone know the exception?
在P中。有人知道例外吗？ 

40
00:01:48,959 --> 00:01:51,149
It's a good puzzle for you.
这对您来说是个好难题。 

41
00:01:51,150 --> 00:01:51,739
Not NP.
不是NP。 

42
00:01:51,939 --> 00:01:52,439
What's next?
下一步是什么？ 

43
00:01:52,439 --> 00:01:55,120
EXP.
经验值

44
00:01:55,120 --> 00:01:56,459
How many people know what EXP is?
有多少人知道EXP是什么？ 

45
00:01:56,659 --> 00:01:58,810
Or you can guess.
或者你可以猜。 

46
00:01:58,810 --> 00:02:00,400
Any guesses?
有什么猜想吗？ 

47
00:02:00,400 --> 00:02:01,569
Exponential.
指数

48
00:02:01,569 --> 00:02:04,109
These are all the problems you can solve in exponential time.
这些都是您可以在指数时间内解决的所有问题。 

49
00:02:04,109 --> 00:02:21,189



50
00:02:21,189 --> 00:02:23,210
If you want to be formal about it, in this case,
如果您想对此保持正式态度，在这种情况下， 

51
00:02:23,210 --> 00:02:29,000
exponential means 2 to the n to some constant.
指数表示2到n的常数。 

52
00:02:29,199 --> 00:02:31,699
So not just 2 the n, but also 2 to the n squared, 2 to the n
因此，不仅2个n，而且2个与n平方，2个与n 

53
00:02:31,699 --> 00:02:32,198
cubed.
立方体。 

54
00:02:32,199 --> 00:02:34,150
Those are all considered-- exponential
这些都被认为-指数

55
00:02:34,349 --> 00:02:38,049
and a polynomial is considered in the class EXP.
在EXP类中考虑多项式。 

56
00:02:38,050 --> 00:02:41,810
Now, basically, almost every problem you can dream of you
现在，基本上，您可以梦想的几乎所有问题

57
00:02:42,009 --> 00:02:43,169
can solve in EXP.
可以解决EXP。 

58
00:02:43,169 --> 00:02:45,369
Exponential time is so much time.
指数时间是如此之多。 

59
00:02:45,370 --> 00:02:47,705
And this class has always been about taking things that
这堂课一直是关于

60
00:02:47,705 --> 00:02:51,460
are obviously in EXP and showing that they're actually in P.
显然在EXP中，表明他们实际上在P中。 

61
00:02:51,460 --> 00:02:53,120
So if you want to draw a picture,
因此，如果您想画一幅画， 

62
00:02:53,120 --> 00:02:54,870
you could say, OK, here's all the problems
你可以说，好的，这就是所有问题

63
00:02:54,870 --> 00:02:57,069
we can solve in polynomial time.
我们可以在多项式时间内求解。 

64
00:02:57,069 --> 00:03:00,287
Here's all the problems we can solve in exponential time.
这是我们可以在指数时间内解决的所有问题。 

65
00:03:00,287 --> 00:03:01,620
And there are problems out here.
这里有问题。 

66
00:03:01,620 --> 00:03:03,189
These are different classes.
这些是不同的类。 

67
00:03:03,389 --> 00:03:06,069
And we want to sort of bring things
我们想带些东西

68
00:03:06,069 --> 00:03:09,620
into here as much as possible.
尽可能地进入这里。 

69
00:03:09,620 --> 00:03:11,939
I actually want to draw this picture
我真的想画这张画

70
00:03:11,939 --> 00:03:16,050
in a different way, which is as a horizontal line.
以另一种方式，即一条水平线。 

71
00:03:16,050 --> 00:03:20,560



72
00:03:20,759 --> 00:03:21,715
So an axis.
所以一个轴。 

73
00:03:21,715 --> 00:03:24,860



74
00:03:24,860 --> 00:03:27,949
I'm going to call this computational difficulty.
我将这种计算难度称为“计算困难”。 

75
00:03:27,949 --> 00:03:29,740
You could call it computational complexity,
您可以称其为计算复杂度， 

76
00:03:29,740 --> 00:03:30,930
but that's a bit of a loaded term that
但这是一个负载词

77
00:03:30,930 --> 00:03:32,469
actually has formal meaning.
实际上具有正式意义。 

78
00:03:32,469 --> 00:03:34,000
Difficulty is nice and vague.
困难是美好而模糊的。 

79
00:03:34,000 --> 00:03:36,039
So I can draw an abstract picture.
所以我可以画一张抽象画。 

80
00:03:36,039 --> 00:03:38,459
This is not a true diagram, but it's
这不是一个真正的图，但它是

81
00:03:38,460 --> 00:03:40,770
a very good guideline of what's going on.
关于正在发生的事情的很好的指导方针。 

82
00:03:40,770 --> 00:03:46,905
So we have-- I'm going to draw-- I believe-- three notches.
因此，我们有-我要画-我相信-三个缺口。 

83
00:03:46,905 --> 00:03:50,199



84
00:03:50,199 --> 00:03:52,769
No, eventually four, so let me give myself some room.
不，最终有四个，所以让我给自己一些空间。 

85
00:03:52,770 --> 00:03:56,280



86
00:03:56,479 --> 00:04:01,919
We have over here, the easy problems are P. Then,
我们到了这里，简单的问题是P。然后， 

87
00:04:01,919 --> 00:04:05,179
we have these problems, which are EXP.
我们有这些问题，即EXP。 

88
00:04:05,180 --> 00:04:08,930
We're going to fill in something in the middle.
我们将在中间填充一些内容。 

89
00:04:08,930 --> 00:04:11,909
And then this is something called R.
然后这就是所谓的R。 

90
00:04:11,909 --> 00:04:13,409
So you've got P is everything, here.
因此，这里有P就是一切。 

91
00:04:13,409 --> 00:04:19,139
EXP is all the way out to here, in some abstract view.
从某种角度来说，EXP一直到这里。 

92
00:04:19,139 --> 00:04:23,289
The next thing is R. How many people know what R is?
接下来是R。有多少人知道R是什么？ 

93
00:04:23,290 --> 00:04:26,250
This one, I had to look up.
这个，我不得不抬头。 

94
00:04:26,250 --> 00:04:29,779
It's not usually given a name.
通常不会给它起一个名字。 

95
00:04:29,779 --> 00:04:30,804
No one.
没有人。 

96
00:04:30,805 --> 00:04:31,430
Teaching staff?
教学人员？ 

97
00:04:31,430 --> 00:04:32,444
You guys know it?
你们知道吗？ 

98
00:04:32,444 --> 00:04:36,500



99
00:04:36,500 --> 00:04:39,899
These are all problems solvable in finite time.
这些都是在有限时间内可以解决的问题。 

100
00:04:39,899 --> 00:04:40,909
R stands for finite.
 R代表有限。 

101
00:04:40,910 --> 00:04:49,980



102
00:04:49,980 --> 00:04:52,079
R stands for recursive.
 R代表递归。 

103
00:04:52,279 --> 00:04:54,529
Recursive used to mean something completely different,
递归曾经意味着完全不同的东西， 

104
00:04:54,529 --> 00:04:56,862
back in the '30s, when people were thinking about what's
早在30年代，当人们在想什么

105
00:04:56,862 --> 00:04:58,470
computable, what's not computable.
可计算的，不可计算的。 

106
00:04:58,470 --> 00:05:02,189
These are, basically, solvable problems, computable problems.
这些基本上是可解决的问题，可计算的问题。 

107
00:05:02,389 --> 00:05:04,889
Finite time is a reasonable requirement, I think,
我认为有限的时间是合理的要求， 

108
00:05:04,889 --> 00:05:06,104
for all algorithms.
适用于所有算法。 

109
00:05:06,105 --> 00:05:09,689
And that's R. Now, I've drawn this arrow
那是R。现在，我画了这个箭头

110
00:05:09,689 --> 00:05:13,105
to keep going because there are problems out here.
继续前进，因为这里有问题。 

111
00:05:13,105 --> 00:05:14,605
It's kind of discouraging, but there
有点令人气,，但在那里

112
00:05:14,605 --> 00:05:16,879
are problems that are unsolvable.
是无法解决的问题。 

113
00:05:17,079 --> 00:05:19,976
In fact, most problems are unsolvable.
实际上，大多数问题是无法解决的。 

114
00:05:19,976 --> 00:05:21,060
We're going to prove that.
我们将证明这一点。 

115
00:05:21,060 --> 00:05:23,339
It's actually really easy to prove.
实际上，这很容易证明。 

116
00:05:23,339 --> 00:05:28,359
Kind of depressing, but true.
有点令人沮丧，但事实如此。 

117
00:05:28,360 --> 00:05:31,819
Let me start with some examples before we get to that proof.
在获得证明之前，让我先举一些例子。 

118
00:05:31,819 --> 00:05:36,199



119
00:05:36,199 --> 00:05:40,729
So I'm writing examples of some things we've seen.
所以我在写一些我们已经看到的东西的例子。 

120
00:05:40,730 --> 00:05:44,170
So here's an example of a problem we've seen.
因此，这是我们已经看到的一个问题的示例。 

121
00:05:44,170 --> 00:05:47,740



122
00:05:47,740 --> 00:05:49,095
Negative-weight cycle detection.
负重循环检测。 

123
00:05:49,095 --> 00:05:52,314



124
00:05:52,314 --> 00:05:54,439
I give you a graph-- a weighted graph.
我给你一个图-加权图。 

125
00:05:54,439 --> 00:05:58,089
I want to know does it have any negative-weight cycles?
我想知道它是否有负重循环？ 

126
00:05:58,089 --> 00:06:00,560
What classes is this problem in?
这个问题在什么课上？ 

127
00:06:00,560 --> 00:06:03,050
P. We know how to solve this in polynomial time--
 P.我们知道如何在多项式时间内解决这个问题- 

128
00:06:03,050 --> 00:06:06,259
in VE time-- using Bellman-Ford.
 VE时代-使用Bellman-Ford。 

129
00:06:06,259 --> 00:06:08,649
VE time-- well, that finds negative-weight cycles
 VE时间-很好，找到负体重循环

130
00:06:08,649 --> 00:06:09,539
reachable from s.
可从s到达。 

131
00:06:09,540 --> 00:06:11,370
But, I guess, if you add a source that
但是，我想，如果您添加一个源

132
00:06:11,370 --> 00:06:14,389
can reach anywhere-- zero weight-- then
可以达到零重量的任何地方，然后

133
00:06:14,389 --> 00:06:18,389
that'll tell you overall that it's in P.
总体上将告诉您它在P中。 

134
00:06:18,389 --> 00:06:19,639
It's also in EXP, of course.
当然，它也在EXP中。 

135
00:06:19,639 --> 00:06:21,322
Everything in P is also in EXP.
 P中的所有内容也都在EXP中。 

136
00:06:21,322 --> 00:06:23,079
Because if you can solve it in polynomial time,
因为如果可以在多项式时间内求解， 

137
00:06:23,279 --> 00:06:25,289
you can solve it in exponential time.
您可以在指数时间内解决它。 

138
00:06:25,290 --> 00:06:29,230
This is at most exponential time.
这最多是指数时间。 

139
00:06:29,230 --> 00:06:30,048
At most polynomial.
最多多项式。 

140
00:06:30,048 --> 00:06:33,439



141
00:06:33,439 --> 00:06:35,680
Here's a problem we haven't seen.
这是我们未曾见过的问题。 

142
00:06:35,680 --> 00:06:37,160
But it's pretty cool.
但这很酷。 

143
00:06:37,160 --> 00:06:39,189
N by n Chess.
国际象棋。 

144
00:06:39,189 --> 00:06:41,319
So this is the problem I give you.
所以这就是我给你的问题。 

145
00:06:41,319 --> 00:06:43,439
So we're in an by n board, and I give you
所以我们在一个n董事会中，我给你

146
00:06:43,439 --> 00:06:45,689
a whole bunch of pieces on the board,
板上的一大堆碎片

147
00:06:45,689 --> 00:06:48,889
and I want to know does White win from here?
我想知道怀特从这里赢了吗？ 

148
00:06:48,889 --> 00:06:51,659
I say it's White to move or Black to move,
我说是白色移动或黑色移动， 

149
00:06:51,660 --> 00:06:55,250
and who's going to win form this position?
谁将从这个位置赢得胜利？ 

150
00:06:55,250 --> 00:06:59,084
This problem, can be solved in exponential time.
这个问题，可以在指数时间内解决。 

151
00:06:59,084 --> 00:07:02,079
You can sort of play out all possible strategies
您可以整理出所有可能的策略

152
00:07:02,079 --> 00:07:05,209
and see who wins.
看看谁赢了。 

153
00:07:05,209 --> 00:07:10,060
And it's not in P. There's no polynomial time algorithm
而且不在P中。没有多项式时间算法

154
00:07:10,060 --> 00:07:12,149
to play generalized Chess.
玩广义象棋。 

155
00:07:12,149 --> 00:07:15,250
This sort of captures why Chess-- even at eight by eight
这种记录说明了为什么国际象棋-即使是八乘八

156
00:07:15,250 --> 00:07:17,509
Chess-- is hard-- because there's no general way
象棋-很难-因为没有通用的方法

157
00:07:17,509 --> 00:07:19,219
to do it.
去做吧。 

158
00:07:19,220 --> 00:07:23,009
So there's no special way to do it, probably.
因此，可能没有特殊的方法可以做到这一点。 

159
00:07:23,209 --> 00:07:25,779
Computational complexity is all about order of growth.
计算复杂性全与增长顺序有关。 

160
00:07:25,779 --> 00:07:27,769
So we can't analyze eight by eight Chess,
因此，我们无法分析八乘八的国际象棋， 

161
00:07:27,769 --> 00:07:29,289
but we can analyze n by n Chess.
但是我们可以用n Chess来分析n 

162
00:07:29,290 --> 00:07:32,290
And that gives us a flavor of why 8 by 8 is so difficult.
这使我们明白了为什么8乘8如此困难。 

163
00:07:32,290 --> 00:07:37,000
Go is also in EXP, but not in P-- lots of games
 Go也出现在EXP中，但不在P中-很多游戏

164
00:07:37,000 --> 00:07:41,430
are in this category, lot's of complicated games, let's say.
可以说，这类游戏非常复杂。 

165
00:07:41,430 --> 00:07:45,129
And so this is a first example of a problem that we know we
这是我们知道的第一个问题示例

166
00:07:45,129 --> 00:07:48,930
cannot solve in polynomial time.
不能在多项式时间内求解。 

167
00:07:48,930 --> 00:07:50,879
Bad news.
坏消息。 

168
00:07:50,879 --> 00:07:53,069
I also talked about Tetris a little bit.
我还谈到了俄罗斯方块。 

169
00:07:53,069 --> 00:07:56,939



170
00:07:56,939 --> 00:07:58,920
Unlike the Tetris training, which we saw,
与我们看到的俄罗斯方块训练不同， 

171
00:07:58,920 --> 00:08:00,629
this is sort of realistic Tetris--
这是一种现实的俄罗斯方块- 

172
00:08:00,629 --> 00:08:02,339
all the rules of Tetris.
俄罗斯方块的所有规则。 

173
00:08:02,339 --> 00:08:04,989
The only catch is that I tell you all the pieces that
唯一的收获是我告诉你所有的碎片

174
00:08:04,990 --> 00:08:06,470
are going to come in advance.
将会提前。 

175
00:08:06,470 --> 00:08:08,442
Because, otherwise, it's some random process
因为，否则，这是一个随机过程

176
00:08:08,442 --> 00:08:10,824
and it's kind of hard to think about what's the best strategy.
而且很难考虑什么是最佳策略。 

177
00:08:11,024 --> 00:08:13,524
But if I tell you what's going to come--
但是，如果我告诉你会发生什么…… 

178
00:08:13,524 --> 00:08:14,939
say it's a pseudo-random generator
说这是伪随机生成器

179
00:08:14,939 --> 00:08:16,365
and you know how it works.
而且您知道它是如何工作的。 

180
00:08:16,365 --> 00:08:17,990
You know all the pieces that will come.
您知道将要发生的所有事情。 

181
00:08:17,990 --> 00:08:22,829
I want to know can I survive from a given initial board mess
我想知道我能否在给定的初始董事会混乱中生存

182
00:08:22,829 --> 00:08:24,979
and for a given sequence of pieces.
和给定的片段顺序。 

183
00:08:24,980 --> 00:08:27,740
This can also be solved in exponential time.
这也可以在指数时间内解决。 

184
00:08:27,740 --> 00:08:29,574
Just try all the possibilities.
只要尝试所有可能性。 

185
00:08:29,574 --> 00:08:34,779



186
00:08:34,779 --> 00:08:45,759
We don't know whether it's in P. We're pretty sure
我们不知道它是否在P中。我们很确定

187
00:08:45,759 --> 00:08:47,919
it's not in P. And by the end of today's lecture,
它不在P中。在今天的演讲结束时， 

188
00:08:47,919 --> 00:08:51,500
you'll understand why we think it's not in P.
您将了解为什么我们认为它不在P中。 

189
00:08:51,500 --> 00:08:54,929
But it's going to be somewhere in between here.
但这将介于两者之间。 

190
00:08:54,929 --> 00:08:57,109
Tetris is actually right here.
俄罗斯方块实际上就在这里。 

191
00:08:57,110 --> 00:08:59,409
But I haven't defined what right here is yet.
但是我还没有定义这里的内容。 

192
00:08:59,409 --> 00:09:06,039



193
00:09:06,039 --> 00:09:10,459
And then the next one is halting problem.
然后下一个是停止问题。 

194
00:09:10,460 --> 00:09:24,720



195
00:09:24,720 --> 00:09:27,139
So halting problem is particularly cool,
因此，暂停问题特别酷， 

196
00:09:27,139 --> 00:09:29,319
as we'll see-- or interesting.
如我们所见-或很有趣。 

197
00:09:29,320 --> 00:09:34,710
It's the problem of given a computer program-- Python,
这是给定计算机程序的问题-Python， 

198
00:09:34,710 --> 00:09:37,339
whatever, it doesn't really matter what language.
随便什么语言都没关系

199
00:09:37,539 --> 00:09:42,149
They're all the same in a theoretical sense--
从理论上讲，它们都是一样的- 

200
00:09:42,149 --> 00:09:43,004
does it ever halt?
有没有停止过？ 

201
00:09:43,004 --> 00:09:46,679



202
00:09:46,679 --> 00:09:50,334
Does it ever stop running, return a result, whatever?
它会停止运行，返回结果吗？ 

203
00:09:50,335 --> 00:09:53,070



204
00:09:53,070 --> 00:09:55,600
This would be really handy-- you're writing some code,
这真的很方便-您正在编写一些代码， 

205
00:09:55,600 --> 00:09:58,360
and you've run it for 5 hours, and you
您已经运行了5个小时，而您

206
00:09:58,360 --> 00:10:00,120
don't know is that because there's a bug
不知道是因为有错误

207
00:10:00,120 --> 00:10:01,452
and you've got an infinite loop?
你有一个无限循环？ 

208
00:10:01,452 --> 00:10:04,000
Or is it just because it's really slow?
还是仅仅是因为它真的很慢？ 

209
00:10:04,000 --> 00:10:08,136
So you'd like to give it to some program-- checking
所以您想将其提供给某些程序-检查

210
00:10:08,136 --> 00:10:09,844
program-- that says will this run forever
程序-这将永远运行

211
00:10:09,845 --> 00:10:11,532
or will it terminate.
否则它将终止。 

212
00:10:11,532 --> 00:10:12,959
That's the halting problem.
那是停顿的问题。 

213
00:10:13,159 --> 00:10:17,079
And this problem is not in R. There
而且这个问题不在R中。 

214
00:10:17,080 --> 00:10:20,259
is no correct algorithm for solving this problem.
没有解决此问题的正确算法。 

215
00:10:20,259 --> 00:10:24,269
There's no way to tell, given an arbitrary program,
在任意程序的情况下，无法分辨

216
00:10:24,269 --> 00:10:25,840
whether it will halt.
是否会停止。 

217
00:10:25,840 --> 00:10:28,129
Now, in some situations-- take the empty program--
现在，在某些情况下-选择空程序- 

218
00:10:28,129 --> 00:10:29,629
I can tell that it halts.
我可以说它停止了。 

219
00:10:29,629 --> 00:10:33,580
Or I take some special simple class of programs,
或者我选一些特别简单的程序

220
00:10:33,580 --> 00:10:36,889
I can tell whether they halt or determine that they don't halt.
我可以告诉他们是停止还是确定他们不停止。 

221
00:10:36,889 --> 00:10:40,889
But there's no algorithm that solves it for all programs,
但是没有一种算法可以解决所有程序， 

222
00:10:40,889 --> 00:10:42,379
in finite time.
在有限的时间内。 

223
00:10:42,379 --> 00:10:44,330
In infinite time, I can solve it.
在无限时间内，我可以解决它。 

224
00:10:44,330 --> 00:10:46,339
Just run it.
只是运行它。 

225
00:10:46,539 --> 00:10:48,339
Run the program.
运行程序。 

226
00:10:48,340 --> 00:10:50,340
Given finite time, there's no way to solve this.
在有限的时间内，无法解决此问题。 

227
00:10:50,340 --> 00:10:53,370
And so this is a little bit beyond what we can prove today.
因此，这超出了我们今天可以证明的范围。 

228
00:10:53,370 --> 00:10:54,929
It's not that hard to prove, but it
证明并不难，但是

229
00:10:54,929 --> 00:10:56,439
takes half an hour or something.
需要半个小时左右。 

230
00:10:56,440 --> 00:10:57,690
I want to get to other things.
我想了解其他事情。 

231
00:10:57,690 --> 00:11:01,819
But if you take 6045, they'll prove this.
但是，如果您使用6045，他们会证明这一点。 

232
00:11:02,019 --> 00:11:03,990
What I want to show you instead is an easier
我想告诉你的是更容易的

233
00:11:03,990 --> 00:11:29,799
result-- that almost every problem is not in R.
结果-几乎每个问题都不在R中。 

234
00:11:29,799 --> 00:11:32,679
I need one term, though, which is decision problems.
不过，我需要一个术语，即决策问题。 

235
00:11:32,679 --> 00:11:35,049
All of these problems, I set it up in a way
所有这些问题，我都将其设置为

236
00:11:35,049 --> 00:11:37,555
that the answer is binary-- yes or no.
答案是二进制的-是或否。 

237
00:11:37,556 --> 00:11:38,729
Is there a negative-weight cycle?
是否存在负体重循环？ 

238
00:11:38,929 --> 00:11:41,089
Yes or no?
是还是不是？ 

239
00:11:41,090 --> 00:11:43,950
Does White win from this position in Chess?
怀特会从国际象棋这个位置获胜吗？ 

240
00:11:43,950 --> 00:11:46,000
Can you survive in Tetris?
你可以在俄罗斯方块生存吗？ 

241
00:11:46,000 --> 00:11:48,240
And does this program halt?
并且该程序停止了吗？ 

242
00:11:48,240 --> 00:11:51,229
For various reasons-- basically convenience--
由于各种原因-基本上是方便- 

243
00:11:51,429 --> 00:11:53,319
the whole field of computational complexity
计算复杂度的整个领域

244
00:11:53,320 --> 00:11:56,349
focuses on decision problems.
专注于决策问题。 

245
00:11:56,549 --> 00:11:59,370
And, in fact-- so decision problems
而且，事实上-决策问题

246
00:11:59,370 --> 00:12:01,080
are ones where the answer is yes or no.
是答案为是或否的答案。 

247
00:12:01,080 --> 00:12:02,719
That's all.
就这样。 

248
00:12:02,919 --> 00:12:03,879
Why?
为什么？ 

249
00:12:03,879 --> 00:12:05,519
Essentially because it doesn't matter.
本质上是因为这无关紧要。 

250
00:12:05,519 --> 00:12:07,919
If you take a problem you care about,
如果您担心自己遇到的问题， 

251
00:12:07,919 --> 00:12:10,199
you can convert it into a decision problem.
您可以将其转换为决策问题。 

252
00:12:10,200 --> 00:12:12,759
We can see examples of that later.
我们稍后会看到示例。 

253
00:12:12,759 --> 00:12:14,289
Decision problems are basically as
决策问题基本上是

254
00:12:14,289 --> 00:12:17,988
hard as optimization problems or whatever.
作为优化问题或其他困难。 

255
00:12:17,989 --> 00:12:19,329
But let's focus on decision problems.
但是，让我们关注决策问题。 

256
00:12:19,529 --> 00:12:20,919
The answer is yes or no.
答案是是或否。 

257
00:12:20,919 --> 00:12:23,589
Claim that most of them are uncomputable.
声称其中大多数没有争议。 

258
00:12:23,590 --> 00:12:26,100
And we can prove this pretty easily
我们可以很容易地证明这一点

259
00:12:26,100 --> 00:12:30,389
if you know a bit of set theory, I guess.
如果您了解一些集合论，我想。 

260
00:12:30,389 --> 00:12:35,308



261
00:12:35,308 --> 00:12:37,350
On the one hand, I have problems I want to solve.
一方面，我有要解决的问题。 

262
00:12:37,350 --> 00:12:38,519
These are decision problems.
这些是决策问题。 

263
00:12:38,519 --> 00:12:41,220
And on the other hand, I have algorithms,
另一方面，我有算法

264
00:12:41,220 --> 00:12:42,820
or computer programs to solve them.
或计算机程序来解决它们。 

265
00:12:42,820 --> 00:12:44,445
I'm going to think of computer programs
我要考虑计算机程序

266
00:12:44,445 --> 00:12:46,439
because more precise algorithms can
因为更精确的算法可以

267
00:12:46,639 --> 00:12:50,230
be a little bit nebulous for thinking about pseudocode--
对于伪代码的思考有点模糊- 

268
00:12:50,230 --> 00:12:51,460
what's valid, what's invalid.
什么是有效的，什么是无效的。 

269
00:12:51,460 --> 00:12:53,610
But computer programs are very clear.
但是计算机程序非常清楚。 

270
00:12:53,610 --> 00:12:55,048
I give you some code.
我给你一些代码。 

271
00:12:55,048 --> 00:12:56,090
You throw it into Python.
您将其放入Python。 

272
00:12:56,090 --> 00:12:57,500
Either it works or it doesn't.
它要么起作用，要么不起作用。 

273
00:12:57,500 --> 00:12:59,552
And it does something.
而且它有作用。 

274
00:12:59,552 --> 00:13:00,259
Runs for a while.
运行一段时间。 

275
00:13:00,259 --> 00:13:04,080



276
00:13:04,080 --> 00:13:08,750
How can I think about the space of all possible programs?
我如何考虑所有可能程序的空间？ 

277
00:13:08,750 --> 00:13:12,019
Well, programs are things you type into a computer
好吧，程序就是您输入计算机的东西

278
00:13:12,019 --> 00:13:13,399
in ASCII, whatever.
以ASCII格式表示。 

279
00:13:13,399 --> 00:13:16,379
In the end, you can think of it as just as a binary string.
最后，您可以将其视为二进制字符串。 

280
00:13:16,379 --> 00:13:18,059
Somehow it gets encoded in binary.
它以某种方式被编码为二进制。 

281
00:13:18,059 --> 00:13:21,869
Everything is reduced to binary in the end, on a computer.
最后，在计算机上所有内容都简化为二进制。 

282
00:13:21,870 --> 00:13:27,340
So this is a binary string.
所以这是一个二进制字符串。 

283
00:13:27,340 --> 00:13:29,229
Now, you can also think of a binary string
现在，您还可以想到一个二进制字符串

284
00:13:29,429 --> 00:13:33,279
as representing a number, in binary.
以二进制形式表示数字。 

285
00:13:33,279 --> 00:13:34,870
So you can also think of a program,
所以您也可以想到一个程序

286
00:13:34,870 --> 00:13:38,960
then, as a natural number-- some number between 0 and infinity.
然后，作为自然数-0到无穷大之间的某个数字。 

287
00:13:38,960 --> 00:13:41,870
And an integer.
和一个整数。 

288
00:13:41,870 --> 00:13:45,850
So usually we represent this as math bold N.
因此通常我们将其表示为数学粗体N。 

289
00:13:45,850 --> 00:13:48,470
That's just 0, 1, 2, 3.
就是0、1、2、3。 

290
00:13:48,470 --> 00:13:50,469
You can think of every program is ultimately
您可以想到每个程序最终

291
00:13:50,669 --> 00:13:51,959
reducing to an integer.
减少为整数。 

292
00:13:51,960 --> 00:13:53,615
It's a big integer, but, hey.
这是一个大整数，但是，嘿。 

293
00:13:53,615 --> 00:13:55,769
It's an integer.
这是一个整数。 

294
00:13:55,769 --> 00:13:57,646
So that's the space of all programs.
这就是所有程序的空间。 

295
00:13:57,647 --> 00:14:00,230
Now, I want to think about the space of all decision problems.
现在，我想考虑所有决策问题的空间。 

296
00:14:00,230 --> 00:14:02,899



297
00:14:02,899 --> 00:14:06,473
So how can I define a decision problem?
那么如何定义决策问题呢？ 

298
00:14:06,474 --> 00:14:08,439
Well, the natural way to think of a decision problem
好吧，思考决策问题的自然方法

299
00:14:08,639 --> 00:14:12,649
is as a function that maps inputs to yes or no.
是将输入映射为是或否的函数。 

300
00:14:12,649 --> 00:14:19,350



301
00:14:19,350 --> 00:14:28,229
Function from inputs to yes or no.
从输入到是或否的功能。 

302
00:14:28,429 --> 00:14:32,309
Or you can think of that as 1 and 0.
或者，您可以将其视为1和0。 

303
00:14:32,309 --> 00:14:34,309
So what's an input?
那么输入是什么？ 

304
00:14:34,309 --> 00:14:36,219
Well, an input is a binary string.
嗯，输入是一个二进制字符串。 

305
00:14:36,220 --> 00:14:39,000
So an input is a number-- a natural number.
因此，输入就是一个数字-一个自然数。 

306
00:14:39,000 --> 00:14:41,789



307
00:14:41,789 --> 00:14:51,579
Input is a binary string, which we can think of as being in N.
输入是一个二进制字符串，我们可以认为它是N。 

308
00:14:51,580 --> 00:14:58,570
So we've got a function from N to 0,1.
因此我们有一个从N到0,1的函数。 

309
00:14:58,570 --> 00:15:03,000
So another way to represent one of these functions
所以代表这些功能之一的另一种方法

310
00:15:03,000 --> 00:15:04,220
is as a table.
是一张桌子。 

311
00:15:04,220 --> 00:15:06,070
I could just write down all the answers.
我可以写下所有答案。 

312
00:15:06,070 --> 00:15:10,110
So I've got, well, the input could be 0-- the number 0.
所以我得到的输入可以是0-数字0。 

313
00:15:10,110 --> 00:15:11,969
And then, maybe it's a 0.
然后，可能是0。 

314
00:15:11,969 --> 00:15:14,059
Input could be could be 1 and then, maybe, output is 0.
输入可能是1，然后输出可能是0。 

315
00:15:14,259 --> 00:15:21,750
Then, the input could be 2, 3, 4, 5, 1, 0, 1, 1, whatever.
然后，输入可能是2、3、4、5、1、0、1、1。 

316
00:15:21,750 --> 00:15:24,509
So I could write the table of all answers.
所以我可以写所有答案的表。 

317
00:15:24,509 --> 00:15:28,429
This is another way to write down such a function.
这是写下这种功能的另一种方式。 

318
00:15:28,429 --> 00:15:32,109
What we have, here, is an infinite string of bits.
在这里，我们拥有的是无限的比特串。 

319
00:15:32,110 --> 00:15:34,289
Each of them could be 0 or 1.
它们每个可以是0或1。 

320
00:15:34,289 --> 00:15:36,809
It would be a different problem.
这将是一个不同的问题。 

321
00:15:36,809 --> 00:15:37,849
But they all exist.
但是它们都存在。 

322
00:15:37,850 --> 00:15:40,859
Any infinite string of bits represents a decision problem.
任何无限的比特串都代表决策问题。 

323
00:15:41,059 --> 00:15:42,750
They're the same thing.
他们是同一回事。 

324
00:15:42,750 --> 00:15:45,950
So a decision problem is an infinite string of bits.
因此，决策问题是无限的位字符串。 

325
00:15:45,950 --> 00:15:49,676
A program is a finite string of bits.
程序是有限的位字符串。 

326
00:15:49,676 --> 00:15:52,259
These are different things.
这些是不同的东西。 

327
00:15:52,259 --> 00:15:54,169
One way to see that they're different
看到他们与众不同的一种方式

328
00:15:54,169 --> 00:15:57,639
is put a decimal point, here.
在这里放一个小数点。 

329
00:15:57,639 --> 00:15:59,629
Now, this infinite string of bits
现在，这无限的比特串

330
00:15:59,629 --> 00:16:03,710
is a number-- a real number-- between 0 and 1.
是介于0和1之间的数字-实数。 

331
00:16:03,710 --> 00:16:04,720
It's written in binary.
它用二进制编写。 

332
00:16:04,720 --> 00:16:07,426
You may not be used to binary point.
您可能不习惯二进制点。 

333
00:16:07,626 --> 00:16:08,959
This dot is not a decimal point.
该点不是小数点。 

334
00:16:08,960 --> 00:16:09,979
It's a binary point.
这是一个二进制点。 

335
00:16:10,179 --> 00:16:12,969
But, hey.
但是，嘿。 

336
00:16:12,970 --> 00:16:15,839
Any real number can be expressed by an infinite string of bits
任何实数都可以由无限的位字符串表示

337
00:16:16,039 --> 00:16:18,819
in this way-- any real number between 0 and 1.
以这种方式-0到1之间的任何实数

338
00:16:18,820 --> 00:16:22,210



339
00:16:22,210 --> 00:16:31,940
So a decision problem is basically
所以决策问题基本上是

340
00:16:31,940 --> 00:16:35,059
something in R, the set of all real numbers,
 R中的所有实数集

341
00:16:35,259 --> 00:16:38,554
whereas a program is something in N, the set of all integers.
而程序是N中的所有整数。 

342
00:16:38,554 --> 00:16:41,750



343
00:16:41,750 --> 00:16:45,360
And the thing is, the number of real numbers
问题是实数

344
00:16:45,360 --> 00:16:50,460
is much, much bigger than the number of integers.
比整数的数量大得多。 

345
00:16:50,460 --> 00:16:53,110
In a formal sense, we call this one uncountably infinite,
从正式意义上讲，我们称其为无限， 

346
00:16:53,110 --> 00:16:54,859
and this one is countably infinite.
而这一点是无限的。 

347
00:16:55,059 --> 00:16:56,829
I'm not going to prove that here, today.
我今天不会在这里证明这一点。 

348
00:16:56,830 --> 00:16:59,009
You may have seen that proof.
您可能已经看到了这一证明。 

349
00:16:59,009 --> 00:17:01,319
It's pretty simple.
很简单

350
00:17:01,320 --> 00:17:02,350
And that's bad news.
那是个坏消息。 

351
00:17:02,350 --> 00:17:04,828
That means that there are way more problems
这意味着还有更多问题

352
00:17:04,828 --> 00:17:07,549
than there are programs to solve them.
而不是有解决方案。 

353
00:17:07,549 --> 00:17:12,889
So this means almost every problem that we could conceive
所以这意味着我们可以想到的几乎所有问题

354
00:17:12,890 --> 00:17:16,525
of is unsolvable by every program.
每个程序都无法解决。 

355
00:17:16,525 --> 00:17:30,399



356
00:17:30,599 --> 00:17:33,244
And this is pretty depressing the first time I saw it.
这是我第一次看到它时非常沮丧。 

357
00:17:33,244 --> 00:17:35,119
That's why we put it at the end of the class.
这就是为什么我们将其放在课程末尾。 

358
00:17:35,119 --> 00:17:37,949



359
00:17:37,950 --> 00:17:40,160
I think you get all existential.
我想你们都存在。 

360
00:17:40,160 --> 00:17:41,839
I mean the thing is every program only
我的意思是，只有每个程序

361
00:17:42,039 --> 00:17:43,201
solves one problem.
解决了一个问题。 

362
00:17:43,201 --> 00:17:44,700
It takes some input, and it's either
它需要一些输入，或者是

363
00:17:44,700 --> 00:17:46,247
going to output yes or no.
将输出是或否。 

364
00:17:46,247 --> 00:17:48,379
And if it's wrong on any of the inputs, then it's wrong.
而且，如果在任何输入上都错了，那就错了。 

365
00:17:48,579 --> 00:17:51,009
So it's going to give an answer.
因此，它将给出一个答案。 

366
00:17:51,009 --> 00:17:52,569
Say it's a deterministic algorithm.
说这是确定性算法。 

367
00:17:52,569 --> 00:17:55,950
No random numbers or things.
没有随机数或事物。 

368
00:17:55,950 --> 00:17:57,670
Then, there's just not enough programs
那就是程序不够

369
00:17:57,670 --> 00:18:01,402
to go around if each program only solves one problem.
如果每个程序都只能解决一个问题，那就去解决。 

370
00:18:01,402 --> 00:18:02,409
This is the end of the proof.
证明到此结束。 

371
00:18:02,609 --> 00:18:05,109
Any questions about that?
对此有任何疑问吗？ 

372
00:18:05,109 --> 00:18:07,389
Kind of weird.
有点奇怪。 

373
00:18:07,390 --> 00:18:10,390
Because yet somehow, most of the problems that we think about
因为无论如何，我们考虑的大多数问题

374
00:18:10,390 --> 00:18:11,329
are computable.
是可计算的。 

375
00:18:11,529 --> 00:18:13,099
I don't know why that is.
我不知道为什么。 

376
00:18:13,099 --> 00:18:15,519
But mathematically, most problems
但是从数学上讲，大多数问题

377
00:18:15,519 --> 00:18:17,424
that you could think of are uncomputable.
您可能认为这是无可争议的。 

378
00:18:17,424 --> 00:18:21,450



379
00:18:21,450 --> 00:18:22,973
Question?
题？ 

380
00:18:22,973 --> 00:18:23,889
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

381
00:18:23,890 --> 00:18:27,649



382
00:18:27,849 --> 00:18:28,750
PROFESSOR: Yeah.
教授：是的。 

383
00:18:28,750 --> 00:18:32,269
It's something like, the way that we describe
就像我们描述的方式

384
00:18:32,269 --> 00:18:35,990
problems is usually almost algorithmic, anyway.
无论如何，问题通常几乎都是算法上的。 

385
00:18:35,990 --> 00:18:39,609
And so, usually, most problems we think of are in EXP.
因此，通常，我们想到的大多数问题都在EXP中。 

386
00:18:39,609 --> 00:18:42,299
And so they're definitely computable.
因此，它们绝对是可计算的。 

387
00:18:42,299 --> 00:18:43,819
There's some metatheorem about how
关于如何有一些元定理

388
00:18:43,819 --> 00:18:46,384
we think about problems, not just programs.
我们不仅考虑程序，还考虑问题。 

389
00:18:46,384 --> 00:18:51,109



390
00:18:51,109 --> 00:18:53,969
So that's all I'm going to say about R. So out here,
这就是我要说的R。所以在这里， 

391
00:18:53,970 --> 00:18:57,971
we have halting problem and, actually, most problems.
我们有停顿的问题，实际上是大多数问题。 

392
00:18:57,971 --> 00:18:59,680
You can think of this as an infinite line
您可以将其视为一条无限线

393
00:18:59,680 --> 00:19:01,980
and then there's just this small portion
然后只有一小部分

394
00:19:01,980 --> 00:19:03,839
which are things you can solve.
您可以解决的问题。 

395
00:19:03,839 --> 00:19:05,879
But we care about this portion because that's
但是我们关心这部分，因为那是

396
00:19:05,880 --> 00:19:06,839
the interesting stuff.
有趣的东西。 

397
00:19:07,039 --> 00:19:08,750
That's what algorithms are about.
这就是算法的意义所在。 

398
00:19:08,750 --> 00:19:13,559
Out here kind of nothing happens.
在这里什么也没发生。 

399
00:19:13,559 --> 00:19:17,069
So I want to talk about this notch, which is NP.
所以我想谈谈这个缺口，即NP。 

400
00:19:17,069 --> 00:19:22,746



401
00:19:22,747 --> 00:19:23,879
I imagine you've heard about NP.
我想您已经听说过NP。 

402
00:19:24,079 --> 00:19:27,251



403
00:19:27,251 --> 00:19:30,240
It's pretty cool, but also kind of confusing.
这很酷，但也有点令人困惑。 

404
00:19:30,240 --> 00:19:34,615



405
00:19:34,615 --> 00:19:37,889
But it's actually very closely related to something
但这实际上与某件事密切相关

406
00:19:37,890 --> 00:19:42,119
we've seen with dynamic programming, which is guessing.
我们已经看到了动态编程，这是猜测。 

407
00:19:42,319 --> 00:19:44,460
So I'm going to give you a couple of definitions
所以我要给你几个定义

408
00:19:44,460 --> 00:19:48,285
of NP-- not formal definition, but high level definitions.
 NP的定义-不是正式定义，而是高级定义。 

409
00:19:48,285 --> 00:19:52,210



410
00:19:52,210 --> 00:19:57,149
So just like P, EXP, and R, it's a set of decision problems.
因此，就像P，EXP和R，这是一组决策问题。 

411
00:19:57,349 --> 00:20:03,649
And it's going to look very similar to P. NP does not
它看起来与P非常相似。NP不

412
00:20:03,650 --> 00:20:05,640
stand for not a polynomial.
代表不是多项式。 

413
00:20:05,640 --> 00:20:08,750
It stands for nondeterministic polynomial.
它代表不确定的多项式。 

414
00:20:08,750 --> 00:20:12,329
We'll get to nondeterministic in a moment.
一会儿我们将变得不确定。 

415
00:20:12,329 --> 00:20:14,435
The first line is the same.
第一行是相同的。 

416
00:20:14,435 --> 00:20:17,740
It's all decision problems you can solve in polynomial time.
您可以在多项式时间内解决所有决策问题。 

417
00:20:17,740 --> 00:20:19,720
That sounds like P. But then, there's
听起来像P。但是然后， 

418
00:20:19,720 --> 00:20:25,480
this extra line, which is via a "lucky" algorithm.
这条额外的线是通过“幸运”算法完成的。 

419
00:20:25,480 --> 00:20:33,730



420
00:20:33,730 --> 00:20:36,839
Let me tell you-- at a high level what
让我告诉您-高层次

421
00:20:36,839 --> 00:20:40,433
a lucky algorithm does is it can make guesses.
幸运的算法确实可以做出猜测。 

422
00:20:40,433 --> 00:20:42,474
But unlike the way that we've been making guesses
但是与我们一直在猜测的方式不同

423
00:20:42,474 --> 00:20:44,359
with dynamic programming-- with dynamic programming
动态编程-动态编程

424
00:20:44,359 --> 00:20:45,442
we had to guess something.
我们不得不猜测一些事情。 

425
00:20:45,442 --> 00:20:47,190
We tried all the possibilities.
我们尝试了所有可能性。 

426
00:20:47,190 --> 00:20:50,596
A lucky algorithm just needs to try one possibility
幸运算法只需要尝试一种可能性

427
00:20:50,596 --> 00:20:51,680
because it's really lucky.
因为真的很幸运

428
00:20:51,680 --> 00:20:54,659
It always guesses the right choice.
它总是猜测正确的选择。 

429
00:20:54,859 --> 00:20:56,439
It's like magic.
就像魔术。 

430
00:20:56,440 --> 00:20:59,309
This is not a realistic model of computation,
这不是现实的计算模型， 

431
00:20:59,309 --> 00:21:04,470
but it is a model of computation called nondeterministic model.
但这是一种计算模型，称为非确定性模型。 

432
00:21:04,470 --> 00:21:09,039



433
00:21:09,039 --> 00:21:11,950
And it's going to sound crazy because it is crazy,
听起来会很疯狂，因为它很疯狂， 

434
00:21:11,950 --> 00:21:14,879
but nonetheless it's actually really useful--
但尽管如此，它实际上确实非常有用- 

435
00:21:15,079 --> 00:21:17,409
even though you could never really build
即使你永远无法真正建造

436
00:21:17,410 --> 00:21:19,576
this on a real computer.
在真实的计算机上。 

437
00:21:19,576 --> 00:21:20,950
The nondeterministic model is not
非确定性模型不是

438
00:21:20,950 --> 00:21:22,115
a model of real computation.
真实计算的模型。 

439
00:21:22,115 --> 00:21:25,410
It is a model of theoretical hypothetical computation.
它是理论假设计算的模型。 

440
00:21:25,410 --> 00:21:27,099
It gets at the root-- at the core
它扎根-核心

441
00:21:27,299 --> 00:21:29,730
of what is possible to solve.
有什么可能解决的。 

442
00:21:29,730 --> 00:21:32,799
You'll see why, in a little bit.
稍后，您会明白为什么。 

443
00:21:32,799 --> 00:21:39,799
So in this model, an algorithm-- it can compute stuff,
因此，在此模型中，一种算法-它可以计算东西， 

444
00:21:39,799 --> 00:21:43,682
but, in particular, it makes guesses.
但是，它尤其让人猜测。 

445
00:21:43,682 --> 00:21:46,029
So should I do this or should I do this?
那么我应该这样做还是应该这样做？ 

446
00:21:46,029 --> 00:21:48,789
And it just says-- It doesn't flip a coin.
它只是说-它不会掷硬币。 

447
00:21:48,789 --> 00:21:50,009
It's not random.
这不是随机的。 

448
00:21:50,009 --> 00:21:53,990
It just thinks-- it just makes a guess.
它只是在想-这只是一个猜测。 

449
00:21:53,990 --> 00:21:54,799
Well, I don't know.
好吧，我不知道。 

450
00:21:54,799 --> 00:21:56,389
Let's go this way.
我们这样走吧。 

451
00:21:56,390 --> 00:21:58,182
And then it comes another fork in the road.
然后它又出现了。 

452
00:21:58,182 --> 00:21:59,431
It's like, well, I don't know.
就像，嗯，我不知道。 

453
00:21:59,431 --> 00:22:00,410
I'll go this way.
我走这边。 

454
00:22:00,410 --> 00:22:01,660
That's the guessing.
那是猜测。 

455
00:22:01,660 --> 00:22:04,160
You give it a list of choices and somehow a choice
您给它一个选择列表，以某种方式选择

456
00:22:04,160 --> 00:22:08,910
is determined, by magic-- nondeterministic magic.
是由魔法-非确定性魔法决定的。 

457
00:22:08,910 --> 00:22:18,970
And then the fun part is-- I should say, at the end
最后，有趣的部分是-我应该说

458
00:22:18,970 --> 00:22:24,652
the algorithm either says yes or no.
该算法说是或否。 

459
00:22:24,652 --> 00:22:25,409
It gives you an output.
它给您输出。 

460
00:22:25,609 --> 00:22:28,419



461
00:22:28,420 --> 00:22:34,389
The guesses are guaranteed-- this is the magic part--
猜测得到保证-这是不可思议的部分- 

462
00:22:34,589 --> 00:22:43,779
to lead to a yes answer, if possible.
如果可能的话，得出肯定的答案。 

463
00:22:43,779 --> 00:22:47,649



464
00:22:47,650 --> 00:22:50,599
So if you imagine the space of executions of this program,
因此，如果您想象该程序的执行空间， 

465
00:22:50,799 --> 00:22:53,341
you start here, and you make some guess and you
你从这里开始，你会猜一猜，你

466
00:22:53,342 --> 00:22:55,190
don't know which way to go.
不知道走哪条路。 

467
00:22:55,190 --> 00:22:56,918
In dynamic programming, we try all of them.
在动态编程中，我们尝试所有这些。 

468
00:22:57,118 --> 00:22:58,909
But this algorithm doesn't try all of them.
但是此算法不会尝试所有方法。 

469
00:22:58,910 --> 00:23:01,379
It's like a branching universe model of the universe.
就像是宇宙的分支宇宙模型。 

470
00:23:01,579 --> 00:23:03,929
So you make some choice, and then you
所以你做出一些选择，然后你

471
00:23:03,930 --> 00:23:06,430
make some other choice, and then you make some other choice.
做出其他选择，然后再做出其他选择。 

472
00:23:06,430 --> 00:23:08,900
All of these are guesses.
所有这些都是猜测。 

473
00:23:08,900 --> 00:23:11,500
And some of these things will lead to yes.
这些事情中的一些将导致是。 

474
00:23:11,500 --> 00:23:13,119
Some of these things will lead to no.
这些事情中的一些将导致没有。 

475
00:23:13,119 --> 00:23:17,039
And in this magical model, if there's any yes out there,
在这个神奇的模型中，如果有任何答案， 

476
00:23:17,039 --> 00:23:19,659
you will follow a path to a yes.
您将遵循“是”的道路。 

477
00:23:19,660 --> 00:23:21,773
If all of the answers are no, then, of course,
如果所有答案都不是，那当然

478
00:23:21,973 --> 00:23:23,639
it doesn't matter what choices you make.
做出什么选择都没有关系。 

479
00:23:23,640 --> 00:23:24,899
You will output no.
您将输出编号。 

480
00:23:25,099 --> 00:23:27,939
But if there's ever a yes, magically these guesses
但是，如果有的话，神奇的是这些猜测

481
00:23:27,940 --> 00:23:28,379
find it.
找到它。 

482
00:23:28,579 --> 00:23:30,389
This is the sense of lucky.
这是幸运的感觉。 

483
00:23:30,390 --> 00:23:33,940
If you're trying to find a yes-- that's your goal in life--
如果您想找到一个是您的人生目标， 

484
00:23:33,940 --> 00:23:37,289
then this corresponds to luck.
那么这相当于运气。 

485
00:23:37,289 --> 00:23:40,259
And NP is the class of all problems solvable
 NP是所有可解决问题的类别

486
00:23:40,259 --> 00:23:43,799
in polynomial time by a really lucky algorithm.
在多项式时间内通过一个非常幸运的算法。 

487
00:23:43,799 --> 00:23:44,849
Crazy.
疯。 

488
00:23:44,849 --> 00:23:45,349
I know.
我知道。 

489
00:23:45,349 --> 00:23:50,449



490
00:23:50,450 --> 00:23:53,115
Let's talk about Tetris.
让我们谈谈俄罗斯方块。 

491
00:23:53,115 --> 00:23:56,319



492
00:23:56,319 --> 00:23:59,870
Tetris, I claim, is in NP.
我声称俄罗斯方块在NP中。 

493
00:23:59,871 --> 00:24:01,669
And we know how to solve it in exponential time.
我们知道如何在指数时间内解决问题。 

494
00:24:01,869 --> 00:24:04,279
Just try all the options.
只需尝试所有选项。 

495
00:24:04,279 --> 00:24:07,639
But, in fact, I don't need to try all the options.
但是，实际上，我不需要尝试所有选项。 

496
00:24:07,640 --> 00:24:11,150
It would be enough just use this nondeterministic magic.
仅使用这种不确定的魔术就足够了。 

497
00:24:11,150 --> 00:24:14,420
I could say, well, should I drop the piece here, here, here,
我可以说，好吧，我应该在这里，这里，这里丢下一块吗？ 

498
00:24:14,420 --> 00:24:15,739
here, here, or here.
这里，这里或这里。 

499
00:24:15,739 --> 00:24:17,779
And should it be rotated like this, or like this,
并且应该像这样旋转， 

500
00:24:17,779 --> 00:24:20,170
or like this, or like this?
还是喜欢这个，或者喜欢这个？ 

501
00:24:20,170 --> 00:24:20,910
I don't know.
我不知道。 

502
00:24:20,910 --> 00:24:22,210
So I guess.
所以我猜。 

503
00:24:22,210 --> 00:24:23,775
And I just place that piece.
我只是把那一块。 

504
00:24:23,775 --> 00:24:25,900
I make another guess where to place the next piece.
我又猜测下一块应该放在哪里。 

505
00:24:25,900 --> 00:24:27,349
Then I make another guess where to place the next piece.
然后，我又猜测下一块的位置。 

506
00:24:27,549 --> 00:24:29,519
I implement the rules of Tetris, which
我执行俄罗斯方块的规则

507
00:24:29,519 --> 00:24:32,425
is if there's a full line it clears.
如果有一个完整的行，它会清除。 

508
00:24:32,425 --> 00:24:34,980
I figure out where these things fall.
我弄清楚这些东西在哪里。 

509
00:24:34,980 --> 00:24:39,079
I can even think about, should I rotate at the last second.
我什至可以考虑，是否应该在最后一秒旋转。 

510
00:24:39,079 --> 00:24:41,894
If I don't know, I'll guess.
如果我不知道，我会猜测。 

511
00:24:41,894 --> 00:24:43,809
Any choice you have to make in playing Tetris,
在玩俄罗斯方块时，您必须做出任何选择， 

512
00:24:43,809 --> 00:24:45,279
you can just guess.
您可以猜测。 

513
00:24:45,279 --> 00:24:47,660
There's only polynomially many guesses you need to make.
您只需做出多项式的猜测。 

514
00:24:47,660 --> 00:24:49,399
So it's still polynomial time.
所以现在仍然是多项式时间。 

515
00:24:49,599 --> 00:24:50,439
That's important.
那很重要

516
00:24:50,440 --> 00:24:52,059
It's not like we can do anything.
并不是说我们可以做任何事情。 

517
00:24:52,059 --> 00:24:54,769
But we can make a polynomial number these magic guesses.
但是我们可以用这些神奇的猜测得出一个多项式数。 

518
00:24:54,769 --> 00:24:59,329
And then at the end, I determine did I die--
最后，我确定我死了- 

519
00:24:59,329 --> 00:25:01,069
or rather, did I survive.
还是我生存了下来

520
00:25:01,069 --> 00:25:02,119
It's important, actually.
实际上，这很重要。 

521
00:25:02,119 --> 00:25:03,979
It only works one way.
它仅以一种方式起作用。 

522
00:25:03,980 --> 00:25:04,779
Did I survive?
我还活着吗

523
00:25:04,779 --> 00:25:05,555
Yes or no?
是还是不是？ 

524
00:25:05,555 --> 00:25:06,680
And that's easy to compute.
这很容易计算。 

525
00:25:06,680 --> 00:25:10,919
I just see did I ever go above the top row.
我只是看到我曾经超过第一行。 

526
00:25:11,119 --> 00:25:13,639
So what this model says is if there is any way
所以这个模型说的是

527
00:25:13,640 --> 00:25:16,899
to survive-- if there is any way to get a yes answer,
生存-如果有任何办法可以得到肯定的答案， 

528
00:25:17,099 --> 00:25:21,219
then, my guesses will find it, magically, in this model.
然后，我的猜测将在此模型中神奇地找到它。 

529
00:25:21,220 --> 00:25:22,169
Therefore, Tetris is in NP.
因此，俄罗斯方块在NP中。 

530
00:25:22,369 --> 00:25:24,979



531
00:25:24,980 --> 00:25:28,200
If I had instead said, did I die, then,
如果我改为说我死了，那么， 

532
00:25:28,200 --> 00:25:30,919
what this algorithm would tell me is there any way
这个算法会告诉我什么

533
00:25:31,119 --> 00:25:33,969
to die-- which, the answer's probably yes,
死了-答案可能是肯定的， 

534
00:25:33,970 --> 00:25:36,159
unless you're given a really trivial input.
除非您得到的是非常琐碎的输入。 

535
00:25:36,359 --> 00:25:39,709
So it's important you set up the yes versus no, correctly.
因此，正确设置是与否非常重要。 

536
00:25:39,710 --> 00:25:43,980
But the Tetris decision problem "can I survive," is in NP.
但是，俄罗斯方块的决策问题“我能生存吗”在NP中。 

537
00:25:43,980 --> 00:25:48,670
The decision problem "can I die," should not be in NP.
决策问题“我可以死”不应该存在于NP中。 

538
00:25:48,670 --> 00:25:49,293
But we don't know.
但是我们不知道。 

539
00:25:49,493 --> 00:25:57,109



540
00:25:57,109 --> 00:25:58,429
Another way to think about NP.
思考NP的另一种方法。 

541
00:25:58,430 --> 00:26:01,382



542
00:26:01,382 --> 00:26:02,950
And you might find this intuitive
而且您可能会发现这很直观

543
00:26:02,950 --> 00:26:04,799
because we've been doing lots of guessing.
因为我们一直在猜测。 

544
00:26:04,799 --> 00:26:06,329
It's just a little crazy.
有点疯狂。 

545
00:26:06,329 --> 00:26:11,490
There's another way that's more intuitive to many people.
对于许多人来说，还有另一种方式更直观。 

546
00:26:11,490 --> 00:26:14,519
So if this doesn't make sense, don't worry, yet.
因此，如果这没有意义，请不要担心。 

547
00:26:14,519 --> 00:26:16,109
This is another way to phrase it.
这是另一种表达方式。 

548
00:26:16,109 --> 00:26:53,151



549
00:26:53,152 --> 00:26:54,909
Another way to think about NP-- which turns out
思考NP的另一种方法-结果

550
00:26:55,109 --> 00:27:01,449
to be equivalent-- is that don't think so much about algorithms
等价的是-对算法的考虑不多

551
00:27:01,450 --> 00:27:04,299
for solving a problem, just think about algorithms
要解决问题，只需考虑算法

552
00:27:04,299 --> 00:27:07,436
for checking the solution to a problem.
用于检查问题的解决方案。 

553
00:27:07,436 --> 00:27:09,269
It's usually a lot easier to check your work
通常检查工作要容易得多

554
00:27:09,269 --> 00:27:11,980
than it is to solve a problem in the first place.
而不是首先解决问题。 

555
00:27:11,980 --> 00:27:15,400
And NP is all about that issue.
 NP就是关于这个问题的。 

556
00:27:15,400 --> 00:27:17,339
So think of decision problems and think
因此，思考决策问题并思考

557
00:27:17,539 --> 00:27:21,269
about if you have a solution-- so let's say in Tetris,
关于您是否有解决方案-假设在俄罗斯方块中， 

558
00:27:21,269 --> 00:27:24,789
the solution is yes.
解决方案是。 

559
00:27:24,789 --> 00:27:27,659
In fact, I need to say this, probably.
实际上，我可能需要这么说。 

560
00:27:27,660 --> 00:27:31,150
The more formal version is whenever
更正式的版本是

561
00:27:31,150 --> 00:27:37,900
the answer is yes, you can prove it.
答案是肯定的，您可以证明这一点。 

562
00:27:37,900 --> 00:27:41,880



563
00:27:41,880 --> 00:27:43,899
And you can check that proof in polynomial time.
您可以在多项式时间内检查该证明。 

564
00:27:44,099 --> 00:27:49,889



565
00:27:49,890 --> 00:27:53,140
This is the more formal-- this a little bit high level.
这比较正式-有点高水平。 

566
00:27:53,140 --> 00:27:54,130
What does check mean?
检查是什么意思？ 

567
00:27:54,130 --> 00:27:55,879
Here's what check means.
这就是检查的意思。 

568
00:27:56,079 --> 00:27:59,559
Whenever an answer is "yes," you can write down a proof
只要答案是“是”，您就可以写下证明

569
00:27:59,559 --> 00:28:00,899
that the answer is yes.
答案是肯定的。 

570
00:28:00,900 --> 00:28:02,400
And someone can come along and check
有人可以过来检查

571
00:28:02,400 --> 00:28:04,169
that proof in polynomial time and be convinced
证明多项式时间并被说服

572
00:28:04,369 --> 00:28:06,309
that the answer is yes.
答案是肯定的。 

573
00:28:06,309 --> 00:28:07,599
What does convinced mean?
说服是什么意思？ 

574
00:28:07,599 --> 00:28:09,799
It's not that hard.
没那么难。 

575
00:28:09,799 --> 00:28:11,659
Think of it is a two player game.
认为这是一个两人游戏。 

576
00:28:11,660 --> 00:28:13,400
There's me trying to play Tetris,
我在尝试玩俄罗斯方块， 

577
00:28:13,400 --> 00:28:15,400
and there's you trying to be convinced
而你试图说服

578
00:28:15,400 --> 00:28:17,899
that I'm really good at Tetris.
我真的很擅长俄罗斯方块。 

579
00:28:18,099 --> 00:28:23,059
It seems a little one sided, but-- it's a asymmetric game.
似乎有些反面，但是-这是一个不对称的游戏。 

580
00:28:23,059 --> 00:28:27,419
So you want to prove Tetris is-- I want to show Tetris is in NP.
所以你想证明俄罗斯方块是-我想证明俄罗斯方块在NP中。 

581
00:28:27,420 --> 00:28:29,789
Imagine I'm this magical creature.
想象我是这个神奇的生物。 

582
00:28:29,789 --> 00:28:31,159
Actually, it's kind of funny.
实际上，这很有趣。 

583
00:28:31,160 --> 00:28:32,680
It reminds me of a story.
它使我想起一个故事。 

584
00:28:32,680 --> 00:28:34,419
On the front of my office door, you
在我办公室门的前面，你

585
00:28:34,619 --> 00:28:37,539
may have seen there's an email I received,
可能看到我收到了一封电子邮件， 

586
00:28:37,539 --> 00:28:39,899
maybe 15 years ago-- oh no, I guess
也许15年前-哦不，我猜

587
00:28:39,900 --> 00:28:41,899
it can't be that long ago.
不可能那么久。 

588
00:28:42,099 --> 00:28:43,709
Must've been about 7 years ago when
一定是在7年前

589
00:28:43,710 --> 00:28:47,039
we proved that Tetris is NP-complete.
我们证明了俄罗斯方块是NP完全的。 

590
00:28:47,039 --> 00:28:51,659
And the email says, "Dear Sir,"-- or whatever--
电子邮件中说：“亲爱的先生”，或其他任何内容， 

591
00:28:51,660 --> 00:28:54,148
"I am NP-complete."
 “我很NP。” 

592
00:28:54,348 --> 00:28:55,889
We don't what NP-complete means, yet,
我们不是NP-complete的意思， 

593
00:28:55,890 --> 00:28:57,109
but it's a meaningless statement.
但这是毫无意义的声明。 

594
00:28:57,309 --> 00:28:59,639
So it doesn't matter that you don't know what it means.
因此，您不知道这意味着什么都没关系。 

595
00:28:59,640 --> 00:29:03,940
It might get funnier throughout the lecture today.
今天的整个讲座可能会更有趣。 

596
00:29:03,940 --> 00:29:07,659
And he's like, I can solve Tetris.
他就像，我可以解决俄罗斯方块。 

597
00:29:07,859 --> 00:29:09,533
I'm really good at playing Tetris.
我真的很擅长玩俄罗斯方块。 

598
00:29:09,534 --> 00:29:11,200
I'm really good at playing Minesweeper--
我真的很擅长打扫雷

599
00:29:11,200 --> 00:29:14,210
all these games that are thought to be intractable.
所有这些被认为是棘手的游戏。 

600
00:29:14,210 --> 00:29:15,809
He gave me his records and so on.
他给了我他的记录，依此类推。 

601
00:29:15,809 --> 00:29:20,230
It's like how can I apply my talent.
就像我该如何运用自己的才能。 

602
00:29:20,230 --> 00:29:26,230
So I will translate what he meant to say was, "I am lucky."
因此，我将翻译他的意思是“我很幸运”。 

603
00:29:26,230 --> 00:29:29,017
And this is probably not true, but he
这可能不是真的，但是他

604
00:29:29,017 --> 00:29:29,899
thought that he was lucky.
以为他很幸运。 

605
00:29:30,099 --> 00:29:31,939
He wanted to convince me he was lucky.
他想说服我他很幸运。 

606
00:29:31,940 --> 00:29:33,409
So how could we do it?
那么我们该怎么做呢？ 

607
00:29:33,609 --> 00:29:36,539
Well, I could give him a really hard Tetris problem.
好吧，我可以给他一个非常困难的俄罗斯方块问题。 

608
00:29:36,539 --> 00:29:38,869
And say, can you survive these pieces?
再说，你能生存下来吗？ 

609
00:29:38,869 --> 00:29:41,449
And he says, "yes, I can survive. "
他说：“是的，我可以生存。” 

610
00:29:41,450 --> 00:29:43,450
And how does he prove to me that he can survive?
他如何向我证明自己可以生存？ 

611
00:29:43,450 --> 00:29:45,150
Well, he just plays it.
好吧，他只是玩。 

612
00:29:45,150 --> 00:29:47,420
He shows me what to do.
他告诉我该怎么办。 

613
00:29:47,420 --> 00:29:53,740
So proof is sequence of moves that you make.
因此，证明就是您所做的一系列动作。 

614
00:29:53,740 --> 00:29:55,669
It's really easy to convince someone
说服某人真的很容易

615
00:29:55,869 --> 00:30:00,289
that you can survive a given level of Tetris.
您可以在给定水平的俄罗斯方块中生存。 

616
00:30:00,289 --> 00:30:04,379
You just show what the sequence of moves are.
您只需要显示移动顺序即可。 

617
00:30:04,380 --> 00:30:07,659
And then I, as a mere mortal polynomial time algorithm
然后我，作为一个凡人多项式时间算法

618
00:30:07,859 --> 00:30:09,779
can check that that sequence works.
可以检查该序列是否有效。 

619
00:30:09,779 --> 00:30:12,064
I just have to implement the rules of Tetris.
我只需要执行俄罗斯方块的规则。 

620
00:30:12,064 --> 00:30:13,980
So in Tetris, the rules are easy to implement.
因此，在俄罗斯方块中，规则很容易实现。 

621
00:30:13,980 --> 00:30:17,919
Its the knowing what thing to do is hard.
知道要做什么是很难的。 

622
00:30:18,119 --> 00:30:21,839
But in NP, knowing which way to go is easy.
但是在NP中，知道走哪条路很容易。 

623
00:30:21,839 --> 00:30:23,339
In this version, you don't even talk
在这个版本中，您甚至都不会说话

624
00:30:23,339 --> 00:30:24,819
about how to find the solution.
关于如何找到解决方案。 

625
00:30:24,819 --> 00:30:26,485
It's just a matter of can you write down
你可以写下来

626
00:30:26,486 --> 00:30:29,079
a solution that can be checked.
可以检查的解决方案。 

627
00:30:29,279 --> 00:30:30,000
Can prove it.
可以证明这一点。 

628
00:30:30,000 --> 00:30:31,420
This is not in polynomial time.
这不是多项式时间。 

629
00:30:31,420 --> 00:30:34,710
You get arbitrarily much time to prove it.
您可以任意花很多时间来证明这一点。 

630
00:30:34,710 --> 00:30:37,539
But then, the check has to happen in polynomial time.
但是随后，检查必须在多项式时间内进行。 

631
00:30:37,539 --> 00:30:41,047



632
00:30:41,047 --> 00:30:41,630
Kind of clear?
有点清楚吗？ 

633
00:30:41,630 --> 00:30:44,089



634
00:30:44,289 --> 00:30:46,450
That's Tetris.
那是俄罗斯方块。 

635
00:30:46,450 --> 00:30:49,220
And every problem that you can solve in polynomial
以及多项式可以解决的所有问题

636
00:30:49,220 --> 00:30:51,048
time you can also, of course, check it.
时间，您当然也可以进行检查。 

637
00:30:51,048 --> 00:30:53,089
Because if you could solve it in polynomial time,
因为如果可以在多项式时间内求解， 

638
00:30:53,089 --> 00:30:54,589
you could just solve it and then see
你可以解决它，然后看

639
00:30:54,589 --> 00:30:56,319
did you get the same answer that I did.
你得到的答案和我一样。 

640
00:30:56,319 --> 00:30:59,789
So P is inside NP.
所以P在NP内部。 

641
00:30:59,789 --> 00:31:04,909
But the big question is does p equal NP.
但是最大的问题是p是否等于NP。 

642
00:31:04,910 --> 00:31:08,399
And most people think no.
大多数人认为不。 

643
00:31:08,599 --> 00:31:12,059
P does not equal NP-- most sane people.
 P不等于NP-大多数理智的人。 

644
00:31:12,059 --> 00:31:16,690



645
00:31:16,690 --> 00:31:18,910
So this is a big problem.
因此，这是一个大问题。 

646
00:31:18,910 --> 00:31:21,900
It's one of the famous Millennium Prize problems.
这是著名的千年奖问题之一。 

647
00:31:21,900 --> 00:31:26,829
So in particular, if you solved it, you would get $1 million,
因此，特别是，如果您解决它，您将获得100万美元， 

648
00:31:27,029 --> 00:31:29,079
and fame, and probably other fortune.
和名望，也许还有其他财富。 

649
00:31:29,079 --> 00:31:31,059
You could do TV spots.
您可以做电视节目。 

650
00:31:31,059 --> 00:31:34,159
I think that's how people mostly make their money.
我认为人们就是这样赚钱的。 

651
00:31:34,160 --> 00:31:35,279
You could do a lot.
你可以做很多事。 

652
00:31:35,279 --> 00:31:38,019
You would become the most famous computer scientist in the world
您将成为世界上最著名的计算机科学家

653
00:31:38,019 --> 00:31:40,019
if you prove this.
如果你证明这一点。 

654
00:31:40,019 --> 00:31:41,269
So a lot of people have tried.
所以很多人都尝试过。 

655
00:31:41,269 --> 00:31:44,069
Every year, there's an attempt to prove either
每年都有尝试证明

656
00:31:44,069 --> 00:31:46,500
what everyone believes or, most often,
每个人都相信或最常

657
00:31:46,500 --> 00:31:49,741
people try to prove the reverse-- that they are equal.
人们试图证明相反的事实-他们是平等的。 

658
00:31:49,741 --> 00:31:50,450
I don't know why.
我不知道为什么

659
00:31:50,450 --> 00:31:53,250
They should bet the other way.
他们应该反赌。 

660
00:31:53,250 --> 00:31:55,359
So what does P does not equal NP mean?
那么P不等于NP是什么意思？ 

661
00:31:55,359 --> 00:32:00,039
It means that there are problems, here, that are in NP
这意味着这里存在NP中的问题

662
00:32:00,039 --> 00:32:03,240
but not in P. Think about what this means.
但请不要在P中考虑。 

663
00:32:03,240 --> 00:32:05,809
This is saying P are the problems that we can actually
这就是说P是我们实际上可以解决的问题

664
00:32:05,809 --> 00:32:07,679
solve on a legitimate computer.
在合法计算机上解决。 

665
00:32:07,680 --> 00:32:10,950
NP are problems that we can solve in this magical fairy
 NP是我们在这个神奇仙女中可以解决的问题

666
00:32:10,950 --> 00:32:14,169
computer where all of our dreams are granted.
实现我们所有梦想的计算机。 

667
00:32:14,369 --> 00:32:16,119
You say, oh, I don't know which way to go.
你说，哦，我不知道走哪条路。 

668
00:32:16,119 --> 00:32:19,509
It doesn't matter because the machine magically
没关系，因为机器神奇

669
00:32:19,509 --> 00:32:21,400
tells you which way to go.
告诉您要走的路。 

670
00:32:21,400 --> 00:32:24,210
If you're goal is to get to a yes.
如果您的目标是获得肯定。 

671
00:32:24,210 --> 00:32:27,930
So NP is a really powerful model of computation.
因此，NP是一个非常强大的计算模型。 

672
00:32:27,930 --> 00:32:29,690
It's an insane model of computation.
这是一个疯狂的计算模型。 

673
00:32:29,690 --> 00:32:31,899
No one in their right mind would consider it legitimate.
在他们的正确思想中，没有人会认为这是合法的。 

674
00:32:32,099 --> 00:32:35,250
So obviously, it's more powerful than P,
所以很明显，它比P更强大， 

675
00:32:35,250 --> 00:32:37,727
except we don't know how to prove it.
除了我们不知道如何证明。 

676
00:32:37,727 --> 00:32:38,109
Very annoying.
很烦人。 

677
00:32:38,309 --> 00:32:45,480



678
00:32:45,480 --> 00:32:47,450
Other phrasings of P does not equal
 P的其他措词不等于

679
00:32:47,450 --> 00:32:50,669
NP is-- these are my phrasings, I them up-- you
 NP是-这些是我的措辞，我是他们-你

680
00:32:50,869 --> 00:32:53,089
can't engineer luck.
不能运气。 

681
00:32:53,089 --> 00:32:57,519



682
00:32:57,519 --> 00:32:59,160
You can believe in luck, if you want.
如果愿意，您可以相信运气。 

683
00:32:59,160 --> 00:33:01,410
But it's not something that we can build out
但这不是我们可以建立的东西

684
00:33:01,410 --> 00:33:03,960
of a regular computer.
普通计算机。 

685
00:33:03,960 --> 00:33:07,545
That's the meaning of this statement.
这就是声明的意思。 

686
00:33:07,545 --> 00:33:09,284
And so I think most people believe that.
因此，我认为大多数人都相信这一点。 

687
00:33:09,484 --> 00:33:13,529



688
00:33:13,529 --> 00:33:19,519
Another phrasing would be that solving problems
另一个说法是解决问题

689
00:33:19,519 --> 00:33:22,460
is harder than checking solutions.
比检查解决方案难。 

690
00:33:22,460 --> 00:33:27,299



691
00:33:27,299 --> 00:33:30,644
A more formal version is that generating solutions or proofs
一个更正式的版本是生成解决方案或证明

692
00:33:30,644 --> 00:33:37,509
of solutions can be harder than checking them.
解决方案比检查它们更难。 

693
00:33:37,509 --> 00:33:44,849



694
00:33:44,849 --> 00:33:47,859
Another phrasing is it's harder to generate
另一个说法是很难产生

695
00:33:47,859 --> 00:33:49,549
a proof of a theorem than it is to check
一个定理的证明而不是检验

696
00:33:49,549 --> 00:33:50,779
the proof of a theorem.
定理的证明。 

697
00:33:50,779 --> 00:33:53,399
We all know checking the proof of a theorem
我们都知道检查定理的证明

698
00:33:53,400 --> 00:33:56,000
should be easy if you write it precisely.
如果您精确地写的话应该很容易。 

699
00:33:56,000 --> 00:33:58,420
Just make sure each step follows from the previous ones.
只要确保每个步骤都遵循先前的步骤即可。 

700
00:33:58,420 --> 00:34:00,152
Done.
做完了

701
00:34:00,152 --> 00:34:01,409
But proving a theorem, that's hard.
但是证明一个定理很难。 

702
00:34:01,609 --> 00:34:02,549
You need inspiration.
您需要灵感。 

703
00:34:02,549 --> 00:34:03,740
You need some clever idea.
您需要一些聪明的主意。 

704
00:34:03,740 --> 00:34:04,920
That's guessing.
那是猜测。 

705
00:34:04,920 --> 00:34:09,019
Inspiration equals luck equals guessing, in this model.
在此模型中，灵感等于运气等于猜测。 

706
00:34:09,019 --> 00:34:10,369
And that's hard.
那很难。 

707
00:34:10,369 --> 00:34:13,380



708
00:34:13,380 --> 00:34:15,880
The only way we know is to try all the proofs.
我们知道的唯一方法是尝试所有证明。 

709
00:34:15,880 --> 00:34:17,269
See which of them work.
看看其中哪个有效。 

710
00:34:17,269 --> 00:34:24,019



711
00:34:24,019 --> 00:34:26,349
So what the heck?
那到底是什么？ 

712
00:34:26,349 --> 00:34:27,509
What could we possibly say?
我们能说什么？ 

713
00:34:27,510 --> 00:34:29,820
This is all kind of weird.
这真是奇怪。 

714
00:34:30,019 --> 00:34:31,519
This would be the end of the lecture
讲座到此结束

715
00:34:31,519 --> 00:34:34,769
if you say, OK, well we don't know.
如果您说，好的，那我们不知道。 

716
00:34:34,769 --> 00:34:37,349
That's it.
而已。 

717
00:34:37,349 --> 00:34:41,523
But thankfully-- I kind of need this board.
但值得庆幸的是，我有点需要这个委员会。 

718
00:34:41,523 --> 00:34:43,690
I also want this one, but I guess I'll go over here.
我也想要这个，但是我想我会过去的。 

719
00:34:43,690 --> 00:34:48,364



720
00:34:48,364 --> 00:34:50,280
Fortunately, this is not the end of the story.
幸运的是，这还不是故事的结局。 

721
00:34:50,280 --> 00:34:55,340
And we can say a lot about things like Tetris.
我们可以说很多有关俄罗斯方块的事情。 

722
00:34:55,340 --> 00:34:57,730
See I drew Tetris not just in this regime.
看到我画了俄罗斯方块，而不仅仅是在这种情况下。 

723
00:34:57,929 --> 00:35:01,329
We're pretty sure Tetris is between NP and P.
我们很确定俄罗斯方块在NP和P之间。 

724
00:35:01,329 --> 00:35:06,480
That it's in NP minus P.
它是NP减去P。 

725
00:35:06,480 --> 00:35:08,829
So let me write that down.
所以让我写下来。 

726
00:35:08,829 --> 00:35:16,639
Tetris is in NP minus P. We don't know that because we
俄罗斯方块是NP减去P。我们不知道那是因为我们

727
00:35:16,639 --> 00:35:20,069
don't know-- this could be the empty set.
不知道-这可能是空集。 

728
00:35:20,070 --> 00:35:26,039
What we do know is that if there's
我们所知道的是，如果有

729
00:35:26,039 --> 00:35:32,039
anything in NP minus P-- if they are different,
 NP减去P的任何值-如果它们不同， 

730
00:35:32,039 --> 00:35:35,900
then-- if there's anything in NP minus P,
然后-如果NP减去P， 

731
00:35:35,900 --> 00:35:39,059
then Tetris is one of those things.
那么俄罗斯方块就是其中之一。 

732
00:35:39,059 --> 00:35:40,759
That's why I drew Tetris out there.
这就是为什么我把俄罗斯方块拉到那里。 

733
00:35:40,760 --> 00:35:45,800
It is, in a certain sense, the hardest problem in NP.
从某种意义上讲，这是NP中最困难的问题。 

734
00:35:45,800 --> 00:35:47,690
Tetris.
俄罗斯方块。 

735
00:35:47,690 --> 00:35:49,550
Why Tetris?
为什么选择俄罗斯方块？ 

736
00:35:49,550 --> 00:35:50,809
Well, it's not just Tetris.
好吧，不只是俄罗斯方块。 

737
00:35:50,809 --> 00:35:52,900
There are a lot of problems right at that little notch.
在这个小缺口上有很多问题。 

738
00:35:53,099 --> 00:35:57,219
But this is pretty interesting because, while we can't figure
但这很有趣，因为尽管我们无法弄清楚

739
00:35:57,219 --> 00:35:59,919
this out, most people believe this is true.
这个出来，大多数人都相信这是真的。 

740
00:35:59,920 --> 00:36:01,981
And so as long as you believe in that-- as long
只要您相信， 

741
00:36:01,981 --> 00:36:05,920
as you have faith-- then you can prove
只要有信心，就可以证明

742
00:36:05,920 --> 00:36:08,159
that Tetris is in NP minus P.
俄罗斯方块是NP减去P。 

743
00:36:08,159 --> 00:36:09,649
And so it's hard.
所以这很难。 

744
00:36:09,650 --> 00:36:11,880
It's not in P, in this case.
在这种情况下，它不在P中。 

745
00:36:11,880 --> 00:36:19,739
In particular, not in P. That's kind of cool.
特别是P中没有。这很酷。 

746
00:36:19,739 --> 00:36:21,780
How in the world do we prove something like this?
我们如何证明这样的事情？ 

747
00:36:21,780 --> 00:36:23,710
It's actually not that hard.
实际上并不难。 

748
00:36:23,909 --> 00:36:25,829
I mean it took us several months,
我的意思是我们花了几个月的时间

749
00:36:25,829 --> 00:36:29,639
but that's just months, whereas this thing has been around
但这只是几个月，而这件事已经存在了

750
00:36:29,639 --> 00:36:33,170
since, I guess, the '70s.
自70年代以来。 

751
00:36:33,170 --> 00:36:36,030
P versus NP.
 P与NP。 

752
00:36:36,030 --> 00:36:38,760
Why is this true?
为什么会这样呢？ 

753
00:36:38,760 --> 00:36:42,960
Because Tetris is NP-hard.
因为俄罗斯方块是NP硬的。 

754
00:36:42,960 --> 00:36:46,210



755
00:36:46,210 --> 00:36:48,420
What does NP-hard mean?
 NP-hard是什么意思？ 

756
00:36:48,420 --> 00:36:54,639
This means as hard as every problem in NP.
这与NP中的每个问题一样困难。 

757
00:36:54,639 --> 00:36:59,339



758
00:36:59,340 --> 00:37:02,010
I can't say harder than because it's non-strict.
我不能说比这更严格，因为它不是严格的。 

759
00:37:02,010 --> 00:37:04,710
So it's at least as hard as every problem in NP.
因此，这至少和NP中的每个问题一样困难。 

760
00:37:04,909 --> 00:37:07,579
And that's why I drew it at the far right.
这就是为什么我在最右边绘制它。 

761
00:37:07,579 --> 00:37:10,340
It's sort of the hardest extreme of NP.
这是NP最难的极端。 

762
00:37:10,340 --> 00:37:13,030
Among everything in NP you can possibly imagine,
在NP的所有内容中，您都可以想象到， 

763
00:37:13,030 --> 00:37:16,000
Tetris is as hard as all of them.
俄罗斯方块和所有人一样困难。 

764
00:37:16,000 --> 00:37:19,429
And therefore, if there's anything that's harder than P,
因此，如果有什么事比P难， 

765
00:37:19,429 --> 00:37:22,349
then Tetris is going to be harder than P because it's
那么俄罗斯方块会比P难，因为

766
00:37:22,349 --> 00:37:23,699
as far to the right as possible.
尽可能地右边。 

767
00:37:23,699 --> 00:37:27,489
Either P equals NP, in which case the picture is like this.
 P都等于NP，在这种情况下，图片就是这样。 

768
00:37:27,489 --> 00:37:29,919
Here's P. Here's NP.
这是P。这是NP。 

769
00:37:29,920 --> 00:37:32,300
Tetris is still at the right extreme, here.
在这里，俄罗斯方块仍然处于最佳状态。 

770
00:37:32,300 --> 00:37:35,230
But it's less interesting because it's still in P.
但这没那么有趣，因为它仍然在P中。 

771
00:37:35,429 --> 00:37:37,589
Or the picture looks like this, and NP is strictly
或图片看起来像这样，NP严格

772
00:37:37,590 --> 00:37:41,019
bigger than P. And then, because Tetris is at the right extreme,
比P大。然后，由于俄罗斯方块处于正确的极端， 

773
00:37:41,019 --> 00:37:45,289
it's outside of P. So we prove this in order
它在P之外。所以我们按顺序证明这一点

774
00:37:45,289 --> 00:37:47,110
to establish this claim.
确立这一主张。 

775
00:37:47,110 --> 00:37:51,010



776
00:37:51,010 --> 00:37:52,630
Just to get some terminology, what
只是为了获得一些术语，什么

777
00:37:52,630 --> 00:37:53,940
is this NP-complete business?
这是NP完整的业务吗？ 

778
00:37:53,940 --> 00:37:58,809



779
00:37:58,809 --> 00:38:09,549
Tetris is NP-complete, which means two things.
俄罗斯方块是NP完全的，这意味着两件事。 

780
00:38:09,550 --> 00:38:11,269
One is that it's NP-hard.
其中之一是它对NP不利。 

781
00:38:11,469 --> 00:38:13,959
And the other is that it's in NP.
另一个是它在NP中。 

782
00:38:13,960 --> 00:38:16,340
So if you think of the intersection, NP intersect
因此，如果您想到相交，NP相交

783
00:38:16,340 --> 00:38:18,210
NP-hard, that's NP-complete.
 NP难，那就是NP完全。 

784
00:38:18,210 --> 00:38:26,289
Let me draw on the picture here what this means.
让我在这里画上这是什么意思。 

785
00:38:26,489 --> 00:38:28,139
So I'm going to draw it on the top.
因此，我将其绘制在顶部。 

786
00:38:28,139 --> 00:38:38,589



787
00:38:38,590 --> 00:38:39,519
This is NP-hard.
这是NP难题。 

788
00:38:39,719 --> 00:38:42,389



789
00:38:42,389 --> 00:38:46,039
Everything from here to the right is NP-hard.
从这里到右边的所有内容都是NP-hard。 

790
00:38:46,039 --> 00:38:48,922
NP-hard means it's at least as hard as everything in NP.
 NP困难意味着它至少与NP中的所有事物一样困难。 

791
00:38:48,922 --> 00:38:50,380
That means it might be at this line
这意味着可能在这一行

792
00:38:50,380 --> 00:38:52,190
or it might be to the right.
或可能在右边。 

793
00:38:52,389 --> 00:38:55,129
But in the case of Tetris, we know that it's in NP.
但是对于俄罗斯方块，我们知道它在NP中。 

794
00:38:55,130 --> 00:38:57,494
We proved that a couple of times.
我们证明了几次。 

795
00:38:57,494 --> 00:38:59,335
And so we know that Tetris is also in this range.
因此，我们知道俄罗斯方块也在此范围内。 

796
00:38:59,534 --> 00:39:01,849
And so if it's in this range and in this range,
因此，如果它在此范围内， 

797
00:39:01,849 --> 00:39:03,690
it's got to be right here.
它必须在这里。 

798
00:39:03,690 --> 00:39:04,940
Completeness is nice.
完整性很好。 

799
00:39:04,940 --> 00:39:07,369
If you prove something is something complete--
如果您证明某件事已经完成， 

800
00:39:07,369 --> 00:39:09,920
prove a problem is some complexity class complete--
证明一个问题是某个复杂性课程完成了- 

801
00:39:09,920 --> 00:39:13,550
then you know sort of exactly where it falls on this line.
那么您就知道它在这条线上的确切位置。 

802
00:39:13,550 --> 00:39:15,750
NP-complete means right here.
 NP-complete表示此处。 

803
00:39:15,750 --> 00:39:18,519
EXP-complete means right here.
 EXP-complete就是这里。 

804
00:39:18,519 --> 00:39:22,880
Turns out Chess is EXP-complete.
事实证明，国际象棋是EXP完整的。 

805
00:39:22,880 --> 00:39:27,710
EXP-hard is anything from here over.
 EXP-hard就是这里的一切。 

806
00:39:27,710 --> 00:39:30,670
EXP is anything from here, over this way.
这样就可以从这里获得EXP。 

807
00:39:30,670 --> 00:39:32,335
Chess is right at that borderline.
国际象棋恰好在那个边界上。 

808
00:39:32,335 --> 00:39:34,512
It is the hardest problem in EXP.
这是EXP中最难的问题。 

809
00:39:34,512 --> 00:39:35,769
And that's actually the only way we
这实际上是我们唯一的方法

810
00:39:35,969 --> 00:39:37,969
know to prove that it's not NP.
知道证明它不是NP。 

811
00:39:37,969 --> 00:39:39,969
It's is pretty easy to show that EXP is bigger
很容易证明EXP更大

812
00:39:39,969 --> 00:39:43,769
than P. And Chess is the farthest to the right in EXP--
比P. Chess在EXP中最右边- 

813
00:39:43,769 --> 00:39:47,800
of any problem in EXP-- and so, therefore, it's not in P.
 EXP中的任何问题-因此，它不在P中。 

814
00:39:47,800 --> 00:39:51,150
So whereas this one-- these two, we're not sure are they equal.
因此，尽管这两个-我们不确定它们是否相等。 

815
00:39:51,349 --> 00:39:55,190
This line we know is different from this one.
我们知道的这一行与此不同。 

816
00:39:55,190 --> 00:39:58,519
We don't know about these two, though.
但是，我们不知道这两个。 

817
00:39:58,719 --> 00:40:01,549
Does NP equal EXP?
 NP等于EXP吗？ 

818
00:40:01,550 --> 00:40:02,039
Not as famous.
没有那么出名。 

819
00:40:02,239 --> 00:40:04,849
You won't get a million dollars, but still a very big,
你不会得到一百万美元，但仍然是非常大的， 

820
00:40:04,849 --> 00:40:07,549
open question.
悬而未决的问题。 

821
00:40:07,550 --> 00:40:09,590
What else do I wanna say?
我还要说什么？ 

822
00:40:09,590 --> 00:40:11,019
Tetris, Chess, EXP-hard.
俄罗斯方块，国际象棋，EXP难度。 

823
00:40:11,019 --> 00:40:16,369
So these lines, here-- this is NP-complete
这些行，这是NP完整的

824
00:40:16,369 --> 00:40:17,210
And this is EXP-complete.
这是EXP完整的。 

825
00:40:17,409 --> 00:40:35,980



826
00:40:35,980 --> 00:40:39,014
So the last thing I want to talk about is reductions.
因此，我要谈的最后一件事是减少费用。 

827
00:40:39,014 --> 00:40:43,769



828
00:40:43,769 --> 00:40:45,980
Reductions-- so how do you prove something like this?
减少-那么您如何证明这样的事情？ 

829
00:40:45,980 --> 00:40:47,710
What is as hard as even mean?
到底有什么困难？ 

830
00:40:47,710 --> 00:40:49,230
I haven't defined that.
我还没有定义。 

831
00:40:49,230 --> 00:40:51,269
But it's not hard to define.
但这并不难定义。 

832
00:40:51,269 --> 00:40:53,130
In fact, it's a concept we've seen already.
实际上，这是我们已经看到的概念。 

833
00:40:53,130 --> 00:41:18,610



834
00:41:18,610 --> 00:41:21,380
Reductions are actually a way to design algorithms
归约实际上是设计算法的一种方式

835
00:41:21,380 --> 00:41:24,153
that we've been using implicitly a lot.
我们已经隐式地使用了很多。 

836
00:41:24,353 --> 00:41:25,769
You may have even heard this term.
您甚至可能听说过这个学期。 

837
00:41:25,769 --> 00:41:28,009
A bunch of recitations have used the word reduction
一堆背诵都使用了减少词

838
00:41:28,010 --> 00:41:29,769
for graph reduction.
用于图形还原。 

839
00:41:29,969 --> 00:41:31,769
You have some problem, you convert it
您遇到问题，将其转换

840
00:41:31,769 --> 00:41:34,590
into a graph problem, then you just call the graph algorithm.
陷入图问题，那么您只需调用图算法即可。 

841
00:41:34,590 --> 00:41:35,829
You're done.
你完成了。 

842
00:41:35,829 --> 00:41:36,759
That's reduction.
那是减少。 

843
00:41:36,760 --> 00:41:38,820
In general, you have some problem, A,
一般来说，您有一些问题，A， 

844
00:41:38,820 --> 00:41:40,630
that you want to solve.
您要解决的问题。 

845
00:41:40,829 --> 00:41:44,029
And you convert it into some other problem, B,
然后将其转换为其他问题B 

846
00:41:44,030 --> 00:41:45,981
that you already know how to solve.
您已经知道如何解决。 

847
00:41:46,181 --> 00:41:47,889
It's a great tool because, in this class,
这是一个很棒的工具，因为在本课程中， 

848
00:41:47,889 --> 00:41:50,629
you learn tons of algorithms for solving tons of problems.
您将学习大量的算法来解决大量的问题。 

849
00:41:50,630 --> 00:41:55,070
Now, someone gives you, in your job or whatever,
现在，有人给您，无论您的工作是什么， 

850
00:41:55,070 --> 00:41:56,750
or you think about some problem that you
或您想到一些您遇到的问题

851
00:41:56,949 --> 00:41:59,179
don't know how to solve, the first thing you should
不知道该怎么解决，你应该做的第一件事

852
00:41:59,179 --> 00:42:01,000
do is-- can I convert it into something
我要做的是-我可以将其转换为某种东西吗

853
00:42:01,000 --> 00:42:02,929
I know how to solve because then you're done.
我知道如何解决，因为到此为止。 

854
00:42:02,929 --> 00:42:04,721
Now it may not be the best way to solve it,
现在，它可能不是解决问题的最佳方法， 

855
00:42:04,721 --> 00:42:06,409
but at least it's a way to solve it.
但这至少是解决问题的一种方法。 

856
00:42:06,409 --> 00:42:09,014
Probably in polynomial time because we think of B as things
可能在多项式时间内，因为我们将B视为事物

857
00:42:09,014 --> 00:42:10,389
you can solve in polynomial time.
您可以在多项式时间内求解。 

858
00:42:10,389 --> 00:42:13,159
Great.
大。 

859
00:42:13,159 --> 00:42:20,730
So just convert problem A, which you
所以只要转换问题A 

860
00:42:20,730 --> 00:42:27,414
want to solve, into some problem B that you know how to solve.
想解决，解决一些您知道如何解决的问题B。 

861
00:42:27,614 --> 00:42:30,689



862
00:42:30,690 --> 00:42:32,369
That's reduction.
那是减少。 

863
00:42:32,369 --> 00:42:35,460
Let me give you some examples that we've already seen,
让我给你一些我们已经看到的例子， 

864
00:42:35,460 --> 00:42:38,065
just to fit this into your mental map of the class.
只是为了使其适合您的班级心理图。 

865
00:42:38,065 --> 00:42:42,639



866
00:42:42,639 --> 00:42:45,059
It's kind of a funny one but it's a very simple one.
这很有趣，但是却很简单。 

867
00:42:45,059 --> 00:42:52,469



868
00:42:52,469 --> 00:42:54,459
So how do you solve unweighted shortest paths?
那么如何解决未加权的最短路径呢？ 

869
00:42:54,460 --> 00:42:58,300



870
00:42:58,300 --> 00:42:59,610
In general?
一般来说？ 

871
00:42:59,809 --> 00:43:00,670
Easy one.
简单的。 

872
00:43:00,670 --> 00:43:02,793
Give you a graph with no weights on the edges and I
给你一个没有权重的图，我

873
00:43:02,793 --> 00:43:04,465
want to the shortest path from s to t.
想要从s到t的最短路径。 

874
00:43:04,465 --> 00:43:05,389
AUDIENCE: BFS
观众：BFS 

875
00:43:05,389 --> 00:43:06,179
PROFESSOR: BFS.
教授：BFS。 

876
00:43:06,179 --> 00:43:07,599
Linear time, right?
线性时间，对吗？ 

877
00:43:07,599 --> 00:43:10,049
Well, that's if you're smart or if you
好吧，那是如果你很聪明或者

878
00:43:10,050 --> 00:43:11,250
feel like implementing BFS.
感觉像实施BFS。 

879
00:43:11,250 --> 00:43:14,380
Suppose someone gave you Djikstra.
假设有人给了你Djikstra。 

880
00:43:14,380 --> 00:43:16,125
Said, here, look, I've got Djikstra code.
说，这里，看，我有Djikstra代码。 

881
00:43:16,125 --> 00:43:17,375
You don't have to do anything.
您不必做任何事情。 

882
00:43:17,375 --> 00:43:18,940
There's Djisktra code right there.
那里有Djisktra代码。 

883
00:43:18,940 --> 00:43:21,099
But Djikstra solves weighted shortest path.
但是Djikstra解决了加权最短路径。 

884
00:43:21,099 --> 00:43:22,159
I don't have any weights.
我没有体重。 

885
00:43:22,159 --> 00:43:24,960
What do I do?
我该怎么办？ 

886
00:43:24,960 --> 00:43:28,139
Set the weights to 1.
将权重设置为1。 

887
00:43:28,139 --> 00:43:30,629
It's very easy, but this is a reduction--
这很简单，但这是一种减少- 

888
00:43:30,630 --> 00:43:32,460
a simple example of reduction.
减少的一个简单例子。 

889
00:43:32,460 --> 00:43:35,329
Not the smartest of reductions, but it's a reduction.
不是最明智的削减方法，而是削减方法。 

890
00:43:35,329 --> 00:43:38,840



891
00:43:38,840 --> 00:43:40,780
So I can convert unweighted shortest paths
这样我就可以转换未加权的最短路径

892
00:43:40,780 --> 00:43:43,750
into weighted shortest paths by adding weights of 1.
通过增加权重1进入加权最短路径。 

893
00:43:43,750 --> 00:43:44,320
Done.
做完了

894
00:43:44,320 --> 00:43:46,070
Adding weights of 0 would not work.
将权重加0将不起作用。 

895
00:43:46,070 --> 00:43:47,170
But weights of 1.
但是权重为1。 

896
00:43:47,170 --> 00:43:47,900
OK.
好。 

897
00:43:47,900 --> 00:43:49,492
Weights of 2 also works.
权重2也可以。 

898
00:43:49,492 --> 00:43:51,750
Pick your favorite number, but as long as you're consistent
选择您喜欢的号码，但只要您保持一致

899
00:43:51,949 --> 00:43:52,779
about it.
关于它。 

900
00:43:52,780 --> 00:43:54,519
That's a reduction.
减少了。 

901
00:43:54,519 --> 00:43:56,570
Here's some more interesting ones.
这是一些更有趣的。 

902
00:43:56,570 --> 00:44:03,920
On the problems set-- problem set six--
关于问题集-问题集6- 

903
00:44:03,920 --> 00:44:08,204
there was this RenBook problem, "I Can Haz Moar Frendz?"
有一个RenBook问题，“我能阻止Moar Frendz吗？” 

904
00:44:08,204 --> 00:44:09,579
That was the name of the problem.
那就是问题的名字。 

905
00:44:09,579 --> 00:44:14,639
And the goal was to solve-- to find
目标是解决-找到

906
00:44:14,639 --> 00:44:17,884
paths that minimize the product of weights.
使重量乘积最小的路径。 

907
00:44:17,884 --> 00:44:19,300
But what we've covered in class is
但是我们在课堂上讲的是

908
00:44:19,300 --> 00:44:21,710
how to solve a problem when it's the sum of weights.
权重之和时如何解决问题。 

909
00:44:21,909 --> 00:44:23,889
How do you do it?
你怎么做呢？ 

910
00:44:23,889 --> 00:44:26,069
In one word, or less?
一句话，还是更少？ 

911
00:44:26,070 --> 00:44:26,789
Logs.
日志。 

912
00:44:26,989 --> 00:44:28,919
Just take logs.
只是拿日志。 

913
00:44:28,920 --> 00:44:31,597
That converts products into sums.
这将乘积转换为总和。 

914
00:44:31,597 --> 00:44:32,730
Now you start to get the flavor.
现在您开始得到味道。 

915
00:44:32,929 --> 00:44:37,149
This is a problem that you could take Djikstra or Bellman-Ford,
这是您可能需要Djikstra或Bellman-Ford的问题， 

916
00:44:37,150 --> 00:44:39,389
and change all the relaxation steps
并更改所有放松步骤

917
00:44:39,389 --> 00:44:42,469
and change it to work directly with products.
并将其更改为直接用于产品。 

918
00:44:42,469 --> 00:44:46,569
That would work, but it's more work.
可以，但是还需要更多工作。 

919
00:44:46,570 --> 00:44:49,000
You have to prove that that's still correct.
您必须证明那是正确的。 

920
00:44:49,199 --> 00:44:50,500
It's annoying to think about.
考虑到这很烦人。 

921
00:44:50,500 --> 00:44:52,659
And it's annoying to program.
而且编程很烦人。 

922
00:44:52,659 --> 00:44:54,589
It's not modular, blah, blah, blah.
它不是模块化的，等等，等等。 

923
00:44:54,590 --> 00:44:56,519
Whereas if you just do this reduction,
而如果您只是这样做， 

924
00:44:56,719 --> 00:44:59,989
you can use exactly the code that you had before,
您可以完全使用以前的代码， 

925
00:44:59,989 --> 00:45:01,959
at the end.
在末尾。 

926
00:45:01,960 --> 00:45:03,019
So that's nice.
很好。 

927
00:45:03,219 --> 00:45:04,669
This is why reductions are really
这就是为什么减少是真正的

928
00:45:04,670 --> 00:45:07,561
the most common algorithm design technique because you don't
最常见的算法设计技术，因为您没有

929
00:45:07,561 --> 00:45:10,019
want to implement an algorithm for every single problem you
想要为您的每个问题实施一种算法

930
00:45:10,019 --> 00:45:10,699
have.
有。 

931
00:45:10,699 --> 00:45:13,199
It would be nice if you could reuse some of those algorithms
如果您可以重用其中一些算法，那就太好了

932
00:45:13,199 --> 00:45:14,629
that you had before.
你以前有过

933
00:45:14,630 --> 00:45:17,099
Reductions let you do that.
减少可让您做到这一点。 

934
00:45:17,099 --> 00:45:21,679
Another one, which was on the quiz in the true-false-- quiz
另一个是对-假-测验中的测验

935
00:45:21,679 --> 00:45:25,531
two-- was converting longest path into shortest path.
二-将最长的路径转换为最短的路径。 

936
00:45:25,532 --> 00:45:26,789
We didn't phrase it as a reduction.
我们没有把它说成是减少。 

937
00:45:26,989 --> 00:45:29,729
It was just can you solve longest path using
只是您能解决使用

938
00:45:29,730 --> 00:45:30,909
Bellman-Ford.
贝尔曼福特。 

939
00:45:30,909 --> 00:45:31,831
And the answer is yes.
答案是肯定的。 

940
00:45:31,831 --> 00:45:33,164
You just negate all the weights.
您只需取消所有权重。 

941
00:45:33,164 --> 00:45:34,900
And that converts a longest path problem
这会转换最长路径问题

942
00:45:34,900 --> 00:45:37,460
into a shortest path problem.
进入最短路径问题。 

943
00:45:37,659 --> 00:45:40,309
Easy.
简单。 

944
00:45:40,309 --> 00:45:43,029
Also on the quiz-- maybe I don't need to write all of these down
同样在测验中-也许我不需要将所有这些写下来

945
00:45:43,030 --> 00:45:45,000
because they're a little bit weird problems.
因为它们有一些奇怪的问题。 

946
00:45:45,199 --> 00:45:46,369
We made them up.
我们弥补了。 

947
00:45:46,369 --> 00:45:50,219
There was the-- what was the duck tour called?
鸭子之旅叫什么？ 

948
00:45:50,219 --> 00:45:50,989
Bird tours?
鸟之旅？ 

949
00:45:50,989 --> 00:45:51,949
Bird tours?
鸟之旅？ 

950
00:45:51,949 --> 00:45:52,699
Aviation tours?
航空旅行？ 

951
00:45:52,699 --> 00:45:53,609
Whatever.
随你。 

952
00:45:53,610 --> 00:45:56,789
You want to visit a bunch of sites in some specified order.
您想按指定的顺序访问许多站点。 

953
00:45:56,989 --> 00:45:58,989
The point in that problem is you could reduce it
该问题的关键是您可以减少它

954
00:45:58,989 --> 00:46:02,899
to a single shortest paths query.
到最短路径查询。 

955
00:46:02,900 --> 00:46:05,481
And so if you already have shortest path code,
因此，如果您已经拥有最短的路径代码， 

956
00:46:05,681 --> 00:46:06,889
you don't have to think much.
您不必考虑太多。 

957
00:46:06,889 --> 00:46:08,400
You just do the graph application.
您只需执行图形应用程序即可。 

958
00:46:08,400 --> 00:46:09,769
Done.
做完了

959
00:46:09,969 --> 00:46:11,599
Then there's the leaky tank problem,
然后是水箱漏水的问题， 

960
00:46:11,599 --> 00:46:14,569
which is also a graph reduction problem.
这也是图形还原的问题。 

961
00:46:14,570 --> 00:46:16,570
You could represent all these extra weird things
您可以代表所有这些额外的怪异事物

962
00:46:16,570 --> 00:46:18,440
that were happening in your car by just
只是在你的车里发生的

963
00:46:18,639 --> 00:46:20,201
changing the graph a little bit.
稍微改变一下图。 

964
00:46:20,202 --> 00:46:21,460
And it's a very powerful technique.
这是一项非常强大的技术。 

965
00:46:21,659 --> 00:46:24,859
In this class, we see it mostly in graph reductions.
在此类中，我们主要在图形约简中看到它。 

966
00:46:24,860 --> 00:46:27,920
But it could apply all over the place.
但这可能适用于整个地方。 

967
00:46:28,119 --> 00:46:30,809
And while this is a powerful technique for coming up
虽然这是一种强大的技巧

968
00:46:30,809 --> 00:46:34,309
with new algorithms, it's also a powerful technique
有了新算法，这也是一项强大的技术

969
00:46:34,309 --> 00:46:41,380
for proving things like Tetris is NP-hard.
证明俄罗斯方块之类的东西很难。 

970
00:46:41,380 --> 00:46:43,829
So what we proved is that a problem
所以我们证明这是一个问题

971
00:46:43,829 --> 00:46:49,599
called 3-Partition can be reduced to Tetris.
所谓的三分区可以简化为俄罗斯方块。 

972
00:46:49,599 --> 00:46:57,809



973
00:46:57,809 --> 00:46:58,610
What's 3-Partition?
什么是3分区？ 

974
00:46:58,610 --> 00:47:01,000
3-Partition is I give you n numbers.
三分区是我给你n个数字。 

975
00:47:01,000 --> 00:47:03,929
I want to know can I divide them into triples,
我想知道是否可以将它们分为三部分， 

976
00:47:03,929 --> 00:47:06,449
each of the same sum.
每个都相同。 

977
00:47:06,449 --> 00:47:07,779
So I have n numbers.
所以我有n个数字。 

978
00:47:07,780 --> 00:47:10,170
Divide them into n over 3 groups of 3,
将它们分成3组，每组3个，n个， 

979
00:47:10,170 --> 00:47:14,030
such that the sum of each of the 3s is equal.
使得3s的总和相等。 

980
00:47:14,030 --> 00:47:15,780
Sounds like an easy enough problem.
听起来很简单。 

981
00:47:15,780 --> 00:47:18,230
But it's an NP-complete problem.
但这是一个NP完全问题。 

982
00:47:18,230 --> 00:47:22,949
And people knew that since one of the first papers.
自从第一批论文以来，人们就知道这一点。 

983
00:47:22,949 --> 00:47:26,789
I guess that was late '70s, early '80s, by Karp.
我猜那是Karp在70年代末80年代初。 

984
00:47:26,789 --> 00:47:28,800
So Karp already proved this is standing
所以卡普已经证明了这一点

985
00:47:28,800 --> 00:47:32,210
on the shoulders of giants.
在巨人的肩膀上。 

986
00:47:32,409 --> 00:47:34,359
Karp proved 3-Partition is NP-complete,
卡普证明3分区是NP完全的， 

987
00:47:34,360 --> 00:47:37,059
so I don't need to think about that.
所以我不需要考虑这一点。 

988
00:47:37,059 --> 00:47:39,210
All I need to focus on is showing
我需要专注的是展示

989
00:47:39,210 --> 00:47:43,269
that Tetris is harder than 3-Partition.
俄罗斯方块比三分区更难。 

990
00:47:43,469 --> 00:47:45,269
This is what I mean by harder.
这就是我的意思。 

991
00:47:45,269 --> 00:47:48,989
Harder means-- so when I can reduce A to B,
比较难的意思-所以当我可以将A减为B时， 

992
00:47:48,989 --> 00:48:02,089
we say the A-- B is at least as hard as A. Why's that?
我们说A– B至少和A一样难。为什么呢？ 

993
00:48:02,090 --> 00:48:05,820
Because I can solve A by solving B. I just apply this reduction
因为我可以通过解决B来解决A。 

994
00:48:05,820 --> 00:48:08,570
and then solve B. So if I had some good way to solve B,
然后解决B。所以如果我有解决B的好方法， 

995
00:48:08,570 --> 00:48:11,110
it would turn into a good way to solve A.
这将成为解决A的好方法。 

996
00:48:11,110 --> 00:48:14,940
Now 3-Partition-- which is A, here-- we're
现在3分区-在这里是A-我们是

997
00:48:14,940 --> 00:48:17,440
pretty sure there's no good algorithm for solving this.
很确定没有解决这个问题的好算法。 

998
00:48:17,440 --> 00:48:22,900
Pretty sure it's not in P. And so Tetris better not be P
可以肯定它不在P中。所以俄罗斯方块最好不要成为P 

999
00:48:22,900 --> 00:48:25,230
either because if Tetris were in P, then
要么因为如果俄罗斯方块在P中， 

1000
00:48:25,429 --> 00:48:27,139
we could just take our 3-Partition,
我们可以采用3分区， 

1001
00:48:27,139 --> 00:48:30,989
reduce it to Tetris, and then 3-Partition would be in P.
将其还原为Tetris，然后将3分区放在P中。 

1002
00:48:30,989 --> 00:48:33,209
In fact, all of the NP-complete problems,
实际上，所有NP完全问题， 

1003
00:48:33,210 --> 00:48:36,269
you can reduce to each other.
您可以互相减少。 

1004
00:48:36,469 --> 00:48:39,819
And so to show that something is at that little position,
因此，为了表明某物处于那个小位置， 

1005
00:48:39,820 --> 00:48:41,900
NP-complete, all you need to do is
 NP完成，您需要做的就是

1006
00:48:41,900 --> 00:48:44,119
find some known NP-complete problem
找到一些已知的NP完全问题

1007
00:48:44,119 --> 00:48:47,519
and reduce it to your problem.
并减少到您的问题。 

1008
00:48:47,519 --> 00:48:51,400
So reductions are super useful for getting positive results
因此，减少对于获得积极结果非常有用

1009
00:48:51,400 --> 00:48:53,579
for making new algorithms, but also
制作新算法，而且

1010
00:48:53,579 --> 00:48:56,110
for proving negative results-- showing that one problem is
用于证明负面结果-表明一个问题是

1011
00:48:56,110 --> 00:48:57,309
harder than another.
比另一个更难。 

1012
00:48:57,309 --> 00:48:59,079
And if you already believe this is hard,
如果您已经相信这很困难， 

1013
00:48:59,079 --> 00:49:00,621
then you should believe this is hard.
那么您应该相信这很难。 

1014
00:49:00,621 --> 00:49:08,570



1015
00:49:08,570 --> 00:49:12,059
I think that's all I really have time for.
我想这就是我真正有时间的。 

1016
00:49:12,059 --> 00:49:14,480
I'll give you a couple more NP-complete problems.
我再给您几个NP完全问题。 

1017
00:49:14,480 --> 00:49:15,929
Kind of fun.
有点乐趣。 

1018
00:49:15,929 --> 00:49:18,895
Traveling salesman problem, you may have heard of.
您可能听说过旅行商的问题。 

1019
00:49:18,896 --> 00:49:20,019
Let's say you have a graph.
假设您有一张图表。 

1020
00:49:20,019 --> 00:49:22,039
And you want to find out the shortest path that
您想找出最短的路径

1021
00:49:22,039 --> 00:49:25,769
visits all the vertices, not just one vertex.
访问所有顶点，而不仅仅是一个顶点。 

1022
00:49:25,769 --> 00:49:28,679
That's NP-complete.
那是NP完成的。 

1023
00:49:28,679 --> 00:49:31,679
We solved longest common subsequence for two strings,
我们解决了两个字符串的最长公共子序列， 

1024
00:49:31,679 --> 00:49:33,279
but if I give you n strings that you
但是如果我给你n个弦，你

1025
00:49:33,280 --> 00:49:35,038
need to find the longest common subsequence of,
需要找到最长的公共子序列

1026
00:49:35,237 --> 00:49:37,730
that's NP-complete.
那是NP完成的。 

1027
00:49:37,730 --> 00:49:41,559
Minesweeper, Sudoku, most puzzles that are interesting
扫雷，数独，大多数有趣的难题

1028
00:49:41,559 --> 00:49:43,989
are NP-complete.
是NP完全的。 

1029
00:49:43,989 --> 00:49:45,359
SAT.
 SAT。 

1030
00:49:45,360 --> 00:49:52,920
SAT is a-- I give you a Boolean formula like x or y AND NOT
 SAT是-我给你一个布尔公式，例如x或y 

1031
00:49:53,119 --> 00:49:55,049
x-- something like that.
 x-像这样。 

1032
00:49:55,050 --> 00:49:57,298
I want to know is there some setting of the variables that
我想知道是否有一些变量设置

1033
00:49:57,498 --> 00:49:58,789
makes this thing come out true?
使这件事成真？ 

1034
00:49:58,789 --> 00:50:01,634
Is it possible to make this true?
是否有可能做到这一点？ 

1035
00:50:01,634 --> 00:50:02,800
That's NP-complete complete.
那是NP完全完成。 

1036
00:50:02,800 --> 00:50:04,110
This was actually the first problem
这实际上是第一个问题

1037
00:50:04,309 --> 00:50:05,610
that was shown NP-complete.
显示为NP完整。 

1038
00:50:05,610 --> 00:50:06,880
There's this issue, right?
有这个问题吧？ 

1039
00:50:06,880 --> 00:50:08,753
If I'm going to show everything's NP-complete
如果我要显示所有的NP完成

1040
00:50:08,753 --> 00:50:10,909
by reduction, how the heck do I get started?
通过减少，我该如何开始？ 

1041
00:50:10,909 --> 00:50:12,359
What's the first problem?
第一个问题是什么？ 

1042
00:50:12,360 --> 00:50:15,420
And this is the first problem.
这是第一个问题。 

1043
00:50:15,619 --> 00:50:18,579
You could sort of prove it by definition, almost, of NP,
您几乎可以通过NP的定义来证明这一点， 

1044
00:50:18,579 --> 00:50:19,480
here.
这里。 

1045
00:50:19,480 --> 00:50:22,760
But I won't do that.
但是我不会那样做。 

1046
00:50:22,760 --> 00:50:24,610
Three coloring a graph.
三着色图形。 

1047
00:50:24,610 --> 00:50:25,280
Shortest paths.
最短路径。 

1048
00:50:25,280 --> 00:50:26,010
This is fun.
这好有趣。 

1049
00:50:26,010 --> 00:50:27,840
Shortest paths in a graph is hard.
图中的最短路径很难。 

1050
00:50:27,840 --> 00:50:30,420
But in the real world, we live in a three dimensional,
但是在现实世界中，我们生活在一个三维空间中

1051
00:50:30,619 --> 00:50:31,880
geometric environment.
几何环境。 

1052
00:50:31,880 --> 00:50:33,338
What if I want to find the shortest
如果我想找到最短的怎么办

1053
00:50:33,338 --> 00:50:35,420
path from this point, where I am, to that point,
从这一点到我现在的路径， 

1054
00:50:35,619 --> 00:50:37,500
over on the ceiling or something.
在天花板上或其他东西上。 

1055
00:50:37,500 --> 00:50:40,019
And I can fly.
我会飞。 

1056
00:50:40,019 --> 00:50:41,668
That's NP-complete.
那是NP完成的。 

1057
00:50:41,668 --> 00:50:42,460
It's kind of weird.
有点奇怪

1058
00:50:42,460 --> 00:50:44,159
Shortest paths in a two dimensional environment
二维环境中的最短路径

1059
00:50:44,159 --> 00:50:44,742
is polynomial.
是多项式。 

1060
00:50:44,742 --> 00:50:47,532
It's a good thing that we are on ground because, then, we
我们站在地面上是一件好事，因为我们

1061
00:50:47,532 --> 00:50:48,789
can model things by two dimensions.
可以按二维模型化事物。 

1062
00:50:48,989 --> 00:50:50,469
We can model things by graphs.
我们可以通过图来建模。 

1063
00:50:50,469 --> 00:50:53,500
But in 3D, shortest paths is NP-complete.
但是在3D中，最短路径是NP完整的。 

1064
00:50:53,500 --> 00:50:56,139
So all these things where a problem-- knapsack,
所以所有这些都有问题的地方-背包， 

1065
00:50:56,139 --> 00:50:56,730
that's another one.
那是另一种。 

1066
00:50:56,929 --> 00:50:58,221
We've already covered knapsack.
我们已经介绍了背包。 

1067
00:50:58,221 --> 00:50:59,989
We saw a pseudo-polynomial algorithm.
我们看到了伪多项式算法。 

1068
00:50:59,989 --> 00:51:02,389
Turns out, you can't do better than pseudo-polynomial
事实证明，没有比伪多项式更好的了

1069
00:51:02,389 --> 00:51:07,029
unless P equals NP because knapsack is NP-complete.
除非P等于NP，因为背包是NP完全的。 

1070
00:51:07,030 --> 00:51:07,960
So there you go.
所以你去了。 

1071
00:51:08,159 --> 00:51:11,312
Computational complexity in 50 minutes.
 50分钟即可实现计算复杂性。 

1072
00:51:11,313 --> 00:51:16,313



