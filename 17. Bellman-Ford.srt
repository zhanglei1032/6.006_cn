1
00:00:00,000 --> 00:00:00,080



2
00:00:00,080 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,000
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,000 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,320
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,320 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:21,403



10
00:00:21,403 --> 00:00:22,820
PROFESSOR: Good morning, everyone.
教授：大家早上好。 

11
00:00:22,820 --> 00:00:25,410



12
00:00:25,410 --> 00:00:32,149
So lecture three of four in the shortest path module and today
因此，在今天最短路径模块中，讲四分之三

13
00:00:32,149 --> 00:00:37,390
we'll finally confront our nemesis,
我们最终将面对我们的克星

14
00:00:37,390 --> 00:00:40,219
which are negative cycles and negative edges.
这是负周期和负边。 

15
00:00:40,219 --> 00:00:44,239
And we will describe an algorithm
我们将描述一个算法

16
00:00:44,240 --> 00:00:46,469
that is due to two different people.
那是由于两个不同的人。 

17
00:00:46,469 --> 00:00:49,359
They didn't collaborate to produce this algorithm.
他们没有合作产生这种算法。 

18
00:00:49,359 --> 00:00:52,570
Bellman and Ford.
贝尔曼和福特。 

19
00:00:52,570 --> 00:00:58,719
This computes shortest paths in a graph with negative edges.
这将计算具有负边的图形中的最短路径。 

20
00:00:58,719 --> 00:01:01,060
And not only that, even in the graph
不仅如此，即使在图中

21
00:01:01,060 --> 00:01:03,890
has negative cycles in it, the algorithm
算法中有负循环

22
00:01:03,890 --> 00:01:06,799
will be correct in the sense that it
从某种意义上说是正确的

23
00:01:06,799 --> 00:01:09,829
will report the existence of a negative cycle
将报告存在负周期

24
00:01:09,829 --> 00:01:13,489
and, essentially, abort the computation of shortest paths
从本质上讲，中止了最短路径的计算

25
00:01:13,489 --> 00:01:15,289
that are undefined.
未定义的

26
00:01:15,290 --> 00:01:18,730
And for the few vertices that do not
对于一些顶点， 

27
00:01:18,730 --> 00:01:22,819
have negative cycles in between them and the source,
在它们和源之间存在负周期， 

28
00:01:23,019 --> 00:01:25,979
the algorithm will report correct shortest paths.
该算法将报告正确的最短路径。 

29
00:01:25,980 --> 00:01:29,260
So it is a polynomial time algorithm.
因此，这是一个多项式时间算法。 

30
00:01:29,260 --> 00:01:30,900
It's fairly easy to describe.
这很容易描述。 

31
00:01:30,900 --> 00:01:34,879
And what we'll do is describe it, analyze its complexity
我们要做的就是描述它，分析它的复杂性

32
00:01:35,079 --> 00:01:40,799
and, for once, we'll do a formal proof of its correctness
并且，我们将对其形式做一次正式的证明

33
00:01:40,799 --> 00:01:43,939
to show that it reports the existence of negative cycles
证明它报告了负周期的存在

34
00:01:43,939 --> 00:01:45,140
if they do exist.
如果它们确实存在。 

35
00:01:45,140 --> 00:01:47,150
And if they don't exist, it correctly
如果它们不存在，那就正确了

36
00:01:47,150 --> 00:01:49,069
computes shortest path weights.
计算最短路径权重。 

37
00:01:49,269 --> 00:01:52,719



38
00:01:52,719 --> 00:01:59,530
So recall that when we look at the general case
所以回想一下，当我们看一般情况时

39
00:01:59,530 --> 00:02:02,299
of the shortest path problem.
最短路径问题。 

40
00:02:02,299 --> 00:02:07,149
We're going to have, let's say, a vertex u that, in this case,
假设我们有一个顶点u在这种情况下， 

41
00:02:07,150 --> 00:02:09,490
happens to be our source.
恰好是我们的来源。 

42
00:02:09,490 --> 00:02:11,439
And let's say for argument's sake
为了争辩而说

43
00:02:11,639 --> 00:02:17,311
that we have a negative weight cycle like so.
我们的负重周期是这样的。 

44
00:02:17,312 --> 00:02:18,810
So let me to draw this in bold.
因此，让我以粗体显示。 

45
00:02:19,009 --> 00:02:21,810



46
00:02:21,810 --> 00:02:24,560
And this happens to be a negative rate cycle.
这恰好是负利率周期。 

47
00:02:24,560 --> 00:02:30,930
Let's assume that all of these edges have positive weights.
假设所有这些边都具有正权重。 

48
00:02:30,930 --> 00:02:37,439
Then, if you have an algorithm that
然后，如果您有一种算法

49
00:02:37,639 --> 00:02:41,599
needs to work on this type of graph, what you want
需要处理这种类型的图，您想要什么

50
00:02:41,599 --> 00:02:45,590
to be able to do is to detect that this negative cycle
能够做的就是检测到这个负周期

51
00:02:45,590 --> 00:02:46,770
exists.
存在。 

52
00:02:46,770 --> 00:02:49,189
And you're going to, essentially,
从本质上讲，您将要

53
00:02:49,189 --> 00:02:53,169
say if this vertex is v1, for example,
例如说这个顶点是否为v1， 

54
00:02:53,169 --> 00:02:59,719
you want to be able to say delta u v1 is undefined and similarly
您希望能够说delta v1是未定义的，并且类似

55
00:02:59,719 --> 00:03:03,317
for v2, v3, et cetera.
对于v2，v3等

56
00:03:03,317 --> 00:03:05,400
For all of these things, the shortest path lengths
对于所有这些事情，最短的路径长度

57
00:03:05,400 --> 00:03:08,810
are undefined because you can essentially
是不确定的，因为您基本上可以

58
00:03:09,009 --> 00:03:11,329
run through this negative cycle any number of times
经历此负面循环多次

59
00:03:11,330 --> 00:03:16,180
and get whatever shortest path weight you want.
并获得所需的最短路径权重。 

60
00:03:16,180 --> 00:03:22,400
For this node, let's call that v0, we have delta u v0
对于这个节点，我们称它为v0，我们有del u v0 

61
00:03:22,400 --> 00:03:25,240
equals 2.
等于2。 

62
00:03:25,240 --> 00:03:28,870
And there's a simple path of length 1
并且有一条长度为1的简单路径

63
00:03:29,069 --> 00:03:32,389
in this case that gets you from u to v0.
在这种情况下，您将从u转到v0。 

64
00:03:32,389 --> 00:03:36,789
You don't encounter a cycle or negative cycle in between.
您之间不会遇到周期或负周期。 

65
00:03:36,789 --> 00:03:38,479
So that's cool.
太酷了。 

66
00:03:38,479 --> 00:03:39,849
All right?
好吧？ 

67
00:03:39,849 --> 00:03:44,139
And of course, if you have a vertex over here, z,
当然，如果这里有一个顶点z 

68
00:03:44,139 --> 00:03:47,359
that can't be reached from u then we're
从你那里无法到达那我们

69
00:03:47,360 --> 00:03:51,430
going to have delta uz being infinity.
会有uz无限大

70
00:03:51,629 --> 00:03:55,139
And you can assume at the beginning of these algorithms
您可以假设在这些算法的开始

71
00:03:55,139 --> 00:03:58,839
that the source-- in this case, I call the source u--
来源-在这种情况下，我称来源u- 

72
00:03:58,840 --> 00:04:03,849
but the shortest path to u would be 0.
但通往u的最短路径为0。 

73
00:04:03,849 --> 00:04:06,139
And all of the other ones are infinity.
其他所有的都是无限的。 

74
00:04:06,139 --> 00:04:08,250
And some of them may stay infinity.
其中一些可能会保持无限。 

75
00:04:08,250 --> 00:04:13,090
Some of them may obtain finite shortest path weights.
其中一些可能会获得有限的最短路径权重。 

76
00:04:13,090 --> 00:04:14,810
And some of them will be undefined
其中一些将是不确定的

77
00:04:14,810 --> 00:04:17,819
if you have a graph with negative cycles in it.
如果您有一个带有负循环的图形。 

78
00:04:17,819 --> 00:04:20,838
So that's sort of the specification, if you will,
所以这就是规范，如果您愿意， 

79
00:04:20,838 --> 00:04:23,529
of the requirements on the Bellman-Ford algorithm.
 Bellman-Ford算法的要求。 

80
00:04:23,529 --> 00:04:27,269
We want it to be able to do all of the things I just described.
我们希望它能够完成我刚刚描述的所有事情。 

81
00:04:27,269 --> 00:04:29,299
OK?
好？ 

82
00:04:29,300 --> 00:04:40,540
So let's take a second look at our generic shortest path
因此，让我们再来看一下通用的最短路径

83
00:04:40,540 --> 00:04:47,310
algorithm that I put up, I think, about a week ago.
我认为大约一个星期前我提出了这个算法。 

84
00:04:47,509 --> 00:04:52,399
And this is a good review of our notation.
这是对我们符号的一个很好的回顾。 

85
00:04:52,399 --> 00:04:53,839
But there are a couple more things
但是还有两件事

86
00:04:53,839 --> 00:04:56,099
I want to say about this algorithm
我想说一下这个算法

87
00:04:56,100 --> 00:04:58,490
that I didn't get to last time.
我没有去上一次。 

88
00:04:58,490 --> 00:05:02,910
So you're given a graph and you set all of the vertices
因此，您得到一个图，并设置了所有顶点

89
00:05:02,910 --> 00:05:06,560
in the graph to have infinite shortest path
在图中具有无限的最短路径

90
00:05:06,759 --> 00:05:10,019
weights, initially.
最初是重量。 

91
00:05:10,019 --> 00:05:13,219
Set the predecessors to be null.
将前任设置为null。 

92
00:05:13,220 --> 00:05:18,509
And then we'll set d of s to be 0.
然后将的d设为0。 

93
00:05:18,709 --> 00:05:20,849
That's your source.
那是你的来源。 

94
00:05:20,850 --> 00:05:30,920
And the main loop would be something like repeat,
而且主循环就像是重复， 

95
00:05:30,920 --> 00:05:33,910
select, and edge.
选择和边缘。 

96
00:05:33,910 --> 00:05:37,800
And we have a particular way of selecting this edge.
我们有一种选择这种优势的特殊方式。 

97
00:05:37,800 --> 00:05:39,810
And we have positive edge weights
我们有积极的权重

98
00:05:39,810 --> 00:05:42,860
that corresponds to the minimum priority.
对应于最低优先级。 

99
00:05:42,860 --> 00:05:45,172
And we talked about Dijkstra but we have, maybe,
我们谈到了Dijkstra，但也许， 

100
00:05:45,172 --> 00:05:46,180
different ways of doing that.
不同的方式。 

101
00:05:46,379 --> 00:05:48,529
We have to select an edge somehow.
我们必须以某种方式选择一条边。 

102
00:05:48,529 --> 00:05:52,044
And then, we relaxed that edge.
然后，我们放松了优势。 

103
00:05:52,045 --> 00:05:55,370



104
00:05:55,370 --> 00:05:58,079
u, v, w.
 u，v，w 

105
00:05:58,079 --> 00:06:00,039
And you know about the relaxation step.
而且您了解放松步骤。 

106
00:06:00,040 --> 00:06:03,000
I won't bother writing it out right now.
我现在就不用再写了。 

107
00:06:03,000 --> 00:06:05,920
But it's basically something where
但这基本上是

108
00:06:05,920 --> 00:06:09,139
you look at the value of d v. And if d v
你看d v的值。如果dv 

109
00:06:09,339 --> 00:06:14,279
is greater than d u plus the weight, you relax the edge.
大于du加上重量，您可以放松边缘。 

110
00:06:14,279 --> 00:06:17,349
And you keep doing this.
而且您继续这样做。 

111
00:06:17,350 --> 00:06:20,250
The other thing that you do in the relaxation
放松时要做的另一件事

112
00:06:20,250 --> 00:06:23,259
is to set the predecessor pointers to be correct.
是将先前的指针设置为正确的。 

113
00:06:23,259 --> 00:06:25,629
And that's part of the relax routine.
这是放松常规的一部分。 

114
00:06:25,629 --> 00:06:33,904
And you keep doing this until you can't relax anymore.
而且您会继续这样做，直到无法放松为止。 

115
00:06:33,904 --> 00:06:36,790



116
00:06:36,790 --> 00:06:37,290
All right?
好吧？ 

117
00:06:37,290 --> 00:06:40,629
So that's our generic shortest path algorithm.
这就是我们通用的最短路径算法。 

118
00:06:40,829 --> 00:06:45,050
There are two problems with this algorithm.
该算法有两个问题。 

119
00:06:45,050 --> 00:06:48,699
The first, which we talked about and both of these
我们讨论过的第一个

120
00:06:48,699 --> 00:06:52,879
have to do with the complexity but the first one
与复杂性有关，但第一个

121
00:06:52,879 --> 00:07:00,120
is that the complexity could be exponential time,
复杂度可能是指数时间， 

122
00:07:00,120 --> 00:07:01,639
even for positive edge weights.
即使对于正的边缘配重。 

123
00:07:01,839 --> 00:07:08,089



124
00:07:08,089 --> 00:07:10,449
And the particular example we talked about
还有我们讨论的特定示例

125
00:07:10,449 --> 00:07:16,899
was something where you had an exponential number of paths.
是您的路径数量成指数增长的地方。 

126
00:07:16,899 --> 00:07:21,370
And if you had a graph that looks like this,
如果您有一个像这样的图表， 

127
00:07:21,370 --> 00:07:25,949
then it's possible that a pathological selection of edges
那么可能是边缘的病理选择

128
00:07:25,949 --> 00:07:31,629
is going to make you relax edges an exponential number of times.
将使您放松边缘的次数呈指数增长。 

129
00:07:31,629 --> 00:07:35,384
And in particular, if you have n nodes in this graph,
特别是如果此图中有n个节点， 

130
00:07:35,384 --> 00:07:37,050
it's plausible that you'd end up getting
看来你最终会得到

131
00:07:37,050 --> 00:07:41,389
the complexity of order 2 raised to n over 2.
 2阶的复杂度提高到2以上的n。 

132
00:07:41,389 --> 00:07:42,360
OK?
好？ 

133
00:07:42,360 --> 00:07:44,809
So that's one problem.
这是一个问题。 

134
00:07:44,809 --> 00:07:46,350
The second problem, which is actually
第二个问题，实际上是

135
00:07:46,350 --> 00:07:52,740
a more obvious problem, is that this algorithm might not even
一个更明显的问题是，该算法甚至可能无法

136
00:07:52,740 --> 00:08:04,800
terminate if this-- actually will not
如果终止，实际上不会

137
00:08:04,800 --> 00:08:14,949
terminate the way it's written if there's a negative weight
如果负重，则终止书写方式

138
00:08:14,949 --> 00:08:18,334
cycle reachable from the source.
从源头可到达的周期。 

139
00:08:18,334 --> 00:08:29,180



140
00:08:29,180 --> 00:08:31,379
All right, so there's two problems.
好的，所以有两个问题。 

141
00:08:31,379 --> 00:08:33,720
We fixed the first one.
我们修复了第一个。 

142
00:08:33,720 --> 00:08:38,548
In the case of positive edges are non-negative edges.
在正边缘的情况下是非负边缘。 

143
00:08:38,548 --> 00:08:41,600
We have a neat algorithm that is an efficient algorithm called
我们有一个整洁的算法，这是一种称为

144
00:08:41,600 --> 00:08:43,990
Dijkstra that we talked about last time that fixed
上次讨论的Dijkstra修复了

145
00:08:43,990 --> 00:08:45,200
the first part.
第一部分。 

146
00:08:45,200 --> 00:08:47,460
But we don't know yet how we're going
但是我们还不知道如何

147
00:08:47,460 --> 00:08:51,370
to handle negative cycles in the general case.
在一般情况下处理负面循环。 

148
00:08:51,370 --> 00:08:52,870
We know how to handle negative edges
我们知道如何处理负边缘

149
00:08:52,870 --> 00:08:55,649
in the case of a DAG-- a directed acyclic graph--
就DAG而言-有向无环图- 

150
00:08:55,649 --> 00:08:57,759
but not in the general case.
但在一般情况下却不是。 

151
00:08:57,759 --> 00:08:58,259
OK?
好？ 

152
00:08:58,259 --> 00:09:01,929



153
00:09:01,929 --> 00:09:07,149
So there's this great little skit from Saturday Night Live
所以星期六夜现场有个很棒的小品

154
00:09:07,149 --> 00:09:11,679
from the 1980s-- so way before your time-- called The Five
从1980年代开始-在您的时代之前-被称为五

155
00:09:11,679 --> 00:09:13,129
Minute University.
分钟大学。 

156
00:09:13,129 --> 00:09:15,100
Anybody seen this?
有人看到吗？ 

157
00:09:15,100 --> 00:09:15,600
All right.
好吧。 

158
00:09:15,600 --> 00:09:16,450
Look it up on YouTube.
在YouTube上查找。 

159
00:09:16,450 --> 00:09:18,408
Don't look it up during lecture but afterwards.
演讲时不要查，而是以后查。 

160
00:09:18,408 --> 00:09:20,919



161
00:09:20,919 --> 00:09:23,939
So the character here is a person
所以这里的人物是一个人

162
00:09:23,940 --> 00:09:26,620
by the name of-- I forget his real name
以...的名字-我忘记了他的真名

163
00:09:26,620 --> 00:09:30,200
but his fake name is Father Guido Sarducci.
但他的假名叫吉多·萨杜奇神父。 

164
00:09:30,200 --> 00:09:31,470
All right?
好吧？ 

165
00:09:31,470 --> 00:09:33,990
So what's this Five Minute University about?
那这五分钟大学是做什么的？ 

166
00:09:33,990 --> 00:09:37,940
Five Minute University, he's selling this notion
五分钟大学，他在推销这个概念

167
00:09:37,940 --> 00:09:41,839
and he says, look, five years after you graduate
他说，看，毕业五年后

168
00:09:42,039 --> 00:09:44,339
you, essentially, are going to remember nothing.
从本质上讲，您将什么也不会记住。 

169
00:09:44,340 --> 00:09:44,709
OK?
好？ 

170
00:09:44,909 --> 00:09:46,799
I mean, you're not going to remember anything
我的意思是，你不会记住任何东西

171
00:09:46,799 --> 00:09:49,579
about all the courses you took, et cetera.
关于您参加的所有课程等等

172
00:09:49,580 --> 00:09:53,590
So why waste your time on a college education or waste
那么，为什么要浪费时间在大学教育上呢？ 

173
00:09:53,590 --> 00:09:55,609
money-- $100,000-- on a college education?
钱-100,000美元-接受大学教育？ 

174
00:09:55,809 --> 00:10:00,849
You know, for $20 I'll teach you in five minutes what you're
你知道，花20美元，我会在五分钟内教你

175
00:10:00,850 --> 00:10:04,320
going to remember five years after you graduate.
记得毕业五年后

176
00:10:04,320 --> 00:10:05,629
All right?
好吧？ 

177
00:10:05,629 --> 00:10:07,960
So let's take it to an extreme.
因此，让我们将其发挥到极致。 

178
00:10:07,960 --> 00:10:11,349
Here's a 30 second version up 6006.
这是6006的30秒版本。 

179
00:10:11,549 --> 00:10:15,699
And this is what I want you to remember five years or 10 years
这就是我要你记住五年或十年

180
00:10:15,700 --> 00:10:16,979
or whatever after you graduate.
或毕业后的其他事情。 

181
00:10:17,179 --> 00:10:18,079
All right?
好吧？ 

182
00:10:18,080 --> 00:10:23,220
And maybe the 10 second version as polynomial time is great.
也许10秒版本的多项式时间很棒。 

183
00:10:23,220 --> 00:10:23,720
OK?
好？ 

184
00:10:23,720 --> 00:10:25,599
Exponential time is bad.
指数时间不好。 

185
00:10:25,799 --> 00:10:28,199
And infinite time gets you fired.
而无限的时间会让你被解雇。 

186
00:10:28,200 --> 00:10:29,720
OK?
好？ 

187
00:10:29,720 --> 00:10:33,267
So that's all you need to remember.
这就是您需要记住的所有内容。 

188
00:10:33,267 --> 00:10:35,350
No, that's all you need to remember for the final.
不，这就是您在决赛中需要记住的所有内容。 

189
00:10:35,350 --> 00:10:38,351
This happens, you know, five years after you graduate.
你知道，这发生在毕业五年之后。 

190
00:10:38,351 --> 00:10:40,059
So you need to remember a lot more if you
因此，如果您需要记住更多

191
00:10:40,059 --> 00:10:42,849
want to take your quiz next week and the final exam.
想在下周参加测验和期末考试。 

192
00:10:42,850 --> 00:10:44,450
But I think that summarized over here.
但我认为这里总结了一下。 

193
00:10:44,450 --> 00:10:47,480
You have a generic shortest path algorithm.
您有一个通用的最短路径算法。 

194
00:10:47,480 --> 00:10:50,529
And you realize that if you do this wrong
你会意识到，如果你做错了

195
00:10:50,529 --> 00:10:54,449
you could very easily get into a situation
你很容易陷入困境

196
00:10:54,450 --> 00:10:56,220
where a polynomial time algorithm, and we
多项式时间算法，而我们

197
00:10:56,220 --> 00:10:59,850
know one for Dijkstra, turns into exponential time
为Dijkstra认识一个，变成指数时间

198
00:10:59,850 --> 00:11:03,009
in the worst case, you know, for a graph like that
在最坏的情况下，对于这样的图

199
00:11:03,009 --> 00:11:05,889
because you're selecting edges wrongly.
因为您错误地选择了边缘。 

200
00:11:05,889 --> 00:11:09,899
And in particular, that's problem number one.
特别是这是第一问题。 

201
00:11:09,899 --> 00:11:13,179
And problem number two is if you have
第二个问题是

202
00:11:13,179 --> 00:11:16,250
a graph that isn't what you expect.
图表不是您所期望的。 

203
00:11:16,250 --> 00:11:19,850
In this case, let's say you expected that a graph
在这种情况下，假设您期望

204
00:11:19,850 --> 00:11:23,099
with no negative cycles or maybe not even negative edges in it.
没有负循环，甚至没有负边。 

205
00:11:23,299 --> 00:11:25,189
You could easily get into a situation
您很容易陷入困境

206
00:11:25,190 --> 00:11:26,719
where your termination condition is such
您的终止条件是这样的

207
00:11:26,919 --> 00:11:29,519
that your algorithm never completes.
您的算法永远无法完成。 

208
00:11:29,519 --> 00:11:32,909
So we need to fix problem number two today
所以我们今天需要解决第二个问题

209
00:11:32,909 --> 00:11:36,829
using this algorithm called Bellman-Ford.
使用称为Bellman-Ford的算法。 

210
00:11:36,830 --> 00:11:40,759
And as it turns out, this algorithm
事实证明，这种算法

211
00:11:40,759 --> 00:11:43,299
is incredibly straightforward.
非常简单。 

212
00:11:43,299 --> 00:11:45,639
I mean, its complexity we'll have to look at.
我的意思是，我们必须研究它的复杂性。 

213
00:11:45,639 --> 00:11:47,850
But from a description standpoint,
但是从描述的角度来看， 

214
00:11:47,850 --> 00:11:50,440
it's four lines of code.
这是四行代码。 

215
00:11:50,440 --> 00:11:54,469
And let me put that up.
让我提出来。 

216
00:11:54,669 --> 00:12:04,269
So Bellman-Ford takes a graph, weights, and a source s.
因此，贝尔曼·福特（Bellman-Ford）采用图表，权重和来源。 

217
00:12:04,269 --> 00:12:12,990
And you can assume an adjacency list specification of the graph
您可以假设图的邻接列表规格

218
00:12:12,990 --> 00:12:14,840
or the representation of the graph.
或图形的表示形式。 

219
00:12:14,840 --> 00:12:16,849
And we do some initialization.
然后我们进行一些初始化。 

220
00:12:17,049 --> 00:12:20,329
It's exactly the same as in the generic case
与一般情况完全相同

221
00:12:20,330 --> 00:12:23,750
except the d values will still be looking at the d values
除了d值之外，仍将查看d值

222
00:12:23,750 --> 00:12:26,500
and talking about the relaxation operation.
并谈论放松操作。 

223
00:12:26,500 --> 00:12:28,710
So we do an initialization.
因此，我们进行了初始化。 

224
00:12:28,710 --> 00:12:33,210
And then, this algorithm has multiple passes
然后，此算法有多次通过

225
00:12:33,210 --> 00:12:38,120
because for I equals 1 to v minus 1.
因为对于我等于1等于v减去1。 

226
00:12:38,120 --> 00:12:42,649
So it does v minus 1 passes roughly order v passes
所以它减去v减去1遍就大致排序了v遍

227
00:12:42,649 --> 00:12:45,039
where v is the number of vertices.
其中v是顶点数。 

228
00:12:45,039 --> 00:12:53,409
And in each of these passes for each edge u v belonging to e
并且在这些通过中的每一个中，对于属于e的每个边uv 

229
00:12:53,409 --> 00:12:54,699
relaxes every edge.
放松每一条边缘。 

230
00:12:54,700 --> 00:13:02,850



231
00:13:02,850 --> 00:13:13,859
And just so everyone remembers, relax u, v, w is if d of v
所有人都记得，放松u，v，w是v的d 

232
00:13:14,059 --> 00:13:29,449
is greater than d of u plus w u v then we'll set d v to be--
大于u + w uv的d，那么我们将dv设置为- 

233
00:13:29,450 --> 00:13:32,200
and we also set pi v to be u.
并且我们还将pi v设置为u。 

234
00:13:32,200 --> 00:13:35,110



235
00:13:35,110 --> 00:13:35,610
OK.
好。 

236
00:13:35,610 --> 00:13:41,080



237
00:13:41,080 --> 00:13:45,730
That's relax operation over here.
这是这里的放松操作。 

238
00:13:45,730 --> 00:13:48,460
So that's the algorithm.
这就是算法。 

239
00:13:48,460 --> 00:13:57,460
And if you know magically that they're
如果你神奇地知道他们是

240
00:13:57,460 --> 00:14:01,840
no negative cycles in the graph.
图中没有负循环。 

241
00:14:01,840 --> 00:14:04,609
So if they're no negative cycles in the graph,
因此，如果它们在图中没有负周期， 

242
00:14:04,809 --> 00:14:07,359
then after these-- we'll have to prove this.
然后在这些之后-我们必须证明这一点。 

243
00:14:07,360 --> 00:14:10,109
But after these v minus 1 passes you're
但是在这些v减1通过之后， 

244
00:14:10,309 --> 00:14:12,730
going to get the correct shortest pathways.
以获得正确的最短路径。 

245
00:14:12,730 --> 00:14:13,230
OK?
好？ 

246
00:14:13,230 --> 00:14:15,759



247
00:14:15,759 --> 00:14:17,460
You want to do a little bit more, right?
您想做更多一点，对吗？ 

248
00:14:17,460 --> 00:14:21,950
I motivated what we want Bellman-Ford to do
我激发了我们希望贝尔曼·福特做的事情

249
00:14:21,950 --> 00:14:23,700
earlier in the lecture.
在讲座的前面。 

250
00:14:23,700 --> 00:14:26,009
So you can also do a check.
因此，您也可以进行检查。 

251
00:14:26,009 --> 00:14:30,750
So you may not know if they're negative weight cycles or not.
因此，您可能不知道它们是否为负体重循环。 

252
00:14:30,750 --> 00:14:32,519
But at this point, you can say I'm
但是在这一点上，你可以说我

253
00:14:32,519 --> 00:14:37,189
going to do one more pass so the v path-- the v
再做一遍，所以v路径-v 

254
00:14:37,190 --> 00:14:41,440
is the number of vertices-- over the graph.
是图形上的顶点数。 

255
00:14:41,440 --> 00:14:48,940
So for each edge in the graph, if you do one more relaxation
因此，对于图形中的每个边，如果再放松一遍

256
00:14:48,940 --> 00:14:55,599
and you see that d v is greater than d u plus w u v. So
您会看到dv大于du plus wu v。 

257
00:14:55,799 --> 00:14:57,049
you're not doing a relaxation.
你没有放松。 

258
00:14:57,049 --> 00:15:02,179
You're doing a check to see if you can relax the edge.
您正在检查是否可以放松边缘。 

259
00:15:02,179 --> 00:15:11,859
Then report minus v negative cycle exists.
然后报告存在负v负循环。 

260
00:15:11,860 --> 00:15:15,729
So this is the check.
这就是支票。 

261
00:15:15,929 --> 00:15:17,849
And the first part is the computation.
第一部分是计算。 

262
00:15:17,850 --> 00:15:22,109



263
00:15:22,309 --> 00:15:23,289
So that's kind of neat.
所以这很整洁。 

264
00:15:23,289 --> 00:15:26,719
I mean, it fit's on a board.
我的意思是，这很合适。 

265
00:15:26,720 --> 00:15:29,139
We talk about the correctness.
我们谈论正确性。 

266
00:15:29,139 --> 00:15:31,085
The functionality, I hope everyone got.
功能，希望大家都能得到。 

267
00:15:31,085 --> 00:15:33,850
Do people understand what's happening here
人们了解这里发生的事情吗

268
00:15:33,850 --> 00:15:35,100
with respect to functionality?
关于功能？ 

269
00:15:35,100 --> 00:15:35,682
Any questions?
任何问题？ 

270
00:15:35,682 --> 00:15:37,489



271
00:15:37,489 --> 00:15:38,954
Not about correctness but functionality?
不是关于正确性而是功能？ 

272
00:15:39,154 --> 00:15:39,654
Yeah?
是啊

273
00:15:39,654 --> 00:15:41,213
AUDIENCE: Where does the [INAUDIBLE]
听众：[听不清]在哪里

274
00:15:41,214 --> 00:15:42,567
get used in the formula?
在公式中使用？ 

275
00:15:42,567 --> 00:15:43,985
PROFESSOR: Oh, it doesn't.
教授：哦，不是。 

276
00:15:43,985 --> 00:15:46,779



277
00:15:46,779 --> 00:15:48,379
It's just a counter that makes sure
只是一个可以确保

278
00:15:48,379 --> 00:15:50,335
that you do v minus 1 passes.
你做v减去1遍。 

279
00:15:50,335 --> 00:15:54,759



280
00:15:54,759 --> 00:15:57,689
So what's that complexity of this algorithm
那这个算法的复杂度是多少

281
00:15:57,690 --> 00:16:03,490
using the best data structure that we can think of?
使用我们能想到的最佳数据结构？ 

282
00:16:03,490 --> 00:16:03,990
Anyone?
任何人？ 

283
00:16:03,990 --> 00:16:07,957



284
00:16:07,957 --> 00:16:08,949
Yeah, go ahead.
是的，继续。 

285
00:16:08,950 --> 00:16:12,918
AUDIENCE: [INAUDIBLE] v plus e if you're using a [INAUDIBLE]
观众：[音频不清晰] v加e（如果您使用的是[音频不清晰] 

286
00:16:12,918 --> 00:16:14,186
to access [INAUDIBLE]?
访问[听不清]？ 

287
00:16:14,386 --> 00:16:15,219
PROFESSOR: v plus e?
教授：v加e？ 

288
00:16:15,220 --> 00:16:18,412
AUDIENCE: Or v e plus e.
听众：或ve加e。 

289
00:16:18,412 --> 00:16:20,431
PROFESSOR: So that would be?
教授：那会是吗？ 

290
00:16:20,631 --> 00:16:22,294
AUDIENCE: That's using a dictionary?
听众：那是在用字典吗？ 

291
00:16:22,294 --> 00:16:24,169
PROFESSOR: Yeah, I know. v e plus e would be?
教授：是的，我知道。 ve plus e是吗？ 

292
00:16:24,169 --> 00:16:25,203
That's correct but.
没错，但是。 

293
00:16:25,203 --> 00:16:26,120
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

294
00:16:26,120 --> 00:16:26,827
PROFESSOR: Right.
教授：对。 

295
00:16:26,827 --> 00:16:31,799
But I mean when do v e plus e you can ignore the e.
但是我的意思是，当做ve plus e时，您可以忽略e。 

296
00:16:31,799 --> 00:16:36,750
So say you have just v times e.
因此，说您只有v倍e。 

297
00:16:36,750 --> 00:16:37,250
All right.
好吧。 

298
00:16:37,250 --> 00:16:37,580
Good.
好。 

299
00:16:37,580 --> 00:16:37,878
Here you go.
干得好。 

300
00:16:38,078 --> 00:16:41,189



301
00:16:41,190 --> 00:16:44,830
So this part here is v times e.
所以这部分是v乘以e。 

302
00:16:44,830 --> 00:16:46,490
And it doesn't really matter.
这并不重要。 

303
00:16:46,490 --> 00:16:49,990
I mean, you can use an array structure adjacency list.
我的意思是，您可以使用数组结构邻接表。 

304
00:16:49,990 --> 00:16:54,142
It's not like Dijkstra where we have this neat requirement
不像Dijkstra，我们有这个整洁的要求

305
00:16:54,142 --> 00:16:56,100
for a priority queue and there's different ways
优先队列，有不同的方法

306
00:16:56,100 --> 00:16:58,840
of implementing the priority queue.
实现优先级队列的过程。 

307
00:16:58,840 --> 00:17:02,079
This part would be order of v e.
这部分将是v e的顺序。 

308
00:17:02,279 --> 00:17:05,059
And that gives you the overall complexity.
这给您带来整体复杂性。 

309
00:17:05,059 --> 00:17:07,639
This part here is only one pass through the edges.
这里的这部分只是边缘的一遍。 

310
00:17:07,640 --> 00:17:10,390
So that's order e, like you said.
就像您说的那样，这就是顺序e。 

311
00:17:10,390 --> 00:17:13,128
So the complexities order v e.
因此，复杂度阶为v e。 

312
00:17:13,328 --> 00:17:17,519
And this could be large, as I said before in, I think,
正如我之前所说，这可能很大

313
00:17:17,519 --> 00:17:18,930
the first lecture.
第一堂课。 

314
00:17:18,930 --> 00:17:26,710
e is order of v square in a simple graph.
 e是简单图中v平方的阶数。 

315
00:17:26,710 --> 00:17:29,240
So you might end up with a v cubed complexity
因此，您可能最终会获得AV多维数据集的复杂性

316
00:17:29,240 --> 00:17:30,690
if you run Bellman-Ford.
如果您运行Bellman-Ford。 

317
00:17:30,690 --> 00:17:33,410
So there's no question that Bellman-Ford
所以毫无疑问，贝尔曼·福特

318
00:17:33,410 --> 00:17:37,170
is, from a practical standpoint, substantially slower
从实际的角度来看，要慢得多

319
00:17:37,170 --> 00:17:38,880
than Dijkstra.
比Dijkstra。 

320
00:17:38,880 --> 00:17:46,460
You can get Dijkstra down to linear complexity.
您可以将Dijkstra降低到线性复杂度。 

321
00:17:46,460 --> 00:17:49,049
But this would potentially, at least in terms of vertices,
但这至少在顶点上可能会

322
00:17:49,049 --> 00:17:52,319
be cubic complexity.
三次复杂度。 

323
00:17:52,319 --> 00:17:54,979
So when you have a chance, you want to use Dijkstra.
因此，如果有机会，您想使用Dijkstra。 

324
00:17:54,979 --> 00:17:56,519
And you're forced to use Bellman-Ford
而且您被迫使用Bellman-Ford 

325
00:17:56,519 --> 00:17:58,839
because you could potentially have negative weight
因为你可能会负重

326
00:17:58,839 --> 00:18:01,099
cycles while you're stuck with that.
循环，而你一直坚持下去。 

327
00:18:01,099 --> 00:18:03,099
All right?
好吧？ 

328
00:18:03,099 --> 00:18:04,769
OK, so why does this work?
好，那为什么行得通？ 

329
00:18:04,769 --> 00:18:06,829
This looks a bit like magic.
这看起来有点像魔术。 

330
00:18:06,829 --> 00:18:12,259
It turns out we can actually do a fairly straightforward proof
事实证明，我们实际上可以做一个相当简单的证明

331
00:18:12,259 --> 00:18:14,480
of correctness of Bellman-Ford.
 Bellman-Ford的正确性。 

332
00:18:14,480 --> 00:18:15,784
And we're going to do two things.
我们将做两件事。 

333
00:18:15,984 --> 00:18:19,849
We're going to not only show that if negative weight
我们不仅要显示负重量

334
00:18:19,849 --> 00:18:25,539
cycles don't exist that this will correctly
周期不存在，这将正确

335
00:18:25,539 --> 00:18:27,720
compute shorter stats.
计算较短的统计信息。 

336
00:18:27,720 --> 00:18:31,480
But we also have to show that it will detect negative weight
但是我们还必须证明它将检测负重

337
00:18:31,480 --> 00:18:33,900
cycles if they in fact exist.
循环，如果它们确实存在。 

338
00:18:33,900 --> 00:18:35,670
So there's two parts to this.
因此，有两个部分。 

339
00:18:35,670 --> 00:18:36,644
And let's start.
让我们开始吧。 

340
00:18:36,644 --> 00:18:39,480



341
00:18:39,480 --> 00:18:43,839
So what we have here for this algorithm
所以我们在这里有这个算法

342
00:18:43,839 --> 00:18:55,439
is that it can guarantee in a graph g equals
可以保证在图中g等于

343
00:18:55,440 --> 00:19:13,150
v E. If it contains no negative weight cycles then
 v E.如果不包含负重量循环，则

344
00:19:13,150 --> 00:19:21,649
after Bellman-Ford finishes execution,
贝尔曼·福特完成执行后， 

345
00:19:21,849 --> 00:19:33,299
d v equals delta s v for all v belonging to v. All right?
对于属于v的所有v，dv等于delta sv。好吗？ 

346
00:19:33,299 --> 00:19:35,460
And then there's that.
然后就是那个。 

347
00:19:35,460 --> 00:19:37,289
That's the theorem you want to prove.
那就是你要证明的定理。 

348
00:19:37,289 --> 00:19:44,230
And the second piece of it is corollary
第二部分是必然的

349
00:19:44,230 --> 00:19:46,210
that we want to prove.
我们想证明的。 

350
00:19:46,210 --> 00:19:48,259
And that has to do with the check.
这与支票有关。 

351
00:19:48,259 --> 00:19:55,460
And this says if a value of d of v
这表示如果d的值为v 

352
00:19:55,460 --> 00:20:05,529
fails to converge after v minus 1
 v减1后无法收敛

353
00:20:05,529 --> 00:20:17,415
passes there exists a negative weight cycle reachable from s.
通过时，存在一个从s可以达到的负重量循环。 

354
00:20:17,415 --> 00:20:24,119



355
00:20:24,119 --> 00:20:29,399
So those are the two things that we need to show.
这就是我们需要展示的两件事。 

356
00:20:29,400 --> 00:20:31,670
I'll probably take a few minutes to do each of these.
我可能要花几分钟来做这些。 

357
00:20:31,670 --> 00:20:34,169
That theorem is a little more involved.
该定理涉及更多。 

358
00:20:34,369 --> 00:20:37,103



359
00:20:37,104 --> 00:20:38,519
So one of the first things that we
所以我们要做的第一件事

360
00:20:38,519 --> 00:20:41,940
have to do in order to prove this theorem
为了证明这个定理必须做

361
00:20:41,940 --> 00:20:50,880
is to think about exactly what the shortest path corresponds
是在思考最短路径的确切含义

362
00:20:50,880 --> 00:20:53,109
to in a generic sense.
从一般意义上讲

363
00:20:53,309 --> 00:20:58,899
So when we have source vertex s and you have
所以当我们有源顶点，而你有

364
00:20:58,900 --> 00:21:02,609
a particular vertex v then there's
一个特定的顶点v然后

365
00:21:02,809 --> 00:21:07,759
the picture that we need to keep in mind as we try
尝试时需要牢记的图片

366
00:21:07,759 --> 00:21:09,779
and prove this theorem.
并证明这个定理。 

367
00:21:09,779 --> 00:21:18,230
So you have v0, v1, v2, et cetera all the way to vk.
因此，您一直拥有v0，v1，v2等，直到vk。 

368
00:21:18,230 --> 00:21:21,460
This is my vertex v. This is s.
这是我的顶点v。这是s。 

369
00:21:21,460 --> 00:21:24,659
So s equals v0.
所以s等于v0。 

370
00:21:24,859 --> 00:21:26,149
V equals vk.
 V等于vk。 

371
00:21:26,150 --> 00:21:26,669
All right?
好吧？ 

372
00:21:26,869 --> 00:21:29,969
So I'm going to have a path p.
所以我要走一条路。 

373
00:21:29,970 --> 00:21:35,470
That is v0, v1, all the way to vk.
那就是v0，v1，一直到vk。 

374
00:21:35,470 --> 00:21:35,970
OK?
好？ 

375
00:21:35,970 --> 00:21:40,809



376
00:21:40,809 --> 00:21:46,200
How big is k in the worst case?
在最坏的情况下k有多大？ 

377
00:21:46,200 --> 00:21:46,919
How big is k?
 k多大？ 

378
00:21:47,119 --> 00:21:50,939



379
00:21:50,940 --> 00:21:51,950
Anybody?
有人吗

380
00:21:51,950 --> 00:21:52,294
How big is k?
 k多大？ 

381
00:21:52,494 --> 00:21:55,149



382
00:21:55,150 --> 00:21:56,535
It's up on the black board.
在黑板上。 

383
00:21:56,535 --> 00:21:58,190
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

384
00:21:58,190 --> 00:21:59,500
PROFESSOR: v minus 1, right?
教授：v减1，对不对？ 

385
00:21:59,500 --> 00:22:00,000
Why?
为什么？ 

386
00:22:00,000 --> 00:22:03,369



387
00:22:03,369 --> 00:22:08,519
What would happen if k is larger than v minus 1?
如果k大于v减去1，会发生什么？ 

388
00:22:08,519 --> 00:22:09,549
I'd have a cycle.
我要骑自行车。 

389
00:22:09,549 --> 00:22:11,779
I'd be visiting a vertex more than once.
我会不止一次访问顶点。 

390
00:22:11,779 --> 00:22:13,869
And it wouldn't be a simple path.
这不是一条简单的道路。 

391
00:22:13,869 --> 00:22:14,369
Right?
对？ 

392
00:22:14,369 --> 00:22:17,299



393
00:22:17,299 --> 00:22:24,809
So k is less than or equal to v minus 1 else I'd have a cycle.
所以k小于或等于v减去1，否则我会有一个循环。 

394
00:22:24,809 --> 00:22:26,589
OK?
好？ 

395
00:22:26,589 --> 00:22:28,629
I wouldn't have a simple path.
我没有简单的道路。 

396
00:22:28,630 --> 00:22:31,319
And we're looking for the shortest, simple paths
我们正在寻找最短，最简单的路径

397
00:22:31,519 --> 00:22:33,150
because if you ever get to the point
因为如果你能做到这一点

398
00:22:33,150 --> 00:22:35,470
where-- why are we looking for shortest, simple paths?
在哪里-我们为什么要寻找最短，最简单的路径？ 

399
00:22:35,470 --> 00:22:39,245
Well, in this case, we're looking
好吧，在这种情况下，我们正在寻找

400
00:22:39,445 --> 00:22:40,569
for shortest, simple paths.
最短，最简单的路径。 

401
00:22:40,569 --> 00:22:43,700
And if there's a negative cycle, we're
如果有一个负周期，我们就是

402
00:22:43,700 --> 00:22:46,900
in trouble because the shortest path is not
陷入困境，因为最短的路径不是

403
00:22:46,900 --> 00:22:49,690
necessarily the simple path because you
必然是简单的路径，因为您

404
00:22:49,690 --> 00:22:52,730
could go around the cycle a bunch of times.
可能会绕过周期很多次。 

405
00:22:52,730 --> 00:22:54,079
I'll get back to that.
我会回到那。 

406
00:22:54,079 --> 00:22:58,679
But in the case where we're trying to prove the theorem,
但是在我们要证明该定理的情况下， 

407
00:22:58,680 --> 00:23:00,808
we know that no negative cycles exist.
我们知道不存在负周期。 

408
00:23:00,808 --> 00:23:02,349
We can assume that no negative cycles
我们可以假设没有负周期

409
00:23:02,349 --> 00:23:04,059
exist for the case of the theorem.
定理的情况下存在。 

410
00:23:04,059 --> 00:23:07,940
And we want to show that Bellman-Ford correctly
我们想正确地证明Bellman-Ford 

411
00:23:07,940 --> 00:23:11,230
computes each of the shortest path weights.
计算每个最短路径权重。 

412
00:23:11,230 --> 00:23:13,970
And in that case, there's no negative weight cycles.
在这种情况下，没有负重量循环。 

413
00:23:13,970 --> 00:23:16,954
We're guaranteed that k is less than or equal to v minus 1.
我们保证k小于或等于v减去1。 

414
00:23:16,954 --> 00:23:18,879
All right?
好吧？ 

415
00:23:18,880 --> 00:23:21,190
Everybody buy that?
大家都买吗？ 

416
00:23:21,190 --> 00:23:21,880
Good.
好。 

417
00:23:21,880 --> 00:23:22,380
All right.
好吧。 

418
00:23:22,380 --> 00:23:24,500
So that's the picture I want you keep in mind.
这就是我要记住的图片。 

419
00:23:24,500 --> 00:23:30,474
Let's dive in and prove this theorem.
让我们深入研究并证明该定理。 

420
00:23:30,474 --> 00:23:33,129
And we prove it using induction.
我们用归纳法证明这一点。 

421
00:23:33,130 --> 00:23:51,359



422
00:23:51,559 --> 00:23:54,829
So let v be any vertex.
因此，令v为任何顶点。 

423
00:23:54,829 --> 00:23:57,779
And let's say that we're looking at a path.
假设我们正在寻找一条道路。 

424
00:23:57,779 --> 00:24:01,779
v0, v1, v2, to vk.
 v0，v1，v2到vk。 

425
00:24:01,779 --> 00:24:06,569
And like I said, from v0 equals s to vk
就像我说的，从v0等于s到vk 

426
00:24:06,569 --> 00:24:14,269
equals v. And in particular, I'm not
等于v。尤其是我不是

427
00:24:14,269 --> 00:24:22,829
going to say that this path p is a shortest
会说这条路径p是最短的

428
00:24:22,829 --> 00:24:28,835
path with the minimum number of edges.
边数最少的路径。 

429
00:24:28,835 --> 00:24:33,549



430
00:24:33,549 --> 00:24:35,769
So there may be many shortest paths.
因此，可能有许多最短的路径。 

431
00:24:35,769 --> 00:24:37,230
And I'm going to pick the one that
我要挑选一个

432
00:24:37,230 --> 00:24:39,039
has the minimum number of edges.
的边数最少。 

433
00:24:39,039 --> 00:24:42,019
If there's a unique shortest path, then that's a given.
如果有唯一的最短路径，那就是给定的。 

434
00:24:42,019 --> 00:24:46,579
But it may be that I have a path with four edges that
但是可能我有一条带有四个边缘的路径

435
00:24:46,579 --> 00:24:48,879
has the same weight as another path with three edges.
具有与具有三个边的另一条路径相同的权重。 

436
00:24:48,880 --> 00:24:51,390
I'm going to pick the one that has three edges.
我将选择具有三个边缘的那个。 

437
00:24:51,390 --> 00:24:51,890
OK?
好？ 

438
00:24:51,890 --> 00:24:54,205
So it may not be unique with respect
因此在尊重方面可能并非唯一

439
00:24:54,405 --> 00:24:56,529
that they're not necessarily unique shortest paths.
他们不一定是唯一的最短路径。 

440
00:24:56,529 --> 00:24:59,899
But I can certainly pick one.
但是我当然可以选一个。 

441
00:24:59,900 --> 00:25:07,169
And no negative weight cycles implies that p is simple.
而且没有负权重循环意味着p很简单。 

442
00:25:07,369 --> 00:25:10,389



443
00:25:10,390 --> 00:25:16,660
And that implies that k is less than or equal to v minus 1,
这意味着k小于或等于v减去1， 

444
00:25:16,660 --> 00:25:19,470
which is what I just argued.
这就是我刚才所说的。 

445
00:25:19,470 --> 00:25:24,559
Now keep in mind that picture over there to the right.
现在，请记住那张右边的图片。 

446
00:25:24,559 --> 00:25:30,849
And basically, the argument is going to go as follows.
基本上，争论将如下进行。 

447
00:25:30,849 --> 00:25:33,250
Remember that I'm going to be relaxing
记住我要放松

448
00:25:33,250 --> 00:25:38,309
every edge in each pass of the algorithm.
算法每次通过的每个边缘。 

449
00:25:38,309 --> 00:25:39,119
OK?
好？ 

450
00:25:39,119 --> 00:25:42,449
There's no choices here.
这里没有选择。 

451
00:25:42,450 --> 00:25:45,490
I'm going be relaxing every edge in each pass of the algorithm.
我将放松算法每一遍的每个方面。 

452
00:25:45,490 --> 00:25:48,680
And essentially, the proof goes as follows.
本质上，证明如下。 

453
00:25:48,680 --> 00:25:53,930
I'm going to be moving closer and closer to vk
我将越来越接近vk 

454
00:25:53,930 --> 00:26:00,170
and constructing this shortest path at every pass.
并在每次通过时都构建最短的路径。 

455
00:26:00,170 --> 00:26:04,140
So at some point in the first pass,
所以在第一遍的某个时刻， 

456
00:26:04,140 --> 00:26:07,419
I'm going to relax this edge v0, v1.
我将放松此边缘v0，v1。 

457
00:26:07,619 --> 00:26:08,599
OK?
好？ 

458
00:26:08,599 --> 00:26:14,639
And at that point, thanks to the optimal substructure property,
在这一点上，由于具有最佳的子结构属性， 

459
00:26:14,640 --> 00:26:16,599
given that this is the shortest path,
鉴于这是最短的路径， 

460
00:26:16,799 --> 00:26:19,379
this has to be a shortest path, as well.
这也必须是最短的路径。 

461
00:26:19,380 --> 00:26:22,880
Any subset of the shortest path has to be a shortest path.
最短路径的任何子集都必须是最短路径。 

462
00:26:22,880 --> 00:26:25,150
I'm going to relax this edge and I'm
我要放松这一优势，我

463
00:26:25,150 --> 00:26:30,899
going to get the value of delta from s to v1.
将从s到v1获得增量值。 

464
00:26:31,099 --> 00:26:33,429
And it's going to be this relaxation that's
这将是这种放松

465
00:26:33,430 --> 00:26:34,861
going to get me that value.
会给我那个价值。 

466
00:26:34,861 --> 00:26:37,159
And after the first pass, I'm going to be able to get to v1.
在第一遍之后，我将能够进入v1。 

467
00:26:37,359 --> 00:26:39,419
After the second pass, I can get to v2.
在第二遍之后，我可以进入v2了。 

468
00:26:39,420 --> 00:26:42,220
And after k passes, I'm going to be able to get to vk.
在k过去之后，我将能够进入vk。 

469
00:26:42,220 --> 00:26:46,899
So I'm just growing this frontier one node every pass.
因此，我只是每过一遍就在这个前沿领域发展一个节点。 

470
00:26:47,099 --> 00:26:49,379
And that's your induction.
那就是你的归纳。 

471
00:26:49,380 --> 00:26:51,379
And you can write that out.
您可以将其写出来。 

472
00:26:51,579 --> 00:26:53,659
And I'll write it out here.
我会在这里写出来。 

473
00:26:53,660 --> 00:26:55,640
But that's basically it.
但是基本上就是这样。 

474
00:26:55,640 --> 00:27:10,640
So after one pass through all of the edges e, we have d of v1
因此，在通过所有边e之后，我们得到了v1的d 

475
00:27:10,640 --> 00:27:12,359
to be delta s v1.
是delta s v1。 

476
00:27:12,559 --> 00:27:15,889



477
00:27:15,890 --> 00:27:19,380
And the reason for this is because we'll relax.
这样做的原因是因为我们会放松。 

478
00:27:19,380 --> 00:27:25,109



479
00:27:25,309 --> 00:27:27,299
We're guaranteed to relax all the edges.
我们保证放松所有的边缘。 

480
00:27:27,299 --> 00:27:33,819
And we'll relax the edge v0, v1 during this pass.
在此过程中，我们将放松边缘v0，v1。 

481
00:27:33,819 --> 00:27:36,539



482
00:27:36,539 --> 00:27:39,480
And we can't find a shorter path than this path
我们找不到比这条路更短的路

483
00:27:39,480 --> 00:27:41,950
because, otherwise we'd violate the optimum substructure
因为，否则我们将违反最佳子结构

484
00:27:41,950 --> 00:27:44,000
property.
属性。 

485
00:27:44,000 --> 00:27:47,269
And that means that it's a contradiction
这意味着这是一个矛盾

486
00:27:47,269 --> 00:27:50,369
that we selected a shortest path in the first place.
首先我们选择了最短路径

487
00:27:50,369 --> 00:27:57,069
So can argue that we have delta s v1 after the first pass.
因此可以辩称，第一遍之后我们有delta s v1。 

488
00:27:57,069 --> 00:27:58,245
And this goes on.
这样下去。 

489
00:27:58,246 --> 00:27:59,419
I'm going to write out this proof
我要写这个证明

490
00:27:59,619 --> 00:28:01,589
because I think it's important for you guys
因为我认为这对你们很重要

491
00:28:01,589 --> 00:28:06,339
to see the full proof.
查看完整的证明。 

492
00:28:06,339 --> 00:28:08,599
But you can probably guess the rest at this point.
但是您可能现在可以猜测其余的内容。 

493
00:28:08,599 --> 00:28:16,779



494
00:28:16,779 --> 00:28:18,319
After one pass, that's what you get.
经过一遍，这就是您得到的。 

495
00:28:18,319 --> 00:28:25,939
After two passes through e we have
经过两次e之后

496
00:28:25,940 --> 00:28:33,710
d v2 equals delta s v2 because in the second pass
 d v2等于delta s v2，因为在第二遍

497
00:28:33,710 --> 00:28:38,500
we're going to relax edge v1, v2.
我们将放宽边缘v1，v2。 

498
00:28:38,500 --> 00:28:46,949



499
00:28:46,949 --> 00:28:48,990
So it' a different edge that needs to be relaxed.
因此，这是另一条需要放松的地方。 

500
00:28:48,990 --> 00:28:51,400
But that's cool because I'm relaxing all the edges.
但这很酷，因为我正在放松所有边缘。 

501
00:28:51,400 --> 00:28:53,740
And I'm going to be able to grow my frontier.
而且我将能够扩大自己的疆界。 

502
00:28:53,740 --> 00:28:57,019
I'm going to be able to compute delta s v2 and the end
我将能够计算delta s v2和结束

503
00:28:57,019 --> 00:29:00,819
of my second pass and so on and so forth.
我的第二遍，等等。 

504
00:29:00,819 --> 00:29:13,450
So after k passes, we have d vk equals delta s vk.
因此，经过k次之后，我们的d vk等于delta s vk。 

505
00:29:13,450 --> 00:29:15,899



506
00:29:16,099 --> 00:29:26,319
And if I run through v minus 1 passes, which
如果我通过v减去1遍， 

507
00:29:26,319 --> 00:29:37,069
is what I do in the algorithm, all reachable vertices
是我在算法中所做的，所有可到达的顶点

508
00:29:37,069 --> 00:29:38,569
have delta values.
具有增量值。 

509
00:29:38,569 --> 00:29:41,409



510
00:29:41,410 --> 00:29:41,910
All right?
好吧？ 

511
00:29:41,910 --> 00:29:44,231
That's basically it.
基本上就是这样。 

512
00:29:44,231 --> 00:29:44,815
Any questions?
任何问题？ 

513
00:29:44,815 --> 00:29:51,220



514
00:29:51,220 --> 00:29:55,710
It's actually a simpler proof than the Dijkstra proof,
它实际上比Dijkstra证明更简单， 

515
00:29:55,710 --> 00:29:57,454
which I just sketched last time.
我上次刚刚绘制的草图。 

516
00:29:57,454 --> 00:29:58,829
I'll just give you some intuition
我会给你一些直觉

517
00:29:58,829 --> 00:29:59,849
of the Dijkstra proof.
 Dijkstra证明。 

518
00:29:59,849 --> 00:30:04,589
It's probably a little too painful to do in a lecture.
在讲课中做起来可能有些痛苦。 

519
00:30:04,589 --> 00:30:09,659
But this one is, as you can see, nice and clean and fits
但是，正如您所看到的，这是一个不错的，干净的，合适的

520
00:30:09,660 --> 00:30:14,419
on two boards, which is kind of an important criterion here.
在两个板上，这在这里是一个重要标准。 

521
00:30:14,619 --> 00:30:16,369
So good.
这么好。 

522
00:30:16,369 --> 00:30:19,939
All right, so that takes care of the theorem.
好的，这样就可以处理定理。 

523
00:30:19,940 --> 00:30:21,940
Hopefully you're all on board with the theorem.
希望大家都支持该定理。 

524
00:30:21,940 --> 00:30:26,230
And one thing that we haven't done is talk about the check.
我们还没有做的一件事就是谈论支票。 

525
00:30:26,230 --> 00:30:31,180
So the argument with respect to the corollary
所以关于推论的争论

526
00:30:31,180 --> 00:30:36,490
bootstraps this particular argument for the theorem.
引导定理的这个特定论点。 

527
00:30:36,490 --> 00:30:44,109
But this requires the insight that if after v
但这需要洞察力

528
00:30:44,109 --> 00:30:49,789
minus 1 passes, if you can find an edge that can be relaxed,
负1遍，如果您发现可以放松的边缘， 

529
00:30:49,789 --> 00:30:50,980
well what does that mean?
那是什么意思？ 

530
00:30:50,980 --> 00:31:03,493



531
00:31:03,493 --> 00:31:11,279
So at this point, let's say that I've done my v minus 1 passes
因此，在这一点上，假设我已经完成了v减1遍

532
00:31:11,279 --> 00:31:19,724
and we find an edge that can be relaxed.
我们发现可以放松的边缘。 

533
00:31:19,724 --> 00:31:23,309



534
00:31:23,309 --> 00:31:39,210
Well, this means that the current shortest path from s
好吧，这意味着当前距离s的最短路径

535
00:31:39,210 --> 00:31:47,200
to some vertex that is obviously reachable v
到一些显然可以达到的顶点

536
00:31:47,200 --> 00:31:56,169
is not simple once I've relaxed this edge because I
一旦放松了这一优势，这并不简单，因为我

537
00:31:56,369 --> 00:32:01,285
have a repeated vertex.
具有重复的顶点。 

538
00:32:01,286 --> 00:32:08,000



539
00:32:08,000 --> 00:32:11,160
So that means it's not simple to have a repeated vertex that's
因此，这意味着要重复一个顶点并不简单

540
00:32:11,160 --> 00:32:13,140
the same as I found a cycle.
就像我发现一个周期一样。 

541
00:32:13,140 --> 00:32:16,839



542
00:32:17,039 --> 00:32:19,940
And it's a negative weight cycle because I
这是负的体重循环，因为我

543
00:32:19,940 --> 00:32:24,799
was able to relax the edge and reduce the weight after I
我之后能够放松边缘并减轻体重

544
00:32:24,799 --> 00:32:28,120
added a vertex that cost a cycle.
添加了一个花费一个周期的顶点。 

545
00:32:28,121 --> 00:32:28,419
All right?
好吧？ 

546
00:32:28,619 --> 00:32:32,236
So this cycle has to be negative weight.
因此，这个周期必须是负重量。 

547
00:32:32,237 --> 00:32:33,619
Found a cycle that is negative weight.
发现一个负重的周期。 

548
00:32:33,819 --> 00:32:39,929



549
00:32:39,930 --> 00:32:40,794
All right.
好吧。 

550
00:32:40,794 --> 00:32:41,710
That's pretty much it.
就是这样。 

551
00:32:41,710 --> 00:32:46,200



552
00:32:46,200 --> 00:32:49,920
So it's, I guess, a painful algorithm
我想这是一个痛苦的算法

553
00:32:49,920 --> 00:32:52,779
from a standpoint of it's not particularly smart.
从它的角度来看不是特别聪明。 

554
00:32:52,779 --> 00:32:54,339
It's just relaxing all of the edges
只是放松所有的边缘

555
00:32:54,339 --> 00:32:56,559
a certain fixed number of times.
一定的固定次数。 

556
00:32:56,559 --> 00:33:02,940
And it just works out because you will find these cycles.
它之所以奏效，是因为您会发现这些循环。 

557
00:33:02,940 --> 00:33:06,101
And if you keep going, it's like this termination condition.
而且，如果您继续前进，就像终止条件一样。 

558
00:33:06,301 --> 00:33:08,759
What is neat is that I don't have the generic shortest path
整洁的是，我没有通用的最短路径

559
00:33:08,759 --> 00:33:10,450
algorithm up there anymore.
算法了。 

560
00:33:10,450 --> 00:33:12,150
But in effect, what you're saying
但是实际上，你在说什么

561
00:33:12,150 --> 00:33:14,759
is after a certain number of passes,
经过一定次数的通过之后

562
00:33:14,759 --> 00:33:16,750
if you haven't finished, you can quit
如果还没有完成，可以退出

563
00:33:16,750 --> 00:33:19,599
because you have found a negative cycle.
因为您发现了一个负周期。 

564
00:33:19,599 --> 00:33:22,709
So it's very similar to the generic shortest path
因此，它与通用最短路径非常相似

565
00:33:22,710 --> 00:33:23,990
algorithm.
算法。 

566
00:33:23,990 --> 00:33:25,599
You're not really selecting the edges.
您并不是真正选择边缘。 

567
00:33:25,599 --> 00:33:28,079
You're selecting all of them, in this case.
在这种情况下，您要选择所有这些。 

568
00:33:28,079 --> 00:33:31,309
And you're running through a bunch of different passes.
您正在经历一系列不同的过程。 

569
00:33:31,309 --> 00:33:34,259
All right?
好吧？ 

570
00:33:34,259 --> 00:33:36,769
So that's it with respect to Bellman-Ford.
就贝尔曼-福特而言就是这样。 

571
00:33:36,769 --> 00:33:38,799
I want to do a couple of special cases
我想做几个特殊情况

572
00:33:38,799 --> 00:33:41,740
and revisit the directed acyclic graph.
并重新查看有向无环图。 

573
00:33:41,740 --> 00:33:45,339
But stop me here if you have any questions about Bellman-Ford.
但是，如果您对贝尔曼福特有任何疑问，请在这里停下来。 

574
00:33:45,339 --> 00:33:48,269



575
00:33:48,269 --> 00:33:49,989
You first and then back there.
你先，然后回到那里。 

576
00:33:49,989 --> 00:33:50,489
Yeah?
是啊

577
00:33:50,489 --> 00:33:52,132
AUDIENCE: Maybe I'm just confused
听众：也许我只是感到困惑

578
00:33:52,132 --> 00:33:54,749
about the definition of a cycle.
关于循环的定义。 

579
00:33:54,749 --> 00:33:57,123
But if you had, like, a tree, which had a negative weight
但是如果您有一棵负重的树

580
00:33:57,123 --> 00:33:58,755
edge, wouldn't it produce the same situation
边缘，会不会产生相同的情况

581
00:33:58,955 --> 00:34:01,359
where you relaxed that edge.
在那放松的地方。 

582
00:34:01,359 --> 00:34:03,839
PROFESSOR: But you would have relaxed that edge previously.
教授：但是您以前会放松这种优势。 

583
00:34:03,839 --> 00:34:04,809
AUDIENCE: But it wouldn't be a cycle, right?
听众：但这不是一个周期，对吗？ 

584
00:34:04,809 --> 00:34:06,750
PROFESSOR: Yeah, it wouldn't be a cycle.
教授：是的，这不是一个周期。 

585
00:34:06,750 --> 00:34:07,665
So let's look at that.
因此，让我们来看一下。 

586
00:34:07,665 --> 00:34:08,793
That's a fine question.
这是一个很好的问题。 

587
00:34:08,793 --> 00:34:10,417
AUDIENCE: Doesn't that make assumptions
听众：不是做假设

588
00:34:10,418 --> 00:34:12,528
about this structure?
关于这个结构？ 

589
00:34:12,528 --> 00:34:15,239
PROFESSOR: Well if you had a tree-- I mean,
教授：如果你有一棵树，我是说， 

590
00:34:15,239 --> 00:34:16,909
a tree is a really simple case.
一棵树是一个非常简单的案例。 

591
00:34:16,909 --> 00:34:20,340
But if you had something like this
但是如果你有这样的事情

592
00:34:20,340 --> 00:34:25,610
and if you did have a minus 1 edge here,
如果您的边缘确实有负1， 

593
00:34:25,610 --> 00:34:27,769
right-- we'll do a more complicated example.
是的-我们将做一个更复杂的例子。 

594
00:34:27,769 --> 00:34:29,519
But let's say you had something like this.
但是，假设您有这样的事情。 

595
00:34:29,519 --> 00:34:31,179
2 3 minus 1.
 2 3减1。 

596
00:34:31,179 --> 00:34:35,070
And what will happen is if this happens to be your s vertex
如果这恰好是您的顶点，将会发生什么

597
00:34:35,070 --> 00:34:38,949
and in the first step you relax all the edges.
第一步，放松所有边缘。 

598
00:34:38,949 --> 00:34:41,530
And this one would get two.
而这个将得到两个。 

599
00:34:41,530 --> 00:34:45,380
And then, depending on the order in which you relaxed,
然后，根据您放松的顺序， 

600
00:34:45,380 --> 00:34:50,199
it's quite possible that if you relax this edge first--
如果您先放松这一优势，很有可能

601
00:34:50,199 --> 00:34:56,070
let's say in the first pass the ordering of the relaxation
假设在第一遍中放松的顺序

602
00:34:56,070 --> 00:34:59,570
is 1, 2, and 3.
是1、2和3。 

603
00:34:59,570 --> 00:35:02,934
So the edges are ordered in a certain way each time,
因此，每次以某种方式对边缘进行排序， 

604
00:35:02,934 --> 00:35:04,900
and you're going to be relaxing the edges in exactly
而且您将完全放松边缘

605
00:35:05,099 --> 00:35:06,989
the same order each time.
每次相同的顺序。 

606
00:35:06,989 --> 00:35:07,939
All right?
好吧？ 

607
00:35:07,940 --> 00:35:08,829
It doesn't matter.
没关系

608
00:35:08,829 --> 00:35:10,545
The beauty of Bellman-Ford is that-- let's say
贝尔曼·福特的美丽在于-可以说

609
00:35:10,744 --> 00:35:11,949
you relax this edge.
您可以放松这一优势。 

610
00:35:11,949 --> 00:35:14,009
Initially, this is at infinity.
最初，这是无限的。 

611
00:35:14,010 --> 00:35:14,920
So this is at 0.
所以这是0。 

612
00:35:15,119 --> 00:35:16,029
This is at infinity.
这是无限的。 

613
00:35:16,030 --> 00:35:16,730
This is at infinity.
这是无限的。 

614
00:35:16,929 --> 00:35:18,799
This is at infinity.
这是无限的。 

615
00:35:18,800 --> 00:35:21,420
If you relax this edge, nothing happens.
如果放松此边缘，则什么也不会发生。 

616
00:35:21,420 --> 00:35:22,920
All right?
好吧？ 

617
00:35:22,920 --> 00:35:25,829
Then you relax, let's say, this edge because that's number two.
然后，您放松一下，说这条边缘，因为那是第二个。 

618
00:35:25,829 --> 00:35:27,819
This gets set to two.
这将设置为两个。 

619
00:35:27,820 --> 00:35:30,190
You relax this edge because that's 3.
您放宽此边缘，因为那是3。 

620
00:35:30,190 --> 00:35:31,909
And this is infinity so nothing happens.
而且这是无限的，所以什么也没有发生。 

621
00:35:31,909 --> 00:35:34,480
Of course, this is already at two so nothing would happen.
当然，已经是两点了，所以什么也不会发生。 

622
00:35:34,480 --> 00:35:38,420
So the end of the first pass, what you have is this is 0.
因此，第一遍的结尾是0。 

623
00:35:38,420 --> 00:35:39,329
That's 2.
那是2 

624
00:35:39,329 --> 00:35:41,059
This is still infinity.
这仍然是无限的。 

625
00:35:41,059 --> 00:35:42,769
That's still infinity.
那仍然是无限的。 

626
00:35:42,769 --> 00:35:43,269
OK?
好？ 

627
00:35:43,269 --> 00:35:45,603
That's going to stay infinity because you can't reach it
这将保持无限，因为您无法达到它

628
00:35:45,603 --> 00:35:45,980
from s.
来自。 

629
00:35:46,179 --> 00:35:47,799
So we can, sort of, ignore that.
因此，我们可以忽略它。 

630
00:35:47,800 --> 00:35:51,019
And then, of the second pass, what you have is
然后，第二遍，您拥有的是

631
00:35:51,219 --> 00:35:55,419
you start with this edge again because that's the ordering.
您再次从该边缘开始，因为这是顺序。 

632
00:35:55,420 --> 00:36:01,039
And this 2 minus 1 would give this a 1.
而这2减1会得到1。 

633
00:36:01,239 --> 00:36:04,719
And then you relax this edge or try to relax this edge.
然后放松该边缘或尝试放松该边缘。 

634
00:36:04,719 --> 00:36:06,061
Nothing happens.
什么都没发生。 

635
00:36:06,061 --> 00:36:07,019
Try to relax this edge.
尝试放松这一优势。 

636
00:36:07,019 --> 00:36:08,460
Nothing happens.
什么都没发生。 

637
00:36:08,460 --> 00:36:10,320
And at this point, you have one more pass
此时，您还有一个通行证

638
00:36:10,320 --> 00:36:12,110
to go because you got 4 vertices.
去，因为你有4个顶点。 

639
00:36:12,110 --> 00:36:15,528
And in that past, nothing changes again.
在过去，没有任何改变。 

640
00:36:15,528 --> 00:36:16,820
So that's what you end up with.
这就是最终的结果。 

641
00:36:16,820 --> 00:36:21,000
You end up with 2 for this and 1 for that.
您最终为此得到2个，为此得到1个。 

642
00:36:21,000 --> 00:36:22,260
OK?
好？ 

643
00:36:22,260 --> 00:36:25,000
That makes sense?
那讲得通？ 

644
00:36:25,199 --> 00:36:27,329
So the important thing to understand
所以重要的是要了解

645
00:36:27,329 --> 00:36:28,980
is that you are actually relaxing
是你实际上在放松

646
00:36:28,980 --> 00:36:31,871
all of the edges in every pass.
每一次通过的所有边缘。 

647
00:36:31,871 --> 00:36:33,829
And there's a slightly more complicated example
还有一个稍微复杂的例子

648
00:36:33,829 --> 00:36:35,909
than this that is in the notes.
比注释中的要多。 

649
00:36:35,909 --> 00:36:38,210
And you can take a look at that offline.
您可以离线查看。 

650
00:36:38,210 --> 00:36:40,119
There's another question in the back.
后面还有另一个问题。 

651
00:36:40,119 --> 00:36:42,049
Did you have a question?
你有问题吗

652
00:36:42,050 --> 00:36:43,130
Someone raised their hand.
有人举手。 

653
00:36:43,329 --> 00:36:43,519
Yeah?
是啊

654
00:36:43,519 --> 00:36:44,998
AUDIENCE: Yes, I'm just curious--
听众：是的，我很好奇

655
00:36:44,998 --> 00:36:47,627
is there a unknown better algorithm that
有没有更好的未知算法

656
00:36:47,628 --> 00:36:49,150
can do the same thing?
可以做同样的事情吗？ 

657
00:36:49,349 --> 00:36:51,349
PROFESSOR: No, there's no known better algorithm
教授：不，没有已知更好的算法

658
00:36:51,349 --> 00:36:53,670
for solving the general case like this.
解决这样的一般情况。 

659
00:36:53,670 --> 00:36:59,159
There are a couple of algorithms that assume weights
有几种假设权重的算法

660
00:36:59,159 --> 00:37:00,399
within a certain range.
在一定范围内。 

661
00:37:00,400 --> 00:37:04,130
And then there complexities include both v and e, as well
然后复杂度也包括v和e 

662
00:37:04,130 --> 00:37:08,250
as w where w is the dynamic range of the weights.
 as w其中w是权重的动态范围。 

663
00:37:08,250 --> 00:37:12,125
And depending on what w is, you could
根据w是什么，您可以

664
00:37:12,125 --> 00:37:13,750
argue that they have better complexity.
认为它们具有更好的复杂性。 

665
00:37:13,750 --> 00:37:15,800
But they're kind of incomparable in the sense
但是它们在某种意义上是无与伦比的

666
00:37:15,800 --> 00:37:17,670
that they have this extra parameter, which
他们有这个额外的参数， 

667
00:37:17,670 --> 00:37:18,918
is the dynamic range of the w.
是w的动态范围。 

668
00:37:18,918 --> 00:37:20,650
OK?
好？ 

669
00:37:20,650 --> 00:37:22,230
Now there's lots of special cases,
现在有很多特殊情况

670
00:37:22,429 --> 00:37:25,149
like I said, and well take a look at the DAG special case
就像我说的，好好看看DAG的特殊情况

671
00:37:25,150 --> 00:37:28,289
in a second where you could imagine doing better
在一秒钟内，您可以想象做得更好

672
00:37:28,489 --> 00:37:32,039
but not for the case where you have an arbitrary graph that
但不适用于您拥有任意图

673
00:37:32,039 --> 00:37:34,820
could have negative cycles in it because it's got negative rate
可能会有负周期，因为它的负利率

674
00:37:34,820 --> 00:37:36,750
edges.
边缘。 

675
00:37:36,949 --> 00:37:37,746
Yeah?
是啊

676
00:37:37,746 --> 00:37:39,579
AUDIENCE: In the corollary, does that assume
听众：在推论中，假设

677
00:37:39,579 --> 00:37:42,040
you have a connected graph because, you know,
您有一个连通的图，因为，您知道， 

678
00:37:42,041 --> 00:37:44,447
you could have a negative weight edge
你可能负重边

679
00:37:44,447 --> 00:37:47,157
in a separate part of the graph, which
在图的单独部分中， 

680
00:37:47,157 --> 00:37:48,645
isn't reachable from this.
由此无法达到的。 

681
00:37:48,646 --> 00:37:51,422



682
00:37:51,621 --> 00:37:52,539
PROFESSOR: Yeah.
教授：是的。 

683
00:37:52,539 --> 00:38:03,420
So you're going to start when you have an undefined weight.
因此，当您的体重不确定时，您将开始学习。 

684
00:38:03,420 --> 00:38:05,980
Remember your initialization condition.
记住您的初始化条件。 

685
00:38:06,179 --> 00:38:08,289
What is affected by s?
 s受什么影响？ 

686
00:38:08,289 --> 00:38:10,759
Initialize is affected by s.
初始化受s的影响。 

687
00:38:10,760 --> 00:38:12,250
The rest of it isn't affected by s
其余部分不受s的影响

688
00:38:12,449 --> 00:38:14,809
because you're just relaxing the edges.
因为你只是放松自己的边缘。 

689
00:38:14,809 --> 00:38:17,309
Initialize is affected by s because d of s
初始化受s的影响，因为s的d 

690
00:38:17,309 --> 00:38:20,739
starts out being 0, like I put over here, and the rest of them
开始是0，就像我放在这里一样，其余的

691
00:38:20,739 --> 00:38:22,909
are infinity.
是无限的

692
00:38:22,909 --> 00:38:26,500
So there is an effect of the choice of the starting vertex.
因此，存在选择起始顶点的效果。 

693
00:38:26,500 --> 00:38:30,239
And the rest of it follows that you
剩下的就是你

694
00:38:30,239 --> 00:38:33,819
will get an undefined value, or you
将获得一个未定义的值，否则您

695
00:38:33,820 --> 00:38:37,019
will find that negative cycle exists
会发现存在负周期

696
00:38:37,219 --> 00:38:39,500
based on whether you can reach it from s or not.
根据您是否可以从到达。 

697
00:38:39,500 --> 00:38:42,800
So if you happen to have s over here,
因此，如果您碰巧在这里， 

698
00:38:42,800 --> 00:38:45,090
and it's just the one node, and then
这只是一个节点，然后

699
00:38:45,090 --> 00:38:49,670
it has no edges going out of it, this algorithm
它没有边缘掉出来，这个算法

700
00:38:49,869 --> 00:38:51,659
would just be trivial.
只是微不足道的。 

701
00:38:51,659 --> 00:38:54,069
But it wouldn't detect any negative cycles
但它不会检测到任何负周期

702
00:38:54,070 --> 00:38:55,960
that aren't reachable from s.
无法从s获得。 

703
00:38:55,960 --> 00:38:56,724
That make sense?
有道理？ 

704
00:38:56,724 --> 00:38:58,599
AUDIENCE: Yeah.
听众：是的。 

705
00:38:58,599 --> 00:39:01,409
PROFESSOR: So there is this-- it's kind of hidden over there.
教授：就是这样-它藏在那儿。 

706
00:39:01,409 --> 00:39:02,920
So I'm glad you asked that question.
所以我很高兴你问了这个问题。 

707
00:39:02,920 --> 00:39:05,409
But initialize is setting things up.
但是初始化是在设置东西。 

708
00:39:05,409 --> 00:39:08,059
And that is something that affects
那就是影响

709
00:39:08,059 --> 00:39:10,190
the rest of the algorithm because d of s is 0
该算法的其余部分，因为s的d为0 

710
00:39:10,190 --> 00:39:12,409
and the rest of them are set to infinity.
其余的都设为无穷大。 

711
00:39:12,409 --> 00:39:14,539
All right?
好吧？ 

712
00:39:14,539 --> 00:39:19,329
So if there are no other questions,
因此，如果没有其他问题， 

713
00:39:19,329 --> 00:39:21,869
I'll move on to the case of the DAG
我将继续讨论DAG的情况

714
00:39:21,869 --> 00:39:24,750
and talk a little bit about shortest paths versus longest
谈论最短路径与最长路径

715
00:39:24,750 --> 00:39:25,809
paths.
路径。 

716
00:39:25,809 --> 00:39:28,710
And this is somewhat of a preview of a lecture
这有点像演讲的预告片

717
00:39:28,710 --> 00:39:34,010
that Eric is going to give a month from now on complexity
埃里克将从现在开始为期一个月的复杂性

718
00:39:34,010 --> 00:39:36,610
and the difference between polynomial time and exponential
以及多项式时间和指数的差

719
00:39:36,809 --> 00:39:39,909
time, though I'm not going to go into much depth here.
时间，尽管我在这里不打算深入探讨。 

720
00:39:39,909 --> 00:39:42,629
But there's some interesting relationships
但是有一些有趣的关系

721
00:39:42,630 --> 00:39:46,750
between the shortest path problem and the longest path
在最短路径问题和最长路径之间

722
00:39:46,949 --> 00:39:49,399
problem that I'd like to get to.
我想解决的问题。 

723
00:39:49,400 --> 00:39:54,139
But any other questions on this?
但是还有其他疑问吗？ 

724
00:39:54,139 --> 00:39:55,750
OK, so let me ask a question.
好，让我问一个问题。 

725
00:39:55,750 --> 00:39:58,940



726
00:39:58,940 --> 00:40:04,269
Suppose I wanted to find longest paths in a graph
假设我想在图中找到最长的路径

727
00:40:04,269 --> 00:40:09,960
and let's say that this graph had all positive edge weights.
假设该图具有所有正边权重。 

728
00:40:09,960 --> 00:40:12,039
OK.
好。 

729
00:40:12,239 --> 00:40:17,319
What if I negated all of the edge weights
如果我否定所有边缘权重怎么办

730
00:40:17,320 --> 00:40:19,840
and ran a Bellman-Ford?
然后跑了贝尔曼福特（Bellman-Ford）？ 

731
00:40:19,840 --> 00:40:23,110



732
00:40:23,110 --> 00:40:26,730
Would I find the longest path in the graph?
我会在图中找到最长的路径吗？ 

733
00:40:26,929 --> 00:40:29,173



734
00:40:29,173 --> 00:40:30,590
Do people understand the question?
人们了解这个问题了吗？ 

735
00:40:30,590 --> 00:40:35,230



736
00:40:35,230 --> 00:40:35,980
I don't need this.
我不需要这个

737
00:40:35,980 --> 00:40:45,500



738
00:40:45,500 --> 00:40:48,809
So maybe we can talk about what a longest path means first.
因此，也许我们可以先谈谈最长路径的含义。 

739
00:40:48,809 --> 00:40:57,150



740
00:40:57,150 --> 00:41:02,980
So if this was s and this v1, v2, v3, fairly straightforward,
因此，如果这是s并且此v1，v2，v3非常简单， 

741
00:41:03,179 --> 00:41:05,699
you know how to compute shortest paths now.
您现在知道如何计算最短路径。 

742
00:41:05,699 --> 00:41:06,899
These are all positive.
这些都是积极的。 

743
00:41:06,900 --> 00:41:08,250
Even easier.
甚至更容易。 

744
00:41:08,449 --> 00:41:13,119
The longest path to v3 is of length.
到v3的最长路径是长度。 

745
00:41:13,119 --> 00:41:16,179
Six because I go here, go there, and go there, right?
六，因为我去这里，去那里，然后去那里，对吗？ 

746
00:41:16,179 --> 00:41:18,049
So that's my longest path.
所以这是我最长的路。 

747
00:41:18,050 --> 00:41:20,440
OK?
好？ 

748
00:41:20,440 --> 00:41:23,929
And the shortest path to v3 is of length 4.
到v3的最短路径是长度4。 

749
00:41:23,929 --> 00:41:29,079
So shortest path, longest paths, have these nice duality.
因此，最短路径，最长路径具有这些良好的对偶性。 

750
00:41:29,079 --> 00:41:32,536
What if I said, well, you know, I
如果我说，好吧，你知道吗，我

751
00:41:32,536 --> 00:41:34,630
can solve the longest path problem, as well,
也可以解决最长路径问题

752
00:41:34,630 --> 00:41:37,440
given all of what I've learned about shortest paths
给出了我所了解的最短路径的所有信息

753
00:41:37,440 --> 00:41:49,750
simply by negating each of these edges and running Bellman-Ford.
只需消除这些优势并运行Bellman-Ford。 

754
00:41:49,750 --> 00:41:52,269
What would happen?
会发生什么？ 

755
00:41:52,269 --> 00:41:52,769
Yeah?
是啊

756
00:41:52,769 --> 00:41:59,244
AUDIENCE: [INAUDIBLE] shortest path branch [INAUDIBLE]
听众：[听不清]最短路径分支[听不清] 

757
00:41:59,244 --> 00:42:02,730
values, and if you switched to absolute value,
值，如果您切换为绝对值， 

758
00:42:02,730 --> 00:42:05,219
it will give you the longest path.
它会给你最长的路径。 

759
00:42:05,219 --> 00:42:06,692
PROFESSOR: So you think it works?
教授：那么您认为它可行吗？ 

760
00:42:06,692 --> 00:42:07,317
AUDIENCE: Yeah.
听众：是的。 

761
00:42:07,317 --> 00:42:09,434
It will also check the cycles.
它还将检查周期。 

762
00:42:09,434 --> 00:42:12,759
So the negative cycles will be the longest path cycles that
因此负周期将是最长的路径周期

763
00:42:12,760 --> 00:42:13,710
[INAUDIBLE].
 [听不清]。 

764
00:42:13,710 --> 00:42:16,840
PROFESSOR: But I think that's the key question.
教授：但是我认为这是关键问题。 

765
00:42:16,840 --> 00:42:19,550
What will Bellman-Ford do when it is run on this?
 Bellman-Ford在此基础上运行将做什么？ 

766
00:42:19,550 --> 00:42:22,492
What would it return?
它会返回什么？ 

767
00:42:22,492 --> 00:42:24,445
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

768
00:42:24,445 --> 00:42:26,320
PROFESSOR: No, what will Bellman-Ford return?
教授：不，贝尔曼·福特会返回什么？ 

769
00:42:26,320 --> 00:42:28,190
I'm asking.
我问。 

770
00:42:28,389 --> 00:42:31,000
Someone else?
其他人？ 

771
00:42:31,000 --> 00:42:33,829
What will Bellman-Ford return if I ran this?
如果执行此操作，Bellman-Ford将返回什么？ 

772
00:42:33,829 --> 00:42:34,840
Undefined.
未定义。 

773
00:42:34,840 --> 00:42:35,710
Right?
对？ 

774
00:42:35,909 --> 00:42:39,574
Undefined because you got this negative weight cycle here.
未定义，因为您在这里遇到了负体重循环。 

775
00:42:39,574 --> 00:42:40,289
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

776
00:42:40,489 --> 00:42:41,539
PROFESSOR: Sorry?
教授：对不起？ 

777
00:42:41,539 --> 00:42:43,420
Oh!
哦! 

778
00:42:43,420 --> 00:42:45,920
Let's put another one in there.
让我们再放一个。 

779
00:42:45,920 --> 00:42:47,110
Oops, sorry.
哎呀，对不起。 

780
00:42:47,110 --> 00:42:47,610
Now I see.
现在我明白了。 

781
00:42:47,610 --> 00:42:47,951
You're right.
你是对的。 

782
00:42:48,150 --> 00:42:49,069
You're right.
你是对的。 

783
00:42:49,070 --> 00:42:49,661
I'm wrong.
我错了。 

784
00:42:49,860 --> 00:42:51,109
And why did you say undefined?
你为什么说未定义？ 

785
00:42:51,110 --> 00:42:52,394
AUDIENCE: I was wrong.
听众：我错了。 

786
00:42:52,594 --> 00:42:54,079
PROFESSOR: OK, good.
教授：好的，很好。 

787
00:42:54,079 --> 00:42:55,559
I got company.
我有陪伴

788
00:42:55,559 --> 00:42:56,059
Thank you.
谢谢。 

789
00:42:56,059 --> 00:42:58,019
Thank you.
谢谢。 

790
00:42:58,019 --> 00:42:58,519
Good.
好。 

791
00:42:58,519 --> 00:43:01,019
Let's take it all over again.
让我们再来一遍。 

792
00:43:01,019 --> 00:43:01,911
All over again.
再来一遍。 

793
00:43:01,911 --> 00:43:02,409
All right.
好吧。 

794
00:43:02,409 --> 00:43:10,569



795
00:43:10,570 --> 00:43:12,500
All right, start over.
好吧，重新开始。 

796
00:43:12,500 --> 00:43:15,989
s v1 v2 v3.
 v1 v2 v3。 

797
00:43:15,989 --> 00:43:18,949



798
00:43:18,949 --> 00:43:20,629
Yeah, that is a cycle.
是的，那是一个周期。 

799
00:43:20,630 --> 00:43:23,260
All right, good.
好，好

800
00:43:23,460 --> 00:43:23,959
Cycle.
周期。 

801
00:43:23,960 --> 00:43:27,639



802
00:43:27,639 --> 00:43:33,579
So when you actually negate each of these edges,
因此，当您实际上否定这些优势时， 

803
00:43:33,579 --> 00:43:37,269
you end up with a negative weight cycle.
最终导致负重循环。 

804
00:43:37,269 --> 00:43:40,250
So it's plausible that you could have a graph like this one
因此，您可能会有像这样的图

805
00:43:40,250 --> 00:43:44,800
where this strategy won't work because what would happen
这种策略行不通的地方，因为会发生什么

806
00:43:44,800 --> 00:43:50,510
is Bellman-Ford would come back with, essentially, an abort
是Bellman-Ford基本上会放弃

807
00:43:50,510 --> 00:43:52,960
that says I can't compute shortest paths because they're
那说我不能计算最短路径，因为它们

808
00:43:53,159 --> 00:43:54,500
undefined.
未定义。 

809
00:43:54,500 --> 00:43:55,190
All right?
好吧？ 

810
00:43:55,190 --> 00:44:00,059
Now it turns out it's actually more subtle than that.
现在事实证明，它实际上比这更微妙。 

811
00:44:00,059 --> 00:44:04,340
What we're trying to do in Bellman-Ford is, in the case
在这种情况下，我们在贝尔曼福特公司试图做的是

812
00:44:04,340 --> 00:44:11,769
where negative weight cycles don't exist,
负负周期不存在的地方

813
00:44:11,769 --> 00:44:15,349
we report on the shortest simple path.
我们报告最短的简单路径。 

814
00:44:15,349 --> 00:44:18,869



815
00:44:18,869 --> 00:44:20,859
That's the whole notion of the proof.
这就是证明的全部概念。 

816
00:44:20,860 --> 00:44:23,460
We say that the path has a certain length, which
我们说路径有一定的长度， 

817
00:44:23,460 --> 00:44:27,289
is, at most, v minus 1 and so on and so forth.
最多为v减去1，依此类推。 

818
00:44:27,289 --> 00:44:28,800
We get the shortest simple path.
我们得到最短的简单路径。 

819
00:44:28,800 --> 00:44:34,420



820
00:44:34,619 --> 00:44:48,309
But if you actually have a problem where you say-- let
但是，如果您实际上在说什么时有问题-让

821
00:44:48,309 --> 00:44:49,309
me start over again.
我重新开始。 

822
00:44:49,309 --> 00:44:52,090
Let's say I want to find the shortest simple path
假设我想找到最短的简单路径

823
00:44:52,090 --> 00:44:56,380
for a different graph and it happens
对于不同的图，它发生了

824
00:44:56,380 --> 00:45:01,280
to have a negative weight cycle in it.
负体重循环。 

825
00:45:01,280 --> 00:45:02,630
So I have something like this.
所以我有这样的事情。 

826
00:45:02,630 --> 00:45:10,039
2 3 minus 6, 3 over here, 3 over here, and so on.
 2 3减去6，这里的3，这里的3，依此类推。 

827
00:45:10,239 --> 00:45:11,750
Maybe 2 here.
也许在这里2。 

828
00:45:11,750 --> 00:45:19,429
And I want to find the shortest simple path that
我想找到最短的简单路径

829
00:45:19,429 --> 00:45:23,250
reaches v from s.
从s到达v。 

830
00:45:23,250 --> 00:45:24,110
OK?
好？ 

831
00:45:24,110 --> 00:45:27,670
What is the shortest simple path that reaches v from s?
从s到达v的最短简单路径是什么？ 

832
00:45:27,670 --> 00:45:29,889
It's this path that goes horizontally,
这条路是水平的

833
00:45:29,889 --> 00:45:32,819
which has a weight 3 plus 2, 5, 5
权重为3加2、5、5 

834
00:45:32,820 --> 00:45:38,269
plus 3, 8, 8 plus 3, 11, 11 plus 2, 13.
加3、8、8加3、11、11加2、13。 

835
00:45:38,469 --> 00:45:39,239
All right?
好吧？ 

836
00:45:39,239 --> 00:45:48,579
So the shortest simple path is 13.
因此，最短的简单路径是13。 

837
00:45:48,579 --> 00:45:52,094
Will Bellman-Ford give you any information about this path?
 Bellman-Ford会为您提供有关此路径的任何信息吗？ 

838
00:45:52,094 --> 00:45:54,593



839
00:45:54,594 --> 00:45:55,510
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

840
00:45:55,510 --> 00:45:57,710
PROFESSOR: No because in [INAUDIBLE].
教授：否，因为在[音频不清晰]中。 

841
00:45:57,909 --> 00:46:06,199
After it does its v minus 1 passes, v is reachable from s.
在完成v减1之后，v可从s到达。 

842
00:46:06,199 --> 00:46:11,480
But you potentially go through a negative weight cycle
但您可能会经历负体重循环

843
00:46:11,480 --> 00:46:14,699
before you reach v. OK?
在到达v。OK之前？ 

844
00:46:14,699 --> 00:46:18,549
So it turns out that if you have a graph with negative weight
事实证明，如果您的图表权重为负

845
00:46:18,550 --> 00:46:22,269
cycles, finding the shortest simple path
循环，找到最短的简单路径

846
00:46:22,469 --> 00:46:24,519
is an NP-hard problem.
是一个NP难题。 

847
00:46:24,519 --> 00:46:26,239
It's a really hard problem.
这是一个非常困难的问题。 

848
00:46:26,239 --> 00:46:27,679
That's what NP means.
那就是NP的意思。 

849
00:46:27,679 --> 00:46:30,419
No, it means something else that Eric
不，这意味着埃里克还有别的东西

850
00:46:30,420 --> 00:46:33,550
will explain to you in a month or so.
会在一个月左右的时间内向您解释。 

851
00:46:33,550 --> 00:46:36,400
But it means that we don't know any algorithm that
但这意味着我们不知道任何算法

852
00:46:36,599 --> 00:46:40,500
is better than exponential time to solve this problem.
比指数时间更好地解决了这个问题。 

853
00:46:40,500 --> 00:46:42,139
OK?
好？ 

854
00:46:42,139 --> 00:46:48,619
So amazingly, all you've done is taken the shortest path problem
令人惊讶的是，您所做的全部都是最短路径问题

855
00:46:48,619 --> 00:46:51,170
and changed it ever so slightly.
并做了些微的改动

856
00:46:51,170 --> 00:46:53,610
You said I want to look for the shortest simple path
您说我想寻找最短的简单路径

857
00:46:53,610 --> 00:46:56,769
in the general case where I could, potentially,
在一般情况下，我可能会

858
00:46:56,969 --> 00:47:00,769
have negative weight cycles in my graph.
我的图表中的负重周期为负。 

859
00:47:00,769 --> 00:47:03,369
And when you do that, all bets are off.
而当您这样做时，所有赌注都关闭了。 

860
00:47:03,369 --> 00:47:06,469
You're not in the polynomial time complexity domain anymore.
您不再处于多项式时间复杂度域中。 

861
00:47:06,469 --> 00:47:08,629
At least, not that we know of.
至少不是我们所知道的。 

862
00:47:08,630 --> 00:47:13,045
And the best that you can do is an exponential time algorithm
而您能做的最好的就是指数时间算法

863
00:47:13,045 --> 00:47:15,230
to find shorter simple paths.
查找较短的简单路径。 

864
00:47:15,429 --> 00:47:17,369
And this problem, as it turns out,
事实证明，这个问题

865
00:47:17,369 --> 00:47:24,849
is equivalent to the longest path problem in the sense
在某种意义上等同于最长路径问题

866
00:47:24,849 --> 00:47:26,699
that they're both NP-hard.
他们都是NP-hard。 

867
00:47:26,699 --> 00:47:29,839
If you can solve one, you could solve the other.
如果您能解决一个，就可以解决另一个。 

868
00:47:29,840 --> 00:47:33,050
So to summarize, what happens here simply
综上所述，这里发生的只是

869
00:47:33,050 --> 00:47:35,940
is that in the case of Bellman-Ford
是在贝尔曼福特的情况下

870
00:47:36,139 --> 00:47:41,909
running on the original shortest path problem,
在最初的最短路径问题上运行

871
00:47:41,909 --> 00:47:46,649
you're allowed to abort when you detect the fact that there's
当您发现有

872
00:47:46,650 --> 00:47:48,639
a negative cycle.
负循环。 

873
00:47:48,639 --> 00:47:50,879
So given that you're allowed to abort when there's
因此，鉴于存在以下情况，您可以中止

874
00:47:50,880 --> 00:47:55,090
a negative cycle, you have a polynomial time solution
负周期，您有多项式时间解

875
00:47:55,090 --> 00:47:58,760
using Bellman-Ford that is not necessarily
使用Bellman-Ford不一定

876
00:47:58,760 --> 00:48:02,980
going to give you shortest path weights but will
将为您提供最短的路径权重，但会

877
00:48:02,980 --> 00:48:06,119
in the case of no negative cycles.
在没有负周期的情况下。 

878
00:48:06,119 --> 00:48:07,609
All right?
好吧？ 

879
00:48:07,610 --> 00:48:11,769
But if you ask for more-- a little bit more-- you said,
但是如果您要求更多（多一点），您说， 

880
00:48:11,769 --> 00:48:14,039
you know, it'd be great if you could somehow
你知道的，如果可以的话，那会很棒

881
00:48:14,039 --> 00:48:18,079
process these negative cycles and tell me
处理这些负面周期并告诉我

882
00:48:18,079 --> 00:48:23,139
that if I had a simple path and I don't go through cycles what
如果我有一条简单的道路而我不经历循环

883
00:48:23,139 --> 00:48:25,029
would the shortest weight be, it becomes
重量最短会变成

884
00:48:25,030 --> 00:48:27,460
a much more difficult problem.
一个更加困难的问题。 

885
00:48:27,659 --> 00:48:29,449
It goes from order of ve complexity
从复杂度的顺序

886
00:48:29,449 --> 00:48:34,259
to exponential time complexity to the best of our knowledge.
据我们所知，时间复杂度成指数增长。 

887
00:48:34,260 --> 00:48:36,570
So that's what I'd like to leave you with.
这就是我想带您离开的地方。 

888
00:48:36,769 --> 00:48:41,159
That there's much more to algorithms than just the ones
算法的意义远不止这些

889
00:48:41,159 --> 00:48:42,230
that we're looking at.
我们正在寻找。 

890
00:48:42,230 --> 00:48:43,730
And we get a little bit of a preview
我们得到了一些预览

891
00:48:43,730 --> 00:48:46,119
of this-- so the difference between polynomial time
这样-多项式时间之间的差

892
00:48:46,119 --> 00:48:49,509
an exponential time-- later on in the term.
指数时间-该词的后面。 

893
00:48:49,510 --> 00:48:54,510



