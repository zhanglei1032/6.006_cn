1
00:00:00,000 --> 00:00:00,050



2
00:00:00,050 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,019
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,019 --> 00:00:06,860
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,320
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,320 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:22,452



10
00:00:22,452 --> 00:00:23,535
PROFESSOR: Hey, everybody.
教授：大家好。 

11
00:00:23,535 --> 00:00:26,960
You ready to learn some algorithms?
您准备学习一些算法吗？ 

12
00:00:26,960 --> 00:00:28,350
Yeah!
是的

13
00:00:28,350 --> 00:00:29,379
Let's do it.
我们开始做吧。 

14
00:00:29,579 --> 00:00:30,539
I'm Eric Domain.
我是Eric Domain。 

15
00:00:30,539 --> 00:00:31,949
You can call me Eric.
你可以叫我埃里克。 

16
00:00:31,949 --> 00:00:35,019
And the last class, we sort of jumped into things.
在最后一堂课中，我们跳入了各种事物。 

17
00:00:35,020 --> 00:00:36,409
We studied peak finding and looked
我们研究了峰发现并看了看

18
00:00:36,609 --> 00:00:37,939
at a bunch of algorithms for peak finding
一堆寻找峰的算法

19
00:00:37,939 --> 00:00:38,879
on your problem set.
在您的问题集上。 

20
00:00:38,880 --> 00:00:42,014
You've already seen a bunch more.
您已经看到了更多。 

21
00:00:42,014 --> 00:00:44,429
And in this class, we're going to do some more algorithms.
在这一课中，我们将做更多的算法。 

22
00:00:44,429 --> 00:00:44,729
Don't worry.
不用担心

23
00:00:44,729 --> 00:00:45,669
That will be at the end.
那将是最后。 

24
00:00:45,670 --> 00:00:47,349
We're going to talk about another problem, document
我们将讨论另一个问题，文件

25
00:00:47,549 --> 00:00:49,949
distance, which will be a running example for a bunch
距离，这将是一堆连续的例子

26
00:00:49,950 --> 00:00:52,359
of topics that we cover in this class.
本课程中涵盖的主题。 

27
00:00:52,359 --> 00:00:55,640
But before we go there, I wanted to take a step back and talk
但是在我们去那里之前，我想退后一步再谈

28
00:00:55,640 --> 00:00:58,399
about, what actually is an algorithm?
关于，什么是算法？ 

29
00:00:58,399 --> 00:01:00,759
What is an algorithm allowed to do?
允许执行什么算法？ 

30
00:01:00,759 --> 00:01:04,701
And also deep philosophical questions like, what is time?
还有深层次的哲学问题，例如什么是时间？ 

31
00:01:04,701 --> 00:01:06,409
What is the running time of an algorithm?
算法的运行时间是多少？ 

32
00:01:06,409 --> 00:01:08,060
How do we measure it?
我们如何衡量？ 

33
00:01:08,060 --> 00:01:10,030
And what are the rules the game?
游戏的规则是什么？ 

34
00:01:10,030 --> 00:01:13,120
For fun, I thought I would first mention
为了娱乐，我想我首先要提到

35
00:01:13,120 --> 00:01:17,319
where the word comes from, the word algorithm.
单词来自哪里，单词算法。 

36
00:01:17,519 --> 00:01:22,390
It comes from this guy, a little hard to spell.
它来自这个家伙，有点难拼写。 

37
00:01:22,390 --> 00:01:27,180



38
00:01:27,180 --> 00:01:31,009
Al-Khwarizmi, who is sort of the father of algebra.
 Al-Khwarizmi，他是代数之父。 

39
00:01:31,209 --> 00:01:35,239
He wrote this book called "The Compendious Book on Calculation
他写了这本书，叫做“关于计算的简明书

40
00:01:35,239 --> 00:01:38,739
by Completion and Balancing" back in the day.
通过完成和平衡”。 

41
00:01:38,739 --> 00:01:40,420
And it was in particular about how
特别是关于

42
00:01:40,420 --> 00:01:44,194
to solve linear and quadratic equations.
解决线性和二次方程式。 

43
00:01:44,194 --> 00:01:45,359
So the beginning of algebra.
因此是代数的开始。 

44
00:01:45,359 --> 00:01:47,150
I don't think he invented those techniques.
我不认为他发明了那些技术。 

45
00:01:47,150 --> 00:01:48,780
But he was sort of the textbook writer
但他有点像教科书作家

46
00:01:48,780 --> 00:01:50,625
who wrote sort of how people solved them.
他写了人们如何解决它们的书。 

47
00:01:50,825 --> 00:01:52,199
And you can think of how to solve
您可以想到如何解决

48
00:01:52,200 --> 00:01:54,549
those equations as early algorithms.
这些方程式是早期算法。 

49
00:01:54,549 --> 00:01:56,079
First, you take this number.
首先，您使用这个数字。 

50
00:01:56,079 --> 00:01:56,969
You multiply by this.
你乘以这个。 

51
00:01:56,969 --> 00:02:01,659
You add it or you reduce to squares, whatever.
可以添加它，也可以减少到正方形。 

52
00:02:01,659 --> 00:02:05,099
So that's where the word algebra comes from and also
这就是代数这个词的来源

53
00:02:05,099 --> 00:02:06,689
where the word algorithm comes from.
单词算法来自哪里。 

54
00:02:06,689 --> 00:02:09,715
There aren't very many words with these roots.
这些词根有很少的词。 

55
00:02:09,715 --> 00:02:10,580
So there you go.
所以你去了。 

56
00:02:10,580 --> 00:02:11,335
Some fun history.
一些有趣的历史。 

57
00:02:11,335 --> 00:02:15,120



58
00:02:15,319 --> 00:02:17,549
What's an algorithm?
什么是算法？ 

59
00:02:17,550 --> 00:02:19,870
I'll start with sort of some informal definitions
我将从一些非正式的定义开始

60
00:02:19,870 --> 00:02:22,069
and then the point of this lecture.
然后是本讲座的重点。 

61
00:02:22,069 --> 00:02:26,219
And the idea of a model of computation
还有计算模型的想法

62
00:02:26,219 --> 00:02:28,683
is to formally specify what an algorithm is.
是正式指定什么是算法。 

63
00:02:28,683 --> 00:02:30,849
I don't want to get super technical and formal here,
我不想在这里获得超级技术性和正式性， 

64
00:02:30,849 --> 00:02:32,900
but I want to give you some grounding
但我想给你一些基础

65
00:02:32,900 --> 00:02:35,330
so when we write Python code, when we write pseudocode,
因此，当我们编写Python代码，编写伪代码时， 

66
00:02:35,330 --> 00:02:38,054
we have some idea what things actually cost.
我们知道事情的实际成本。 

67
00:02:38,054 --> 00:02:38,969
This is a new lecture.
这是新演讲。 

68
00:02:38,969 --> 00:02:40,469
We've never done this before in 006.
在006年之前，我们从未做到过。 

69
00:02:40,469 --> 00:02:42,800
But I think it's important.
但我认为这很重要。 

70
00:02:42,800 --> 00:02:45,870
So at a high level, you can think
因此，从高层次上，您可以考虑

71
00:02:45,870 --> 00:02:49,599
of an algorithm is just a-- I'm sure you've
一种算法只是-我确定你已经

72
00:02:49,599 --> 00:02:50,870
seen the definition before.
之前看过定义。 

73
00:02:50,870 --> 00:02:54,550



74
00:02:54,550 --> 00:02:57,588
It's a way to define computation or computational procedure
这是定义计算或计算过程的一种方式

75
00:02:57,788 --> 00:02:58,829
for solving some problem.
解决一些问题。 

76
00:02:58,830 --> 00:03:05,030



77
00:03:05,030 --> 00:03:06,651
So whereas computer code, I mean,
因此，我的意思是计算机代码

78
00:03:06,651 --> 00:03:08,400
it could just be running in the background
它可能只是在后台运行

79
00:03:08,400 --> 00:03:09,566
all the time doing whatever.
一直在做什么。 

80
00:03:09,566 --> 00:03:12,000
An algorithm we think of as having some input
我们认为有一些输入的算法

81
00:03:12,000 --> 00:03:13,800
and generating some output.
并产生一些输出。 

82
00:03:13,800 --> 00:03:15,770
Usually, it's to solve some problem.
通常，这是为了解决一些问题。 

83
00:03:15,770 --> 00:03:19,840



84
00:03:20,039 --> 00:03:22,039
You want to know is this number prime, whatever.
您想知道这个数字是素数吗？ 

85
00:03:22,039 --> 00:03:22,539
Question?
题？ 

86
00:03:22,539 --> 00:03:26,120
AUDIENCE: Can you turn up the volume for your mic?
听众：可以调高麦克风的音量吗？ 

87
00:03:26,120 --> 00:03:28,750
PROFESSOR: This microphone does not feed into the AV system.
教授：此麦克风未插入AV系统。 

88
00:03:28,949 --> 00:03:31,066
So I shall just talk louder, OK?
所以我要大声说话，好吗？ 

89
00:03:31,066 --> 00:03:33,789



90
00:03:33,789 --> 00:03:36,799
And quiet the set, please.
请安静一下。 

91
00:03:36,800 --> 00:03:38,150
OK, so that's an algorithm.
好，那是一个算法。 

92
00:03:38,150 --> 00:03:39,689
You take some input.
您需要一些输入。 

93
00:03:39,889 --> 00:03:41,319
You run it through.
您运行通过。 

94
00:03:41,319 --> 00:03:43,009
You compute some output.
您计算一些输出。 

95
00:03:43,009 --> 00:03:45,209
Of course, computer code can do this too.
当然，计算机代码也可以做到这一点。 

96
00:03:45,210 --> 00:03:47,939
An algorithm is basically the mathematical analog
算法基本上是数学模拟

97
00:03:48,139 --> 00:03:49,379
of a computer program.
计算机程序。 

98
00:03:49,379 --> 00:03:52,620
So if you want to reason about what computer programs do,
因此，如果您想知道计算机程序的功能， 

99
00:03:52,620 --> 00:03:55,248
you translate it into the world algorithms.
您将其转换为世界算法。 

100
00:03:55,248 --> 00:03:57,539
And vice versa, you want to solve some problem-- first,
反之亦然，您想解决一些问题-首先， 

101
00:03:57,539 --> 00:04:00,709
you usually develop an algorithm using mathematics,
您通常使用数学来开发算法， 

102
00:04:00,710 --> 00:04:01,618
using this class.
使用此类。 

103
00:04:01,818 --> 00:04:03,609
And then you convert it into computer code.
然后将其转换为计算机代码。 

104
00:04:03,610 --> 00:04:05,560
And this class is about that transition from one
这节课是关于从一个

105
00:04:05,759 --> 00:04:07,109
to the other.
到另一个。 

106
00:04:07,110 --> 00:04:10,064
You can draw a picture of sort of analogs.
您可以画一幅类似的图画。 

107
00:04:10,264 --> 00:04:13,659



108
00:04:13,659 --> 00:04:16,769
So an algorithm is a mathematical analog
所以算法是数学的模拟

109
00:04:16,769 --> 00:04:20,288
of a computer program.
计算机程序。 

110
00:04:20,288 --> 00:04:24,253
A computer program is built on top of a programming language.
计算机程序是建立在编程语言之上的。 

111
00:04:24,254 --> 00:04:26,045
And it's written in a programming language.
它是用编程语言编写的。 

112
00:04:26,045 --> 00:04:33,740



113
00:04:33,740 --> 00:04:36,759
The mathematical analog of a programming language,
编程语言的数学模拟， 

114
00:04:36,759 --> 00:04:39,629
what we write algorithms in, usually we
我们用什么编写算法，通常我们

115
00:04:39,629 --> 00:04:44,889
write them in pseudocode, which is basically
用伪代码写出来，基本上

116
00:04:44,889 --> 00:04:49,649
another fancy word for structured English,
结构化英语的另一个花哨词， 

117
00:04:49,649 --> 00:04:51,949
good English, whatever you want to say.
良好的英语，无论您想说什么。 

118
00:04:51,949 --> 00:04:54,199
Of course, you could use another natural language.
当然，您可以使用其他自然语言。 

119
00:04:54,199 --> 00:04:58,139
But the idea is, you need to express that algorithm in a way
但想法是，您需要以某种方式表达该算法

120
00:04:58,139 --> 00:05:00,610
that people can understand and reason about formally.
人们可以正式理解并推理的内容。 

121
00:05:00,610 --> 00:05:02,350
So that's the structured part.
这就是结构化的部分。 

122
00:05:02,350 --> 00:05:05,579
Pseudocode means lots of different things.
伪代码意味着很多不同的东西。 

123
00:05:05,779 --> 00:05:08,039
It's just sort of an abstract how you would write down
这只是一个摘要，您将如何写下来

124
00:05:08,040 --> 00:05:10,629
formal specification without necessarily being
正式规范，不一定要

125
00:05:10,629 --> 00:05:13,738
able to actually run it on a computer.
能够在计算机上实际运行它。 

126
00:05:13,738 --> 00:05:16,029
Though there's a particular pseudocode in your textbook
虽然教科书中有特定的伪代码

127
00:05:16,029 --> 00:05:18,049
which you probably could run on a computer.
您可能可以在计算机上运行。 

128
00:05:18,050 --> 00:05:19,425
A lot of it, anyway.
无论如何，很多。 

129
00:05:19,425 --> 00:05:21,050
But you don't have to use that version.
但是您不必使用该版本。 

130
00:05:21,050 --> 00:05:25,949
It just makes sense to humans who do the mathematics.
这对做数学的人来说才有意义。 

131
00:05:25,949 --> 00:05:30,420
OK, and then ultimately, this program runs on a computer.
单击确定，然后最终，该程序在计算机上运行。 

132
00:05:30,420 --> 00:05:34,139
You all have computers, probably in your pockets.
你们都有电脑，可能在您的口袋里。 

133
00:05:34,339 --> 00:05:39,129
There's an analog of a computer in the mathematical world.
在数学世界中，有一台计算机的类似物。 

134
00:05:39,129 --> 00:05:42,230
And that is the model of computation.
那就是计算模型。 

135
00:05:42,230 --> 00:05:46,560
And that's sort of the focus of the first part of this lecture.
这就是本讲座第一部分的重点。 

136
00:05:46,560 --> 00:05:50,850
Model of computation says what your computer is allowed to do,
计算模型表明您的计算机可以执行的操作， 

137
00:05:50,850 --> 00:05:53,569
what it can do in constant time, basically?
基本上，它可以在固定时间内做什么？ 

138
00:05:53,769 --> 00:05:57,459
And that's what I want to talk about here.
这就是我在这里要谈的。 

139
00:05:57,459 --> 00:06:13,079
So the model of computation specifies basically
所以计算模型基本上指定

140
00:06:13,079 --> 00:06:28,289
what operations you can do in an algorithm
您可以在算法中执行哪些操作

141
00:06:28,290 --> 00:06:30,180
and how much they cost.
以及它们的价格。 

142
00:06:30,180 --> 00:06:31,430
This is the what is time.
这就是时间。 

143
00:06:31,430 --> 00:06:38,274



144
00:06:38,274 --> 00:06:39,689
So for each operation, we're going
因此，对于每个操作，我们将

145
00:06:39,689 --> 00:06:41,550
to specify how much time it costs.
指定花费多少时间。 

146
00:06:41,550 --> 00:06:43,680
Then the algorithm does a bunch of operations.
然后，该算法执行一堆操作。 

147
00:06:43,680 --> 00:06:45,312
They're combined together with control flow,
它们与控制流结合在一起， 

148
00:06:45,512 --> 00:06:48,060
for loops, if statements, stuff like that which we're not
 for循环，if语句，诸如此类的东西

149
00:06:48,060 --> 00:06:50,079
going to worry about too much.
会担心太多。 

150
00:06:50,279 --> 00:06:52,439
But obviously, we'll use them a lot.
但是显然，我们会经常使用它们。 

151
00:06:52,439 --> 00:06:55,019
And what we count is how much do each of the operations cost.
我们计算的是每个运营成本。 

152
00:06:55,019 --> 00:06:55,719
You add them up.
您将它们加起来。 

153
00:06:55,720 --> 00:06:57,894
That is the total cost of your algorithm.
那就是算法的总成本。 

154
00:06:58,093 --> 00:07:00,009
So in particular, we care mostly in this class
所以特别地，我们主要在这个班级

155
00:07:00,009 --> 00:07:01,959
about running time.
关于运行时间。 

156
00:07:01,959 --> 00:07:03,899
Each operation has a time cost.
每个操作都有时间成本。 

157
00:07:03,899 --> 00:07:04,959
You add those up.
您将它们加起来。 

158
00:07:04,959 --> 00:07:07,399
That's running time of the algorithm.
那是算法的运行时间。 

159
00:07:07,399 --> 00:07:14,973
OK, so let's-- I'm going to cover two models of computation
好的，让我们-我将介绍两种计算模型

160
00:07:14,973 --> 00:07:17,389
which you can just think of as different ways of thinking.
您可以将其视为不同的思维方式。 

161
00:07:17,389 --> 00:07:19,379
You've probably seen them in some sense
您可能从某种意义上看过他们

162
00:07:19,379 --> 00:07:22,649
as-- what you call them?
作为-你叫他们什么？ 

163
00:07:22,649 --> 00:07:25,329
Styles of programming.
编程风格。 

164
00:07:25,329 --> 00:07:28,449
Object oriented style of programming, more assembly
面向对象的编程风格，更多的汇编

165
00:07:28,449 --> 00:07:29,529
style of programming.
编程风格。 

166
00:07:29,529 --> 00:07:32,075
There's lots of different styles of programming languages
有许多不同风格的编程语言

167
00:07:32,076 --> 00:07:33,500
which I'm not going to talk about here.
我在这里不打算讨论。 

168
00:07:33,699 --> 00:07:35,909
But you've see analogs if you've seen those before.
但是，如果您以前曾经看过类似物，那么您已经看到过类似物。 

169
00:07:35,910 --> 00:07:38,550



170
00:07:38,550 --> 00:07:41,579
And these models really give you a way
这些模型确实为您提供了一种方法

171
00:07:41,579 --> 00:07:44,939
of structuring your thinking about how
关于如何思考的构想

172
00:07:44,939 --> 00:07:46,769
you write an algorithm.
你写一个算法。 

173
00:07:46,769 --> 00:07:49,019
So they are the random access machine and the pointer
所以它们是随机访问机器和指针

174
00:07:49,019 --> 00:07:51,009
machine.
机。 

175
00:07:51,009 --> 00:08:04,550
So we'll start with random access machine, also known
所以我们将从随机存取机开始

176
00:08:04,550 --> 00:08:07,329
as the RAM.
作为RAM。 

177
00:08:07,529 --> 00:08:10,458
Can someone tell me what else RAM stands for?
有人可以告诉我RAM代表什么吗？ 

178
00:08:10,459 --> 00:08:11,750
AUDIENCE: Random Access Memory?
听众：随机存取存储器？ 

179
00:08:11,750 --> 00:08:13,220
PROFESSOR: Random Access Memory.
教授：随机存取存储器。 

180
00:08:13,220 --> 00:08:15,860
So this is both confusing but also convenience.
因此，这既混乱又方便。 

181
00:08:15,860 --> 00:08:18,870
Because RAM simultaneously stands for two things
因为RAM同时代表两件事

182
00:08:18,870 --> 00:08:21,134
and they mean almost the same thing, but not quite.
他们的意思几乎相同，但不完全相同。 

183
00:08:21,134 --> 00:08:23,009
So I guess that's more confusing than useful.
因此，我认为这比有用更令人困惑。 

184
00:08:23,009 --> 00:08:24,560
But there you go.
但是，你去了。 

185
00:08:24,560 --> 00:08:31,244
So we have random access memory.
所以我们有随机存取存储器。 

186
00:08:31,244 --> 00:08:32,379
Oh, look at that.
哦，看那个。 

187
00:08:32,379 --> 00:08:35,548
Fits perfectly.
非常适合。 

188
00:08:35,548 --> 00:08:37,340
And so we're thinking, this is a real--
所以我们在想，这是真实的- 

189
00:08:37,340 --> 00:08:41,129
this is-- random access memory is over here in real computer
这是-实际计算机中的随机存取存储器在这里

190
00:08:41,129 --> 00:08:41,629
land.
土地。 

191
00:08:41,629 --> 00:08:43,808
That's like, D-RAM SD-RAM, whatever--
就像D-RAM SD-RAM， 

192
00:08:43,808 --> 00:08:48,309
the things you buy and stick into your motherboard, your GP,
您购买并粘贴在主板，GP上的东西， 

193
00:08:48,309 --> 00:08:49,189
or whatever.
管他呢。 

194
00:08:49,190 --> 00:08:53,076
And over here, the mathematical analog of-- so here's,
在这里，...的数学模拟

195
00:08:53,076 --> 00:08:53,575
it's a RAM.
这是一个RAM。 

196
00:08:53,575 --> 00:08:55,070
Here, it's also a RAM.
在这里，它也是一个RAM。 

197
00:08:55,070 --> 00:08:57,349
Here, it's a random access machine.
在这里，这是一台随机访问的机器。 

198
00:08:57,549 --> 00:09:00,559
Here, it's a random access memory.
在这里，它是一个随机存取存储器。 

199
00:09:00,559 --> 00:09:02,449
It's technical detail.
这是技术细节。 

200
00:09:02,450 --> 00:09:09,479
But the idea is, if you look at RAM that's in your computer,
但想法是，如果您查看计算机中的RAM， 

201
00:09:09,679 --> 00:09:12,309
it's basically a giant array, right?
它基本上是一个巨大的阵列，对不对？ 

202
00:09:12,309 --> 00:09:16,089
You can go from zero to, I don't know.
您不知道可以从零到零。 

203
00:09:16,090 --> 00:09:20,080
A typical chip these days is like four gigs in one thing.
这些天的典型芯片在一件事上就像四场演出。 

204
00:09:20,080 --> 00:09:21,889
So you can go from zero to four gigs.
因此，您可以从零到四个演出。 

205
00:09:21,889 --> 00:09:25,659
You can access anything in the middle there in constant time.
您可以在恒定时间内访问中间的任何内容。 

206
00:09:25,659 --> 00:09:28,490
To access something, you need to know where it is.
要访问某物，您需要知道它在哪里。 

207
00:09:28,490 --> 00:09:30,269
That's random access memory.
那是随机存取存储器。 

208
00:09:30,269 --> 00:09:31,319
So that's an array.
所以这是一个数组。 

209
00:09:31,320 --> 00:09:34,490



210
00:09:34,490 --> 00:09:36,090
So I'll just draw a big picture.
所以我会画一幅大图。 

211
00:09:36,090 --> 00:09:37,490
Here's an array.
这是一个数组。 

212
00:09:37,490 --> 00:09:41,840
Now, RAM is usually organized by words.
现在，RAM通常是按单词组织的。 

213
00:09:41,840 --> 00:09:45,889
So these are a machine word, which
这些是机器字， 

214
00:09:45,889 --> 00:09:47,509
we're going to put in this model.
我们将采用这种模型。 

215
00:09:47,509 --> 00:09:51,509
And then there's address zero, address one, address two.
然后是地址零，地址一，地址二。 

216
00:09:51,509 --> 00:09:53,149
This is the fifth word.
这是第五个字。 

217
00:09:53,149 --> 00:09:54,069
And just keeps going.
并且继续前进。 

218
00:09:54,070 --> 00:09:55,285
You can think of this as infinite.
您可以认为这是无限的。 

219
00:09:55,485 --> 00:09:57,569
Or the amount that you use, that's
或您使用的金额，即

220
00:09:57,570 --> 00:10:01,459
the space of your algorithm, if you care about storage space.
算法的空间（如果您关心存储空间）。 

221
00:10:01,659 --> 00:10:03,610
So that's basically it.
基本上就是这样。 

222
00:10:03,610 --> 00:10:06,000
OK, now how do we-- this is the memory side of things.
好的，现在我们该怎么做-这就是事物的记忆方面。 

223
00:10:06,000 --> 00:10:08,149
How do we actually compute with it?
我们如何实际计算呢？ 

224
00:10:08,149 --> 00:10:09,240
It's very simple.
非常简单

225
00:10:09,240 --> 00:10:18,490
We just say, in constant time, an algorithm can basically
我们只是说，在恒定时间内，算法可以

226
00:10:18,490 --> 00:10:25,159
read in or load a constant number of words from memory,
从内存中读取或加载恒定数量的单词， 

227
00:10:25,159 --> 00:10:33,019
do a constant number of computations on them,
对它们进行恒定数量的计算， 

228
00:10:33,019 --> 00:10:34,949
and then write them out.
然后写出来。 

229
00:10:34,950 --> 00:10:35,949
It's usually called store.
通常称为商店。 

230
00:10:36,149 --> 00:10:43,538



231
00:10:43,538 --> 00:10:45,330
OK, it needs to know where these words are.
好的，它需要知道这些单词在哪里。 

232
00:10:45,330 --> 00:10:52,089
It accesses them by address.
它通过地址访问它们。 

233
00:10:52,289 --> 00:10:54,389
And so I guess I should write here
所以我想我应该在这里写

234
00:10:54,389 --> 00:11:01,909
you have a constant number of registers just hanging around.
您有固定数量的寄存器随处可见。 

235
00:11:01,909 --> 00:11:04,039
So you load some words into registers.
因此，您将一些单词加载到寄存器中。 

236
00:11:04,039 --> 00:11:06,105
You can do some computations on those registers.
您可以对那些寄存器进行一些计算。 

237
00:11:06,105 --> 00:11:07,480
And then you can write them back,
然后你可以写回去

238
00:11:07,480 --> 00:11:09,120
storing them in locations that are
将它们存储在

239
00:11:09,120 --> 00:11:10,850
specified by your registers.
由您的寄存器指定。 

240
00:11:10,850 --> 00:11:12,690
So you've ever done assembly programming,
这样您就完成了汇编编程， 

241
00:11:12,690 --> 00:11:15,309
this is what assembly programming is like.
这就是汇编编程的样子。 

242
00:11:15,509 --> 00:11:20,500
And it can be rather annoying to write algorithms in this model.
在此模型中编写算法可能会很烦人。 

243
00:11:20,500 --> 00:11:22,139
But in some sense, it is reality.
但是从某种意义上说，这是现实。 

244
00:11:22,139 --> 00:11:24,319
This is how we think about computers.
这就是我们对计算机的看法。 

245
00:11:24,320 --> 00:11:25,579
If you ignore things like caches,
如果您忽略诸如缓存之类的内容， 

246
00:11:25,779 --> 00:11:28,269
this is an accurate model of computation
这是一个精确的计算模型

247
00:11:28,269 --> 00:11:30,331
that loading, computing, and storing
加载，计算和存储

248
00:11:30,331 --> 00:11:32,039
all take roughly the same amount of time.
全部花费大致相同的时间。 

249
00:11:32,039 --> 00:11:33,719
They all take constant time.
他们都花固定的时间。 

250
00:11:33,720 --> 00:11:35,980
You can manipulate a whole word at a time.
您可以一次操纵整个单词。 

251
00:11:35,980 --> 00:11:38,479
Now, what exactly is a word?
现在，一个字到底是什么？ 

252
00:11:38,679 --> 00:11:42,829
You know, computers these days, it's like 32 bits or 64 bits.
您知道，如今的计算机就像32位或64位。 

253
00:11:42,830 --> 00:11:45,710
But we like to be a little bit more abstract.
但是，我们希望更加抽象一些。 

254
00:11:45,710 --> 00:11:51,220
A word is w bits.
一个字是w位。 

255
00:11:51,220 --> 00:11:52,529
It's slightly annoying.
有点烦人。 

256
00:11:52,529 --> 00:11:55,339
And most of this class, we won't really worry about what w is.
在本课程的大部分时间里，我们都不会真正担心w是什么。 

257
00:11:55,340 --> 00:11:57,079
We'll assume that we're given as input
我们假设我们被作为输入

258
00:11:57,279 --> 00:11:58,970
a bunch of things which are words.
一堆东​​西就是文字。 

259
00:11:58,970 --> 00:12:00,720
So for example, peak finding.
因此，例如峰发现。 

260
00:12:00,720 --> 00:12:02,849
We're given a matrix of numbers.
我们得到了一个数字矩阵。 

261
00:12:03,049 --> 00:12:05,379
We didn't really say whether they're integers or floats
我们没有真正说出它们是整数还是浮点数

262
00:12:05,379 --> 00:12:06,407
or what.
要不然是啥。 

263
00:12:06,407 --> 00:12:07,490
We don't worry about that.
我们不用担心。 

264
00:12:07,490 --> 00:12:08,609
We just think of them as words and we
我们只是将它们视为单词，而我们

265
00:12:08,809 --> 00:12:10,559
assume that we can manipulate those words.
假设我们可以操纵这些单词。 

266
00:12:10,559 --> 00:12:12,839
In particular, given two numbers, we can compare them.
特别是，给定两个数字，我们可以对其进行比较。 

267
00:12:12,840 --> 00:12:13,820
Which is bigger?
哪个更大？ 

268
00:12:13,820 --> 00:12:17,469
And so we can determine, is this cell in the matrix
这样我们可以确定矩阵中的这个单元格

269
00:12:17,669 --> 00:12:20,949
a peak by comparing it with its neighbors in constant time.
通过在恒定时间内将其与邻域进行比较来形成一个峰值。 

270
00:12:20,950 --> 00:12:23,479
We didn't say why it was constant time to do that.
我们没有说为什么要持续这样做。 

271
00:12:23,479 --> 00:12:24,319
But now you kind of know.
但是现在您知道了。 

272
00:12:24,519 --> 00:12:26,159
If those things are all words and you
如果这些都是言语而你

273
00:12:26,159 --> 00:12:28,617
can manipulate a constant number of words in constant time,
可以在恒定时间内操纵恒定数量的单词， 

274
00:12:28,618 --> 00:12:31,479
you can tell whether a number is a peak in constant time.
您可以判断一个数字是否是恒定时间的峰值。 

275
00:12:31,679 --> 00:12:37,929
Some things like w should be at least log the size of memory.
诸如w之类的东西至少应记录日志的内存大小。 

276
00:12:37,929 --> 00:12:41,159



277
00:12:41,159 --> 00:12:43,569
Because my word should be able to specify
因为我的话应该能够说明

278
00:12:43,570 --> 00:12:46,719
an index into this array.
该数组的索引。 

279
00:12:46,919 --> 00:12:48,230
And we might use that someday.
我们可能有一天会使用它。 

280
00:12:48,230 --> 00:12:49,730
But basically, don't worry about it.
但基本上，不用担心。 

281
00:12:49,730 --> 00:12:50,710
Words are words.
单词就是单词。 

282
00:12:50,710 --> 00:12:52,080
Words come in as inputs.
单词作为输入进来。 

283
00:12:52,080 --> 00:12:53,720
You can manipulate them and you don't
您可以操纵它们，而您却不能

284
00:12:53,720 --> 00:12:58,240
have to worry about it for the most part.
大部分时候都需要担心。 

285
00:12:58,240 --> 00:13:00,009
In unit four of this class, we're
在本课程的第四单元中，我们是

286
00:13:00,009 --> 00:13:02,919
going to talk about, what if we have really giant integers that
要谈论的是，如果我们有真正的巨型整数

287
00:13:02,919 --> 00:13:03,986
don't fit in a word?
一句话不适合吗？ 

288
00:13:03,986 --> 00:13:05,069
How do we manipulate them?
我们如何操纵它们？ 

289
00:13:05,070 --> 00:13:06,830
How do we add them, multiply them?
我们如何相加，相乘？ 

290
00:13:06,830 --> 00:13:08,490
So that's another topic.
这是另一个话题。 

291
00:13:08,490 --> 00:13:10,620
But most of this class, we'll just
但是在这堂课的大部分时间里

292
00:13:10,620 --> 00:13:13,029
assume everything we're given is one word.
假设我们得到的一切都是一个字。 

293
00:13:13,029 --> 00:13:16,889
And it's easy to compute on.
而且很容易计算。 

294
00:13:16,889 --> 00:13:19,419
So this is a realistic model, more or less.
因此，这或多或少是一个现实的模型。 

295
00:13:19,419 --> 00:13:21,259
And it's a powerful one.
这是一个强大的功能。 

296
00:13:21,259 --> 00:13:25,230
But a lot of the time, a lot of code
但是很多时候，很多代码

297
00:13:25,230 --> 00:13:27,190
just doesn't use arrays-- doesn't need it.
只是不使用数组-不需要它。 

298
00:13:27,190 --> 00:13:30,339
Sometimes we need arrays, sometimes we don't.
有时我们需要数组，有时我们不需要。 

299
00:13:30,539 --> 00:13:33,919
Sometimes you feel like a nut, sometimes you don't.
有时您感觉像个坚果，有时却不。 

300
00:13:33,919 --> 00:13:38,104
So it's useful to think about somewhat more abstract models
因此，考虑更多抽象模型很有用

301
00:13:38,105 --> 00:13:42,120
that are not quite as powerful but offer a simpler
并不那么强大，但提供了更简单的方法

302
00:13:42,120 --> 00:13:44,360
way of thinking about things.
思考事物的方式。 

303
00:13:44,360 --> 00:13:45,830
For example, in this model there's
例如，在此模型中

304
00:13:45,830 --> 00:13:47,884
no dynamic memory allocation.
没有动态内存分配。 

305
00:13:47,884 --> 00:13:49,849
You probably know you could implement dynamic memory
您可能知道可以实现动态内存

306
00:13:50,049 --> 00:13:52,589
allocation because real computers do it.
分配，因为真正的计算机可以做到。 

307
00:13:52,590 --> 00:13:54,519
But it's nice to think about a model
但是考虑一个模型真是太好了

308
00:13:54,519 --> 00:13:56,620
where that's taken care of for you.
照顾您的地方。 

309
00:13:56,620 --> 00:14:00,009
It's kind of like a higher level programming abstraction.
有点像更高层次的编程抽象。 

310
00:14:00,009 --> 00:14:03,580
So the one is useful in this class is the pointer machine.
因此在此类中有用的是指针计算机。 

311
00:14:03,580 --> 00:14:06,190
This basically corresponds to object oriented programming
这基本上对应于面向对象的编程

312
00:14:06,190 --> 00:14:09,819
in a simple, very simple version.
在一个非常简单的版本中。 

313
00:14:10,019 --> 00:14:12,659
So we have dynamically allocated objects.
因此，我们已经动态分配了对象。 

314
00:14:12,659 --> 00:14:21,409



315
00:14:21,409 --> 00:14:30,370
And an object has a constant number of fields.
一个对象具有恒定数量的字段。 

316
00:14:30,370 --> 00:14:34,649



317
00:14:34,649 --> 00:14:44,039
And a field is going to be either a word-- so you
一个字段将是一个单词-所以你

318
00:14:44,039 --> 00:14:46,389
can think of this as, for example,
可以这样认为， 

319
00:14:46,389 --> 00:14:49,470
storing an integer, one of the input objects
存储整数，输入对象之一

320
00:14:49,470 --> 00:14:52,600
or something you computed on it or a counter, all these sorts
或您在其上计算过的东西或计数器，所有这些种类

321
00:14:52,600 --> 00:14:57,570
of things-- or a pointer.
的东西-或指针。 

322
00:14:57,570 --> 00:15:02,370
And that's where pointer machine gets its name.
这就是指针机的名称。 

323
00:15:02,370 --> 00:15:09,109
A pointer is something that points to another object
指针是指向另一个对象的东西

324
00:15:09,309 --> 00:15:14,469
or has a special value null, also known as nil,
或具有特殊值null（也称为nil）， 

325
00:15:14,470 --> 00:15:15,870
also known as none in Python.
在Python中也称为none。 

326
00:15:15,870 --> 00:15:20,429



327
00:15:20,429 --> 00:15:23,859
OK, how many people have heard about pointers before?
好，以前有多少人听说过指针？ 

328
00:15:23,860 --> 00:15:25,496
Who hasn't?
谁没有？ 

329
00:15:25,496 --> 00:15:26,329
Willing to admit it?
愿意承认吗？ 

330
00:15:26,330 --> 00:15:27,230
OK, only a few.
好，只有几个。 

331
00:15:27,230 --> 00:15:27,769
That's good.
那很好。 

332
00:15:27,769 --> 00:15:29,019
You should have seen pointers.
您应该已经看到了指针。 

333
00:15:29,019 --> 00:15:31,079
You may have heard them called references.
您可能听说过它们称为参考。 

334
00:15:31,080 --> 00:15:33,700
Modern languages these days don't call them pointers
如今，现代语言不再称其为指针

335
00:15:33,700 --> 00:15:35,690
because pointers are scary.
因为指针很可怕。 

336
00:15:35,690 --> 00:15:38,189
But there's a very subtle difference between them.
但是它们之间有一个非常细微的差异。 

337
00:15:38,389 --> 00:15:40,994
And this model actually really is references.
这个模型实际上是参考。 

338
00:15:40,994 --> 00:15:43,084
But for whatever reason, it's called a pointer machine.
但是无论出于什么原因，它都被称为指针机。 

339
00:15:43,284 --> 00:15:45,350
It doesn't matter.
没关系

340
00:15:45,350 --> 00:15:49,480
The point is, you've seem linked lists I hope.
关键是，您似乎希望找到链表。 

341
00:15:49,480 --> 00:15:54,240
And linked lists have a bunch of fields in each node.
链接列表在每个节点中都有一堆字段。 

342
00:15:54,240 --> 00:15:56,490
Maybe you've got a pointer to the previous element,
也许您有一个指向上一个元素的指针， 

343
00:15:56,490 --> 00:16:00,820
a pointer to the next element, and some value.
指向下一个元素的指针和一些值。 

344
00:16:00,820 --> 00:16:04,349
So here's a very simple linked list.
因此，这是一个非常简单的链表。 

345
00:16:04,549 --> 00:16:07,049
This is what you'd call a doubly linked list because it
这就是您所说的双向链接列表，因为它

346
00:16:07,049 --> 00:16:10,049
has previous and next pointers.
具有上一个和下一个指针。 

347
00:16:10,049 --> 00:16:12,389
So the next pointer points to this node.
因此，下一个指针指向此节点。 

348
00:16:12,389 --> 00:16:15,110
The previous pointer points to this node.
前一个指针指向此节点。 

349
00:16:15,110 --> 00:16:17,075
Next pointer points to null.
下一个指针指向null。 

350
00:16:17,075 --> 00:16:19,940
The previous pointer points to null, let's say.
假设前一个指针指向null。 

351
00:16:19,940 --> 00:16:21,931
So that's a two node doubly linked list.
这就是两个节点的双向链表。 

352
00:16:21,931 --> 00:16:23,979
You presume we have a pointer to the head of the list,
您假设我们有一个指向列表开头的指针， 

353
00:16:24,179 --> 00:16:26,899
maybe a pointer to the tail of list, whatever.
也许是指向列表尾部的指针，无论如何。 

354
00:16:26,899 --> 00:16:29,394
So this is a structure in the pointer machine.
因此，这是指针机中的结构。 

355
00:16:29,394 --> 00:16:31,379
It's a data structure.
这是一个数据结构。 

356
00:16:31,379 --> 00:16:33,789
In Python, you might call this a named tuple,
在Python中，您可以将其称为命名元组， 

357
00:16:33,789 --> 00:16:38,339
or it's just an object with three attributes,
或仅仅是具有三个属性的对象， 

358
00:16:38,340 --> 00:16:40,090
I guess, they're called in Python.
我猜，它们在Python中被称为。 

359
00:16:40,090 --> 00:16:43,340
So here we have the value.
因此，在这里我们具有价值。 

360
00:16:43,340 --> 00:16:45,450
That's a word like an integer.
那是一个像整数的词。 

361
00:16:45,450 --> 00:16:46,959
And then some things can be pointers
然后一些东西可以成为指针

362
00:16:47,159 --> 00:16:48,419
that point to other nodes.
指向其他节点。 

363
00:16:48,419 --> 00:16:49,729
And you can create a new node.
您可以创建一个新节点。 

364
00:16:49,730 --> 00:16:50,720
You can destroy a node.
您可以销毁节点。 

365
00:16:50,720 --> 00:16:54,109
That's the dynamic memory allocation.
这就是动态内存分配。 

366
00:16:54,309 --> 00:16:56,919
In this model, yeah, pointers are pointers.
是的，在这种模型中，指针就是指针。 

367
00:16:56,919 --> 00:16:58,219
You can't touch them.
你不能碰他们。 

368
00:16:58,220 --> 00:17:00,959
Now, you can implement this model in a random access
现在，您可以在随机访问中实现此模型

369
00:17:01,159 --> 00:17:01,899
machine.
机。 

370
00:17:01,899 --> 00:17:06,068
A pointer becomes an index into this giant table.
指针成为该巨型表的索引。 

371
00:17:06,068 --> 00:17:08,068
And that's more like the pointers in C
那更像是C中的指针

372
00:17:08,068 --> 00:17:09,761
if you've ever written C programs.
如果您曾经编写过C程序。 

373
00:17:09,761 --> 00:17:11,220
Because then you can take a pointer
因为那样你就可以指针

374
00:17:11,220 --> 00:17:13,868
and you can add one to it and go to the next thing after that.
您可以在其中添加一个，然后转到下一个内容。 

375
00:17:13,868 --> 00:17:15,743
In this model, you can just follow a pointer.
在此模型中，您可以仅跟随一个指针。 

376
00:17:15,743 --> 00:17:17,057
That's all you can do.
那就是您所能做的。 

377
00:17:17,057 --> 00:17:18,890
OK, following a pointer costs constant time.
好的，跟随指针花费的时间是恒定的。 

378
00:17:18,890 --> 00:17:21,128
Changing one of these fields costs constant time.
更改这些字段之一将花费固定的时间。 

379
00:17:21,328 --> 00:17:24,930
All the usual things you might imagine doing to these objects
您可能会想到对这些对象执行的所有常规操作

380
00:17:24,930 --> 00:17:26,408
take constant time.
花费固定的时间。 

381
00:17:26,608 --> 00:17:29,754
So it's actually a weaker model than this one.
因此，它实际上是比这个模型更弱的模型。 

382
00:17:29,755 --> 00:17:31,630
Because you could implement a pointer machine
因为您可以实现一个指针机

383
00:17:31,630 --> 00:17:33,540
with a random access machine.
用随机存取机。 

384
00:17:33,740 --> 00:17:35,490
But it offers a different way of thinking.
但这提供了不同的思维方式。 

385
00:17:35,490 --> 00:17:37,323
A lot of data structures are built this way.
这种方式构建了许多数据结构。 

386
00:17:37,323 --> 00:17:39,504



387
00:17:39,704 --> 00:17:40,204
Cool.
凉。 

388
00:17:40,204 --> 00:17:42,769



389
00:17:42,769 --> 00:17:45,129
So that's the theory side.
这就是理论方面。 

390
00:17:45,130 --> 00:17:49,309
What I'd like to talk about next is actually in Python,
接下来我要说的实际上是Python， 

391
00:17:49,509 --> 00:17:53,519
what's a reasonable model of what's going on?
发生什么情况的合理模型是什么？ 

392
00:17:53,519 --> 00:17:55,160
So these are old models.
因此，这些都是旧模型。 

393
00:17:55,160 --> 00:17:56,970
This goes back to the '80s.
这可以追溯到80年代。 

394
00:17:56,970 --> 00:17:59,111
This one probably '80s or '70s.
这个大概是80年代或70年代。 

395
00:17:59,311 --> 00:18:00,769
So they've been around a long time.
因此，他们已经存在了很长时间。 

396
00:18:00,769 --> 00:18:02,119
People have used them forever.
人们永远使用它们。 

397
00:18:02,119 --> 00:18:04,871
Python is obviously much more recent, at least
 Python显然是最近的，至少

398
00:18:04,872 --> 00:18:05,754
modern versions of Python.
现代版本的Python。 

399
00:18:05,954 --> 00:18:11,449



400
00:18:11,450 --> 00:18:14,789
And it's the model of computation in some sense
从某种意义上讲，它是计算模型

401
00:18:14,789 --> 00:18:16,200
that we use in this class.
我们在本课中使用的。 

402
00:18:16,200 --> 00:18:18,200
Because we're implementing everything in Python.
因为我们正在用Python实现所有内容。 

403
00:18:18,200 --> 00:18:21,409
And Python offers both a random access machine perspective
 Python提供了随机访问机器的观点

404
00:18:21,609 --> 00:18:24,429
because it has arrays, and it offers a pointer machine
因为它具有数组，并且提供了指针机

405
00:18:24,430 --> 00:18:26,779
perspective because it has references,
透视，因为它有参考， 

406
00:18:26,779 --> 00:18:28,599
because it has pointers.
因为它有指针。 

407
00:18:28,599 --> 00:18:31,149
So you can do either one.
所以你可以做任何一个。 

408
00:18:31,150 --> 00:18:32,890
But it also has a lot of operations.
但是它也有很多操作。 

409
00:18:32,890 --> 00:18:38,180
It doesn't just have load and store and follow pointer.
它不仅具有加载，存储和跟随指针的功能。 

410
00:18:38,180 --> 00:18:43,029
It's got things like sort and append
它具有排序和附加之类的功能

411
00:18:43,029 --> 00:18:46,589
and concatenation of two lists and lots of things.
和两个列表和很多东西的串联。 

412
00:18:46,589 --> 00:18:48,939
And each of those has a cost associated with them.
而每个人都有与之相关的成本。 

413
00:18:48,940 --> 00:18:50,990
So whereas the random access machine and pointer machine,
因此，尽管随机存取机和指针机

414
00:18:50,990 --> 00:18:52,115
they're theoretical models.
它们是理论模型。 

415
00:18:52,115 --> 00:18:53,710
They're designed to be super simple.
它们的设计非常简单。 

416
00:18:53,710 --> 00:18:58,230
So it's clear that everything you do takes constant time.
显然，您所做的每一件事都需要花费固定的时间。 

417
00:18:58,230 --> 00:19:01,000
In Python, some of the operations you can do
在Python中，您可以执行一些操作

418
00:19:01,000 --> 00:19:03,150
take a lot of time.
花很多时间。 

419
00:19:03,150 --> 00:19:05,533
Some of the operations in Python take exponential time to do.
 Python中的某些操作需要花费大量时间。 

420
00:19:05,733 --> 00:19:08,149
And you've got to know when you're writing your algorithms
而且您必须知道何时编写算法

421
00:19:08,150 --> 00:19:11,259
down either thinking in a Python model or your implementing
在Python模型中思考或实现

422
00:19:11,259 --> 00:19:13,950
your algorithms in actual Python,
您在实际Python中的算法， 

423
00:19:13,950 --> 00:19:16,259
which operations are fast and which are slow.
哪些操作快，哪些操作慢。 

424
00:19:16,259 --> 00:19:19,703
And that's what I'd like to spend the next few minutes on.
这就是我接下来要花费的时间。 

425
00:19:19,703 --> 00:19:20,869
There's a lot of operations.
有很多操作。 

426
00:19:20,869 --> 00:19:23,619
I'm not going to cover all of them.
我不会覆盖所有这些。 

427
00:19:23,619 --> 00:19:27,279
But we'll cover more in recitation.
但是我们将在背诵中介绍更多内容。 

428
00:19:27,279 --> 00:19:29,129
And there's a whole bunch in my notes.
我的笔记里有一堆。 

429
00:19:29,130 --> 00:19:30,859
I won't get to all of them.
我不会全部了解。 

430
00:19:31,059 --> 00:19:36,139
So in Python, you can do random access style things.
因此，在Python中，您可以执行随机访问样式的事情。 

431
00:19:36,140 --> 00:19:38,339
In Python, arrays are called lists,
在Python中，数组称为列表， 

432
00:19:38,539 --> 00:19:40,230
which is super confusing.
超级混乱。 

433
00:19:40,230 --> 00:19:42,240
But there you go.
但是，你去了。 

434
00:19:42,240 --> 00:19:48,109
A list in Python is an array in real world.
 Python中的列表是现实世界中的数组。 

435
00:19:48,109 --> 00:19:51,284
It's a super cool array, of course?
当然，这是一个非常酷的阵列？ 

436
00:19:51,285 --> 00:19:52,750
And you can think of it as a list.
您可以将其视为列表。 

437
00:19:52,750 --> 00:19:55,460
But in terms implementation, it's implemented as an array.
但就实现而言，它是作为数组实现的。 

438
00:19:55,460 --> 00:19:55,960
Question?
题？ 

439
00:19:55,960 --> 00:19:58,660
AUDIENCE: I thought that [INAUDIBLE].
听众：我认为[听不清]。 

440
00:19:58,660 --> 00:20:01,160
PROFESSOR: You thought Python links lists were linked lists.
教授：您认为Python链接列表是链接列表。 

441
00:20:01,160 --> 00:20:02,167
That's why it's so confusing.
这就是为什么它如此令人困惑。 

442
00:20:02,367 --> 00:20:04,279
In fact, they are not.
实际上，事实并非如此。 

443
00:20:04,279 --> 00:20:07,629
In, say, scheme, back in the days when we taught scheme,
例如，在计划中，当我们教计划的时候， 

444
00:20:07,630 --> 00:20:09,839
lists are linked lists.
列表是链接列表。 

445
00:20:10,039 --> 00:20:11,579
And it's very different.
这是非常不同的。 

446
00:20:11,579 --> 00:20:14,529
So when you do-- I'll give an operation here.
所以，当您这样做时，我将在此处进行操作。 

447
00:20:14,529 --> 00:20:17,329
You have a list L, and you do something like this.
您有一个列表L，您会执行以下操作。 

448
00:20:17,329 --> 00:20:21,179



449
00:20:21,180 --> 00:20:23,390
L is a list object.
 L是列表对象。 

450
00:20:23,390 --> 00:20:25,446
This takes constant time.
这需要固定的时间。 

451
00:20:25,646 --> 00:20:27,480
In a linked list, it would take linear time.
在链接列表中，将花费线性时间。 

452
00:20:27,480 --> 00:20:30,769
Because we've got a scan to position I, scan to position J,
因为我们已经扫描到位置I，所以扫描到位置J， 

453
00:20:30,769 --> 00:20:33,000
add 5, and store.
加5，然后存储。 

454
00:20:33,000 --> 00:20:38,029
But conveniently in Python, this takes constant time.
但是在Python中很方便，这需要持续的时间。 

455
00:20:38,029 --> 00:20:39,862
And that's important to know.
这一点很重要。 

456
00:20:39,862 --> 00:20:41,619
I know that the terminology is super confusing.
我知道术语超级混乱。 

457
00:20:41,819 --> 00:20:49,139
But blame the benevolent dictator for life.
但是要怪仁慈的独裁者一生。 

458
00:20:49,140 --> 00:20:55,379
On the other hand, you can do style two, pointer machine,
另一方面，您可以进行样式二，指针机， 

459
00:20:55,579 --> 00:20:57,829
using object oriented programming, obviously.
显然，使用面向对象的编程。 

460
00:20:57,829 --> 00:21:01,119



461
00:21:01,119 --> 00:21:05,209
I'll just mention that I'm not really
我只想说我不是真的

462
00:21:05,210 --> 00:21:07,529
worrying about methods here.
担心这里的方法。 

463
00:21:07,529 --> 00:21:11,639
Because methods are just sort of a way of thinking about things,
因为方法只是一种思考事物的方式， 

464
00:21:11,640 --> 00:21:14,669
not super important from a cost standpoint.
从成本的角度来看并不是很重要。 

465
00:21:14,869 --> 00:21:17,149
If your object has a constant number of attributes--
如果您的对象具有恒定数量的属性， 

466
00:21:17,150 --> 00:21:19,099
it can't have like a million attributes
它不能具有一百万个属性

467
00:21:19,299 --> 00:21:21,250
or can't have n executes-- then it
或没有n执行-那么它

468
00:21:21,250 --> 00:21:22,890
fits into this pointer machine model.
适合此指针机模型。 

469
00:21:22,890 --> 00:21:24,450
So if you have an object that only
因此，如果您只有一个物体

470
00:21:24,450 --> 00:21:27,078
has like three things or 10 things or whatever,
有三件事或十件事等等

471
00:21:27,078 --> 00:21:28,119
that's a pointer machine.
那是一个指针机。 

472
00:21:28,119 --> 00:21:29,827
You can think of manipulating that object
您可以考虑操纵该对象

473
00:21:29,827 --> 00:21:31,349
as taking constant time.
因为需要固定的时间。 

474
00:21:31,349 --> 00:21:33,954
If you are screwing around the object's dictionary
如果您正在拧紧对象的字典

475
00:21:33,954 --> 00:21:35,730
and doing lots of crazy things, then you
做很多疯狂的事情，那么你

476
00:21:35,730 --> 00:21:37,990
have to be careful about whether this remains true.
必须注意是否仍然如此。 

477
00:21:37,990 --> 00:21:40,460
But as long as you only have a reasonable number
但是只要你有一个合理的数字

478
00:21:40,460 --> 00:21:43,230
of attributes, this is all fair game.
属性，这都是公平的游戏。 

479
00:21:43,230 --> 00:21:46,549
And so if you do something like, if you're implementing a linked
因此，如果您执行类似操作， 

480
00:21:46,549 --> 00:21:48,184
list, Python I checked still does not
列表，我检查过的Python仍然没有

481
00:21:48,184 --> 00:21:49,309
have built-in linked lists.
具有内置的链接列表。 

482
00:21:49,309 --> 00:21:51,429
They're pretty easy to build, though.
但是，它们很容易构建。 

483
00:21:51,430 --> 00:21:52,420
You have a pointer.
你有一个指针。 

484
00:21:52,420 --> 00:21:54,389
And you just say x equals x.next.
您只说x等于x.next。 

485
00:21:54,589 --> 00:21:58,699
That takes constant time because accessing this field
这需要持续的时间，因为访问此字段

486
00:21:58,700 --> 00:22:02,318
in an object of constant size takes constant time.
大小恒定的对象花费的时间不变。 

487
00:22:02,318 --> 00:22:04,109
And we don't care what these constants are.
而且我们不在乎这些常量是什么。 

488
00:22:04,109 --> 00:22:05,442
That's the beauty of algorithms.
那就是算法的美。 

489
00:22:05,442 --> 00:22:07,450
Because we only care about scalability with n.
因为我们只关心n的可伸缩性。 

490
00:22:07,450 --> 00:22:09,150
There's no n here.
这里没有人。 

491
00:22:09,150 --> 00:22:10,200
This takes constant time.
这需要固定的时间。 

492
00:22:10,200 --> 00:22:12,910
This takes constant time.
这需要固定的时间。 

493
00:22:12,910 --> 00:22:14,529
No matter how big your linked list
无论您的链表多大

494
00:22:14,529 --> 00:22:17,139
is or no matter how many objects you have,
不管有多少物体， 

495
00:22:17,140 --> 00:22:19,099
these are constant time.
这些是恒定的时间。 

496
00:22:19,299 --> 00:22:21,759
OK, let's do some harder ones, though.
好的，让我们做一些更难的事情。 

497
00:22:21,759 --> 00:22:24,480
In general, the idea is, if you take
一般来说，如果

498
00:22:24,480 --> 00:22:29,160
an operation like L.append-- so you have a list.
 L.append之类的操作-这样您就有了一个列表。 

499
00:22:29,160 --> 00:22:31,460
And you want to append some item to the list.
您想将一些项目添加到列表中。 

500
00:22:31,460 --> 00:22:33,579
It's an array, though.
不过，这是一个数组。 

501
00:22:33,579 --> 00:22:35,789
So think about it.
所以考虑一下。 

502
00:22:35,789 --> 00:22:38,839
The way to figure out how much does this cost
弄清楚这要花多少钱的方法

503
00:22:38,839 --> 00:22:40,599
is to think about how it's implemented
考虑如何实施

504
00:22:40,599 --> 00:22:42,750
in terms of these basic operations.
在这些基本操作方面。 

505
00:22:42,750 --> 00:22:46,779
So these are your sort of the core concept time things.
因此，这些是您的核心概念时间事物。 

506
00:22:46,779 --> 00:22:50,319
Most everything can be reduced to thinking about this.
大多数事情都可以简化为思考。 

507
00:22:50,319 --> 00:22:53,319
But sometimes, it's less obvious.
但是有时候，它并不那么明显。 

508
00:22:53,319 --> 00:22:55,516
L.apend is a little tricky to think about.
 L.apend的思考有点棘手。 

509
00:22:55,517 --> 00:22:57,399
Because basically, you have an array of some size.
因为基本上，您有一些大小的数组。 

510
00:22:57,599 --> 00:23:00,250
And now you want to make an array one larger.
现在，您想将数组扩大一个。 

511
00:23:00,250 --> 00:23:02,625
And the obvious way to do that is to allocate a new array
显而易见的方法是分配一个新数组

512
00:23:02,625 --> 00:23:03,708
and copy all the elements.
并复制所有元素。 

513
00:23:03,708 --> 00:23:05,259
That would take linear time.
这将花费线性时间。 

514
00:23:05,259 --> 00:23:07,180
Python doesn't do that.
 Python不会那样做。 

515
00:23:07,180 --> 00:23:09,910
What does it do?
它有什么作用？ 

516
00:23:09,910 --> 00:23:11,680
Stay tuned for lecture eight.
请继续关注第八讲。 

517
00:23:11,680 --> 00:23:14,299



518
00:23:14,299 --> 00:23:17,139
It does something called table doubling.
它执行称为表加倍的操作。 

519
00:23:17,140 --> 00:23:18,140
It's a very simple idea.
这是一个非常简单的想法。 

520
00:23:18,140 --> 00:23:20,359
You can almost get guess it from the title.
您几乎可以从标题中猜到它。 

521
00:23:20,559 --> 00:23:23,945
And if you go to lecture-- is it eight or nine?
如果您去听课，是八九吗？ 

522
00:23:23,945 --> 00:23:26,179
Nine, sorry.
九，对不起。 

523
00:23:26,180 --> 00:23:28,049
You'll see how this can basically
您将基本了解

524
00:23:28,049 --> 00:23:30,819
be done in constant time.
在固定时间内完成。 

525
00:23:30,819 --> 00:23:33,859
There's a slight catch, but basically, think of it
有一点收获，但基本上，请考虑一下

526
00:23:33,859 --> 00:23:36,279
as a constant time operation.
作为恒定时间操作。 

527
00:23:36,279 --> 00:23:38,253
Once we have that, and so this is
一旦有了，就这样

528
00:23:38,253 --> 00:23:39,919
why you should take this class so you'll
为什么要上这堂课

529
00:23:39,920 --> 00:23:41,920
understand how Python works.
了解Python的工作原理。 

530
00:23:41,920 --> 00:23:44,409
This is using an algorithmic concept that was invented,
这使用了发明的算法概念， 

531
00:23:44,609 --> 00:23:47,179
I don't know, decades ago, but is a simple thing
我不知道，几十年前，但这很简单

532
00:23:47,180 --> 00:23:49,769
that we need to do to solve lots of other problems.
解决很多其他问题需要做的事情。 

533
00:23:49,769 --> 00:23:50,309
So it's cool.
太酷了。 

534
00:23:50,309 --> 00:23:53,799
There's a lot of features in Python that use algorithms.
 Python中有很多使用算法的功能。 

535
00:23:53,799 --> 00:23:56,500
And that's kind of why I'm telling you.
这就是为什么我告诉你。 

536
00:23:56,500 --> 00:23:58,119
All right, so let's do another one.
好吧，让我们再做一个。 

537
00:23:58,119 --> 00:23:59,209
A little easier.
容易一点。 

538
00:23:59,210 --> 00:24:01,029
What if I want to concatenate two lists?
如果要串联两个列表怎么办？ 

539
00:24:01,029 --> 00:24:04,079
You should know in Python this is a non-destructive operation.
您应该知道在Python中这是一种非破坏性的操作。 

540
00:24:04,079 --> 00:24:07,439
You basically take a copy of L1 and L2 and concatenate them.
您基本上可以复制L1和L2并将它们连接起来。 

541
00:24:07,440 --> 00:24:09,299
Of course, they're arrays.
当然，它们是数组。 

542
00:24:09,299 --> 00:24:11,440
The way to think about this is to re-implement it
思考此问题的方法是重新实现它

543
00:24:11,440 --> 00:24:12,279
as Python code.
作为Python代码。 

544
00:24:12,279 --> 00:24:14,629
This is the same thing as saying, well,
这和说，是一样的， 

545
00:24:14,630 --> 00:24:16,440
L is initially empty.
 L最初是空的。 

546
00:24:16,440 --> 00:24:21,250
And then for every item x and L1, L.append(x).
然后对于每个项x和L1，L.append（x）。 

547
00:24:21,250 --> 00:24:24,880



548
00:24:24,880 --> 00:24:27,099
And a lot of the times in documentation for Python,
很多时候在Python文档中， 

549
00:24:27,299 --> 00:24:30,819
you see this sort of here's what it means, especially
您会看到这种意思，尤其是

550
00:24:30,819 --> 00:24:33,519
in the fancier features.
在更高级的功能上。 

551
00:24:33,519 --> 00:24:38,878
They give sort of an equivalent simple Python, if you will.
如果可以的话，它们提供了等效的简单Python。 

552
00:24:38,878 --> 00:24:40,419
This doesn't use any fancy operations
这不使用任何花哨的操作

553
00:24:40,420 --> 00:24:41,920
that we haven't seen already.
我们还没有看到。 

554
00:24:41,920 --> 00:24:44,849
So now we know this takes constant time.
所以现在我们知道这需要持续的时间。 

555
00:24:45,049 --> 00:24:47,839
The append, this append, takes constant time.
附件（此附件）需要固定的时间。 

556
00:24:47,839 --> 00:24:50,019
And so the amount of time here is basically
所以这里的时间基本上是

557
00:24:50,019 --> 00:24:53,230
order the length of L1.
订购L1的长度。 

558
00:24:53,230 --> 00:24:56,670
And the time here is order the length of L2.
而这里的时间是L2的长度。 

559
00:24:56,670 --> 00:24:59,140
And so in total, it's order-- I'm
总的来说，这是命令-我是

560
00:24:59,140 --> 00:25:02,470
going to be careful and say 1 plus length of L1
要小心，说1加L1的长度

561
00:25:02,470 --> 00:25:06,160
plus length of L2.
加上L2的长度

562
00:25:06,160 --> 00:25:07,859
The 1 plus is just in case these are both 0.
如果它们都是0，则加1。 

563
00:25:08,059 --> 00:25:11,960
It still takes constant time to build an initial list.
建立初始列表仍然需要花费固定的时间。 

564
00:25:11,960 --> 00:25:14,019
OK, so there are a bunch of operations
好，所以有很多操作

565
00:25:14,019 --> 00:25:15,650
that are written in these notes.
这些注释中写的。 

566
00:25:15,650 --> 00:25:17,629
I'm not going to go through all of them
我不会经历所有的

567
00:25:17,829 --> 00:25:19,129
because they're tedious.
因为它们很乏味。 

568
00:25:19,130 --> 00:25:22,379
But a lot of you, could just expand out code like this.
但是你们中的很多人都可以像这样扩展代码。 

569
00:25:22,579 --> 00:25:23,829
And it's very easy to analyze.
而且非常容易分析。 

570
00:25:23,829 --> 00:25:25,245
Whereas you just look at plus, you
而您只看加号

571
00:25:25,246 --> 00:25:26,670
think, oh, plus is constant time.
想想，哦，加上是恒定的时间。 

572
00:25:26,670 --> 00:25:28,659
And plus is constant time if this is a word
如果这是一个字，那么加号就是固定时间

573
00:25:28,659 --> 00:25:29,450
and this is a word.
这是一个词。 

574
00:25:29,450 --> 00:25:31,759
But these are entire data structures.
但是这些都是完整的数据结构。 

575
00:25:31,759 --> 00:25:34,480
And so it's not constant time.
因此，时间不是固定的。 

576
00:25:34,480 --> 00:25:35,993
All right.
好吧。 

577
00:25:35,993 --> 00:25:37,909
There are more subtle fun ones to think about.
还有更多有趣的事情要考虑。 

578
00:25:37,910 --> 00:25:43,339
Like, if I want to know is x in the list, how does that happen?
就像，如果我想知道列表中的x，这是怎么发生的？ 

579
00:25:43,539 --> 00:25:45,869
Any guesses?
有什么猜想吗？ 

580
00:25:45,869 --> 00:25:47,659
There's an operator in Python called
 Python中有一个运算子叫做

581
00:25:47,660 --> 00:25:51,670
in-- x in L. How long do you think this takes?
 in-- x inL。您认为这需要多长时间？ 

582
00:25:51,670 --> 00:25:54,869



583
00:25:55,069 --> 00:25:56,769
Altogether?
共？ 

584
00:25:56,769 --> 00:25:59,009
Linear, yeah.
线性，是的。 

585
00:25:59,009 --> 00:25:59,759
Linear time.
线性时间。 

586
00:25:59,759 --> 00:26:00,786
In the worst case, you're going to have
在最坏的情况下，您将拥有

587
00:26:00,786 --> 00:26:01,889
to scan through the whole list.
扫描整个列表。 

588
00:26:02,089 --> 00:26:03,500
Lists aren't necessarily sorted.
列表不一定要排序。 

589
00:26:03,500 --> 00:26:05,029
We don't know anything about them.
我们对他们一无所知。 

590
00:26:05,029 --> 00:26:06,539
So you've got to just scan through and test
因此，您只需要扫描并测试

591
00:26:06,539 --> 00:26:07,289
for every item.
对于每个项目。 

592
00:26:07,289 --> 00:26:09,240
Is x equal to that item?
 x等于那个项目吗？ 

593
00:26:09,240 --> 00:26:12,011
And it's even worse if equal equals costs a lot.
如果等于等于付出很多代价，那就更糟了。 

594
00:26:12,011 --> 00:26:13,720
So if x is some really complicated thing,
因此，如果x是一件非常复杂的事情， 

595
00:26:13,720 --> 00:26:16,669
you have to take that into account.
您必须考虑到这一点。 

596
00:26:16,869 --> 00:26:18,399
OK, blah, blah, blah.
好吧，等等，等等。 

597
00:26:18,400 --> 00:26:19,250
OK, another fun one.
好，另一个有趣的。 

598
00:26:19,250 --> 00:26:21,680
This is like a pop quiz.
这就像一个流行测验。 

599
00:26:21,680 --> 00:26:25,660
How long's it take to compute the length of a list?
计算列表的长度需要多长时间？ 

600
00:26:25,660 --> 00:26:26,599
Constant.
不变。 

601
00:26:26,799 --> 00:26:29,196
Yeah, luckily, if you didn't know anything,
是的，幸运的是，如果您什么都不知道， 

602
00:26:29,196 --> 00:26:31,529
you'd have to scan through the list and count the items.
您必须浏览列表并计算项目。 

603
00:26:31,529 --> 00:26:33,930
But in Python, lists are implemented
但是在Python中，列表已实现

604
00:26:33,930 --> 00:26:34,899
with a counter built in.
内置计数器。 

605
00:26:35,099 --> 00:26:37,269
It always stores the list at the beginning--
它总是将列表存储在开头- 

606
00:26:37,269 --> 00:26:38,619
stores the length of the list at the beginning.
将列表的长度存储在开头。 

607
00:26:38,619 --> 00:26:39,789
So you just look it up.
因此，您只需查找一下即可。 

608
00:26:39,789 --> 00:26:42,299
This is instantaneous.
这是瞬时的。 

609
00:26:42,299 --> 00:26:43,690
It's important, though.
这很重要。 

610
00:26:43,690 --> 00:26:46,269
That can matter.
那很重要。 

611
00:26:46,269 --> 00:26:47,920
All right.
好吧。 

612
00:26:47,920 --> 00:26:48,890
Let's do some more.
让我们做更多。 

613
00:26:48,890 --> 00:26:58,900



614
00:26:58,900 --> 00:27:00,169
What if I want to sort a list?
如果我想对列表进行排序怎么办？ 

615
00:27:00,369 --> 00:27:01,369
How long does that take?
这需要多长时间？ 

616
00:27:01,369 --> 00:27:06,579



617
00:27:06,579 --> 00:27:13,799
N log n where n is the length of the list.
 N log n其中n是列表的长度。 

618
00:27:13,799 --> 00:27:20,450
Technically times the time to compare two items, which
从技术上讲，比较两个项目的时间乘以

619
00:27:20,450 --> 00:27:22,130
usually we're just sorting words.
通常我们只是对单词进行排序。 

620
00:27:22,130 --> 00:27:25,649
And so this is constant time.
因此，这是恒定时间。 

621
00:27:25,849 --> 00:27:27,529
If you look at Python sorting algorithm,
如果您看一下Python排序算法， 

622
00:27:27,529 --> 00:27:29,240
it uses a comparison sort.
它使用比较排序。 

623
00:27:29,240 --> 00:27:35,259
This is the topic of lectures three and four and seven.
这是第三，第四和第七讲的主题。 

624
00:27:35,259 --> 00:27:37,500
But in particular, the very next lecture,
但特别是在接下来的演讲中

625
00:27:37,500 --> 00:27:41,670
we will see how this is done in n log n time.
我们将看到如何在n log n时间内完成此操作。 

626
00:27:41,670 --> 00:27:45,690
And that is using algorithms.
那就是使用算法。 

627
00:27:45,690 --> 00:27:52,210
All right, let's go to dictionaries.
好吧，让我们去看看字典。 

628
00:27:52,210 --> 00:27:55,240
Python called dicts.
 Python称为dicts。 

629
00:27:55,240 --> 00:27:57,599
And these let you do things.
这些让您做事。 

630
00:27:57,599 --> 00:27:59,599
They're a generalization of lists in some sense.
从某种意义上讲，它们是列表的概括。 

631
00:27:59,599 --> 00:28:03,129
Instead of putting just an index here, an integer between 0
而不是仅在此处放置索引，而是0之间的整数

632
00:28:03,130 --> 00:28:05,819
and the length minus 1, you can put an arbitrary key
长度减去1，您可以放置​​任意键

633
00:28:06,019 --> 00:28:08,250
and store a value, for example.
并存储一个值。 

634
00:28:08,250 --> 00:28:09,940
How long does this take?
这需要多长时间？ 

635
00:28:09,940 --> 00:28:12,795
I'm not going to ask you because, it's not obvious.
我不会问你，因为这并不明显。 

636
00:28:12,795 --> 00:28:16,659
In fact, this is one of the most important data structures
实际上，这是最重要的数据结构之一

637
00:28:16,859 --> 00:28:18,579
in all of computer science.
在所有计算机科学中。 

638
00:28:18,579 --> 00:28:20,409
It's called a hash table.
它称为哈希表。 

639
00:28:20,410 --> 00:28:25,269
And it is the topic of lectures eight through 10.
这是第8至10讲课的主题。 

640
00:28:25,269 --> 00:28:28,349
So stay tuned for how to do this in constant time,
因此，请继续关注如何在恒定时间内执行此操作， 

641
00:28:28,349 --> 00:28:30,250
how to be able to store an arbitrary key,
如何能够存储任意密钥， 

642
00:28:30,250 --> 00:28:32,119
get it back out in constant time.
在固定时间内将其取出。 

643
00:28:32,119 --> 00:28:34,849
This is assuming the key is a single word.
假设键是一个单词。 

644
00:28:34,849 --> 00:28:35,619
Yeah.
是的

645
00:28:35,619 --> 00:28:38,244
AUDIENCE: Does it first check to see whether the key is already
听众：首先检查密钥是否已经存在

646
00:28:38,244 --> 00:28:39,699
in the dictionary?
在字典中？ 

647
00:28:39,700 --> 00:28:42,389
PROFESSOR: Yeah, it will clobber any existing key.
教授：是的，它将破坏任何现有的密钥。 

648
00:28:42,589 --> 00:28:44,731
There's also, you know, you can test
您还可以测试

649
00:28:44,731 --> 00:28:46,190
whether a key is in the dictionary.
密钥是否在字典中。 

650
00:28:46,190 --> 00:28:47,725
That also takes constant time.
这也需要持续的时间。 

651
00:28:47,925 --> 00:28:49,799
You can delete something from the dictionary.
您可以从字典中删除某些内容。 

652
00:28:49,799 --> 00:28:53,710
All the usual-- dealing with a single key in dictionaries,
通常-处理字典中的单个键， 

653
00:28:53,710 --> 00:28:56,509
obviously dictionary.update, that involves a lot of keys.
显然是dictionary.update，其中涉及很多键。 

654
00:28:56,509 --> 00:28:58,069
That doesn't take some time.
不需要时间。 

655
00:28:58,069 --> 00:28:59,058
How long does it take?
多久时间？ 

656
00:28:59,058 --> 00:29:00,974
Well, you write out a for loop and count them.
好吧，您编写了一个for循环并对其进行计数。 

657
00:29:00,974 --> 00:29:02,794
AUDIENCE: But how can you see whether [INAUDIBLE]
听众：但是你怎么看[听不清] 

658
00:29:02,795 --> 00:29:04,160
dictionary in constant time?
字典在恒定的时间？ 

659
00:29:04,160 --> 00:29:05,917
PROFESSOR: How do you do this in constant time?
教授：您如何在固定时间内做到这一点？ 

660
00:29:06,117 --> 00:29:08,220
Come to lecture eight through 10.
参加第8至10堂课。 

661
00:29:08,220 --> 00:29:10,420
I should say a slight catch, which
我应该说一点收获， 

662
00:29:10,420 --> 00:29:13,480
is this is constant time with high probability.
这是恒定时间的可能性很高吗？ 

663
00:29:13,480 --> 00:29:15,834
It's a randomized algorithm.
这是一个随机算法。 

664
00:29:15,834 --> 00:29:17,375
It doesn't always take constant time.
并非总是需要固定的时间。 

665
00:29:17,375 --> 00:29:18,569
It's always correct.
总是正确的。 

666
00:29:18,569 --> 00:29:21,379
But sometimes, very rarely, it takes a little more
但是有时候，很少会花更多的时间

667
00:29:21,380 --> 00:29:22,559
than constant time.
而不是固定的时间。 

668
00:29:22,759 --> 00:29:26,170
And I'm going to abbreviate this WHP.
我将简化此WHP。 

669
00:29:26,170 --> 00:29:29,410
And we'll see more what that means mostly, actually,
实际上，我们将看到更多的含义， 

670
00:29:29,410 --> 00:29:30,390
in 6046.
在6046年。 

671
00:29:30,390 --> 00:29:33,233
But we'll see a fair amount in 6006 on how this works
但是我们会在6006中看到相当多的数字

672
00:29:33,433 --> 00:29:34,349
and how it's possible.
以及它如何成为可能。 

673
00:29:34,349 --> 00:29:35,679
It's a big area of research.
这是一个很大的研究领域。 

674
00:29:35,680 --> 00:29:37,430
A lot of people work on hashing.
很多人从事散列工作。 

675
00:29:37,430 --> 00:29:38,919
It's very cool and it's super useful.
这非常酷，而且超级有用。 

676
00:29:39,119 --> 00:29:41,719
If you write any code these days, you use a dictionary.
如果这些天您编写任何代码，则可以使用字典。 

677
00:29:41,720 --> 00:29:45,470
It's the way to solve problems.
这是解决问题的方法。 

678
00:29:45,470 --> 00:29:47,990
I'm basically using Python is a platform
我基本上是使用Python是一个平台

679
00:29:47,990 --> 00:29:50,839
to advertise the rest of the class you may have noticed.
宣传您可能已经注意到的其余课程。 

680
00:29:50,839 --> 00:29:53,599
Not every topic we cover in this class is already in Python,
并非我们在本课程中涵盖的所有主题都已经在Python中了， 

681
00:29:53,599 --> 00:29:55,209
but a lot of them are.
但是很多。 

682
00:29:55,210 --> 00:29:58,210
So we've got table doubling.
因此，我们将表加倍。 

683
00:29:58,210 --> 00:30:03,069
We've got dictionaries.
我们有字典。 

684
00:30:03,069 --> 00:30:04,460
We've got sorting.
我们已经排序。 

685
00:30:04,460 --> 00:30:09,299
Another one is longs, which are long integers in Python
另一个是long，在Python中是long整数

686
00:30:09,299 --> 00:30:11,990
through version two.
通过第二版。 

687
00:30:11,990 --> 00:30:17,849
And this is the topic of lecture 11.
这是第11讲的主题。 

688
00:30:17,849 --> 00:30:21,359
And so for fun, if I have two integers x and y,
所以很有趣，如果我有两个整数x和y， 

689
00:30:21,359 --> 00:30:24,609
and let's say one of them is this many words long
假设其中之一是那么长

690
00:30:24,609 --> 00:30:26,359
and the other one is this many words long,
另一个是这么长的字， 

691
00:30:26,359 --> 00:30:28,150
how long do you think it takes to add them?
您认为添加它们需要多长时间？ 

692
00:30:28,151 --> 00:30:33,289



693
00:30:33,289 --> 00:30:33,789
Guesses?
猜猜

694
00:30:33,789 --> 00:30:37,589



695
00:30:37,589 --> 00:30:40,019
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

696
00:30:40,019 --> 00:30:40,900
PROFESSOR: Plus?
教授：还有吗？ 

697
00:30:40,900 --> 00:30:41,379
Times?
时间？ 

698
00:30:41,579 --> 00:30:43,826
Plus is the answer.
加号就是答案。 

699
00:30:43,826 --> 00:30:45,160
You can do it in that much time.
您可以在那么长的时间内完成操作。 

700
00:30:45,160 --> 00:30:47,735



701
00:30:47,935 --> 00:30:49,809
If you think about the grade school algorithm
如果您考虑年级算法

702
00:30:49,809 --> 00:30:53,029
for adding really big multi-digit numbers,
用于添加非常大的多位数字， 

703
00:30:53,029 --> 00:30:54,500
it'll only take that much time.
只需要那么多时间。 

704
00:30:54,500 --> 00:30:56,769
Multiplication is a little bit harder, though.
但是，乘法要困难一些。 

705
00:30:56,769 --> 00:30:58,519
If you look at the grade school algorithm,
如果您看小学的算法， 

706
00:30:58,519 --> 00:31:01,309
it's going to be x times y-- it's quadratic time not so
这将是y的x倍-不是二次方的时间

707
00:31:01,309 --> 00:31:02,659
good.
好。 

708
00:31:02,660 --> 00:31:05,399
The algorithm that's implemented in Python
用Python实现的算法

709
00:31:05,599 --> 00:31:11,869
is x plus y to the log base 2 of 3.
对数以2为底的对数是x加y。 

710
00:31:11,869 --> 00:31:16,879
By the way, I always write LG to mean log base 2.
顺便说一句，我总是将LG写入对数基2。 

711
00:31:16,880 --> 00:31:20,430
Because it only has two letters, so OK, this is 2.
因为它只有两个字母，所以确定为2。 

712
00:31:20,430 --> 00:31:24,710
Log base 2 of 3 is about 1.6.
 3的对数底数为2约为1.6。 

713
00:31:24,710 --> 00:31:27,240
So while the straightforward algorithm is basically
所以虽然简单的算法基本上是

714
00:31:27,240 --> 00:31:31,410
x plus y squared, this one is x plus y to the 1.6 power,
 x加y的平方，这是x加y为1.6的幂， 

715
00:31:31,410 --> 00:31:32,910
a little better than quadratic.
比平方好一点。 

716
00:31:32,910 --> 00:31:37,680
And the Python developers found that was faster
而且Python开发人员发现速度更快

717
00:31:37,680 --> 00:31:39,149
than grade school multiplication.
而不是小学乘法。 

718
00:31:39,349 --> 00:31:40,490
And so that's what they implemented.
这就是他们所实施的。 

719
00:31:40,490 --> 00:31:42,573
And that is something we will cover in lecture 11,
这就是我们将在第11讲中介绍的内容

720
00:31:42,573 --> 00:31:43,240
how to do that.
怎么做。 

721
00:31:43,240 --> 00:31:44,509
It's pretty cool.
它太酷了。 

722
00:31:44,509 --> 00:31:46,289
There are faster algorithms, but this
有更快的算法，但这

723
00:31:46,289 --> 00:31:50,430
is one that works quite practically.
是一种非常实用的工具。 

724
00:31:50,430 --> 00:31:51,879
One more.
多一个。 

725
00:31:52,079 --> 00:31:55,451
Heap queue, this is in the Python standard library
堆队列，这在Python标准库中

726
00:31:55,451 --> 00:31:57,410
and implements something called the heap, which
并实现了称为堆的东西

727
00:31:57,410 --> 00:31:59,339
will be in lecture four.
将在第四讲中。 

728
00:31:59,539 --> 00:32:02,779
So, coming soon to a classroom near you.
因此，很快就会来到您附近的教室。 

729
00:32:02,779 --> 00:32:04,759
All right, enough advertisement.
好的，足够的广告。 

730
00:32:04,759 --> 00:32:07,200
That gives you some idea of the model of computation.
这使您对计算模型有了一些了解。 

731
00:32:07,200 --> 00:32:11,129
There's a whole bunch more in these notes which are online.
这些在线笔记中还有很多。 

732
00:32:11,329 --> 00:32:12,929
Go check them out.
去看看他们。 

733
00:32:12,930 --> 00:32:17,354
And some of them, we'll cover in recitation tomorrow.
其中一些，我们明天再讲。 

734
00:32:17,354 --> 00:32:19,769
I'd like to-- now that we are sort of comfortable for what
我想-现在我们对什么感到满意

735
00:32:19,769 --> 00:32:23,349
costs what in Python, I want to do a real example.
花费了Python中的费用，我想做一个真实的例子。 

736
00:32:23,349 --> 00:32:25,151
So last time, we did peak finding.
所以上次，我们做了高峰发现。 

737
00:32:25,152 --> 00:32:26,659
We're going to have another example which
我们将有另一个例子

738
00:32:26,859 --> 00:32:31,399
is called document distance.
称为文档距离。 

739
00:32:31,400 --> 00:32:32,180
So let's do that.
因此，让我们这样做。 

740
00:32:32,180 --> 00:32:35,390



741
00:32:35,390 --> 00:32:36,569
Any questions before we go on?
在我们继续之前有任何疑问吗？ 

742
00:32:36,769 --> 00:32:40,234



743
00:32:40,234 --> 00:32:41,224
All right.
好吧。 

744
00:32:41,224 --> 00:33:10,959



745
00:33:10,960 --> 00:33:15,639
So document distance problem is, I give you two documents.
所以文件距离问题是，我给你两个文件。 

746
00:33:15,839 --> 00:33:19,049
I'll call them D1 D2.
我称它们为D1 D2。 

747
00:33:19,049 --> 00:33:22,180
And I want to compute the distance between them.
我想计算它们之间的距离。 

748
00:33:22,180 --> 00:33:25,150
And the first question is, what does that mean?
第一个问题是，这是什么意思？ 

749
00:33:25,150 --> 00:33:27,170
What is this distance function?
这是什么距离函数？ 

750
00:33:27,170 --> 00:33:29,349
Let me first tell you some motivations
我先告诉你一些动机

751
00:33:29,549 --> 00:33:32,009
for computing document distance.
用于计算文档距离。 

752
00:33:32,009 --> 00:33:35,579
Let's say you're Google and you're
假设您是Google，而您

753
00:33:35,579 --> 00:33:37,129
cataloging the entire web.
对整个网络进行分类。 

754
00:33:37,130 --> 00:33:40,859
You'd like to know when two web pages are basically identical.
您想知道两个网页何时基本相同。 

755
00:33:41,059 --> 00:33:43,990
Because then you store less and because you present it
因为那样您就减少了存储量并且因为您展示了它

756
00:33:43,990 --> 00:33:44,990
differently to the user.
与用户不同。 

757
00:33:44,990 --> 00:33:46,769
You say, well, there's this page.
您说的很好，有此页面。 

758
00:33:46,769 --> 00:33:48,319
And there's lots of extra copies.
而且还有很多额外的副本。 

759
00:33:48,319 --> 00:33:51,470
But you just need-- here's the canonical one.
但是，您只需要-这就是规范的一个。 

760
00:33:51,470 --> 00:33:52,814
Or you're Wikipedia.
或者你是维基百科。 

761
00:33:52,814 --> 00:33:54,980
And I don't know if you've ever looked at Wikipedia.
而且我不知道您是否看过Wikipedia。 

762
00:33:54,980 --> 00:33:56,770
There's a list of all mirrors of Wikipedia.
列出了Wikipedia的所有镜像。 

763
00:33:56,770 --> 00:33:58,599
There's like millions of them.
那里有数百万。 

764
00:33:58,599 --> 00:34:01,619
And they find them by hand.
他们是手工找到的。 

765
00:34:01,619 --> 00:34:04,159
But you could do that using document distance.
但是您可以使用文档距离来做到这一点。 

766
00:34:04,160 --> 00:34:05,680
Say, are these basically identical
说，这些基本相同

767
00:34:05,680 --> 00:34:07,509
other than like some stuff at the-- junk
除了喜欢垃圾东西

768
00:34:07,509 --> 00:34:10,115
at the beginning or the end?
在开始还是结束？ 

769
00:34:10,115 --> 00:34:12,449
Or if you're teaching this class and you want to detect,
或者，如果您正在教这门课，并且想发现， 

770
00:34:12,449 --> 00:34:14,298
are two problem sets cheating?
是两个问题作弊吗？ 

771
00:34:14,498 --> 00:34:15,289
Are they identical?
他们是相同的吗？ 

772
00:34:15,289 --> 00:34:16,230
We do this a lot.
我们经常这样做。 

773
00:34:16,230 --> 00:34:18,630
I'm not going to tell you what distance function we use.
我不会告诉您我们使用什么距离函数。 

774
00:34:18,630 --> 00:34:20,129
Because that would defeat the point.
因为那样会失败。 

775
00:34:20,130 --> 00:34:21,920
It's not the one we cover in class.
这不是我们在课堂上讨论的内容。 

776
00:34:21,920 --> 00:34:25,769
But we use automated tests for whether you're cheating.
但是我们会使用自动化测试来确定您是否作弊。 

777
00:34:25,769 --> 00:34:29,250
I've got some more.
我还有更多。 

778
00:34:29,250 --> 00:34:30,570
Web search.
网络搜索。 

779
00:34:30,570 --> 00:34:31,880
Let's say you're Google again.
假设您再次成为Google。 

780
00:34:31,880 --> 00:34:35,139
And you want to implement searching.
您想实现搜索。 

781
00:34:35,139 --> 00:34:37,389
Like, I give you three words.
就像，我给你三个字。 

782
00:34:37,389 --> 00:34:40,489
I'm searching for introduction to algorithms.
我正在寻找算法的介绍。 

783
00:34:40,489 --> 00:34:42,280
You can think of introduction to algorithms
您可以想到算法介绍

784
00:34:42,280 --> 00:34:43,980
as a very short document.
作为一个非常简短的文件。 

785
00:34:43,980 --> 00:34:45,980
And you want to test whether that document is
您想测试该文档是否

786
00:34:45,980 --> 00:34:48,416
similar to all the other documents on the web.
类似于网络上的所有其他文档。 

787
00:34:48,416 --> 00:34:50,289
And the one that's most similar, the one that
最相似的那个

788
00:34:50,289 --> 00:34:51,820
has the small distance, that's maybe
距离很小，也许

789
00:34:51,820 --> 00:34:52,969
what you want to put at the top.
您想放在顶部的内容。 

790
00:34:52,969 --> 00:34:54,552
That's obviously not what Google does.
显然那不是Google所做的。 

791
00:34:54,552 --> 00:34:56,969
But it's part of what it does.
但这是其工作的一部分。 

792
00:34:56,969 --> 00:34:58,750
So that's why you might care.
这就是为什么您可能会在意。 

793
00:34:58,750 --> 00:35:00,280
It's partly also just a toy problem.
部分原因只是玩具问题。 

794
00:35:00,280 --> 00:35:03,519
It lets us illustrate a lot of the techniques
它让我们说明了很多技术

795
00:35:03,719 --> 00:35:07,789
that we develop in this class.
我们在这个班上发展的。 

796
00:35:07,789 --> 00:35:12,279
All right, I'm going to think of a document
好吧，我要考虑一个文件

797
00:35:12,280 --> 00:35:13,735
as a sequence of words.
作为一个单词序列。 

798
00:35:13,735 --> 00:35:16,789



799
00:35:16,789 --> 00:35:19,409
Just to be a little bit more formal,
只是稍微正式一点

800
00:35:19,409 --> 00:35:21,609
what do I mean by document?
文件是什么意思？ 

801
00:35:21,610 --> 00:35:26,150
And a word is just going to be a string
一个词只是一个字符串

802
00:35:26,150 --> 00:35:30,023
of alphanumeric characters-- A through Z
字母数字字符-A到Z 

803
00:35:30,023 --> 00:35:30,940
and zero through nine.
从零到九。 

804
00:35:30,940 --> 00:35:35,179



805
00:35:35,179 --> 00:35:36,980
OK, so if I have a document which you also
好，如果我有一个文件，你也

806
00:35:36,980 --> 00:35:39,199
think of as a string and you basically
认为是一个字符串，你基本上

807
00:35:39,199 --> 00:35:42,039
delete all the white space and punctuation all the other junk
删除所有空白，并删除所有其他垃圾标点符号

808
00:35:42,039 --> 00:35:43,099
that's in there.
在那里。 

809
00:35:43,099 --> 00:35:46,819
This Everything in between those, those are the words.
在这一切之间，那些就是单词。 

810
00:35:46,820 --> 00:35:49,630
That's a simple definition of decomposing documents
这是分解文档的简单定义

811
00:35:49,630 --> 00:35:51,289
into words.
变成文字。 

812
00:35:51,489 --> 00:35:53,239
And now we can think of about what--
现在我们可以考虑一下…… 

813
00:35:53,239 --> 00:35:55,339
I want to know whether D1 and D2 are similar.
我想知道D1和D2是否相似。 

814
00:35:55,340 --> 00:35:57,000
And I've thought about my document
我考虑过我的文件

815
00:35:57,000 --> 00:35:58,300
as a collection of words.
作为单词的集合。 

816
00:35:58,300 --> 00:36:02,539
Maybe they're similar if they share a lot of words in common.
如果他们有很多共同点，也许他们是相似的。 

817
00:36:02,539 --> 00:36:05,659
So that's the idea.
这就是想法。 

818
00:36:05,659 --> 00:36:11,549
Look at shared words and use that to define
查看共享词并用它来定义

819
00:36:11,550 --> 00:36:12,300
document distance.
文件距离。 

820
00:36:12,300 --> 00:36:14,614
This is obviously only one way to define distance.
显然，这只是定义距离的一种方法。 

821
00:36:14,614 --> 00:36:16,280
It'll be the way we do it in this class.
这将是我们在本课中做到的方式。 

822
00:36:16,280 --> 00:36:20,730
But there are lots of other possibilities.
但是还有许多其他可能性。 

823
00:36:20,730 --> 00:36:27,809
So I'm going to think of a document.
因此，我将考虑一个文档。 

824
00:36:27,809 --> 00:36:28,860
It's a sequence of words.
这是一个单词序列。 

825
00:36:28,860 --> 00:36:32,155
But I could also think of it as a vector.
但我也可以将其视为向量。 

826
00:36:32,155 --> 00:36:35,090



827
00:36:35,090 --> 00:36:41,329
So if I have a document D and I have a word W, this D of W
因此，如果我有一个文档D并且我有一个单词W，则W的这个D 

828
00:36:41,329 --> 00:36:43,929
is going to be the number of times
将是次数

829
00:36:43,929 --> 00:36:47,159
that word occurs in the document.
该单词出现在文档中。 

830
00:36:47,159 --> 00:36:52,259
So, number of recurrences W in the document D.
因此，文档D中的重复次数W。 

831
00:36:52,260 --> 00:36:52,940
So it's a number.
这是一个数字。 

832
00:36:53,139 --> 00:36:54,480
It's an integer.
这是一个整数。 

833
00:36:54,480 --> 00:36:56,510
Non-negative integer.
非负整数。 

834
00:36:56,510 --> 00:36:57,599
Could be 0.
可以为0。 

835
00:36:57,599 --> 00:36:57,940
Could be one.
可能是一个。 

836
00:36:58,139 --> 00:37:00,440
Could be a million.
可能是一百万。 

837
00:37:00,440 --> 00:37:03,210
I think of this as a giant vector.
我认为这是一个巨大的载体。 

838
00:37:03,210 --> 00:37:07,800
A vector is indexed by all words.
向量由所有单词索引。 

839
00:37:07,800 --> 00:37:10,110
And for each of them, there's some frequency.
对于每个人，都有一定的频率。 

840
00:37:10,110 --> 00:37:11,530
Of lot of them are zero.
其中许多为零。 

841
00:37:11,530 --> 00:37:16,106
And then some of them have some positive number occurrences.
然后其中一些出现了一些正数。 

842
00:37:16,106 --> 00:37:17,480
You could think of every document
您可以想到所有文件

843
00:37:17,480 --> 00:37:22,353
is as being one of these plots in this common axis.
就像是在此公共轴上的这些图之一。 

844
00:37:22,353 --> 00:37:24,019
There's infinitely many words down here.
这里有无数的词。 

845
00:37:24,019 --> 00:37:25,219
So it's kind of a big axis.
所以这是一个很大的轴。 

846
00:37:25,219 --> 00:37:27,599
But it's one way to draw the picture.
但这是绘制图片的一种方法。 

847
00:37:27,599 --> 00:37:36,420
OK, so for example, take two very important documents.
好的，例如，拿两个非常重要的文件。 

848
00:37:36,420 --> 00:37:38,269
Everybody likes cats and dogs.
每个人都喜欢猫和狗。 

849
00:37:38,269 --> 00:37:41,509
So these are two word documents.
因此，这是两个Word文档。 

850
00:37:41,510 --> 00:37:42,690
And so we can draw them.
这样我们就可以绘制它们。 

851
00:37:42,889 --> 00:37:44,888
Because there's only three different words here,
因为这里只有三个不同的词， 

852
00:37:44,889 --> 00:37:47,443
we can draw them in three dimensional space.
我们可以在三维空间中绘制它们。 

853
00:37:47,443 --> 00:37:49,110
Beyond that, it's a little hard to draw.
除此之外，还很难绘制。 

854
00:37:49,110 --> 00:37:53,010
So we have, let's say, which one's the-- let's say
所以我们可以说，这是- 

855
00:37:53,010 --> 00:37:56,550
this one's the-- makes it easier to draw.
这是-使绘制更容易。 

856
00:37:56,550 --> 00:38:00,150
So there's going to be just zero here and one.
因此，这里将只有零个，一个。 

857
00:38:00,349 --> 00:38:06,309
For each of the axes, let's say this is dog and this is cat.
对于每个轴，假设这是狗，这是猫。 

858
00:38:06,309 --> 00:38:10,509
OK, so the cat has won the-- it has one cat and no dog.
好吧，那只猫赢了，它只有一只猫，没有一只狗。 

859
00:38:10,510 --> 00:38:12,170
So it's here.
就在这里。 

860
00:38:12,170 --> 00:38:15,480
It's a vector pointing out there.
这是一个指向那里的向量。 

861
00:38:15,480 --> 00:38:20,992
The dog you've got basically pointing there.
你的狗基本上都指向那里。 

862
00:38:20,992 --> 00:38:22,000
OK, so these are two vectors.
好的，所以这是两个向量。 

863
00:38:22,199 --> 00:38:25,149



864
00:38:25,150 --> 00:38:27,639
So how do I measure how different two vectors are?
那么，如何测量两个向量有何不同？ 

865
00:38:27,639 --> 00:38:30,234
Any suggestions from vector calculus?
向量演算有什么建议吗？ 

866
00:38:30,235 --> 00:38:33,864



867
00:38:33,864 --> 00:38:35,559
AUDIENCE: Inner product?
听众：内在的产品？ 

868
00:38:35,559 --> 00:38:36,400
PROFESSOR: Inner product?
教授：内在产品？ 

869
00:38:36,599 --> 00:38:38,779
Yeah, that's good suggestion.
是的，这是个好建议。 

870
00:38:38,780 --> 00:38:41,550
Any others.
任何其他。 

871
00:38:41,550 --> 00:38:43,010
OK, we'll go with inner product.
好的，我们将使用内部产品。 

872
00:38:43,010 --> 00:38:48,389
I like inner product, also known as dot product.
我喜欢内部产品，也称为点产品。 

873
00:38:48,588 --> 00:38:49,630
Just define that quickly.
只需快速定义即可。 

874
00:38:49,630 --> 00:38:56,780



875
00:38:56,780 --> 00:38:58,590
So we could-- I'm going to call this D prime
所以我们可以-我将其称为D素数

876
00:38:58,789 --> 00:39:02,360
because it's not what we're going to end up with.
因为这不是我们要最终得到的。 

877
00:39:02,360 --> 00:39:05,960
We could think of this as the dot product of D1 and D2,
我们可以认为这是D1和D2的点积， 

878
00:39:06,159 --> 00:39:17,379
also known as the sum over all words of D1 of W times D2 of W.
也称为W的D1的所有字的总和乘以W的D2。 

879
00:39:17,380 --> 00:39:20,010
So for example, you take the dot product of these two guys.
因此，例如，您采用这两个家伙的点积。 

880
00:39:20,010 --> 00:39:21,340
Those match.
那些比赛。 

881
00:39:21,539 --> 00:39:27,940
So you get one point there, cat and dog multiplied by zero.
这样一来，猫和狗乘以零就可以得到1分。 

882
00:39:27,940 --> 00:39:30,599
So you don't get much there.
所以你在那里没有很多。 

883
00:39:30,599 --> 00:39:33,409
So this is some measure of distance.
所以这是一些距离的量度。 

884
00:39:33,409 --> 00:39:38,219
But it's a measure of, actually, of commonality.
但这实际上是对通用性的衡量。 

885
00:39:38,219 --> 00:39:41,159
So it would be sort of inverse distance, sorry.
抱歉，这将是反距离。 

886
00:39:41,159 --> 00:39:43,208
If you have a high dot product, you
如果您有高点产品，那么您

887
00:39:43,208 --> 00:39:44,500
have a lot of things in common.
有很多共同点。 

888
00:39:44,500 --> 00:39:46,210
Because a lot of these things didn't be--
因为很多事情不是- 

889
00:39:46,210 --> 00:39:47,840
wasn't zero times something.
不是零倍的东西。 

890
00:39:47,840 --> 00:39:50,460
It's actually a positive number times some positive number.
它实际上是一个正数乘以某个正数。 

891
00:39:50,460 --> 00:39:53,197
If you have a lot of shared words, than that looks good.
如果您有很多共同的词，那么看起来不错。 

892
00:39:53,197 --> 00:39:55,280
The trouble of this is if I have a long document--
问题是如果我的文档很长， 

893
00:39:55,280 --> 00:39:59,210
say, a million words-- and it's 99% in common
比方说一百万个字-共有99％ 

894
00:39:59,210 --> 00:40:02,760
with another document that's a million words long,
还有另一本长达一百万字的文档， 

895
00:40:02,760 --> 00:40:06,110
it's still-- it looks super similar.
它仍然-看起来超级相似。 

896
00:40:06,309 --> 00:40:08,969
Actually, I need to do it the other way around.
实际上，我需要反过来做。 

897
00:40:08,969 --> 00:40:12,266
Let's say it's a million words long and half of the words
假设这是一百万个字，一半是字

898
00:40:12,266 --> 00:40:12,849
are in common.
是共同的。 

899
00:40:12,849 --> 00:40:15,190
So not that many, but a fair number.
因此，数量不多，但数量不多。 

900
00:40:15,190 --> 00:40:18,278
Then I have a score of like 500,000.
那我的分数大约是500,000。 

901
00:40:18,478 --> 00:40:21,019
And then I have two documents which are, say, 100 words long.
然后我有两个文档，比如说100个字长。 

902
00:40:21,019 --> 00:40:22,539
And they're identical.
它们是相同的。 

903
00:40:22,539 --> 00:40:25,670
Their score is maybe only 100.
他们的分数可能只有100。 

904
00:40:25,670 --> 00:40:27,309
So even though they're identical,
因此，即使它们相同， 

905
00:40:27,309 --> 00:40:29,170
it's not quite scale invariant.
它不是规模不变的。 

906
00:40:29,170 --> 00:40:31,630
So it's not quite a perfect measure.
因此，这并不是一个完美的措施。 

907
00:40:31,630 --> 00:40:33,240
Any suggestions for how to fix this?
有关如何解决此问题的任何建议？ 

908
00:40:33,240 --> 00:40:34,739
This, I think, is a little trickier.
我认为这有点棘手。 

909
00:40:34,739 --> 00:40:35,721
Yeah?
是啊

910
00:40:35,722 --> 00:40:37,639
AUDIENCE: Divide by the length of the vectors?
听众：除以向量的长度？ 

911
00:40:37,639 --> 00:40:39,596
PROFESSOR: Divide by the length of the vectors.
教授：除以向量的长度。 

912
00:40:39,596 --> 00:40:40,969
I think that's worth a pillow.
我认为这值得一个枕头。 

913
00:40:40,969 --> 00:40:43,279
Haven't done any pillows yet.
还没做枕头

914
00:40:43,280 --> 00:40:44,769
Sorry about that.
对于那个很抱歉。 

915
00:40:44,769 --> 00:40:47,550
So, divide by the length of vector.
因此，除以向量的长度。 

916
00:40:47,550 --> 00:40:49,447
That's good.
那很好。 

917
00:40:49,447 --> 00:40:51,030
I'm going to call this D double prime.
我将其称为D双素数。 

918
00:40:51,030 --> 00:40:54,190
Still not quite the right answer.
仍然不是很正确的答案。 

919
00:40:54,190 --> 00:40:56,039
Or not-- no, it's pretty good.
还是不-不，这很好。 

920
00:40:56,239 --> 00:40:58,059
It's pretty good.
这是相当不错。 

921
00:40:58,059 --> 00:40:59,960
So here, the length of the vectors
所以在这里，向量的长度

922
00:40:59,960 --> 00:41:02,030
is the number of words that occur
是出现的单词数

923
00:41:02,030 --> 00:41:06,610
in them This is pretty cool.
在他们那里，这很酷。 

924
00:41:06,610 --> 00:41:10,610
But does anyone recognize this formula?
但是有人知道这个公式吗？ 

925
00:41:10,610 --> 00:41:12,000
Angle, yeah.
角度，是的。 

926
00:41:12,199 --> 00:41:14,649
It's a lot like the angle between the two vectors.
这很像两个向量之间的角度。 

927
00:41:14,650 --> 00:41:18,670
It's just off by an arc cos.
刚刚被电弧cos关闭。 

928
00:41:18,670 --> 00:41:21,028
This is the cosine of the angle between the two vectors.
这是两个向量之间夹角的余弦。 

929
00:41:21,228 --> 00:41:22,019
And I'm a geometer.
我是几何学家。 

930
00:41:22,019 --> 00:41:23,019
I like geometry.
我喜欢几何。 

931
00:41:23,019 --> 00:41:25,110
So if you take arc cos of that thing,
所以，如果你把那个东西当作反角， 

932
00:41:25,110 --> 00:41:27,519
that's a well established distance metric.
这是一个公认的距离指标。 

933
00:41:27,519 --> 00:41:32,210
This goes back to '75, if you can believe it,
如果可以相信的话，可以追溯到75年

934
00:41:32,210 --> 00:41:34,849
back when people-- early days of document, information
回到人们-文件，信息的早期

935
00:41:34,849 --> 00:41:37,585
retrieval, way before the web, people
检索，网络之前的人们

936
00:41:37,585 --> 00:41:40,670
were still working on this stuff.
仍在研究这些东西。 

937
00:41:40,670 --> 00:41:43,789
So it's a natural measure of the angle between the two vectors.
因此，这是两个向量之间夹角的自然度量。 

938
00:41:43,989 --> 00:41:46,689
If it's 0, they're basically identical.
如果为0，则基本上相同。 

939
00:41:46,690 --> 00:41:49,670
If it's 90 degrees, they're really, really different.
如果是90度，它们的确非常不同。 

940
00:41:49,670 --> 00:41:53,030
And so that gives you a nice way to compute document distance.
这样就为您提供了一种计算文档距离的好方法。 

941
00:41:53,030 --> 00:41:55,670
The question is, how do we actually compute that measure?
问题是，我们如何实际计算该度量？ 

942
00:41:55,670 --> 00:41:58,019
Now that we've come up with something that's reasonable,
现在我们提出了合理的东西， 

943
00:41:58,019 --> 00:42:00,460
how do I actually find this value?
我实际上如何找到该值？ 

944
00:42:00,460 --> 00:42:03,929
I need to compute these vectors-- the number
我需要计算这些向量-数字

945
00:42:03,929 --> 00:42:06,500
of recurrences of each word in the document.
文档中每个单词的重复出现次数。 

946
00:42:06,500 --> 00:42:08,817
And I need you compute the dot product.
我需要您计算点积。 

947
00:42:08,817 --> 00:42:09,900
And then I need to divide.
然后我需要分开。 

948
00:42:09,900 --> 00:42:10,490
That's really easy.
真的很简单。 

949
00:42:10,690 --> 00:42:13,259
So, dot product-- and I also need
所以，点积-我也需要

950
00:42:13,260 --> 00:42:15,610
to decompose a document to a list of words.
将文档分解为单词列表。 

951
00:42:15,610 --> 00:42:17,492
So there are three things I need to do.
因此，我需要做三件事。 

952
00:42:17,492 --> 00:42:18,250
Let me write them down.
让我写下来。 

953
00:42:18,449 --> 00:42:30,416



954
00:42:30,416 --> 00:42:31,375
So a sort of algorithm.
所以是一种算法。 

955
00:42:31,375 --> 00:42:36,579



956
00:42:36,579 --> 00:42:42,744
There's one, split a document into words.
有一个，将文档拆分为单词。 

957
00:42:42,744 --> 00:42:46,130



958
00:42:46,130 --> 00:42:51,039
Second is compute word frequencies,
其次是计算单词频率

959
00:42:51,039 --> 00:42:54,079
how many times each word appears.
每个单词出现多少次。 

960
00:42:54,079 --> 00:42:55,860
This is the document vectors .
这是文档向量。 

961
00:42:55,860 --> 00:42:58,380



962
00:42:58,380 --> 00:43:02,019
And then the third step is to compute the dot product.
然后第三步是计算点积。 

963
00:43:02,019 --> 00:43:07,123



964
00:43:07,123 --> 00:43:09,289
Let me tell you a little bit about how each of those
让我告诉您一些有关

965
00:43:09,289 --> 00:43:10,690
is done.
已经完成了。 

966
00:43:10,690 --> 00:43:14,860
Some of these will be covered more in future lectures.
其中一些将在以后的讲座中介绍。 

967
00:43:14,860 --> 00:43:16,980
I want to give you an overview.
我想给你一个概述。 

968
00:43:16,980 --> 00:43:19,800
There's a lot of ways to do each of these steps.
有很多方法可以执行这些步骤。 

969
00:43:19,800 --> 00:43:21,900
If you look at the-- next to the lecture
如果您查看讲座旁边的- 

970
00:43:21,900 --> 00:43:25,309
notes for this lecture two, there's a bunch of code
关于本讲座二的注释，有一堆代码

971
00:43:25,309 --> 00:43:28,639
and a bunch of data examples of documents--
和一堆文件的数据示例- 

972
00:43:28,639 --> 00:43:30,529
big corpuses of text.
大文本语料库。 

973
00:43:30,530 --> 00:43:32,070
And you can run, I think, there are
我想你可以跑步

974
00:43:32,070 --> 00:43:34,760
eight different algorithms for it.
八个不同的算法。 

975
00:43:34,760 --> 00:43:37,010
And let me give you-- actually, why don't I
让我给你-实际上，我为什么不

976
00:43:37,010 --> 00:43:38,860
cut to the chase a little bit and tell you
切入正题然后告诉你

977
00:43:39,059 --> 00:43:42,429
about the run times of these different implementations
关于这些不同实现的运行时间

978
00:43:42,429 --> 00:43:43,431
of this same algorithms.
同样的算法

979
00:43:43,431 --> 00:43:45,637
There are lots of sort of versions of this algorithm.
此算法有多种版本。 

980
00:43:45,637 --> 00:43:46,909
We implement it a whole bunch.
我们实施了很多。 

981
00:43:46,909 --> 00:43:49,849
Every semester I teach this, I change them a little bit more,
我每学一个学期都会对此进行一些修改， 

982
00:43:49,849 --> 00:43:51,969
add a few more variants.
添加更多变体。 

983
00:43:51,969 --> 00:43:55,259
So version one, on a particular pair
所以在特定的一对上

984
00:43:55,260 --> 00:44:00,500
of documents which is like a megabyte-- not very much text--
像兆字节的文档-文本不多- 

985
00:44:00,699 --> 00:44:05,460
it takes 228.1 seconds-- super slow.
需要228.1秒-超级慢。 

986
00:44:05,460 --> 00:44:06,789
Pathetic.
可悲的。 

987
00:44:06,789 --> 00:44:09,409
Then we do a little bit of algorithmic tweaking.
然后，我们进行一些算法调整。 

988
00:44:09,409 --> 00:44:11,779
We get down to 164 seconds.
我们下降到164秒。 

989
00:44:11,780 --> 00:44:14,539
Then we get to 123 seconds.
然后我们到达123秒。 

990
00:44:14,739 --> 00:44:17,339
Then we get down to 71 seconds.
然后我们下降到71秒。 

991
00:44:17,340 --> 00:44:21,460
Then we get down to 18.3 seconds.
然后我们下降到18.3秒。 

992
00:44:21,460 --> 00:44:25,130
And then we get to 11.5 seconds.
然后我们到达11.5秒。 

993
00:44:25,130 --> 00:44:28,269
Then we get to 1.8 seconds.
然后我们到达1.8秒。 

994
00:44:28,269 --> 00:44:31,759
Then we get to 0.2 seconds.
然后我们到达0.2秒。 

995
00:44:31,760 --> 00:44:33,630
So factor of 1,000.
因此，系数为1,000。 

996
00:44:33,630 --> 00:44:36,530
This is just in Python.
这只是在Python中。 

997
00:44:36,530 --> 00:44:38,730
2/10 of a second to process a megabytes.
 2/10秒用于处理兆字节。 

998
00:44:38,730 --> 00:44:39,409
It's all right.
没关系。 

999
00:44:39,409 --> 00:44:40,750
It's getting reasonable.
越来越合理了。 

1000
00:44:40,750 --> 00:44:41,969
This is not so reasonable.
这不是那么合理。 

1001
00:44:41,969 --> 00:44:43,760
Some of these improvements are algorithmic.
其中一些改进是算法上的。 

1002
00:44:43,760 --> 00:44:46,300
Some of them are just better coding.
其中一些只是更好的编码。 

1003
00:44:46,300 --> 00:44:49,280
So there's improving the constant factors.
因此，不断改进的恒定因素。 

1004
00:44:49,280 --> 00:44:52,710
But if you look at larger and larger texts,
但是，如果您看越来越大的文字， 

1005
00:44:52,710 --> 00:44:54,210
this will become even more dramatic.
这将变得更加戏剧化。 

1006
00:44:54,210 --> 00:44:56,019
Because a lot of these were improvements
因为这些都是很多改进

1007
00:44:56,219 --> 00:44:59,789
from quadratic time algorithms to linear and log n algorithms.
从二次时间算法到线性和log n算法。 

1008
00:44:59,789 --> 00:45:02,431
And so for a megabyte, yeah, it's a reasonable improvement.
因此，对于一个兆字节，这是一个合理的改进。 

1009
00:45:02,431 --> 00:45:04,889
But if you look at a gigabyte, it'll be a huge improvement.
但是，如果您查看千兆字节，那将是一个巨大的进步。 

1010
00:45:04,889 --> 00:45:06,098
There will be no comparison.
不会有比较。 

1011
00:45:06,099 --> 00:45:07,440
In fact, there will be no comparison.
实际上，将没有任何比较。 

1012
00:45:07,639 --> 00:45:09,097
Because this one will never finish.
因为这个永远不会完成。 

1013
00:45:09,097 --> 00:45:11,329
So the reason I ran such a small example
所以我跑了一个小例子的原因

1014
00:45:11,329 --> 00:45:13,539
so I could have patience to wait for this one.
因此我可以耐心等待。 

1015
00:45:13,539 --> 00:45:17,050
But this one you could run on the bigger examples.
但是您可以使用更大的示例。 

1016
00:45:17,050 --> 00:45:22,289
All right, so where do I want to go from here?
好吧，那我想从这里去哪里呢？ 

1017
00:45:22,489 --> 00:45:24,379
Five minutes.
 5分钟。 

1018
00:45:24,380 --> 00:45:26,559
I want to tell you about some of those improvements
我想告诉你一些改进

1019
00:45:26,559 --> 00:45:29,380
and some of the algorithms here.
以及此处的一些算法。 

1020
00:45:29,380 --> 00:45:31,769
Let's start with this very simple one.
让我们从这个非常简单的例子开始。 

1021
00:45:31,769 --> 00:45:36,324
How would you split a document into words in Python?
您将如何用Python将文档拆分成单词？ 

1022
00:45:36,324 --> 00:45:36,824
Yeah?
是啊

1023
00:45:36,824 --> 00:45:38,279
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

1024
00:45:38,280 --> 00:45:40,735
Iterate through the document, [INAUDIBLE] the dictionary?
遍历文档，[听不清]字典？ 

1025
00:45:40,934 --> 00:45:42,559
PROFESSOR: Iterate through the-- that's
教授：遍历- 

1026
00:45:42,559 --> 00:45:44,489
actually how we do number two.
实际上我们该怎么做第二。 

1027
00:45:44,489 --> 00:45:46,899
OK, we can talk about that one.
好，我们可以谈一谈。 

1028
00:45:46,900 --> 00:45:52,019
Iterate through the words in the document
遍历文档中的单词

1029
00:45:52,219 --> 00:45:53,689
and put it in a dictionary.
并放入字典中

1030
00:45:53,690 --> 00:45:59,980
Let's say, count of word plus equals 1.
假设字数加等于1。 

1031
00:45:59,980 --> 00:46:02,320
This would work if count is something called a count
如果计数是所谓的计数，这将工作

1032
00:46:02,320 --> 00:46:05,440
dictionary if you're super Pythonista.
字典，如果您是超级Pythonista。 

1033
00:46:05,440 --> 00:46:07,940
Otherwise, you have to check, is the word in the dictionary?
否则，您必须检查一下，词典中的单词是吗？ 

1034
00:46:07,940 --> 00:46:09,610
If not, set it to one.
如果不是，请将其设置为1。 

1035
00:46:09,610 --> 00:46:12,259
If it is there, add one to it.
如果存在，则添加一个。 

1036
00:46:12,458 --> 00:46:14,000
But I think you know what this means.
但是我想你知道这意味着什么。 

1037
00:46:14,000 --> 00:46:15,858
This will count the number of words--
这将计算字数- 

1038
00:46:15,858 --> 00:46:18,400
this will count the frequency of each word in the dictionary.
这将计算字典中每个单词的频率。 

1039
00:46:18,400 --> 00:46:21,019
And becomes dictionaries run in constant time
并成为字典在恒定时间内运行

1040
00:46:21,019 --> 00:46:26,019
with high probability-- with high probability--
很有可能

1041
00:46:26,019 --> 00:46:31,170
this will take order-- well, cheating a little bit.
这需要命令-好吧，有点作弊。 

1042
00:46:31,170 --> 00:46:32,630
Because words can be really long.
因为言语可能真的很长。 

1043
00:46:32,630 --> 00:46:35,480
And so to reduce a word down to a machine word
这样就可以将单词简化为机器单词

1044
00:46:35,480 --> 00:46:38,809
could take order the length of the word time.
可以接受单词时间长度的排序。 

1045
00:46:38,809 --> 00:46:40,210
To a little more precise, this is
更确切地说，这是

1046
00:46:40,210 --> 00:46:41,626
going to be the sum of the lengths
将是长度的总和

1047
00:46:41,626 --> 00:46:45,800
of the words in the document, which is also
文档中的单词

1048
00:46:45,800 --> 00:46:48,264
known as a length of the document, basically.
基本上称为文档的长度。 

1049
00:46:48,463 --> 00:46:49,130
So this is good.
所以这很好。 

1050
00:46:49,130 --> 00:46:51,565
This is linear time with high probability.
这是线性时间，概率很高。 

1051
00:46:51,565 --> 00:46:54,500



1052
00:46:54,500 --> 00:46:55,769
OK, that's a good algorithm.
好的，这是一个很好的算法。 

1053
00:46:55,769 --> 00:47:02,389
That is introduced in algorithm four.
在算法四中介绍。 

1054
00:47:02,389 --> 00:47:04,626
So we got a significant boost.
因此，我们获得了巨大的推动。 

1055
00:47:04,626 --> 00:47:05,960
There are other ways to do this.
还有其他方法可以做到这一点。 

1056
00:47:05,960 --> 00:47:09,190
For example, you could sort the words
例如，您可以对单词进行排序

1057
00:47:09,190 --> 00:47:10,929
and then run through the sorted list
然后遍历排序列表

1058
00:47:10,929 --> 00:47:13,429
and count, how many do you get in a row for each one?
算一下，您每个人连续得到多少？ 

1059
00:47:13,429 --> 00:47:15,924
If it's sorted, you can count-- I mean,
如果排序的话，您可以数-我是说， 

1060
00:47:15,925 --> 00:47:18,300
all the identical words are put right next to each other.
所有相同的词都紧挨着放置。 

1061
00:47:18,300 --> 00:47:19,800
So it's easy to count them.
因此很容易计算它们。 

1062
00:47:19,800 --> 00:47:21,110
And that'll run almost as fast.
而且运行速度几乎一样快。 

1063
00:47:21,309 --> 00:47:22,690
That was one of these algorithms.
那是这些算法之一。 

1064
00:47:22,690 --> 00:47:26,269



1065
00:47:26,469 --> 00:47:29,349
OK, so that's a couple different ways to do that.
好的，这是几种不同的方法。 

1066
00:47:29,349 --> 00:47:30,739
Let's go back to this first step.
让我们回到第一步。 

1067
00:47:30,739 --> 00:47:33,784
How would you split a document into words in the first place?
首先如何将文档拆分为单词？ 

1068
00:47:33,784 --> 00:47:34,283
Yeah?
是啊

1069
00:47:34,284 --> 00:47:36,617
AUDIENCE: Search circulated spaces and then [INAUDIBLE].
听众：搜索循环的空格，然后搜索[听不清]。 

1070
00:47:36,617 --> 00:47:39,150
PROFESSOR: Run through though the string.
教授：贯穿字符串。 

1071
00:47:39,150 --> 00:47:41,869
And every time you see anything that's not alphanumeric,
每次您看到非字母数字的内容时， 

1072
00:47:41,869 --> 00:47:43,250
start a new word.
开始一个新词。 

1073
00:47:43,250 --> 00:47:45,380
OK, that would run in linear time.
好的，那将在线性时间内运行。 

1074
00:47:45,380 --> 00:47:47,380
That's a good answer.
那是一个很好的答案。 

1075
00:47:47,380 --> 00:47:48,590
So it's not hard.
因此，这并不困难。 

1076
00:47:48,590 --> 00:47:54,210
If you're a fancy Pythonista, you might do it like this.
如果您是个喜欢Pythonista的人，可以这样做。 

1077
00:47:54,210 --> 00:48:01,429



1078
00:48:01,429 --> 00:48:02,484
Remember my Reg Exes.
记住我的Reg Exes。 

1079
00:48:02,485 --> 00:48:05,039



1080
00:48:05,039 --> 00:48:07,090
This will find all the words in a document.
这将找到文档中的所有单词。 

1081
00:48:07,090 --> 00:48:10,460
Trouble is, in general, re takes exponential time.
通常，麻烦是花费指数时间。 

1082
00:48:10,659 --> 00:48:14,259
So if you think about algorithms, be very careful.
因此，如果您考虑算法，请务必小心。 

1083
00:48:14,260 --> 00:48:16,010
Unless you know how re is implemented,
除非您知道如何实施re， 

1084
00:48:16,010 --> 00:48:19,800
this probably will run in linear time.
这可能会线性运行。 

1085
00:48:19,800 --> 00:48:22,000
But it's not obvious at all.
但这一点都不明显。 

1086
00:48:22,000 --> 00:48:24,210
Do anything fancy with regular expressions.
用正则表达式做任何花哨的事情。 

1087
00:48:24,210 --> 00:48:26,543
If you don't know what this means, don't worry about it.
如果您不知道这意味着什么，请不必担心。 

1088
00:48:26,543 --> 00:48:27,099
Don't use it.
不要使用它。 

1089
00:48:27,099 --> 00:48:28,989
If you know about it, be very careful in this class
如果您知道这一点，请在本节课中非常小心

1090
00:48:28,989 --> 00:48:29,655
when you use re.
当您使用re。 

1091
00:48:29,655 --> 00:48:31,663
Because it's not always linear time.
因为它并不总是线性时间。 

1092
00:48:31,664 --> 00:48:33,130
But there is an easy algorithm for this,
但这有一个简单的算法， 

1093
00:48:33,329 --> 00:48:38,074
which is just scan through and look for alpha numerics.
只是扫描并寻找字母数字。 

1094
00:48:38,074 --> 00:48:38,949
String them together.
将它们串在一起。 

1095
00:48:38,949 --> 00:48:39,448
It's good.
很好。 

1096
00:48:39,449 --> 00:48:41,530
There's a few other algorithms here in the notes.
注释中还有其他一些算法。 

1097
00:48:41,530 --> 00:48:42,670
You should check them out.
你应该检查出来。 

1098
00:48:42,670 --> 00:48:46,730
And for fun, look at this code and see how small differences
为了好玩，请看一下这段代码，看看有多么小的差异

1099
00:48:46,929 --> 00:48:49,190
make dramatic difference in performance.
在性能上产生巨大变化。 

1100
00:48:49,190 --> 00:48:54,190
Next class will be about sorting.
下一堂课是关于排序的。 

