1
00:00:00,000 --> 00:00:00,060



2
00:00:00,060 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,330
To make a donation, or view additional materials
捐款或查看其他材料

7
00:00:13,330 --> 00:00:17,207
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,207 --> 00:00:17,832
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,832 --> 00:00:22,242



10
00:00:22,242 --> 00:00:23,449
PROFESSOR: Thanks for coming.
教授：谢谢您的光临。 

11
00:00:23,449 --> 00:00:25,489
I know there's a problem set due.
我知道有一个问题要解决。 

12
00:00:25,489 --> 00:00:27,889
There's a quiz coming up on Thursday.
星期四有一个测验。 

13
00:00:27,890 --> 00:00:30,910
We won't have lecture on Thursday.
我们星期四不上课。 

14
00:00:30,910 --> 00:00:35,490
But we will have a quiz in the evening.
但是晚上我们会进行测验。 

15
00:00:35,490 --> 00:00:38,750
And there will be a recitation section tomorrow,
明天将有一个朗诵课， 

16
00:00:38,750 --> 00:00:41,899
which will be a quiz review.
这将是一个测验评论。 

17
00:00:41,899 --> 00:00:47,219
So, today's lecture is the last of the lectures in the shortest
所以，今天的讲座是最短的讲座的最后

18
00:00:47,219 --> 00:00:48,719
path module.
路径模块。 

19
00:00:48,719 --> 00:00:53,019
And, unlike previous lectures, we're
而且，与之前的讲座不同，我们

20
00:00:53,020 --> 00:00:57,099
going to be talking about optimizations that don't change
将要谈论的是不变的优化

21
00:00:57,299 --> 00:01:00,669
the worst case, or asymptotic, complexity.
最坏的情况，即渐近复杂性。 

22
00:01:00,670 --> 00:01:05,890
But improve empirical, real life performance.
但是要提高经验，现实生活的表现。 

23
00:01:05,890 --> 00:01:09,579
Or potentially, and we can't prove this, but performance
或潜在地，我们无法证明这一点，但是性能

24
00:01:09,579 --> 00:01:11,640
in the average case.
在一般情况下。 

25
00:01:11,640 --> 00:01:15,549
And so we look at a couple of examples.
因此，我们来看几个示例。 

26
00:01:15,549 --> 00:01:18,450
The first one you've already done.
您已经完成的第一个。 

27
00:01:18,450 --> 00:01:21,969
You can optimize Dijkstra when you're
您可以在需要时优化Dijkstra 

28
00:01:21,969 --> 00:01:25,000
looking for a single target.
寻找一个目标。 

29
00:01:25,000 --> 00:01:28,609
So, implicitly, we've assumed that we're
因此，隐式地，我们假设我们

30
00:01:28,609 --> 00:01:39,900
solving the single source, any or all destination problem,
解决单一来源，任何或所有目的地问题， 

31
00:01:39,900 --> 00:01:42,650
when we've looked at the original Dijkstra
当我们看原始的Dijkstra时

32
00:01:42,650 --> 00:01:46,819
algorithm, and the Bellman-Ford algorithm.
算法和Bellman-Ford算法。 

33
00:01:47,019 --> 00:01:51,099
Many a time, you're going to have a source, s.
很多时候，您将拥有一个来源。 

34
00:01:51,099 --> 00:01:53,500
And you want to find the shortest path
而您想找到最短的路径

35
00:01:53,500 --> 00:01:55,859
to a specific destination, t.
到特定的目的地，t。 

36
00:01:55,859 --> 00:01:57,670
And you're doing this in your problem set.
您正在问题集中进行此操作。 

37
00:01:57,670 --> 00:01:59,799
And you can do some optimization.
您可以进行一些优化。 

38
00:01:59,799 --> 00:02:02,609
It doesn't change the worst case complexity.
它不会改变最坏情况下的复杂性。 

39
00:02:02,609 --> 00:02:05,209
But it reduces runtime.
但是它减少了运行时间。 

40
00:02:05,209 --> 00:02:06,989
And then you have a specific target.
然后您有一个特定的目标。 

41
00:02:06,989 --> 00:02:09,240
Especially if the target is close to you.
特别是如果目标离您很近。 

42
00:02:09,240 --> 00:02:11,969
And you don't have to traverse the entire graph.
而且您不必遍历整个图形。 

43
00:02:12,169 --> 00:02:14,399
Obviously, the algorithm has to prove
显然，该算法必须证明

44
00:02:14,400 --> 00:02:16,650
that the particular path that was chosen
选择的特定路径

45
00:02:16,650 --> 00:02:19,210
is, in fact, the shortest path from s to t.
实际上是从s到t的最短路径。 

46
00:02:19,210 --> 00:02:21,349
But it's a fairly straightforward modification.
但这是一个相当简单的修改。 

47
00:02:21,349 --> 00:02:23,099
And I will go over it, but you're actually
我会仔细研究，但实际上

48
00:02:23,099 --> 00:02:26,037
implementing it in PS 6.
在PS 6中实施。 

49
00:02:26,037 --> 00:02:27,620
We talked about bi-directional search.
我们讨论了双向搜索。 

50
00:02:27,620 --> 00:02:30,000
Again, something you're doing from a standpoint
同样，从立场上讲，您正在做的事情

51
00:02:30,000 --> 00:02:32,330
of breadth-first search.
广度优先搜索。 

52
00:02:32,330 --> 00:02:38,860
How can you get from one source to a destination,
您如何从一个来源到达目的地， 

53
00:02:38,860 --> 00:02:41,650
by doing bi-directional Dijkstra?
通过做双向Dijkstra？ 

54
00:02:41,650 --> 00:02:45,900
And you can think of this as a frontier off shortest paths
您可以将其视为最短路径的前沿

55
00:02:45,900 --> 00:02:50,500
is being constructed from the source, s, forward.
正在从源s向前构建。 

56
00:02:50,699 --> 00:02:55,469
And this backward frontier, you're falling edges backward,
而在这个向后的边界，您正在向后退边， 

57
00:02:55,469 --> 00:02:58,159
is being constructed from the destination.
正在从目的地构建。 

58
00:02:58,159 --> 00:03:01,280
And, effectively, when these two frontiers meet,
而且，有效地，当这两个领域相遇时， 

59
00:03:01,280 --> 00:03:04,379
you're going to be able to discover shortest paths.
您将能够发现最短的路径。 

60
00:03:04,379 --> 00:03:06,870
And, it turns out, it's not as simple as what I just
而且事实证明，这不像我刚才那么简单

61
00:03:06,870 --> 00:03:07,373
described.
描述。 

62
00:03:07,373 --> 00:03:09,789
And so we'll have to look at that a little more carefully.
因此，我们将不得不更加仔细地研究它。 

63
00:03:09,789 --> 00:03:13,349



64
00:03:13,349 --> 00:03:16,739
So that is our single source, single target problem.
这就是我们的单一来源，单一目标问题。 

65
00:03:16,740 --> 00:03:19,280
We won't cover this in 006.
我们不会在006中介绍。 

66
00:03:19,280 --> 00:03:26,050
But there's also this notion of all pairs shortest paths, which
但也有所有对最短路径的概念， 

67
00:03:26,050 --> 00:03:28,520
is something that 6046 covers.
是6046涵盖的内容。 

68
00:03:28,520 --> 00:03:30,800
And that is something that says, well, I
那就是说，嗯，我

69
00:03:30,800 --> 00:03:32,219
don't know what the source is.
不知道来源是什么。 

70
00:03:32,419 --> 00:03:34,329
I don't know what the destination is.
我不知道目的地是什么。 

71
00:03:34,330 --> 00:03:38,150
For any pair of vertices, find me the shortest path
对于任何一对顶点，找到我的最短路径

72
00:03:38,349 --> 00:03:42,120
from s to t, given that pair.
给定那对，从s到t 

73
00:03:42,120 --> 00:03:44,300
And so that, of course, is more work
因此，这当然是更多的工作

74
00:03:44,300 --> 00:03:47,120
than even the single source, all destination problem
甚至比单一来源，所有目的地问题

75
00:03:47,319 --> 00:03:49,849
because you're varying the source.
因为您在改变来源。 

76
00:03:49,849 --> 00:03:50,479
All right?
好吧？ 

77
00:03:50,479 --> 00:03:55,079
So those are the three different shortest path problems.
因此，这是三个不同的最短路径问题。 

78
00:03:55,080 --> 00:03:57,469
And we've looked at that.
我们已经看过了。 

79
00:03:57,469 --> 00:04:00,359
And we're going to look at this today.
我们今天要看一下。 

80
00:04:00,360 --> 00:04:03,210
And we looked at it in the problem set.
我们在问题集中对其进行了研究。 

81
00:04:03,210 --> 00:04:07,409
But we'll spend time, specifically on this one.
但是我们会花时间，特别是在这上面。 

82
00:04:07,409 --> 00:04:11,799
And try and see if we can do some coding optimizations,
并尝试看看我们是否可以进行一些编码优化， 

83
00:04:11,800 --> 00:04:14,430
if you will, to improve run time.
如果可以的话，可以缩短运行时间。 

84
00:04:14,430 --> 00:04:14,930
All right?
好吧？ 

85
00:04:14,930 --> 00:04:18,250
So, I emphasize that worst case complexity
因此，我强调最坏情况下的复杂性

86
00:04:18,250 --> 00:04:22,019
is unchanged for all of the Dijkstra versions
对于所有Dijkstra版本均未更改

87
00:04:22,019 --> 00:04:24,889
that we'll be looking at today.
我们今天要看的。 

88
00:04:25,089 --> 00:04:31,519
So I want to put up a pseudocode that you've written code
所以我想写一个你写过的伪代码

89
00:04:31,519 --> 00:04:34,930
for at this point, which is the Dijkstra pseudocode.
此时，这是Dijkstra伪代码。 

90
00:04:34,930 --> 00:04:41,959
Because we'll take a look at it, and modify it, and execute it.
因为我们将对其进行查看，修改和执行。 

91
00:04:41,959 --> 00:04:46,649
So you have your set of vertices that you
因此，您拥有一组顶点

92
00:04:46,649 --> 00:04:48,539
don't know the shortest paths to.
不知道到达的最短路径。 

93
00:04:48,540 --> 00:04:53,889
So we do have initialize is going to set d of s to be 0.
所以我们确实有将s的d设置为0的初始化。 

94
00:04:54,089 --> 00:04:59,119
And b of u, not equal to s, to be infinity.
 u的b不等于s为无穷大。 

95
00:04:59,120 --> 00:05:03,980
And we have this set, Q, that we're
我们有这个问题Q 

96
00:05:03,980 --> 00:05:11,500
going to process and continually extract the minimum priority
进行处理并不断提取最低优先级

97
00:05:11,500 --> 00:05:17,439
from Q. And, once we do that, we actually
来自Q。一旦完成，我们实际上

98
00:05:17,439 --> 00:05:21,920
know the shortest path to you already.
已经知道通往您的最短路径。 

99
00:05:21,920 --> 00:05:26,490
That's what the Dijkstra invariant is.
这就是Dijkstra不变式。 

100
00:05:26,490 --> 00:05:32,250
And the process of extracting u implies
提取u的过程意味着

101
00:05:32,250 --> 00:05:35,920
that we have to do a relaxation step that
我们必须放松一下

102
00:05:35,920 --> 00:05:37,889
updates the priorities.
更新优先级。 

103
00:05:38,089 --> 00:05:42,159
And also modifies the parent pointers.
并且还修改了父指针。 

104
00:05:42,160 --> 00:05:48,355
So there's also the pi of v that is set to u.
因此，还有v的pi设置为u。 

105
00:05:48,355 --> 00:05:52,660



106
00:05:52,660 --> 00:05:58,000
As well as d of v getting decremented.
以及v的d递减。 

107
00:05:58,199 --> 00:05:59,170
OK?
好？ 

108
00:05:59,170 --> 00:06:01,379
So that's the Dijkstra algorithm.
这就是Dijkstra算法。 

109
00:06:01,579 --> 00:06:03,889
And one of the things that we can do,
我们可以做的一件事， 

110
00:06:03,889 --> 00:06:07,269
the straightforward thing, which is one line of code literally,
直截了当的事情，从字面上看是一行代码， 

111
00:06:07,269 --> 00:06:12,819
is to say that, if you know what the single target is, then
就是说，如果您知道单个目标是什么，那么

112
00:06:12,819 --> 00:06:19,189
you simply stop if u equals t.
您只要u等于t就停止。 

113
00:06:19,189 --> 00:06:25,899
So no need to stop when Q becomes null.
因此，当Q变为空时，无需停止。 

114
00:06:25,899 --> 00:06:28,659
Or, you don't get to the point where Q is null.
否则，您将无法达到Q为零的地步。 

115
00:06:28,660 --> 00:06:36,220
You stop when you've lifted off the y vertex from Q. All right?
从Q离开y顶点时，您会停下来。好吗？ 

116
00:06:36,220 --> 00:06:38,490
And so, obviously, this will run faster,
因此，显然，这将运行得更快， 

117
00:06:38,689 --> 00:06:43,870
assuming this check is a 0 time check.
假设此检查是0次检查。 

118
00:06:43,870 --> 00:06:45,930
And that's really one instruction,
那真的是一条指令， 

119
00:06:45,930 --> 00:06:49,139
so you can think of it that way.
所以你可以这样想。 

120
00:06:49,139 --> 00:06:55,219
And you will, basically, run faster for sure,
基本上，您可以肯定会更快地运行， 

121
00:06:55,220 --> 00:06:56,870
when you have a specific target.
当您有特定目标时。 

122
00:06:57,069 --> 00:07:00,099
It may be the case that your target is the last vertex
您的目标可能是最后一个顶点

123
00:07:00,100 --> 00:07:00,889
that you find.
你发现的。 

124
00:07:01,089 --> 00:07:05,179
And in that case, you run no slower.
在这种情况下，您的运行速度不会变慢。 

125
00:07:05,180 --> 00:07:06,129
All right?
好吧？ 

126
00:07:06,129 --> 00:07:09,719
So that's something that you looked at.
这就是您所看的东西。 

127
00:07:09,720 --> 00:07:16,430
And that takes care of the first optimization corresponding
并负责相应的第一个优化

128
00:07:16,430 --> 00:07:18,305
to single source, single target.
单一来源，单一目标。 

129
00:07:18,305 --> 00:07:19,680
Let's talk about something that's
让我们谈谈

130
00:07:19,680 --> 00:07:25,389
a little more interesting, and non-obvious,
更加有趣，而且不明显， 

131
00:07:25,589 --> 00:07:27,464
which is the notion of bi-directional search.
这是双向搜索的概念。 

132
00:07:27,464 --> 00:07:30,259



133
00:07:30,259 --> 00:07:36,800
And, in bi-directional search, we have s.
并且，在双向搜索中，我们有。 

134
00:07:36,800 --> 00:07:39,930
And we have t.
我们有。 

135
00:07:39,930 --> 00:07:48,170
And we have a bunch of nodes in between,
我们之间有一堆节点， 

136
00:07:48,170 --> 00:07:56,670
corresponding to this graph here.
与此图相对应。 

137
00:07:56,670 --> 00:08:01,540
And what you do is, you alternate search
而您要做的是，您交替搜索

138
00:08:01,540 --> 00:08:06,939
in the forward direction and backward direction.
在前进方向和后退方向。 

139
00:08:06,939 --> 00:08:15,550
So, you're going to do one step of Dijkstra, standard Dijkstra
因此，您将要执行Dijkstra（标准Dijkstra）的一个步骤

140
00:08:15,550 --> 00:08:19,060
that starts with s.
以s开头。 

141
00:08:19,060 --> 00:08:21,360
And goes forward.
并前进。 

142
00:08:21,360 --> 00:08:23,389
And so, you could imagine that you're forward
因此，您可以想象自己正在前进

143
00:08:23,589 --> 00:08:30,409
search in the first step, you're going to pick the vertex, s,
在第一步中进行搜索，您将选择顶点s， 

144
00:08:30,410 --> 00:08:34,000
off of Q. And you're going to process
 Q。然后您将要处理

145
00:08:34,000 --> 00:08:36,470
the edges that come out of s.
 s产生的边缘。 

146
00:08:36,470 --> 00:08:39,009
And that would correspond with these two edges.
那将与这两个边缘相对应。 

147
00:08:39,009 --> 00:08:43,480
And so that's one step of forward search, going forward.
因此，这是向前搜索，向前迈出的一步。 

148
00:08:43,480 --> 00:08:46,860
And then you stop with the forward search,
然后停止前进搜索， 

149
00:08:46,860 --> 00:08:50,169
and you do a step of backward search.
然后您进行了向后搜索。 

150
00:08:50,169 --> 00:08:52,870
And so, you go backward search, and I'll
因此，您进行向后搜索，我会

151
00:08:52,870 --> 00:08:58,917
explain exactly what this means, backward search from t.
从t向后搜索，确切解释这意味着什么。 

152
00:08:58,917 --> 00:09:00,500
And the important thing is that you're
重要的是你

153
00:09:00,500 --> 00:09:05,379
following edges backward.
跟随边缘向后。 

154
00:09:05,379 --> 00:09:08,960
So that means your data structure
因此，这意味着您的数据结构

155
00:09:08,960 --> 00:09:12,070
has to, essentially, have these edges that can be traversed
本质上必须具有这些可以遍历的边缘

156
00:09:12,070 --> 00:09:15,339
in either the forward direction, or the reverse direction.
正向或反向。 

157
00:09:15,539 --> 00:09:17,099
So that's something to keep in mind.
所以这是要牢记的。 

158
00:09:17,100 --> 00:09:18,580
But what will happen here is simply
但是这里会发生的只是

159
00:09:18,580 --> 00:09:24,750
that your first frontier of backward search,
您的反向搜索的第一个领域， 

160
00:09:24,750 --> 00:09:30,360
t now, in the backward search, is the minimum priority.
现在，在向后搜索中，t是最小优先级。 

161
00:09:30,360 --> 00:09:32,859
So , we're going to have to have two priorities corresponding
因此，我们将必须有两个优先级对应

162
00:09:33,059 --> 00:09:37,589
to s in the fourth search, where that's a straightforward one.
到第四搜索中，这很简单。 

163
00:09:37,590 --> 00:09:39,629
v of s equals 0.
 s的v等于0。 

164
00:09:39,629 --> 00:09:46,210
And we should think of it as d of f s equals 0.
我们应该将其视为fs的d等于0。 

165
00:09:46,210 --> 00:09:52,109
And we have d of b t equals 0.
并且bt的d等于0。 

166
00:09:52,309 --> 00:09:54,750
And these subscripts correspond to these two
这些下标对应于这两个

167
00:09:54,750 --> 00:09:56,370
different priorities.
不同的优先级。 

168
00:09:56,370 --> 00:10:00,240
And it's exactly complimentary.
而且完全是免费的。 

169
00:10:00,240 --> 00:10:02,610
Only the source, s, in the forward search,
在前向搜索中，只有源s 

170
00:10:02,610 --> 00:10:04,889
has 0 priority in the beginning.
开头的优先级为0。 

171
00:10:04,889 --> 00:10:08,189
Everything else has infinite priority.
其他所有事物都有无限的优先权。 

172
00:10:08,190 --> 00:10:13,230
Only the target, or destination, has
只有目标或目的地具有

173
00:10:13,230 --> 00:10:15,529
0 priority in the backward search.
向后搜索优先级为0。 

174
00:10:15,529 --> 00:10:17,709
Everything else is infinity.
其他一切都是无限的。 

175
00:10:17,710 --> 00:10:22,480
And you go forward, backward, forward, backward.
然后您前进，后退，前进，后退。 

176
00:10:22,480 --> 00:10:23,539
And so on.
等等。 

177
00:10:23,539 --> 00:10:25,599
And the question is, when do you stop?
问题是，什么时候停止？ 

178
00:10:25,600 --> 00:10:26,979
And we have to talk about that.
我们必须谈论这一点。 

179
00:10:27,179 --> 00:10:30,229
And, it turns out, it's not a perfectly straightforward
而且，事实证明，这并非完全简单

180
00:10:30,230 --> 00:10:31,480
stopping condition.
停止条件。 

181
00:10:31,480 --> 00:10:34,269
But it's something that will make sense, hopefully,
但这是有意义的，希望， 

182
00:10:34,269 --> 00:10:36,980
when I get around to describing it.
当我开始描述它时。 

183
00:10:36,980 --> 00:10:41,769
But, having said all that, let's just
但是，说了这么多，让我们

184
00:10:41,769 --> 00:10:45,769
put down all of the different data structures
放下所有不同的数据结构

185
00:10:45,769 --> 00:10:47,490
that we have to have.
我们必须拥有的。 

186
00:10:47,490 --> 00:10:49,899
And it's kind of a doubling of the data structure,
这是数据结构的两倍， 

187
00:10:49,899 --> 00:10:52,529
right, because just like I double the priorities,
是的，因为就像我将优先级加倍一样， 

188
00:10:52,529 --> 00:10:54,649
I also need two different min priority
我还需要两个不同的最小优先级

189
00:10:54,649 --> 00:10:58,750
queues, corresponding to Q f and Q b.
队列，对应于Q f和Q b。 

190
00:10:58,750 --> 00:11:01,009
And, as I said before, these edges
而且，正如我之前所说，这些优势

191
00:11:01,009 --> 00:11:04,090
have to be traversable in the backward direction.
必须在反向方向上遍历。 

192
00:11:04,090 --> 00:11:07,250
So this edge, in the graph, goes this way.
因此，图中的这一边沿这种方式移动。 

193
00:11:07,250 --> 00:11:09,590
But you're going in the backward direction,
但是你在往后走， 

194
00:11:09,590 --> 00:11:12,360
as you are growing your backward frontier.
随着您不断发展落后领域。 

195
00:11:12,360 --> 00:11:13,789
OK?
好？ 

196
00:11:13,789 --> 00:11:15,759
That's important to understand.
了解这一点很重要。 

197
00:11:15,759 --> 00:11:21,269
So let me put down all of the specifics associated
所以让我放下所有相关的细节

198
00:11:21,269 --> 00:11:23,639
with these data structures.
这些数据结构。 

199
00:11:23,639 --> 00:11:29,789
df u correspond to the distances for the forward search.
 df u对应于向前搜索的距离。 

200
00:11:29,789 --> 00:11:33,769



201
00:11:33,769 --> 00:11:39,389
And db u correspond to the distances
和db u对应于距离

202
00:11:39,389 --> 00:11:40,394
for the backward search.
用于向后搜索。 

203
00:11:40,394 --> 00:11:43,528



204
00:11:43,528 --> 00:11:44,840
OK?
好？ 

205
00:11:44,840 --> 00:11:47,190
And, of course, we're going to have
而且，当然，我们将拥有

206
00:11:47,190 --> 00:11:58,500
to have priority queues, plural.
具有多个优先级队列。 

207
00:11:58,500 --> 00:12:03,649
Qf corresponding to the forward search.
 Qf对应于正向搜索。 

208
00:12:03,649 --> 00:12:08,230
And Qb corresponding to the backward search.
与Qb相对应的向后搜索。 

209
00:12:08,230 --> 00:12:10,960
And in initialize, as I said before,
正如我之前所说，在初始化中

210
00:12:10,960 --> 00:12:14,940
we're going to initialize df s to be 0 and db t equals 0.
我们将df初始化为0，而db t等于0。 

211
00:12:14,940 --> 00:12:18,000
And then everything, the df's and the db's, are
然后，df和db的所有内容

212
00:12:18,000 --> 00:12:19,419
going to be infinity.
将无限。 

213
00:12:19,419 --> 00:12:21,129
All right?
好吧？ 

214
00:12:21,129 --> 00:12:21,629
OK.
好。 

215
00:12:21,629 --> 00:12:22,480
Great.
大。 

216
00:12:22,480 --> 00:12:24,759
So that's what we have here.
这就是我们在这里所拥有的。 

217
00:12:24,759 --> 00:12:27,085
Now, first question.
现在，第一个问题。 

218
00:12:27,085 --> 00:12:40,230



219
00:12:40,230 --> 00:12:45,039
Roughly speaking, as I said, you can imagine intuitively
粗略地说，正如我所说，您可以凭直觉想象

220
00:12:45,039 --> 00:12:48,719
that you're going to terminate the search when
您将在以下情况下终止搜索

221
00:12:48,720 --> 00:12:50,830
these frontiers meet, OK?
这些边疆相遇，好吗？ 

222
00:12:51,030 --> 00:12:52,529
Clearly, you can't terminate it when
显然，您不能在以下情况下终止它

223
00:12:52,529 --> 00:12:56,459
these frontiers look like this, OK.
这些边界看起来像这样，好的。 

224
00:12:56,460 --> 00:13:00,579
So that's the intuition.
这就是直觉。 

225
00:13:00,779 --> 00:13:02,459
And you see that for the [INAUDIBLE]
您会看到[听不清] 

226
00:13:02,460 --> 00:13:04,849
first, as well, in your problem set.
首先，在您的问题集中。 

227
00:13:05,049 --> 00:13:09,370
But in the context of Dijkstra, single source, single target,
但是在Dijkstra的背景下，单一来源，单一目标， 

228
00:13:09,370 --> 00:13:12,450
can someone tell me what the termination condition
有人可以告诉我终止条件是什么

229
00:13:12,450 --> 00:13:15,729
should be by looking at the code?
应该通过看代码？ 

230
00:13:15,929 --> 00:13:19,589
I want a more specific, or a more concrete,
我想要一个更具体或更具体的内容

231
00:13:19,590 --> 00:13:21,980
termination condition that I can actually code up,
我可以实际编码的终止条件， 

232
00:13:21,980 --> 00:13:24,070
as opposed to saying, the frontiers meet.
而不是说，边疆汇合。 

233
00:13:24,070 --> 00:13:26,379
Which, you know, I don't know how to code.
您不知道该怎么编码。 

234
00:13:26,379 --> 00:13:28,450
OK?
好？ 

235
00:13:28,450 --> 00:13:30,850
Someone else?
其他人？ 

236
00:13:30,850 --> 00:13:31,885
All right, go for it.
好吧，去吧。 

237
00:13:31,885 --> 00:13:36,016
AUDIENCE: When there's some node that
听众：当有某个节点

238
00:13:36,017 --> 00:13:41,610
can keep track of two different cost values from--
可以跟踪- 

239
00:13:41,610 --> 00:13:43,710
PROFESSOR: The Qf and the Qb, that's correct.
教授：Qf和Qb是正确的。 

240
00:13:43,710 --> 00:13:45,047
And, somehow--
而且， 

241
00:13:45,047 --> 00:13:48,185
AUDIENCE: Somehow they're cost runs
听众：不知何故它们是成本运行

242
00:13:48,385 --> 00:13:53,159
to get there from the start and from the [INAUDIBLE].
从一开始就从[音频不清晰]到达那里。 

243
00:13:53,159 --> 00:13:53,929
PROFESSOR: OK.
教授：好的。 

244
00:13:53,929 --> 00:13:55,370
It's close.
关闭了。 

245
00:13:55,370 --> 00:13:58,070
It's not quite something I can code up.
我还不能编写代码。 

246
00:13:58,070 --> 00:14:00,120
Someone want to improve that?
有人想要改善吗？ 

247
00:14:00,120 --> 00:14:01,679
Someone want to improve that?
有人想要改善吗？ 

248
00:14:01,679 --> 00:14:04,500
I want something very, very specific.
我想要一些非常非常具体的东西。 

249
00:14:04,500 --> 00:14:05,389
Someone?
有人吗

250
00:14:05,389 --> 00:14:06,755
Go for it.
去吧。 

251
00:14:06,755 --> 00:14:10,103
AUDIENCE: The node has been extracted from both Qf and Qb.
听众：该节点已从Qf和Qb中提取。 

252
00:14:10,104 --> 00:14:11,319
PROFESSOR: The node which has been
教授：该节点已

253
00:14:11,519 --> 00:14:13,579
extracted from both Qf and Qb.
从Qf和Qb中提取。 

254
00:14:13,580 --> 00:14:15,460
So, the reason I didn't quite buy your answer
所以，我之所以不买你的答案

255
00:14:15,460 --> 00:14:20,229
was, finite part is obviously correct.
过去，有限的部分显然是正确的。 

256
00:14:20,429 --> 00:14:22,739
But I wanted a specific condition
但是我想要一个特定的条件

257
00:14:22,740 --> 00:14:25,789
that says, I'm going to do extract-min,
那就是说，我要提取分钟

258
00:14:25,789 --> 00:14:28,375
just like I said when I extract-min and u equals t,
就像我说的那样，当我提取min且u等于t时， 

259
00:14:28,375 --> 00:14:31,009
I stop with the single source, single target.
我从单一来源，单一目标开始。 

260
00:14:31,009 --> 00:14:32,779
In the bi-directional case, I need
在双向情况下，我需要

261
00:14:32,779 --> 00:14:35,809
to pull out a node from Qf.
从Qf中拉出一个节点。 

262
00:14:35,809 --> 00:14:38,509
And pull out a node from Qb.
并从Qb中拉出一个节点。 

263
00:14:38,509 --> 00:14:40,370
And then I get to stop, all right?
然后我停下来，好吗？ 

264
00:14:40,370 --> 00:14:43,133
So, you get a cushion.
因此，您得到了缓冲。 

265
00:14:43,333 --> 00:14:45,000
You don't need to feel too bad because I
你不必因为我感到难过

266
00:14:45,000 --> 00:14:47,019
think you already have a cushion.
以为你已经坐垫了。 

267
00:14:47,019 --> 00:14:47,590
Yeah.
是的

268
00:14:47,590 --> 00:14:48,149
I know that.
我知道。 

269
00:14:48,149 --> 00:14:50,716
I know everyone who has cushions.
我知道每个有垫子的人。 

270
00:14:50,716 --> 00:14:52,229
Right.
对。 

271
00:14:52,429 --> 00:14:53,179
Actually, I don't.
其实我不知道

272
00:14:53,179 --> 00:14:56,149
But I'm going to pretend I do.
但是我要假装我这样做。 

273
00:14:56,149 --> 00:15:03,490
So, the termination condition is that some vertex, and this is
因此，终止条件是某个顶点，这是

274
00:15:03,490 --> 00:15:09,799
correct, some vertex, u, has been processed,
正确，某些顶点u已被处理， 

275
00:15:09,799 --> 00:15:23,879
both in the forward search and the backward search.
在向前搜索和向后搜索中都可以。 

276
00:15:23,879 --> 00:15:24,669
OK?
好？ 

277
00:15:24,669 --> 00:15:28,809
That corresponds to the frontiers meeting.
那相当于边疆会议。 

278
00:15:28,809 --> 00:15:33,289
But, specifically, it's been deleted,
但是，具体地说，它已被删除， 

279
00:15:33,289 --> 00:15:42,019
or extracted from both Qf and Qb.
或从Qf和Qb中提取。 

280
00:15:42,019 --> 00:15:46,090
So that's actually the easier question.
所以这实际上是一个更简单的问题。 

281
00:15:46,090 --> 00:15:58,769
Visit a harder question, which is how do we find the shortest
访问一个更棘手的问题，那就是我们如何找到最短的问题

282
00:15:58,769 --> 00:16:07,704
path after termination from s to t?
从s到t终止后的路径？ 

283
00:16:07,705 --> 00:16:08,480
OK?
好？ 

284
00:16:08,480 --> 00:16:11,490
And I should say specifically, that-- and I forgot
我应该特别说-我忘记了

285
00:16:11,490 --> 00:16:14,019
to put this up, which I should-- that we're
提出这个，我应该-我们

286
00:16:14,019 --> 00:16:18,679
going to have to have pi f and pi b, which
必须要有pi f和pi b 

287
00:16:18,679 --> 00:16:21,689
this is the normal data structure.
这是正常的数据结构。 

288
00:16:21,690 --> 00:16:27,960
And the pi b is following the edges backward.
 pi b跟随边缘向后。 

289
00:16:27,960 --> 00:16:30,979
So, in some sense, the predecessor,
因此，从某种意义上说，前任

290
00:16:31,179 --> 00:16:35,989
in the case of pi b, what you're saying is, on this node
对于pi b，您要说的是在此节点上

291
00:16:35,990 --> 00:16:44,419
here-- which I'll call v2 for example--
在这里-我将其称为v2- 

292
00:16:44,419 --> 00:16:46,729
is, if I'm going to choose this path here--
是的，如果我要在这里选择此路径， 

293
00:16:46,730 --> 00:16:51,690
and I need to obviously choose this edge here in any shortest
很明显，我需要在最短的时间内选择此优势

294
00:16:51,690 --> 00:16:53,470
path that gets to t, right?
到达t的路径，对不对？ 

295
00:16:53,470 --> 00:16:55,599
Because that's the only edge that goes to t.
因为那是t的唯一优势。 

296
00:16:55,799 --> 00:17:05,409
And so, what I'm saying here is that a predecessor of pi b t
因此，我在这里所说的是pi bt的前身

297
00:17:05,410 --> 00:17:07,660
equals v2.
等于v2。 

298
00:17:07,660 --> 00:17:09,849
OK?
好？ 

299
00:17:10,049 --> 00:17:10,990
That make sense?
有道理？ 

300
00:17:10,990 --> 00:17:13,809
And then over here, if this was v1,
然后在这里，如果这是v1， 

301
00:17:13,809 --> 00:17:22,240
then I would have pi f v1 equals s.
则pi f v1等于s。 

302
00:17:22,240 --> 00:17:23,098
Right?
对？ 

303
00:17:23,098 --> 00:17:25,000
That make sense?
有道理？ 

304
00:17:25,000 --> 00:17:26,660
Everybody buy that?
大家都买吗？ 

305
00:17:26,660 --> 00:17:31,980
All right, so how do I find the shortest path from s to t,
好吧，如何找到从s到t的最短路径， 

306
00:17:31,980 --> 00:17:36,819
after these frontiers have met, and I've terminated the search?
在这些边疆相遇之后，我已经终止了搜索？ 

307
00:17:36,819 --> 00:17:38,960
How do I do that?
我怎么做？ 

308
00:17:38,960 --> 00:17:39,460
Someone?
有人吗

309
00:17:39,460 --> 00:17:42,569



310
00:17:42,569 --> 00:17:43,159
Go ahead.
前进。 

311
00:17:43,160 --> 00:17:47,518
AUDIENCE: Well, given that data structure, you start at your t.
听众：嗯，考虑到数据结构，您从t开始。 

312
00:17:47,518 --> 00:17:49,392
And you keep on going back to the [INAUDIBLE]
然后您继续返回[音频不清晰] 

313
00:17:49,392 --> 00:17:52,875
until you get to the point where they've peaked.
直到达到峰值为止。 

314
00:17:52,875 --> 00:17:55,296
Then you use the pi f to go from that node,
然后您使用pi f从该节点开始， 

315
00:17:55,296 --> 00:17:56,748
all the way back to s.
一直回到s。 

316
00:17:56,748 --> 00:18:00,058



317
00:18:00,058 --> 00:18:01,849
PROFESSOR: So, what I'm going to have to do
教授：所以，我要做的是

318
00:18:01,849 --> 00:18:07,469
is-- but where do I switch, is the question.
是-但我要切换到哪里？ 

319
00:18:07,470 --> 00:18:11,069
Where do I switch from pi f to pi b?
从pi f切换到pi b的地方？ 

320
00:18:11,069 --> 00:18:16,240
There has to be some point where I switch from-- Yeah, go ahead.
我必须要从某个角度出发-是的，继续。 

321
00:18:16,240 --> 00:18:18,160
AUDIENCE: At the meeting point of the node
听众：在节点的交汇点

322
00:18:18,160 --> 00:18:23,440
that was [INAUDIBLE] Q [INAUDIBLE].
那是[听不清] Q [听不清]。 

323
00:18:23,440 --> 00:18:24,400
PROFESSOR: All right.
教授：好的。 

324
00:18:24,400 --> 00:18:25,816
Is that what you were saying, too?
那也是你的意思吗？ 

325
00:18:25,816 --> 00:18:28,289
OK.
好。 

326
00:18:28,289 --> 00:18:43,720
So the claim is, if w was processed first, extracted
所以说，如果先处理w，就提取

327
00:18:43,720 --> 00:18:56,059
from both Qf and Qb, then find the shortest path using pi
从Qf和Qb中，然后使用pi找到最短路径

328
00:18:56,059 --> 00:19:02,181
f from s to w.
 f从s到w。 

329
00:19:02,181 --> 00:19:02,680
Right?
对？ 

330
00:19:02,680 --> 00:19:05,250
So, you can use pi f to get from s to w.
因此，您可以使用pi f从s到w。 

331
00:19:05,250 --> 00:19:08,440
And the way you do that is by applying pi f to w.
这样做的方法是将pi f应用于w。 

332
00:19:08,440 --> 00:19:12,230
And then keep applying it until you get to s, OK?
然后继续应用它，直到到达s，好吗？ 

333
00:19:12,230 --> 00:19:13,890
This is normal search, right?
这是正常搜索，对不对？ 

334
00:19:13,890 --> 00:19:15,200
Everybody knows this.
大家都知道这一点。 

335
00:19:15,200 --> 00:19:16,269
You coded it.
您已编码。 

336
00:19:16,269 --> 00:19:17,650
So I hope you know it.
所以我希望你知道。 

337
00:19:17,650 --> 00:19:20,690



338
00:19:20,690 --> 00:19:28,299
And then, we go find shortest path using pi b, right?
然后，我们使用pi b找到最短路径，对吗？ 

339
00:19:28,299 --> 00:19:30,379
And you're going to constantly apply
而且您将不断申请

340
00:19:30,380 --> 00:19:38,319
pi b-- and this is the backward path-- from t to w.
 pi b-这是从t到w的后退路径。 

341
00:19:38,519 --> 00:19:42,619



342
00:19:42,619 --> 00:19:48,449
And this follows the edges backward, all right?
然后沿着边缘向后走，好吗？ 

343
00:19:48,450 --> 00:19:50,736
This sounds pretty good?
听起来不错吗？ 

344
00:19:50,936 --> 00:19:52,019
Everybody agree with this?
每个人都同意吗？ 

345
00:19:52,019 --> 00:19:54,599



346
00:19:54,599 --> 00:19:56,539
Anybody disagree?
有人不同意吗？ 

347
00:19:56,539 --> 00:19:58,087
Yeah.
是的

348
00:19:58,087 --> 00:19:59,455
AUDIENCE: Pi b.
听众：Pi b。 

349
00:19:59,455 --> 00:20:07,593
If [INAUDIBLE], pi b would be like pi b b2 equals t,
如果[音频不清晰]，pi b就像pi b b2等于t， 

350
00:20:07,594 --> 00:20:08,607
because b2 [INAUDIBLE]--
因为b2 [听不清]- 

351
00:20:08,607 --> 00:20:10,023
PROFESSOR: That's a good question.
教授：这是一个很好的问题。 

352
00:20:10,023 --> 00:20:13,069
I might have done this wrong.
我可能做错了。 

353
00:20:13,069 --> 00:20:21,230
So, in the backward search, this can get pretty confusing.
因此，在向后搜索中，这可能会造成混乱。 

354
00:20:21,230 --> 00:20:23,160
So what do I have here?
那我这里有什么？ 

355
00:20:23,160 --> 00:20:26,630
I want to follow the predecessor.
我想效仿前任。 

356
00:20:26,630 --> 00:20:27,915
You're exactly right.
你说的没错

357
00:20:28,115 --> 00:20:28,990
You're exactly right.
你说的没错

358
00:20:28,990 --> 00:20:29,589
Thank you.
谢谢。 

359
00:20:29,589 --> 00:20:30,980
Thank you for pointing that out.
感谢您指出这一点。 

360
00:20:30,980 --> 00:20:35,220
All right, so what I have here is
好吧，我在这里的是

361
00:20:35,220 --> 00:20:38,759
when I look at this path that goes this way, all right?
当我看着这条路，好吗？ 

362
00:20:38,759 --> 00:20:42,129
I'm going to look at the path that goes this way.
我将研究这种方式。 

363
00:20:42,130 --> 00:20:44,190
s is the predecessor of v1.
 s是v1的前身。 

364
00:20:44,190 --> 00:20:47,250
v1 is a predecessor of, let's call this v3.
 v1是它的前身，我们称其为v3。 

365
00:20:47,250 --> 00:20:49,200
v3 is a predecessor of v4.
 v3是v4的前身。 

366
00:20:49,200 --> 00:20:51,960
I'm just talking about the regular forward path.
我只是在谈论常规的前进路线。 

367
00:20:51,960 --> 00:20:53,299
We have s to v1.
我们有到v1。 

368
00:20:53,299 --> 00:20:54,509
v1 to v3.
 v1到v3。 

369
00:20:54,509 --> 00:20:55,990
v3 to v4.
 v3到v4。 

370
00:20:55,990 --> 00:20:59,169
All the way to t, right?
一直到t，对不对？ 

371
00:20:59,369 --> 00:21:01,219
So what I have here is correct.
所以我在这里是正确的。 

372
00:21:01,220 --> 00:21:02,659
The predecessor of v1 is s.
 v1的前身是s。 

373
00:21:02,859 --> 00:21:05,599
The predecessor of v3 would be v1.
 v3的前身是v1。 

374
00:21:05,599 --> 00:21:11,049
So I could write, pi f v3 equals v1.
所以我可以写，pi f v3等于v1。 

375
00:21:11,049 --> 00:21:12,116
Et cetera.
等等。 

376
00:21:12,116 --> 00:21:14,450
Now, let's just forget about the forward path, and let's
现在，让我们忘掉前进的道路，让我们

377
00:21:14,450 --> 00:21:16,250
just talk about the backward path.
只是谈论落后的道路。 

378
00:21:16,250 --> 00:21:20,859
In the backwoods path, I want to be
在偏僻的道路上，我想成为

379
00:21:20,859 --> 00:21:22,839
able to construct this backward path.
能够构建此后退路径。 

380
00:21:22,839 --> 00:21:27,069
It's got to be the reverse of what I have, OK?
这一定与我所拥有的相反，好吗？ 

381
00:21:27,069 --> 00:21:29,669
And, in that case, what I'm saying
而且，在这种情况下，我的意思是

382
00:21:29,670 --> 00:21:34,039
is that I want to move in this direction.
是我想朝这个方向前进。 

383
00:21:34,039 --> 00:21:39,829
So pretend that I've made the edges flip, OK?
假装我使边缘翻转了，好吗？ 

384
00:21:39,829 --> 00:21:45,389
So, in that case, if I pretend that this edge is like that,
因此，在那种情况下，如果我假装这种优势就是这样， 

385
00:21:45,390 --> 00:21:47,649
and then I just apply the regular predecessor
然后我只是申请常规的前任

386
00:21:47,849 --> 00:21:52,219
relationship, then t is the predecessor of v2.
关系，则t是v2的前身。 

387
00:21:52,220 --> 00:21:54,019
And that's the point you're making.
这就是您要提出的重点。 

388
00:21:54,019 --> 00:21:56,940
OK? t is the predecessor of v2.
好？ t是v2的前身。 

389
00:21:56,940 --> 00:21:58,539
And so, my apologies.
因此，我很抱歉。 

390
00:21:58,539 --> 00:22:02,859



391
00:22:02,859 --> 00:22:08,119
I have pi b v2 equals t.
我pi b v2等于t。 

392
00:22:08,119 --> 00:22:11,563
And, if I follow this edge here, then I'd
而且，如果我在这方面保持优势，那么我会

393
00:22:11,564 --> 00:22:12,980
have the appropriate relationship.
有适当的关系。 

394
00:22:12,980 --> 00:22:15,509
But let's just stick to this one because that's
但是让我们坚持下去，因为那是

395
00:22:15,509 --> 00:22:16,509
the simple example.
简单的例子。 

396
00:22:16,509 --> 00:22:19,019
I don't quite know whether this edge
我不太清楚这个优势

397
00:22:19,019 --> 00:22:21,299
is going to be part of my shortest path or not.
是否会成为我最短路径的一部分。 

398
00:22:21,299 --> 00:22:22,053
It might be.
有可能。 

399
00:22:22,054 --> 00:22:23,720
And that's something that we'll compute.
这就是我们要计算的东西。 

400
00:22:23,720 --> 00:22:29,150
But what I have here is the predecessor relationship
但是我这里是前辈关系

401
00:22:29,150 --> 00:22:31,390
corresponding to the backward edge.
对应于后边缘。 

402
00:22:31,390 --> 00:22:33,099
And so, that's like flipping this edge.
因此，这就像翻转此边缘。 

403
00:22:33,299 --> 00:22:37,909
And, hopefully, that makes sense now.
而且，希望这现在有意义。 

404
00:22:37,910 --> 00:22:40,940
Thanks for pointing that out.
感谢您指出了这一点。 

405
00:22:40,940 --> 00:22:42,930
And so, let's talk about what happens here.
因此，让我们谈谈这里发生的事情。 

406
00:22:42,930 --> 00:22:44,721
We know what happens in the forward search.
我们知道在正向搜索中会发生什么。 

407
00:22:44,721 --> 00:22:46,279
You've done that before.
您之前已经做过。 

408
00:22:46,279 --> 00:22:48,769
In the backward search, what happens
在向后搜索中，会发生什么

409
00:22:48,769 --> 00:22:54,789
is that I need to start-- according to this condition--
是我需要根据这种情况开始- 

410
00:22:54,789 --> 00:22:58,759
just like in the forward search, I found a w.
就像在向前搜索中一样，我找到了w。 

411
00:22:58,759 --> 00:23:03,410
And I continually applied pi of f to w.
而且我不断将f的pi应用于w。 

412
00:23:03,410 --> 00:23:08,190
So, this is apply pi of f to w.
因此，这是将f的pi应用于w。 

413
00:23:08,190 --> 00:23:12,920
And then do pi of f pi of f w.
然后做f w的pi。 

414
00:23:12,920 --> 00:23:14,129
And so on and so forth.
等等等等。 

415
00:23:14,329 --> 00:23:17,839
And that's what you do in order to construct the shortest path.
这就是您为了构造最短路径所做的事情。 

416
00:23:17,839 --> 00:23:18,819
People buy that?
人们买那个？ 

417
00:23:18,819 --> 00:23:19,439
Right?
对？ 

418
00:23:19,440 --> 00:23:29,519
And what I want to do here is apply pi b to w.
我想在这里将pi b应用于w。 

419
00:23:29,519 --> 00:23:35,740
And then, pi b of pi b to w.
然后，将pi b中的pi b转换为w。 

420
00:23:35,740 --> 00:23:38,131
And so on and so forth, till I get to t.
依此类推，直到我开始。 

421
00:23:38,131 --> 00:23:38,630
Right?
对？ 

422
00:23:38,630 --> 00:23:40,619
And this one, till I get to s.
而这个，直到我得到。 

423
00:23:40,819 --> 00:23:41,319
Right?
对？ 

424
00:23:41,319 --> 00:23:45,329
So, what I wrote here, s to w, t to w.
所以，我在这里写的是，从s到w，从t到w。 

425
00:23:45,329 --> 00:23:49,000
There's nothing incorrect about that.
没什么不对的。 

426
00:23:49,000 --> 00:23:52,309
What's important to understand is the application of the pi
重要的是要了解pi的应用

427
00:23:52,309 --> 00:23:55,210
f and the pi b.
 f和pi b。 

428
00:23:55,210 --> 00:23:59,460
Both, according to this, start with w,
因此，两者都以w开头， 

429
00:23:59,460 --> 00:24:05,149
which is this vertex that caused the termination to happen.
导致终止发生的顶点。 

430
00:24:05,349 --> 00:24:06,789
All right?
好吧？ 

431
00:24:06,789 --> 00:24:09,789
So, people buy this?
那么，人们买这个吗？ 

432
00:24:09,789 --> 00:24:11,651
Any other questions?
还有其他问题吗？ 

433
00:24:11,651 --> 00:24:12,150
All right.
好吧。 

434
00:24:12,150 --> 00:24:14,750
Turns out this is not quite correct.
事实证明这不是很正确。 

435
00:24:14,750 --> 00:24:15,250
OK?
好？ 

436
00:24:15,250 --> 00:24:18,349
This is not quite correct, right?
这不是很正确，对吧？ 

437
00:24:18,349 --> 00:24:24,359
And not because of the pi b inversion that I had before,
并不是因为我之前的pi b反演， 

438
00:24:24,359 --> 00:24:24,859
right?
对？ 

439
00:24:24,859 --> 00:24:26,869
So what have I said, so far?
那么到目前为止，我说了什么？ 

440
00:24:26,869 --> 00:24:27,839
It makes perfect sense.
这是很合理的。 

441
00:24:27,839 --> 00:24:32,490
It says, I have a vertex that caused the termination.
它说，我有一个导致终止的顶点。 

442
00:24:32,490 --> 00:24:34,490
I'm going to call it w.
我将其称为w。 

443
00:24:34,490 --> 00:24:34,990
OK?
好？ 

444
00:24:34,990 --> 00:24:39,419
And that vertex is on the intersection of these two
那个顶点在这两个的交点上

445
00:24:39,619 --> 00:24:42,504
frontiers, OK?
边疆好不好

446
00:24:42,505 --> 00:24:44,630
And I'm going to use that to construct the shortest
我将用它来构造最短的

447
00:24:44,630 --> 00:24:47,650
path by constructing two sub paths,
通过构造两个子路径， 

448
00:24:47,650 --> 00:24:51,639
using the forward pointers and the backward pointers.
使用前向指针和后向指针。 

449
00:24:51,839 --> 00:24:52,569
All right?
好吧？ 

450
00:24:52,569 --> 00:24:55,019
So all of that makes sense except,
所以所有这一切都有意义，除了， 

451
00:24:55,019 --> 00:25:03,799
it turns out, that w may not be on the shortest path.
事实证明，w可能不在最短路径上。 

452
00:25:03,799 --> 00:25:06,134



453
00:25:06,134 --> 00:25:06,634
OK?
好？ 

454
00:25:06,634 --> 00:25:09,700



455
00:25:09,700 --> 00:25:11,569
And I'll show you an example where
我会给你举一个例子

456
00:25:11,569 --> 00:25:13,700
w is not on the shortest path.
 w不在最短路径上。 

457
00:25:13,700 --> 00:25:14,149
All right?
好吧？ 

458
00:25:14,349 --> 00:25:17,649
So that's at a real subtle condition.
所以这是一个真正的微妙条件。 

459
00:25:17,650 --> 00:25:22,240
So we have to actually augment the termination condition.
因此，我们实际上必须增加终止条件。 

460
00:25:22,240 --> 00:25:25,460
Or, we have to do something more than the termination condition.
或者，除了终止条件，我们还需要做更多的事情。 

461
00:25:25,460 --> 00:25:28,420
So, I will tell you right away, the termination condition
所以，我马上告诉你终止条件

462
00:25:28,420 --> 00:25:29,690
is correct.
是正确的。 

463
00:25:29,690 --> 00:25:30,680
OK?
好？ 

464
00:25:30,680 --> 00:25:34,419
And so, the guy who got the cushion, deserved the cushion.
因此，得到靠垫的那个人应该得到靠垫。 

465
00:25:34,619 --> 00:25:35,869
OK?
好？ 

466
00:25:35,869 --> 00:25:38,355
So the termination condition as correct.
因此终止条件正确。 

467
00:25:38,355 --> 00:25:41,779
You are going to run Dijkstra 's ultimate forward search
您将运行Dijkstra的终极搜索

468
00:25:41,779 --> 00:25:43,149
and backward search.
和向后搜索。 

469
00:25:43,150 --> 00:25:46,190
And you're going to terminate when a particular vertex, call
当特定的顶点调用时，您将终止

470
00:25:46,190 --> 00:25:51,509
it w, is going to get pulled out from both Qf and Qb.
它要从Qf和Qb中拉出来。 

471
00:25:51,509 --> 00:25:52,109
All right?
好吧？ 

472
00:25:52,109 --> 00:25:57,669
What is incorrect here is the use of w
这里不正确的是使用w 

473
00:25:57,670 --> 00:26:00,130
to construct the shortest path.
构造最短的路径。 

474
00:26:00,130 --> 00:26:00,630
All right?
好吧？ 

475
00:26:00,630 --> 00:26:02,869
It turns out, we have to do a little more work
事实证明，我们需要做更多的工作

476
00:26:03,069 --> 00:26:06,629
to go find the shortest path, after we've terminated.
我们终止后去寻找最短的路径。 

477
00:26:06,630 --> 00:26:09,660
And w may not be on the shortest path.
 w可能不在最短的路径上。 

478
00:26:09,660 --> 00:26:11,409
All right?
好吧？ 

479
00:26:11,609 --> 00:26:15,169
Any ideas as to what we might do?
关于我们可能做什么的任何想法？ 

480
00:26:15,170 --> 00:26:16,980
This is a bit of an unfair question,
这是一个不公平的问题， 

481
00:26:16,980 --> 00:26:20,144
but certainly worth a cushion.
但肯定值得缓冲。 

482
00:26:20,144 --> 00:26:21,519
How do you think we can fix this?
您认为我们如何解决这个问题？ 

483
00:26:21,519 --> 00:26:24,299



484
00:26:24,299 --> 00:26:26,359
If w is not on the shortest path,
如果w不在最短路径上， 

485
00:26:26,359 --> 00:26:28,879
what do you think would be on the shortest path?
您认为最短的路线是什么？ 

486
00:26:28,880 --> 00:26:30,379
Is there a way of finding this vertex,
有没有找到这个顶点的方法， 

487
00:26:30,579 --> 00:26:31,899
so we can break this up?
这样我们可以分手吗？ 

488
00:26:31,900 --> 00:26:35,640
We absolutely have to use both pi f and pi b.
我们绝对必须同时使用pi f和pi b。 

489
00:26:35,640 --> 00:26:37,150
There's no getting away from that
没有摆脱它的地方

490
00:26:37,150 --> 00:26:40,659
because these two frontiers have just barely collided.
因为这两个领域刚刚相撞。 

491
00:26:40,859 --> 00:26:43,759
The instant they barely collided, we've stopped.
他们几乎没有发生碰撞的那一刻，我们就停了下来。 

492
00:26:43,759 --> 00:26:44,339
OK?
好？ 

493
00:26:44,339 --> 00:26:47,230
So we can't use pi f all the way from s to t.
因此，我们不能从s到t一直使用pi f。 

494
00:26:47,230 --> 00:26:49,710
We can't use pi b all the way from t to s.
从t到s，我们不能一直使用pi b。 

495
00:26:49,710 --> 00:26:51,920
These frontiers have just barely collided.
这些边界刚刚相撞。 

496
00:26:51,920 --> 00:26:52,930
OK?
好？ 

497
00:26:52,930 --> 00:26:56,269
So what happens if w is not on the shortest path?
那么，如果w不在最短路径上会发生什么呢？ 

498
00:26:56,269 --> 00:26:57,639
And why is that the case?
为什么会这样呢？ 

499
00:26:57,640 --> 00:26:58,326
Yeah.
是的

500
00:26:58,326 --> 00:26:59,659
AUDIENCE: I just had a question.
听众：我只是有一个问题。 

501
00:26:59,659 --> 00:27:01,189
Are all the edge weights identical?
所有边缘权重都相同吗？ 

502
00:27:01,189 --> 00:27:01,730
Or are they--
还是他们- 

503
00:27:01,730 --> 00:27:03,604
PROFESSOR: So, the edge weights don't change.
教授：因此，边缘权重不会改变。 

504
00:27:03,604 --> 00:27:05,680



505
00:27:05,680 --> 00:27:08,834
There are no new edges.
没有新的优势。 

506
00:27:08,834 --> 00:27:10,250
The way you want to think about is
你想的方法是

507
00:27:10,250 --> 00:27:13,849
that, you can traverse the edges backward.
您可以向后移动边缘。 

508
00:27:13,849 --> 00:27:19,019
And so, it's not like there are two edges here.
因此，这并不像这里有两个边缘。 

509
00:27:19,019 --> 00:27:20,930
Now, you could fake it, and have two edges
现在，您可以伪造它，并具有两个优势

510
00:27:20,930 --> 00:27:23,199
with exactly the same weights over here.
此处的权重完全相同。 

511
00:27:23,199 --> 00:27:25,490
But are you saying there are edge weights in the graph,
但是您是说图中有边缘权重， 

512
00:27:25,490 --> 00:27:26,919
all identical across the edges?
所有相同的边缘？ 

513
00:27:27,119 --> 00:27:28,869
Or are you asking about the forward search
还是您在询问正向搜索

514
00:27:28,869 --> 00:27:30,046
versus the backward search?
与向后搜索？ 

515
00:27:30,047 --> 00:27:31,505
AUDIENCE: That's what I was asking.
听众：那是我要的。 

516
00:27:31,505 --> 00:27:33,159
Is each edge weight the same in the graph.
图中每个边的权重是否相同？ 

517
00:27:33,359 --> 00:27:34,089
PROFESSOR: No.
教授：不。 

518
00:27:34,089 --> 00:27:35,129
They're using Dijkstra.
他们正在使用Dijkstra。 

519
00:27:35,130 --> 00:27:37,250
The edge ways can be arbitrary.
边缘方式可以是任意的。 

520
00:27:37,250 --> 00:27:40,910
But they're non-negative.
但是它们不是负数。 

521
00:27:40,910 --> 00:27:41,410
OK?
好？ 

522
00:27:41,410 --> 00:27:43,849
So that's the usual Dijkstra requirement.
这就是通常的Dijkstra要求。 

523
00:27:44,049 --> 00:27:45,210
They could be real numbers.
它们可以是实数。 

524
00:27:45,210 --> 00:27:46,419
They could be irrational numbers.
他们可能是不合理的数字。 

525
00:27:46,619 --> 00:27:48,000
They could be whatever.
他们可以是任何东西。 

526
00:27:48,000 --> 00:27:51,190
But they're all non-negative.
但是它们都是非负的。 

527
00:27:51,190 --> 00:27:51,970
All right?
好吧？ 

528
00:27:51,970 --> 00:27:54,670
Now, in the backward search and the forward search-- just
现在，在向后搜索和向前搜索中， 

529
00:27:54,670 --> 00:27:59,269
to make that clear-- while I've drawn this particular edge,
为了明确起见-虽然我画了这个特殊的边缘， 

530
00:27:59,269 --> 00:28:01,690
that weight hasn't changed, OK?
体重没有改变，好吗？ 

531
00:28:01,690 --> 00:28:03,419
That weight had better be the same.
那个重量最好是一样的。 

532
00:28:03,619 --> 00:28:05,139
OK?
好？ 

533
00:28:05,140 --> 00:28:08,069
All right, so I'll show you an example.
好的，我给你看一个例子。 

534
00:28:08,269 --> 00:28:12,819
And we'll take an example, a fairly straightforward example,
我们将举一个例子，一个相当简单的例子， 

535
00:28:12,819 --> 00:28:14,629
it turns out.
事实证明。 

536
00:28:14,630 --> 00:28:16,879
It took a while to concoct this five node
花费了一些时间炮制这五个节点

537
00:28:17,079 --> 00:28:22,449
example that shows the idea here.
在此处显示想法的示例。 

538
00:28:22,450 --> 00:28:27,480
But what we're going to do is, take a look at the termination
但是我们要做的是，看看终止

539
00:28:27,480 --> 00:28:28,909
condition in a specific case, where
在特定情况下的条件

540
00:28:29,109 --> 00:28:32,289
we're going to do this alternation of forward
我们将进行前向轮换

541
00:28:32,289 --> 00:28:33,569
and backward search.
和向后搜索。 

542
00:28:33,569 --> 00:28:35,389
And we'll see, when it terminates,
我们会看到，当它终止时， 

543
00:28:35,390 --> 00:28:39,720
as to what the correct way is to construct the shortest path.
关于构造最短路径的正确方法是什么

544
00:28:39,720 --> 00:28:40,289
All right?
好吧？ 

545
00:28:40,289 --> 00:28:42,289
And, as I said before, the termination condition
而且，正如我之前说的，终止条件

546
00:28:42,289 --> 00:28:43,210
is correct.
是正确的。 

547
00:28:43,210 --> 00:28:45,480
It's not like we stop too early.
并不是说我们停得太早。 

548
00:28:45,480 --> 00:28:50,759
When one of those nodes gets off from Qf and Qb,
当这些节点之一从Qf和Qb下车时， 

549
00:28:50,759 --> 00:28:52,440
you get to stop.
你停下来。 

550
00:28:52,440 --> 00:28:55,890
So that's my s, over here.
这就是我的，在这里。 

551
00:28:55,890 --> 00:29:00,660
And I have a fairly straightforward graph.
我有一个相当简单的图表。 

552
00:29:00,660 --> 00:29:06,682
I have 5, 5, 3, 3, 3.
我有5、5、3、3、3。 

553
00:29:06,682 --> 00:29:08,140
So we don't need a computer program
因此我们不需要计算机程序

554
00:29:08,140 --> 00:29:11,160
to tell us that the shortest path from s to t
告诉我们从s到t的最短路径

555
00:29:11,160 --> 00:29:15,180
is the path with three edges that goes on top, OK,
是具有三个边缘的路径，好， 

556
00:29:15,180 --> 00:29:17,690
which has a weight of 9.
权重为9。 

557
00:29:17,690 --> 00:29:18,139
All right.
好吧。 

558
00:29:18,339 --> 00:29:23,119
So this is a forward search.
所以这是向前搜索。 

559
00:29:23,119 --> 00:29:26,819
And I'm going to call all of these vertices names.
我将把所有这些顶点命名为“顶点”。 

560
00:29:26,819 --> 00:29:29,599
So I have u prime.
所以我有素。 

561
00:29:29,599 --> 00:29:31,149
t. et cetera.
 t。等等。 

562
00:29:31,150 --> 00:29:32,220
OK?
好？ 

563
00:29:32,220 --> 00:29:35,789
So, in the first step of the forward search,
因此，在正向搜索的第一步中， 

564
00:29:35,789 --> 00:29:39,159
I'm going to be able to set-- oh, I'm sorry.
我将能够进行设置-抱歉，对不起。 

565
00:29:39,160 --> 00:29:40,930
This one is a w.
这个是w。 

566
00:29:40,930 --> 00:29:46,859
I'm going to be able to set df w equals 5.
我将能够将df w设置为5。 

567
00:29:47,059 --> 00:29:51,220
And df u equals 3.
而df u等于3。 

568
00:29:51,220 --> 00:29:55,625
And, obviously, df of s equals 0.
显然，s的df等于0。 

569
00:29:55,625 --> 00:29:57,750
And I'm not going to bother writing the infinities.
而且我不会费心写无穷大。 

570
00:29:57,750 --> 00:30:00,400
It's just going to clutter up the board, all right?
这只会使董事会混乱，好吗？ 

571
00:30:00,400 --> 00:30:03,129
So, stop me if you have questions on anything
所以，如果您有任何疑问，请阻止我

572
00:30:03,329 --> 00:30:05,740
I'm writing here.
我在这里写。 

573
00:30:05,740 --> 00:30:08,730
So that's a forward search.
所以这是向前搜索。 

574
00:30:08,730 --> 00:30:12,940
Now, let's do the first step of backward search, right?
现在，让我们进行向后搜索的第一步，对吧？ 

575
00:30:12,940 --> 00:30:14,440
Alternate, remember?
备用，还记得吗？ 

576
00:30:14,440 --> 00:30:16,190
Alternate forward search, backward search,
交替向前搜索，向后搜索， 

577
00:30:16,190 --> 00:30:17,890
forward search, backward search.
向前搜索，向后搜索。 

578
00:30:17,890 --> 00:30:19,170
And I'm just going to write this out again,
我将再次写出来， 

579
00:30:19,170 --> 00:30:20,711
so bear with me, because I think it'd
所以忍受我，因为我认为

580
00:30:20,711 --> 00:30:26,380
be clearer if you see this graph many times.
如果您多次看到此图表，请更清楚。 

581
00:30:26,380 --> 00:30:30,419
As opposed to my erasing what I've written.
与删除我写的内容相反。 

582
00:30:30,619 --> 00:30:32,295
So I've got an s, here.
所以我在这里有一个s。 

583
00:30:32,296 --> 00:30:34,029
t there.
在那里。 

584
00:30:34,029 --> 00:30:34,579
u.
你

585
00:30:34,579 --> 00:30:35,559
u prime.
总理。 

586
00:30:35,559 --> 00:30:36,279
w.
 w。 

587
00:30:36,279 --> 00:30:39,789
And I'm going to hash this vertex vertically
我将垂直哈希此顶点

588
00:30:39,789 --> 00:30:41,599
because that's my backward search.
因为那是我的向后搜索。 

589
00:30:41,599 --> 00:30:46,689
And db of t equals 0.
 t的db等于0。 

590
00:30:46,690 --> 00:30:47,139
OK?
好？ 

591
00:30:47,339 --> 00:30:51,470
And I'm going to follow this backward, and this backward.
我将遵循此后退，以及此后退。 

592
00:30:51,470 --> 00:30:53,809
And my weights are the same.
我的体重是一样的。 

593
00:30:53,809 --> 00:30:55,589
It's the same graph.
这是同一张图。 

594
00:30:55,589 --> 00:31:03,543
So I'm going to have d of b u prime equals 3.
因此，我将使d的素数d等于3。 

595
00:31:03,544 --> 00:31:07,569
And db of w equals 5.
 w的db等于5。 

596
00:31:07,769 --> 00:31:11,049
And I haven't seen u yet.
而且我还没有看到你。 

597
00:31:11,049 --> 00:31:13,220
I haven't seen s yet.
我还没看过。 

598
00:31:13,220 --> 00:31:15,789
And so, all I've done is mark these two.
因此，我所做的只是标记这两个。 

599
00:31:15,789 --> 00:31:17,059
All right?
好吧？ 

600
00:31:17,059 --> 00:31:18,369
So far, so good?
到现在为止还挺好？ 

601
00:31:18,369 --> 00:31:21,879
Again, stop me if you have questions.
同样，如果您有任何疑问，请阻止我。 

602
00:31:21,880 --> 00:31:26,669
We've got, obviously, a couple more steps to go here.
显然，我们还有几个步骤要去这里。 

603
00:31:26,869 --> 00:31:35,279
And let's keep going.
让我们继续前进。 

604
00:31:35,279 --> 00:31:37,075
So now we do a forward search again.
因此，现在我们再次进行前向搜索。 

605
00:31:37,075 --> 00:31:49,680



606
00:31:49,680 --> 00:31:50,430
Yeah, that's fine.
是的，很好。 

607
00:31:50,430 --> 00:31:53,119
That's this hash that way, just to make sure.
这就是这种哈希，只是为了确保。 

608
00:31:53,319 --> 00:31:57,019
This is s, u, u prime, w, t.
这是s，u，u质数，w，t。 

609
00:31:57,019 --> 00:32:03,019



610
00:32:03,019 --> 00:32:05,759
And what I have now is, I'm going
现在我要去的是

611
00:32:05,759 --> 00:32:07,910
process this vertex in the forward search
在正向搜索中处理此顶点

612
00:32:07,910 --> 00:32:09,785
because I have a choice in the forward search
因为我在向前搜索中有选择

613
00:32:09,785 --> 00:32:12,420
to either pick w or w.
选择w或w。 

614
00:32:12,420 --> 00:32:17,380
This clearly has lower priority because df w equals 5.
显然，它的优先级较低，因为df w等于5。 

615
00:32:17,380 --> 00:32:20,660
And df of u equals 3.
 u的df等于3。 

616
00:32:20,660 --> 00:32:23,399
So extract-min is obviously going to pick u.
因此，extract-min很显然会选择您。 

617
00:32:23,599 --> 00:32:28,339
And it's going to process this edge now, after extract-min.
在extract-min之后，它将立即处理此边缘。 

618
00:32:28,339 --> 00:32:33,089
And I'm going have df of u prime equals 6.
我要得到的素数df等于6。 

619
00:32:33,089 --> 00:32:33,589
OK?
好？ 

620
00:32:33,589 --> 00:32:34,756
AUDIENCE: It's 3 over there.
听众：那边是3点。 

621
00:32:34,757 --> 00:32:36,131
PROFESSOR: Oh, it's 3 over there.
教授：哦，那边是3点。 

622
00:32:36,131 --> 00:32:36,836
Thanks.
谢谢。 

623
00:32:36,836 --> 00:32:38,660
Good.
好。 

624
00:32:38,660 --> 00:32:40,740
So, so far, so good?
那么，到目前为止，很好吗？ 

625
00:32:40,740 --> 00:32:41,420
Yeah?
是啊

626
00:32:41,420 --> 00:32:41,920
All right.
好吧。 

627
00:32:41,920 --> 00:32:44,755
So now, I go to the backward search.
所以现在，我去向后搜索。 

628
00:32:44,755 --> 00:32:55,170



629
00:32:55,170 --> 00:33:01,349
And again, I have s, t, u, u prime, w.
再说一次，我有s，t，u，u素数w。 

630
00:33:01,549 --> 00:33:04,190
I'm going to go ahead and hash this.
我将继续对此进行哈希处理。 

631
00:33:04,190 --> 00:33:06,491
This has been hashed horizontally.
这已被水平散列。 

632
00:33:06,491 --> 00:33:09,779
The hash horizontally means that it's been removed from Qf.
水平散列表示已将其从Qf中删除。 

633
00:33:09,779 --> 00:33:13,220
The hash vertically means that it's been removed from Qb.
纵向上的哈希表示已将其从Qb中删除。 

634
00:33:13,220 --> 00:33:17,169
And so, when I look at this, and I do a backward search,
因此，当我查看此内容并进行向后搜索时， 

635
00:33:17,369 --> 00:33:20,179
I'm going to hash this.
我将对此进行哈希处理。 

636
00:33:20,180 --> 00:33:25,159
And I'm going to set db of u prime equals 3.
我将设置u的db等于3。 

637
00:33:25,359 --> 00:33:30,714
And I have db of w equals 5.
我的w的分贝等于5。 

638
00:33:30,714 --> 00:33:36,369



639
00:33:36,369 --> 00:33:38,599
So, that I already had.
所以，我已经有了。 

640
00:33:38,599 --> 00:33:43,339
And so, when I have db of w equals 5 and db of u prime
所以，当我的w的分贝等于5而u的分贝

641
00:33:43,339 --> 00:33:46,099
equals 3, then, obviously, I'm going
等于3，那么，显然，我要

642
00:33:46,099 --> 00:33:53,049
to pick the one with the min priority.
选择优先级最低的那个

643
00:33:53,049 --> 00:33:55,930
This corresponds to this one.
这与此对应。 

644
00:33:55,930 --> 00:33:58,509
And what it's going to do is, it's
它要做的是

645
00:33:58,509 --> 00:34:03,174
going to go process that and set db of u equals 6.
进行处理，并将您的db设置为6。 

646
00:34:03,174 --> 00:34:04,460
All right?
好吧？ 

647
00:34:04,460 --> 00:34:09,034
So what happened here simply was that I picked this vertex off
所以这里发生的只是我摘下了这个顶点

648
00:34:09,034 --> 00:34:12,309
of Qb because that was the min priority.
 Qb，因为这是最低优先级。 

649
00:34:12,309 --> 00:34:15,559
And all I did was relax this particular edge
我所做的就是放松这个特殊的优势

650
00:34:15,559 --> 00:34:17,079
in the backward direction.
在向后的方向。 

651
00:34:17,079 --> 00:34:19,398
And said db u equals 6.
并说db u等于6。 

652
00:34:19,398 --> 00:34:20,170
All right?
好吧？ 

653
00:34:20,170 --> 00:34:21,610
Almost there.
快好了。 

654
00:34:21,610 --> 00:34:22,789
Any questions so far?
到目前为止有什么问题吗？ 

655
00:34:22,789 --> 00:34:25,889
Any bugs you noticed so far, in what I've written?
到目前为止，您在我写的文章中发现任何错误吗？ 

656
00:34:25,889 --> 00:34:27,527
Yeah, back there, question.
是的，回到那里，问。 

657
00:34:27,726 --> 00:34:30,199
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

658
00:34:30,199 --> 00:34:31,000
PROFESSOR: OK.
教授：好的。 

659
00:34:31,000 --> 00:34:31,500
Good.
好。 

660
00:34:31,500 --> 00:34:32,940
So people agree with this.
因此人们对此表示赞同。 

661
00:34:32,940 --> 00:34:34,519
All right, one more.
好吧，再说一遍。 

662
00:34:34,519 --> 00:34:36,710
One more board to draw.
再画一个板。 

663
00:34:36,710 --> 00:34:38,135
And we'll be done.
我们会完成的。 

664
00:34:38,135 --> 00:34:39,135
We will have terminated.
我们将终止。 

665
00:34:39,135 --> 00:34:47,409



666
00:34:47,409 --> 00:34:49,800
All right, so getting pretty close.
好吧，所以距离很近。 

667
00:34:49,800 --> 00:35:06,289



668
00:35:06,489 --> 00:35:09,049
So I'm set up this way.
所以我是这样设置的。 

669
00:35:09,050 --> 00:35:09,769
Oh, shoot.
哦，开枪。 

670
00:35:09,969 --> 00:35:10,469
Sorry.
抱歉。 

671
00:35:10,469 --> 00:35:13,318



672
00:35:13,318 --> 00:35:14,110
This is horizontal.
这是水平的。 

673
00:35:14,110 --> 00:35:21,289



674
00:35:21,289 --> 00:35:27,840
So, now I'm looking at it, and I've taken care of these two.
因此，现在我正在研究它，并且已经处理了这两个问题。 

675
00:35:27,840 --> 00:35:29,820
And I'm talking about the forward search here.
我在这里谈论正向搜索。 

676
00:35:29,820 --> 00:35:32,059
So this is, again, the forward.
所以这又是前进的方向。 

677
00:35:32,059 --> 00:35:34,739
And that's the backward.
那就是落后。 

678
00:35:34,739 --> 00:35:37,729
And now I'm doing a forward again.
现在，我再次前进。 

679
00:35:37,730 --> 00:35:43,610
And my only choice, now, is to pick the w vertex off of Qf.
现在，我唯一的选择是从Qf中选择w顶点。 

680
00:35:43,610 --> 00:35:44,109
Right?
对？ 

681
00:35:44,110 --> 00:35:47,900
Because df w equals 5.
因为df w等于5。 

682
00:35:47,900 --> 00:35:50,250
And this one has already been processed.
并且这个已经被处理了。 

683
00:35:50,449 --> 00:35:52,529
df of u equals 3.
 u的df等于3。 

684
00:35:52,530 --> 00:35:54,000
But I've hashed that.
但是我已经将其散列了。 

685
00:35:54,000 --> 00:35:58,099
And so I've gone ahead and processed that vertex.
因此，我继续进行处理该顶点。 

686
00:35:58,099 --> 00:36:03,940
And this one, df of u prime equals 6.
这个素数的df等于6。 

687
00:36:03,940 --> 00:36:09,550
So, in Qf, I would be comparing u prime and w.
因此，在Qf中，我将比较u prime和w。 

688
00:36:09,550 --> 00:36:12,130
And I would take w, OK?
我会拿w，好吗？ 

689
00:36:12,329 --> 00:36:13,860
People buy that?
人们买那个？ 

690
00:36:13,860 --> 00:36:17,519
That's because, I guess you by the fact that 5 is less than 6.
这是因为，我猜您是5小于6。 

691
00:36:17,719 --> 00:36:19,239
I hope.
我希望。 

692
00:36:19,239 --> 00:36:24,239
So that's what happens in the step of forward search.
这就是正向搜索步骤中发生的情况。 

693
00:36:24,239 --> 00:36:28,799
And then you go ahead and process this.
然后继续进行处理。 

694
00:36:28,800 --> 00:36:36,030
You're going to set df of t to be 10.
您将把t的df设置为10。 

695
00:36:36,030 --> 00:36:36,880
OK?
好？ 

696
00:36:37,079 --> 00:36:38,759
And now you're starting to see why
现在您开始明白为什么

697
00:36:38,760 --> 00:36:41,820
there may be a bit of a problem with our shortest path
我们最短的路径可能会出现问题

698
00:36:41,820 --> 00:36:43,190
computation, right?
计算吧？ 

699
00:36:43,389 --> 00:36:44,719
Maybe.
也许。 

700
00:36:44,719 --> 00:36:45,343
All right?
好吧？ 

701
00:36:45,344 --> 00:36:46,010
Everything good?
一切都很好？ 

702
00:36:46,010 --> 00:36:46,570
All right.
好吧。 

703
00:36:46,769 --> 00:36:49,019
So what have I done here?
那我在这里做了什么？ 

704
00:36:49,019 --> 00:36:54,699
I've removed w from Qf.
我已经从Qf中删除了w。 

705
00:36:54,699 --> 00:36:55,460
OK.
好。 

706
00:36:55,460 --> 00:36:57,375
I've removed w from Qf.
我已经从Qf中删除了w。 

707
00:36:57,375 --> 00:36:58,000
All right.
好吧。 

708
00:36:58,000 --> 00:37:01,050
Now, let's look at the last step here, of the backward search.
现在，让我们看一下向后搜索的最后一步。 

709
00:37:01,050 --> 00:37:09,690



710
00:37:09,889 --> 00:37:10,634
s, t.
 s，t。 

711
00:37:10,635 --> 00:37:14,170



712
00:37:14,369 --> 00:37:16,173
And so, this was hashed.
因此，这是哈希值。 

713
00:37:16,173 --> 00:37:16,840
That was hashed.
那是散列的。 

714
00:37:16,840 --> 00:37:22,579



715
00:37:22,579 --> 00:37:24,559
And, if I look at what I have here,
而且，如果我看看这里的东西， 

716
00:37:24,559 --> 00:37:31,789
I have db u prime equals 3.
我的分贝u等于3。 

717
00:37:31,789 --> 00:37:36,789
df u prime equals 6.
 df u等于6。 

718
00:37:36,789 --> 00:37:41,130
This was df w equals 5.
这是dw w等于5。 

719
00:37:41,130 --> 00:37:45,250
db w equals 5.
 db w等于5。 

720
00:37:45,250 --> 00:37:46,630
And so on and so forth.
等等等等。 

721
00:37:46,630 --> 00:37:48,710
Again, you compare w.
同样，您比较w。 

722
00:37:48,909 --> 00:37:51,329
And you see that db w equals 5.
您会看到db w等于5。 

723
00:37:51,329 --> 00:37:53,880
And df u prime equals 6.
 df u素数等于6。 

724
00:37:53,880 --> 00:37:57,655
So therefore, you will pick w.
因此，您将选择w。 

725
00:37:57,655 --> 00:37:58,730
OK?
好？ 

726
00:37:58,929 --> 00:38:01,989
You will pick w, and remove it from Qf.
您将选择w，并将其从Qf中删除。 

727
00:38:01,989 --> 00:38:07,619
So remove w from Qf.
因此，从Qf中删除w。 

728
00:38:07,619 --> 00:38:08,339
All right?
好吧？ 

729
00:38:08,340 --> 00:38:10,050
And process it.
并处理它。 

730
00:38:10,050 --> 00:38:16,880
And what you end up with is df of s equals 10.
最终得到的是的df等于10。 

731
00:38:17,079 --> 00:38:18,269
OK?
好？ 

732
00:38:18,269 --> 00:38:20,916
That's what you get because this is a 5.
这就是您得到的，因为这是5。 

733
00:38:20,916 --> 00:38:21,539
And that's a 5.
那是5。 

734
00:38:21,539 --> 00:38:24,519



735
00:38:24,519 --> 00:38:26,155
OK?
好？ 

736
00:38:26,155 --> 00:38:28,360
People see the problem here?
人们在这里看到问题了吗？ 

737
00:38:28,360 --> 00:38:30,110
What's the problem?
有什么问题？ 

738
00:38:30,110 --> 00:38:31,715
Someone articulate the problem.
有人明确指出了这个问题。 

739
00:38:31,715 --> 00:38:32,824
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

740
00:38:32,824 --> 00:38:33,289
PROFESSOR: Yeah.
教授：是的。 

741
00:38:33,489 --> 00:38:37,889
I mean, so, what I have so far is, I've terminated.
我的意思是，到目前为止，我已经终止了。 

742
00:38:37,889 --> 00:38:41,650
But it looks like I end up with d of s.
但看起来我最终得到s的d。 

743
00:38:41,650 --> 00:38:43,690
If I look at it from a standpoint
如果我从一个角度来看

744
00:38:43,690 --> 00:38:49,550
of the forward weight, I got a 10 for t.
向前重量的一半，我得到10吨。 

745
00:38:49,550 --> 00:38:51,835
I get db t equals 10.
我得到db t等于10。 

746
00:38:52,034 --> 00:38:54,889
If I look from a standpoint of the backward weight,
如果从后向重量的角度来看， 

747
00:38:54,889 --> 00:38:57,519
I get db s equals 10.
我得到db等于10。 

748
00:38:57,519 --> 00:38:58,019
OK?
好？ 

749
00:38:58,019 --> 00:39:01,079
And we all know that the shortest path should be 9.
我们都知道最短路径应该是9。 

750
00:39:01,079 --> 00:39:01,869
OK.
好。 

751
00:39:01,869 --> 00:39:03,250
So what happened here?
那么这里发生了什么？ 

752
00:39:03,250 --> 00:39:05,760
Well, we terminated according to this condition.
好吧，我们根据这种情况终止了。 

753
00:39:05,760 --> 00:39:10,730
We terminated when w was pulled off from Qf and Qb
当w从Qf和Qb断开时，我们终止了

754
00:39:10,730 --> 00:39:12,829
because that was the short path, in some sense,
因为从某种意义上说，这是一条短路， 

755
00:39:12,829 --> 00:39:15,719
in terms of number of edges, right?
就边缘数量而言，对吗？ 

756
00:39:15,719 --> 00:39:18,289
It was only of length 2.
它只有长度2。 

757
00:39:18,289 --> 00:39:20,500
And so, then the frontiers collide.
因此，边界发生了冲突。 

758
00:39:20,500 --> 00:39:22,219
This is a subtlety in the algorithm.
这是算法中的一个微妙之处。 

759
00:39:22,219 --> 00:39:25,539
The frontiers collide at some vertex,
边界在某个顶点发生碰撞， 

760
00:39:25,539 --> 00:39:28,630
regardless of the weights of the edges.
无论边缘的重量如何。 

761
00:39:28,630 --> 00:39:30,630
Because we are alternating the forward search
因为我们交替进行正向搜索

762
00:39:30,630 --> 00:39:33,000
and the backward search, in effect,
实际上，向后搜索

763
00:39:33,000 --> 00:39:36,690
the frontiers are going to collide on the shortest length
边界将在最短的长度上发生碰撞

764
00:39:36,690 --> 00:39:37,519
path.
路径。 

765
00:39:37,519 --> 00:39:38,019
Right?
对？ 

766
00:39:38,019 --> 00:39:40,070
That makes sense, right?
那是有道理的，对吧？ 

767
00:39:40,070 --> 00:39:45,769
So this example is set up so the shortest length path is not
因此，此示例已设置，因此最短的路径不是

768
00:39:45,969 --> 00:39:47,739
the shortest weight path.
最短的重量路径。 

769
00:39:47,739 --> 00:39:49,259
OK?
好？ 

770
00:39:49,260 --> 00:39:59,110
So we can't take the w and use pi f to construct
所以我们不能使用w并使用pi f来构造

771
00:39:59,309 --> 00:40:02,299
part of the path, and use pi b to construct
路径的一部分，并使用pi b进行构造

772
00:40:02,300 --> 00:40:03,630
the other part of the path.
路径的另一部分。 

773
00:40:03,829 --> 00:40:05,779
And find the shortest weight path.
并找到最短的重量路径。 

774
00:40:05,780 --> 00:40:07,155
We would get something incorrect.
我们会得到不正确的东西。 

775
00:40:07,155 --> 00:40:07,655
Right?
对？ 

776
00:40:07,655 --> 00:40:09,735
We would get a path of length 10, in this case,
我们将得到一个长度为10的路径，在这种情况下， 

777
00:40:09,735 --> 00:40:11,170
if we did that.
如果我们做到了。 

778
00:40:11,369 --> 00:40:14,529
So how do we fix it?
那么我们如何解决呢？ 

779
00:40:14,530 --> 00:40:16,460
How do we fix it?
我们该如何解决？ 

780
00:40:16,460 --> 00:40:19,409
One little termination condition doesn't change.
一个小的终止条件不会改变。 

781
00:40:19,409 --> 00:40:20,920
How do we fix it?
我们该如何解决？ 

782
00:40:20,920 --> 00:40:22,559
Someone?
有人吗

783
00:40:22,559 --> 00:40:23,429
Back there.
回到那里。 

784
00:40:23,429 --> 00:40:24,397
Or, actually, you.
或者，实际上是你。 

785
00:40:24,398 --> 00:40:26,594
AUDIENCE: Ordinate based on the weight.
听众：以体重为准。 

786
00:40:26,594 --> 00:40:28,260
PROFESSOR: Ordinate based on the weight.
教授：根据重量进行排序。 

787
00:40:28,260 --> 00:40:30,592
So exactly how would we do that?
那么我们该怎么做呢？ 

788
00:40:30,592 --> 00:40:32,476
AUDIENCE: At each point you take the one
听众：在每一点上你都

789
00:40:32,476 --> 00:40:34,336
that has the [INAUDIBLE].
有[听不清]。 

790
00:40:34,536 --> 00:40:36,619
PROFESSOR: But that's what we're doing now, right?
教授：但这就是我们现在正在做的，对吧？ 

791
00:40:36,619 --> 00:40:39,449



792
00:40:39,449 --> 00:40:41,014
So, are you changing the alternation
所以，您是否要更改交替

793
00:40:41,014 --> 00:40:43,139
between the forward search and the backward search?
在向前搜索和向后搜索之间？ 

794
00:40:43,139 --> 00:40:44,299
AUDIENCE: Yeah.
听众：是的。 

795
00:40:44,300 --> 00:40:45,800
PROFESSOR: You're saying that you're
教授：您是说您在

796
00:40:45,800 --> 00:40:47,650
going to do more forward searches, as opposed
会进行更多的前向搜索，而不是

797
00:40:47,849 --> 00:40:49,454
to backward searches?
向后搜索？ 

798
00:40:49,454 --> 00:40:51,079
AUDIENCE: If the overall cost is lower.
听众：如果总体成本较低。 

799
00:40:51,079 --> 00:40:52,614
PROFESSOR: Overall cost is lower.
教授：总体成本较低。 

800
00:40:52,614 --> 00:40:58,009
You know, if you code it up, you get to keep this.
您知道，如果对它进行编码，就可以保留它。 

801
00:40:58,010 --> 00:41:01,880
If I want a slightly different, simpler
如果我想稍微不同一点，更简单

802
00:41:01,880 --> 00:41:04,190
fix because I think what you're saying here--
解决，因为我认为您在这里说的是- 

803
00:41:04,190 --> 00:41:05,260
and I like the idea.
我喜欢这个主意

804
00:41:05,260 --> 00:41:06,860
I actually do like the idea.
我实际上很喜欢这个主意。 

805
00:41:06,860 --> 00:41:11,146
You're saying you're going to not do strict alternation.
您是说您不会进行严格的轮换。 

806
00:41:11,146 --> 00:41:13,519
But you're going to do some sort of weighted alternation,
但是您将要进行某种加权交替， 

807
00:41:13,519 --> 00:41:16,019
from what I can tell, based on the weights.
我可以根据权重判断。 

808
00:41:16,019 --> 00:41:16,659
OK?
好？ 

809
00:41:16,659 --> 00:41:20,681
And I think there's an algorithm there that's correct.
我认为这里有一个正确的算法。 

810
00:41:20,681 --> 00:41:21,179
OK?
好？ 

811
00:41:21,179 --> 00:41:24,359
I probably won't be able to prove
我可能无法证明

812
00:41:24,360 --> 00:41:28,190
that it's correct to myself in five minutes.
五分钟之内对我自己是正确的。 

813
00:41:28,190 --> 00:41:28,690
OK.
好。 

814
00:41:28,690 --> 00:41:30,079
Or 10 minutes.
或10分钟。 

815
00:41:30,079 --> 00:41:33,150
But let's talk about that offline.
但是，让我们离线讨论一下。 

816
00:41:33,150 --> 00:41:34,340
And see if there's a way.
看看是否有办法。 

817
00:41:34,340 --> 00:41:36,260
I'm a little worried that, if you
我有点担心，如果你

818
00:41:36,260 --> 00:41:39,780
have positive rational numbers, and you've
有正有理数，而你已经

819
00:41:39,780 --> 00:41:44,110
got root 2, square root of 2, and pi.
得到根2、2的平方根和pi。 

820
00:41:44,110 --> 00:41:47,170
And the transcendental number corresponding to these weights,
与这些权重相对应的超越数， 

821
00:41:47,170 --> 00:41:48,980
that this weighted alternation is
这个加权的交替是

822
00:41:48,980 --> 00:41:52,630
going to be a bit hard to implement correctly.
正确实施会有些困难。 

823
00:41:52,630 --> 00:41:54,460
But it's a neat idea.
但这是一个好主意。 

824
00:41:54,460 --> 00:41:56,840
I would actually like a follow up on that.
我实际上希望对此进行跟进。 

825
00:41:56,840 --> 00:41:59,918
Something that's a little-- yeah, back there.
有点儿-是的，回到那儿。 

826
00:41:59,918 --> 00:42:02,259
AUDIENCE: Can you look at the neighbors of all the nodes that
听众：您能看一下所有节点的邻居吗？ 

827
00:42:02,458 --> 00:42:04,503
are in your forward [INAUDIBLE], and see
在你的前进中[听不清]， 

828
00:42:04,503 --> 00:42:07,003
if any of their neighbors are in backwards [INAUDIBLE].
如果他们的任何邻居都倒向[听不清]。 

829
00:42:07,003 --> 00:42:10,737
And see if that's going to give you a shorter path than the one
看看这是否会让您走得更短

830
00:42:10,737 --> 00:42:12,596
that you pulled out previously.
是你以前退出的

831
00:42:12,597 --> 00:42:13,480
PROFESSOR: That's correct.
教授：是的。 

832
00:42:13,679 --> 00:42:17,139
That's almost exactly correct.
这几乎是完全正确的。 

833
00:42:17,139 --> 00:42:19,809
I won't bother throwing it over, but this is yours.
我不会把它扔过去，但这是你的。 

834
00:42:19,809 --> 00:42:20,750
You want to catch it?
你想抓住吗？ 

835
00:42:20,750 --> 00:42:21,610
AUDIENCE: I already have one.
听众：我已经有一个。 

836
00:42:21,610 --> 00:42:23,010
PROFESSOR: You already have a cushion.
教授：您已经坐垫了。 

837
00:42:23,010 --> 00:42:23,360
All right.
好吧。 

838
00:42:23,360 --> 00:42:24,568
So how about I just throw it.
那我就扔吧。 

839
00:42:24,568 --> 00:42:26,480
And anybody who wants to catch it gets it.
任何想要抓住它的人都可以得到它。 

840
00:42:26,480 --> 00:42:27,210
How's that?
怎么样？ 

841
00:42:27,210 --> 00:42:28,405
Whoa.
哇

842
00:42:28,405 --> 00:42:28,940
All right.
好吧。 

843
00:42:29,139 --> 00:42:30,420
I didn't hit anybody.
我没打人

844
00:42:30,420 --> 00:42:32,860
Anybody who wants it, who doesn't have a cushion.
任何想要它的人，没有缓冲。 

845
00:42:32,860 --> 00:42:33,230
Right.
对。 

846
00:42:33,429 --> 00:42:36,629
We've got all these cushions in my office, and Eric's office.
我们办公室和Eric的办公室都有这些垫子。 

847
00:42:36,630 --> 00:42:39,626
We've got to do something about them.
我们必须对它们做一些事情。 

848
00:42:39,626 --> 00:42:40,960
They're actually not that great.
他们实际上不是那么好。 

849
00:42:40,960 --> 00:42:43,690



850
00:42:43,690 --> 00:42:46,534
You know, it's bit of an issue, I understand.
我知道，这是个问题。 

851
00:42:46,534 --> 00:42:48,420
You know, we've got to do Frisbees next time,
你知道，我们下次必须做飞盘， 

852
00:42:48,420 --> 00:42:50,630
or something.
或者其他的东西。 

853
00:42:50,630 --> 00:42:53,541
I can see why you're not enthusiastic about this.
我明白了您为什么不对此感兴趣。 

854
00:42:53,541 --> 00:42:54,039
Right?
对？ 

855
00:42:54,039 --> 00:42:54,980
OK.
好。 

856
00:42:54,980 --> 00:42:59,099
All right, so the answer was, in fact, correct.
好吧，答案实际上是正确的。 

857
00:42:59,099 --> 00:43:04,269
And let me write it up over here.
让我在这里写下来。 

858
00:43:04,269 --> 00:43:06,250
So we had to do a little more work.
因此，我们不得不做更多的工作。 

859
00:43:06,250 --> 00:43:07,969
We terminate properly.
我们正确终止。 

860
00:43:07,969 --> 00:43:09,989
We do the strict alternation.
我们进行严格的变更。 

861
00:43:09,989 --> 00:43:13,029
But we have to do a little bit more work.
但是，我们需要做更多的工作。 

862
00:43:13,030 --> 00:43:14,750
OK.
好。 

863
00:43:14,750 --> 00:43:19,949
And the work we have to do is summarized very neatly
我们要做的工作总结得很整齐

864
00:43:19,949 --> 00:43:30,029
by saying, we want to find an x, which is maybe
就是说，我们想找到一个x，也许

865
00:43:30,030 --> 00:43:40,610
different from w, possibly, that has
与w不同，可能有

866
00:43:40,610 --> 00:43:53,894
minimum value of d of x plus db x.
 x加上db x的d的最小值。 

867
00:43:53,894 --> 00:43:54,500
All right?
好吧？ 

868
00:43:54,500 --> 00:43:55,750
So we have to actually look.
因此，我们必须实际看一下。 

869
00:43:55,750 --> 00:43:58,489
And this x is going to be neighboring.
这个x将是相邻的。 

870
00:43:58,489 --> 00:44:00,879
But we don't really need to specify that.
但是我们真的不需要指定它。 

871
00:44:00,880 --> 00:44:05,289
What we say is, you're going to have to look at Qf and Qb.
我们的意思是，您将不得不考虑Qf和Qb。 

872
00:44:05,289 --> 00:44:08,579
And it's possible that w is the one that
 w可能是

873
00:44:08,579 --> 00:44:11,809
has minimum df w plus db w.
具有最小dw和db w。 

874
00:44:11,809 --> 00:44:14,820
But, clearly, that wasn't the case in this example.
但是，显然，在此示例中并非如此。 

875
00:44:14,820 --> 00:44:17,650
So, in this example, w caused the termination.
因此，在此示例中，w导致了终止。 

876
00:44:17,650 --> 00:44:18,800
But now we need to scan.
但是现在我们需要扫描。 

877
00:44:18,800 --> 00:44:20,057
And there's only two other vertices
而且只有两个顶点

878
00:44:20,257 --> 00:44:22,829
that are interesting here, which are u and u prime.
在这里有趣的是你和你素数。 

879
00:44:22,829 --> 00:44:24,840
And either of those will fit the bill
这些都适合

880
00:44:24,840 --> 00:44:31,269
because we see that df of u plus db of u equals 3 plus 6
因为我们看到u的d加上u的db等于3加6 

881
00:44:31,269 --> 00:44:32,710
equals 9.
等于9。 

882
00:44:32,710 --> 00:44:41,070
And df of u prime plus db of u prime equals-- I'm sorry,
 u素数的df和u素数的db等于-对不起， 

883
00:44:41,070 --> 00:44:42,400
I should have out db here.
我应该在这里有分贝。 

884
00:44:42,400 --> 00:44:48,369
db of u prime would be 6 plus 3 equals 9.
 u prime的db是6加3等于9。 

885
00:44:48,369 --> 00:44:48,869
Right?
对？ 

886
00:44:48,869 --> 00:44:50,929
So both of these are less than 10.
所以这两个都小于10。 

887
00:44:50,929 --> 00:44:54,449
And so we had to pick one of these as our x.
因此，我们必须选择其中一个作为x。 

888
00:44:54,449 --> 00:44:55,409
OK.
好。 

889
00:44:55,409 --> 00:45:01,051
And if you pick one of these as our x, then, at that point,
如果您选择其中一个作为x，那么在那时， 

890
00:45:01,052 --> 00:45:03,670
we don't do w here.
我们在这里不做。 

891
00:45:03,670 --> 00:45:05,519
We do x.
我们做x。 

892
00:45:05,519 --> 00:45:06,019
OK?
好？ 

893
00:45:06,019 --> 00:45:09,329



894
00:45:09,329 --> 00:45:10,204
Let me write it as x.
让我将其写为x。 

895
00:45:10,204 --> 00:45:11,489
It looks like a cross here.
这里看起来像个十字架。 

896
00:45:11,489 --> 00:45:15,569



897
00:45:15,570 --> 00:45:16,570
So that's what happens.
就是这样。 

898
00:45:16,570 --> 00:45:18,039
So this small little tweak.
所以这个小小的调整。 

899
00:45:18,239 --> 00:45:19,349
Do the alternation.
进行轮换。 

900
00:45:19,349 --> 00:45:20,699
Do the termination.
执行终止。 

901
00:45:20,699 --> 00:45:22,210
Once you do the termination, go look
终止后，请继续查看

902
00:45:22,210 --> 00:45:25,289
and see if you can minimize the shortest path
看看是否可以最小化最短路径

903
00:45:25,289 --> 00:45:27,679
length by finding an appropriate x.
通过找到适当的x来确定长度。 

904
00:45:27,679 --> 00:45:31,029
Which has the minimum sum of the forward and the backward
其中前向和后向的总和最小

905
00:45:31,030 --> 00:45:31,860
priorities.
优先事项。 

906
00:45:32,059 --> 00:45:34,000
And then, you're in business.
然后，您正在做生意。 

907
00:45:34,000 --> 00:45:35,530
And then, everything works.
然后，一切正常。 

908
00:45:35,530 --> 00:45:36,650
OK?
好？ 

909
00:45:36,849 --> 00:45:37,349
All right.
好吧。 

910
00:45:37,349 --> 00:45:38,110
Great.
大。 

911
00:45:38,110 --> 00:45:42,750
So, so much for bi-directional search.
因此，双向搜索就这么多。 

912
00:45:42,949 --> 00:45:45,519
Let me talk a little bit about heuristics
让我谈谈启发式

913
00:45:45,519 --> 00:45:53,159
that people use to modify the graph so things run faster
人们用来修改图形，以便更快地运行

914
00:45:53,159 --> 00:45:54,489
in practice.
在实践中。 

915
00:45:54,489 --> 00:46:01,500
So, in particular, you can think about the goal directed search,
因此，尤其是您可以考虑目标定向搜索， 

916
00:46:01,500 --> 00:46:04,400
or a star, if you're taking 6034.
或星星，如果您要使用6034。 

917
00:46:04,400 --> 00:46:08,769
And there's some commonality between what
两者之间有一些共同点

918
00:46:08,969 --> 00:46:13,709
I'm going to talk about here, and that material.
我将在这里讨论该材料。 

919
00:46:13,710 --> 00:46:17,190
The basic idea is that we're going
基本思想是我们要

920
00:46:17,190 --> 00:46:29,909
to modify the edge weights in such a way
以这种方式修改边缘权重

921
00:46:29,909 --> 00:46:36,659
that you go downhill toward the shortest path.
沿着最短的路走下坡路。 

922
00:46:36,659 --> 00:46:41,639
And so, the priorities are modified heuristically.
因此，优先级将通过启发式修改。 

923
00:46:41,639 --> 00:46:43,806
So things run a little bit quicker.
这样事情就快一点了。 

924
00:46:43,806 --> 00:46:45,429
You're trying to prune the search here.
您正在尝试修剪此处的搜索。 

925
00:46:45,429 --> 00:46:50,019



926
00:46:50,019 --> 00:46:52,472
So we're going to modify edge weights.
因此，我们将修改边缘权重。 

927
00:46:52,472 --> 00:46:54,480
And we have to be careful when we do this, obviously.
显然，我们必须谨慎行事。 

928
00:46:54,679 --> 00:46:57,809
We don't want to do things that are incorrect.
我们不想做不正确的事情。 

929
00:46:57,809 --> 00:47:03,960
But the way we want to modify the edge weights
但是我们想要修改边缘权重的方法

930
00:47:03,960 --> 00:47:07,769
is by having some sort of potential function
是通过具有某种潜在功能

931
00:47:07,969 --> 00:47:10,799
that corresponds to lambda.
对应于lambda。 

932
00:47:10,800 --> 00:47:13,130
And, if the edge is between u and v,
而且，如果边在u和v之间， 

933
00:47:13,329 --> 00:47:17,179
then we have an equation given a lambda that says,
那么我们有一个给出了lambda的方程式， 

934
00:47:17,179 --> 00:47:22,759
the new w, w bar, is w u, v minus lambda u plus lambda
新的w，w bar是wu，v减去lambda u加lambda 

935
00:47:22,760 --> 00:47:24,940
v. OK?
 v。好吗？ 

936
00:47:25,139 --> 00:47:29,319
Now, we have to be a little careful here, with respect
现在，我们必须在此谨慎一点

937
00:47:29,320 --> 00:47:30,650
to the choice of lambda.
选择lambda。 

938
00:47:30,849 --> 00:47:33,730
But the basic idea, in terms of lambda,
但是基本概念，就lambda而言， 

939
00:47:33,730 --> 00:47:45,719
is that, suppose you have something like this,
是的，假设您有这样的事情， 

940
00:47:45,719 --> 00:47:49,813
where you have a source vertex, s.
在其中具有源顶点的位置。 

941
00:47:49,813 --> 00:47:51,730
And you're again trying to do a single source,
您再次尝试做一个单一来源， 

942
00:47:51,730 --> 00:47:53,789
single target going to t.
单一目标去t。 

943
00:47:53,989 --> 00:47:56,809
And let's say I have an edge of weight 5 going out
假设我有5的优势

944
00:47:56,809 --> 00:47:59,429
and an edge of a 5 going out this way.
和这样的优势5的边缘。 

945
00:47:59,429 --> 00:48:03,789
Is there a way that you can guess
有没有办法可以猜到

946
00:48:03,789 --> 00:48:06,300
that this is the edge that is more
这是更多的优势

947
00:48:06,300 --> 00:48:08,550
likely to be on your shortest path?
可能是您最短的路？ 

948
00:48:08,550 --> 00:48:09,940
As opposed to this other edge?
相对于另一优势？ 

949
00:48:09,940 --> 00:48:17,429



950
00:48:17,429 --> 00:48:21,199
Essentially increase the potential
从根本上增加潜力

951
00:48:21,199 --> 00:48:23,689
of this node, all right?
这个节点的，好吗？ 

952
00:48:23,690 --> 00:48:28,400
So this node here may be the node t2.
因此，此节点可能是节点t2。 

953
00:48:28,400 --> 00:48:30,460
And this node may be the node t1.
并且该节点可以是节点t1。 

954
00:48:30,659 --> 00:48:34,389
You want to increase the potential of node t2,
您想增加节点t2的潜力， 

955
00:48:34,389 --> 00:48:35,829
such that, you're actually trying
这样，您实际上正在尝试

956
00:48:35,829 --> 00:48:38,400
to go uphill when you go this way.
这样走上坡路。 

957
00:48:38,400 --> 00:48:40,050
And this goes downhill.
这很艰难。 

958
00:48:40,050 --> 00:48:42,190
And that has the appropriate modifications
并进行了适当的修改

959
00:48:42,389 --> 00:48:45,739
on the edge weights, such that the Dijkstra algorithm is
在边缘权重上，例如Dijkstra算法是

960
00:48:45,739 --> 00:48:48,069
steered towards going downhill.
转向下坡。 

961
00:48:48,070 --> 00:48:49,420
And going down this path.
然后走这条路。 

962
00:48:49,619 --> 00:48:51,800
And it terminates a little bit quicker.
而且终止更快。 

963
00:48:51,800 --> 00:48:52,299
Right?
对？ 

964
00:48:52,300 --> 00:48:54,269
It doesn't change as asymptotic complexity.
它不会随着渐进复杂性而改变。 

965
00:48:54,269 --> 00:48:58,179
It just makes things run, in practice, a little bit faster.
实际上，它只是使事情运行得更快。 

966
00:48:58,179 --> 00:49:00,369
If you choose the right potentials.
如果您选择合适的潜力。 

967
00:49:00,369 --> 00:49:01,319
Right?
对？ 

968
00:49:01,320 --> 00:49:01,880
Feels like magic.
感觉就像魔术。 

969
00:49:02,079 --> 00:49:06,029
How do you know how to increase the potential?
您怎么知道如何增加潜力？ 

970
00:49:06,030 --> 00:49:10,010
What would you increase the potential for?
您会增加什么潜力？ 

971
00:49:10,010 --> 00:49:11,500
What nodes do you want to make uphill?
您要爬坡哪些节点？ 

972
00:49:11,699 --> 00:49:15,019
What nodes do you want to make downhill?
您想下坡哪些节点？ 

973
00:49:15,019 --> 00:49:16,909
So there's a bunch of questions.
所以有很多问题。 

974
00:49:16,909 --> 00:49:18,730
I'm not going to get into a lot of details.
我不会涉及很多细节。 

975
00:49:18,730 --> 00:49:21,380
But I will tell you a couple of things.
但是我会告诉你一些事情。 

976
00:49:21,380 --> 00:49:26,400
I'm going to give you, really quickly, a simple example
我将很快给你一个简单的例子

977
00:49:26,400 --> 00:49:30,769
that is both correct, in terms of the actual shortest path you
就您实际的最短路径而言，这都是正确的

978
00:49:30,969 --> 00:49:33,750
will get is the correct one.
会得到正确的答案。 

979
00:49:33,750 --> 00:49:37,059
And a particular mechanism off modifying
还有一种特殊的修改机制

980
00:49:37,059 --> 00:49:39,909
the potentials that uses landmarks.
利用地标的潜力。 

981
00:49:39,909 --> 00:49:40,409
Right.
对。 

982
00:49:40,409 --> 00:49:43,960
So the way we are going to do this
所以我们要做的方式

983
00:49:43,960 --> 00:49:48,210
is by saying that any path wp is going
就是说任何路径wp都会走

984
00:49:48,210 --> 00:50:05,519
to get modified based on its destination and source.
根据其目的地和来源进行修改。 

985
00:50:05,719 --> 00:50:10,489
So the only way that we can use the potential method
因此，我们可以使用潜在方法的唯一方法

986
00:50:10,489 --> 00:50:12,849
is by ensuring that all of the shortest
通过确保所有最短的

987
00:50:12,849 --> 00:50:16,699
paths between any pair of vertices, we're
任意一对顶点之间的路径

988
00:50:16,699 --> 00:50:18,789
only concerned about single source, single target here.
这里只关注单一来源，单一目标。 

989
00:50:18,989 --> 00:50:20,579
But, in general, it's a good thing
但是，总的来说，这是一件好事

990
00:50:20,579 --> 00:50:22,920
to not change any of the shortest paths.
不改变任何最短的路径。 

991
00:50:22,920 --> 00:50:24,420
So what used to be a shortest path
那曾经是最短的道路

992
00:50:24,420 --> 00:50:26,059
should stay the shortest path.
应该走最短的路。 

993
00:50:26,059 --> 00:50:27,980
And the way you do that is by having
而你要做的就是

994
00:50:27,980 --> 00:50:30,710
a potential function that, if you have an arbitrary
一个潜在的功能，如果您具有任意性

995
00:50:30,710 --> 00:50:34,920
path, essentially-- and this is a path from s to t.
本质上是路径-这是从s到t的路径。 

996
00:50:34,920 --> 00:50:36,880
That you subtract out something based
你减去一些基于

997
00:50:36,880 --> 00:50:39,099
on a function of the vertex.
在顶点的函数上。 

998
00:50:39,099 --> 00:50:40,509
In this case, you have s.
在这种情况下，您有。 

999
00:50:40,510 --> 00:50:42,000
And, in this case, you have t.
并且，在这种情况下，您有t。 

1000
00:50:42,199 --> 00:50:45,019
So the nice thing is that, any path from s to t
所以很高兴的是，从s到t的任何路径

1001
00:50:45,019 --> 00:50:48,019
is going to get shifted by the same amount, corresponding
将要移动相同的数量，对应

1002
00:50:48,019 --> 00:50:51,380
to this additional term here.
这个附加条款。 

1003
00:50:51,380 --> 00:50:53,829
So what that means is that the final shortest
所以这意味着最后的最短

1004
00:50:53,829 --> 00:50:56,789
path that you discover will be the correct shortest path.
您发现的路径将是正确的最短路径。 

1005
00:50:56,789 --> 00:51:00,079
You just may, hopefully, discover it faster.
希望您可以更快地发现它。 

1006
00:51:00,079 --> 00:51:00,710
All right?
好吧？ 

1007
00:51:00,710 --> 00:51:02,349
So that's the correctness check.
这就是正确性检查。 

1008
00:51:02,349 --> 00:51:04,969
And I'll put this in the notes.
我将其放在笔记中。 

1009
00:51:04,969 --> 00:51:08,579
And maybe the TAs can cover it in the section.
也许TA可以在本节中介绍它。 

1010
00:51:08,579 --> 00:51:12,860
But one way of getting this potential function
但是获得这种潜在功能的一种方法

1011
00:51:12,860 --> 00:51:15,559
is to use what's called a landmark.
使用所谓的地标。 

1012
00:51:15,559 --> 00:51:25,039
And so the basic idea is that you have a landmark, l,
因此，基本思路是，您具有地标性， 

1013
00:51:25,039 --> 00:51:27,739
which is a vertex belonging to v.
这是属于v的顶点。 

1014
00:51:27,739 --> 00:51:37,879
And we're going to pre-compute delta of u comma l.
我们将预先计算u逗号的增量。 

1015
00:51:37,880 --> 00:51:42,000
So, for any input vertex, you want
因此，对于任何输入顶点， 

1016
00:51:42,199 --> 00:51:44,319
to find the shortest path to this landmark.
找到通往这个地标的最短路径。 

1017
00:51:44,320 --> 00:51:47,110
So it's like, change the source, but the destination
就像更改源，但更改目标

1018
00:51:47,110 --> 00:51:48,769
stays the same.
保持不变。 

1019
00:51:48,769 --> 00:51:53,900
And the potential lambda t u is defined
并定义了潜在的lambda tu 

1020
00:51:53,900 --> 00:52:00,840
as delta of u, l minus delta of t, l.
作为u，l的增量减去t，l的增量。 

1021
00:52:00,840 --> 00:52:01,340
OK?
好？ 

1022
00:52:01,340 --> 00:52:02,690
So you have the source, s.
因此，您有来源。 

1023
00:52:02,889 --> 00:52:04,309
You have a destination, t.
您有目的地，t。 

1024
00:52:04,309 --> 00:52:08,179
And now you have a landmark, l.
现在您有了一个里程碑。 

1025
00:52:08,179 --> 00:52:16,710
I'm going to pre-compute delta u,l for all u belonging to v.
我将为属于v的所有u预先计算delta u，l。 

1026
00:52:16,710 --> 00:52:21,449
And I'm also going to pre-compute, for a given t,
对于给定的t，我还要进行预计算

1027
00:52:21,449 --> 00:52:22,219
delta t, l.
三角洲湖

1028
00:52:22,219 --> 00:52:23,719
So that's just a single t.
因此，这仅是一个t。 

1029
00:52:23,719 --> 00:52:25,369
So that's just one computation.
因此，这只是一种计算。 

1030
00:52:25,369 --> 00:52:28,380
This one is much more computation.
这是更多的计算。 

1031
00:52:28,380 --> 00:52:35,360
And, if I use this potential, you can show that it's correct,
而且，如果我利用这一潜力，您可以证明它是正确的， 

1032
00:52:35,360 --> 00:52:37,349
using the triangle inequality.
使用三角形不等式。 

1033
00:52:37,349 --> 00:52:40,239
And this is not a heuristic.
这不是启发式的。 

1034
00:52:40,239 --> 00:52:42,529
With the correct choice of landmark,
正确选择地标， 

1035
00:52:42,530 --> 00:52:45,769
Dijkstra, empirically, will run faster.
根据经验，Dijkstra将运行得更快。 

1036
00:52:45,969 --> 00:52:47,659
So, if you know for sure that you
因此，如果您确定知道自己

1037
00:52:47,659 --> 00:52:50,029
need to go through middle America to get from Cal Tech
需要经历中美洲才能从Cal Tech获得

1038
00:52:50,030 --> 00:52:54,030
to Boston-- and there's one particular landmark
到波士顿-有一个特别的地标

1039
00:52:54,030 --> 00:52:58,500
you want to go through-- Texas or something.
您想经历-德州之类的

1040
00:52:58,500 --> 00:53:02,840
And you pick Austin, Texas, then you can do this computation.
然后选择德克萨斯州的奥斯丁，然后就可以进行此计算了。 

1041
00:53:02,840 --> 00:53:07,250
And maybe Dijkstra runs 2x faster, 20% faster.
也许Dijkstra的运行速度快了2倍，快了20％。 

1042
00:53:07,250 --> 00:53:07,769
All right?
好吧？ 

1043
00:53:07,769 --> 00:53:10,590
I'll put the argument about correctness, and the specifics
我会提出关于正确性和具体性的论点

1044
00:53:10,590 --> 00:53:12,789
of these things, in the notes.
这些东西，在笔记中。 

1045
00:53:12,789 --> 00:53:17,789
And you can take a look at it offline.
您可以离线查看它。 

