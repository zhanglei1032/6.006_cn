1
00:00:00,000 --> 00:00:00,060



2
00:00:00,060 --> 00:00:01,770
The following content is provided
提供以下内容

3
00:00:01,770 --> 00:00:04,009
under a Creative Commons license.
根据知识共享许可。 

4
00:00:04,009 --> 00:00:06,859
Your support will help MIT OpenCourseWare continue
您的支持将帮助MIT OpenCourseWare继续

5
00:00:06,860 --> 00:00:10,720
to offer high-quality educational resources for free.
免费提供高质量的教育资源。 

6
00:00:10,720 --> 00:00:13,339
To make a donation or view additional materials
捐款或查看其他材料

7
00:00:13,339 --> 00:00:17,225
from hundreds of MIT courses, visit MIT OpenCourseWare
从数百门麻省理工学院的课程中，访问MIT OpenCourseWare 

8
00:00:17,225 --> 00:00:17,850
at ocw.mit.edu.
在ocw.mit.edu。 

9
00:00:17,850 --> 00:00:22,030



10
00:00:22,030 --> 00:00:25,070
PROFESSOR: So did everyone turn in PSET1?
教授：那么每个人都上交PSET1吗？ 

11
00:00:25,269 --> 00:00:25,769
Yes?
是？ 

12
00:00:25,769 --> 00:00:27,219
Good.
好。 

13
00:00:27,219 --> 00:00:30,759
OK, so there is a PSET1 critique due in a few days.
好的，几天后将有一个PSET1评论。 

14
00:00:30,760 --> 00:00:32,189
My advice?
我的建议？ 

15
00:00:32,189 --> 00:00:33,215
You already did PSET1.
您已经做过PSET1。 

16
00:00:33,215 --> 00:00:35,090
You remember what you wrote out on the proof.
您还记得您在证明上写的内容。 

17
00:00:35,090 --> 00:00:36,506
Look at the solution.
查看解决方案。 

18
00:00:36,506 --> 00:00:38,630
Write one paragraph today, and you're done with it.
今天写一个段落，就完成了。 

19
00:00:38,630 --> 00:00:40,599
Then you go focus on PSET2.
然后，您将重点放在PSET2上。 

20
00:00:40,799 --> 00:00:42,333
If you leave it off until Tuesday,
如果您推迟到周二， 

21
00:00:42,334 --> 00:00:44,250
you're going to have to read your proof again,
您将不得不再次阅读证明， 

22
00:00:44,250 --> 00:00:46,369
remember what you're thinking.
记住你在想什么。 

23
00:00:46,369 --> 00:00:47,576
It's a lot more work.
还有很多工作要做。 

24
00:00:47,576 --> 00:00:49,159
Just do it now, get it out of the way,
现在就做，摆脱它， 

25
00:00:49,159 --> 00:00:51,465
and put PSET1 behind you.
并把PSET1放在你身后。 

26
00:00:51,466 --> 00:00:53,340
AUDIENCE: Is the critique only for the proof?
听众：批评只是为了证明？ 

27
00:00:53,340 --> 00:00:54,583
Or is this for all of them?
还是所有这些都适合？ 

28
00:00:54,783 --> 00:00:55,449
PROFESSOR: Nope.
教授：不。 

29
00:00:55,450 --> 00:00:56,399
Just the proof.
只是证明。 

30
00:00:56,399 --> 00:00:58,439
So you have to compare your proof with our proof?
因此，您必须将您的证明与我们的证明进行比较？ 

31
00:00:58,439 --> 00:01:01,128



32
00:01:01,128 --> 00:01:02,880
AUDIENCE: Is there an assignment for that?
听众：是否有作业？ 

33
00:01:02,880 --> 00:01:04,876
Or do we just know to do it?
还是我们只知道这样做？ 

34
00:01:04,876 --> 00:01:05,609
PROFESSOR: Uh.
教授：嗯。 

35
00:01:05,609 --> 00:01:07,474
PSET1 be Stellar.
 PSET1是恒星。 

36
00:01:07,474 --> 00:01:09,989



37
00:01:09,989 --> 00:01:10,579
Oh, no, sorry.
哦，不，对不起。 

38
00:01:10,579 --> 00:01:11,412
It's not in Stellar.
它不在恒星中。 

39
00:01:11,412 --> 00:01:13,579
It's on our new grading site that just went out.
只是在我们刚刚发布的新评分网站上。 

40
00:01:13,579 --> 00:01:15,329
So you have to go to our new grading site,
因此，您必须转到我们的新评分网站， 

41
00:01:15,329 --> 00:01:17,500
and you have to type in your critique there.
而且您必须在此处输入您的评论。 

42
00:01:17,500 --> 00:01:18,790
And it's one paragraph.
这是一个段落。 

43
00:01:18,790 --> 00:01:20,019
You should aim for one paragraph.
您应该瞄准一个段落。 

44
00:01:20,219 --> 00:01:21,760
If you're doing more than that, then you're
如果您要做的不止这些，那您就是

45
00:01:21,760 --> 00:01:22,676
doing something wrong.
做错了事。 

46
00:01:22,676 --> 00:01:25,299
And it's LATEX Plus math mode.
这是LATEX Plus数学模式。 

47
00:01:25,299 --> 00:01:29,459
So you can use math mode, and that's about it.
因此，您可以使用数学模式，仅此而已。 

48
00:01:29,459 --> 00:01:31,851
OK, any more questions about the critique?
好吧，关于评论还有其他问题吗？ 

49
00:01:31,852 --> 00:01:32,560
It's a new thing.
这是新事物。 

50
00:01:32,560 --> 00:01:35,159
We care about it because it will make our grading life easier.
我们很在意它，因为它会使我们的分级生活变得更加轻松。 

51
00:01:35,159 --> 00:01:37,359
And because it'll force you to look at the solutions and see
而且因为它会迫使您查看解决方案并查看

52
00:01:37,359 --> 00:01:39,129
what you understood and what you didn't.
你了解什么，你不了解什么。 

53
00:01:39,129 --> 00:01:40,060
So we care about it.
因此，我们关心它。 

54
00:01:40,060 --> 00:01:41,759
Don't ignore it.
不要忽略它。 

55
00:01:41,959 --> 00:01:43,637
Yes?
是？ 

56
00:01:43,638 --> 00:01:45,304
AUDIENCE: Like, how much is it weighted?
听众：像，它加权了多少？ 

57
00:01:45,304 --> 00:01:48,293
How much does it count toward the grade?
多少计入年级？ 

58
00:01:48,293 --> 00:01:49,959
PROFESSOR: If you don't have a critique,
教授：如果您没有批评意见， 

59
00:01:49,959 --> 00:01:53,393
we will most likely give you a 0 for proof.
我们很可能会给您0作为证明。 

60
00:01:53,394 --> 00:01:54,310
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

61
00:01:54,310 --> 00:01:57,149



62
00:01:57,349 --> 00:02:00,069
PROFESSOR: If your proof is bad and your critique of the proof
教授：如果您的证明不正确，并且您对证明的批评

63
00:02:00,069 --> 00:02:02,069
is good, then you might get something.
是好的，那么你可能会得到一些。 

64
00:02:02,069 --> 00:02:04,369
If your proof is bad and you have no critique--
如果您的证明不正确，并且没有批评意见， 

65
00:02:04,370 --> 00:02:06,370
actually if your proof is whatever it is and you
实际上，如果您的证明是事实，并且您

66
00:02:06,370 --> 00:02:07,618
have no critique, you get a 0.
没有评论，您得到0。 

67
00:02:07,618 --> 00:02:10,032
AUDIENCE: Yeah. [CHUCKLE]
听众：是的。 [笑声] 

68
00:02:10,032 --> 00:02:11,740
PROFESSOR: Any more questions about that?
教授：还有其他问题吗？ 

69
00:02:11,740 --> 00:02:14,870



70
00:02:14,870 --> 00:02:17,080
OK.
好。 

71
00:02:17,080 --> 00:02:20,740
Who needs help remembering what the document distance
谁需要帮助记住文档距离

72
00:02:20,740 --> 00:02:21,960
problem is?
问题是？ 

73
00:02:21,960 --> 00:02:24,909



74
00:02:24,909 --> 00:02:25,409
OK.
好。 

75
00:02:25,409 --> 00:02:28,349
Everyone who went to lecture or to [INAUDIBLE] remembers.
参加演讲或[听不清]的每个人都记得。 

76
00:02:28,349 --> 00:02:29,840
That's good.
那很好。 

77
00:02:29,840 --> 00:02:31,360
Who went to lecture last time?
上次谁去讲课？ 

78
00:02:31,360 --> 00:02:34,520



79
00:02:34,719 --> 00:02:35,289
Cool.
凉。 

80
00:02:35,289 --> 00:02:36,009
That's good.
那很好。 

81
00:02:36,009 --> 00:02:38,560
So we did insertion sort and merge sort
所以我们做了插入排序和合并排序

82
00:02:38,560 --> 00:02:39,969
from a theoretical standpoint.
从理论上讲。 

83
00:02:39,969 --> 00:02:42,850
Today we're going to look at the code for the insertion sort
今天，我们将看一下插入排序的代码

84
00:02:42,850 --> 00:02:45,099
and, if we have time, look at the code for merge-sort,
如果有时间，请查看合并排序的代码， 

85
00:02:45,099 --> 00:02:48,659
and use the same strategy as we did last time to analyze them,
并使用与上次分析时相同的策略， 

86
00:02:48,659 --> 00:02:51,289
look at the running time, make sure the running time matches
查看运行时间，确保运行时间匹配

87
00:02:51,289 --> 00:02:55,409
the theory, and see how pseudocode turns into Python.
理论，并了解伪代码如何变成Python。 

88
00:02:55,409 --> 00:02:59,009



89
00:02:59,009 --> 00:03:01,689
So you all have your listings.
所以大家都有您的清单。 

90
00:03:01,689 --> 00:03:05,789
Last time in document distance, we covered Main,
上次是文档距离，我们介绍了Main， 

91
00:03:05,789 --> 00:03:07,569
and we covered most of the functions
我们涵盖了大多数功能

92
00:03:07,569 --> 00:03:10,449
except for count frequency.
除了计数频率。 

93
00:03:10,449 --> 00:03:15,199
Can anyone remind me what the call graph looked like?
谁能提醒我调用图的样子？ 

94
00:03:15,199 --> 00:03:16,699
So the call graph is the tree that I
所以调用图就是我的树

95
00:03:16,699 --> 00:03:18,989
had up on the left, and it started at Main.
在左上方，它从Main开始。 

96
00:03:18,990 --> 00:03:28,650



97
00:03:28,650 --> 00:03:29,150
Thank you.
谢谢。 

98
00:03:29,150 --> 00:03:31,810



99
00:03:31,810 --> 00:03:40,610
So Main calls word frequencies for file, which in turn calls?
那么Main调用文件的单词频率，哪个依次调用？ 

100
00:03:40,610 --> 00:03:42,270
AUDIENCE: Well, it's probably line list.
听众：嗯，可能是线路清单。 

101
00:03:42,469 --> 00:03:43,090
PROFESSOR: OK.
教授：好的。 

102
00:03:43,090 --> 00:03:45,042
AUDIENCE: And count frequency.
听众：并计算频率。 

103
00:03:45,042 --> 00:03:51,189



104
00:03:51,389 --> 00:03:54,149
PROFESSOR: So we pretend we don't see the read file called.
教授：所以我们假装看不到读取的文件。 

105
00:03:54,150 --> 00:03:57,360
We assume that the data is already in memory
我们假设数据已经在内存中

106
00:03:57,360 --> 00:03:59,770
or that the call takes time that's
或通话需要花费时间

107
00:03:59,969 --> 00:04:03,729
proportional to the running-- to the length of the file.
与文件的长度成正比。 

108
00:04:03,729 --> 00:04:07,036
And we only look at get-word from line list and count
我们只看行列表中的获取单词并计数

109
00:04:07,036 --> 00:04:07,534
frequency.
频率。 

110
00:04:07,534 --> 00:04:13,340



111
00:04:13,340 --> 00:04:14,189
OK.
好。 

112
00:04:14,389 --> 00:04:17,072
Who else does Main call?
 Main还打电话给谁？ 

113
00:04:17,072 --> 00:04:17,829
AUDIENCE: Vector angle?
听众：矢量角？ 

114
00:04:18,029 --> 00:04:25,759



115
00:04:25,759 --> 00:04:28,623
PROFESSOR: And the vector angle?
教授：矢量角？ 

116
00:04:28,624 --> 00:04:29,624
AUDIENCE: Inner product.
受众：内部产品。 

117
00:04:29,624 --> 00:04:37,817



118
00:04:38,016 --> 00:04:38,600
PROFESSOR: OK.
教授：好的。 

119
00:04:38,600 --> 00:04:43,370
Let's put up the constants for-- for the document distance
让我们为文档距离设置常量

120
00:04:43,370 --> 00:04:46,720
problem that we used last time.
我们上次使用的问题。 

121
00:04:46,720 --> 00:04:51,579
So we said that the document has W words.
所以我们说文件有W字。 

122
00:04:51,779 --> 00:04:54,169
And then when you take that list of words
然后当你把那个单词列表

123
00:04:54,170 --> 00:04:57,129
and you turn it into a distance vector,
然后把它变成距离矢量

124
00:04:57,329 --> 00:04:59,849
you will get assigned to a document vector.
您将被分配到文档向量。 

125
00:04:59,850 --> 00:05:04,180
You will get L elements, which basically means L unique words.
您将获得L个元素，这基本上意味着L个唯一词。 

126
00:05:04,180 --> 00:05:09,730
So L is the document vector length.
所以L是文档向量长度。 

127
00:05:09,730 --> 00:05:12,329
And we assume we're using a natural language like English,
我们假设我们使用的是自然语言，例如英语， 

128
00:05:12,529 --> 00:05:15,089
so all the words are bounded in size.
因此所有单词的大小都有限制。 

129
00:05:15,089 --> 00:05:17,469
Like 5 to 10 characters, for example.
例如5到10个字符。 

130
00:05:17,470 --> 00:05:20,009
And to make our life easier, we say
为了使我们的生活更轻松，我们说

131
00:05:20,209 --> 00:05:30,430
all the words have the same size W. So w is the word length.
所有的单词都具有相同的大小W。因此w是单词长度。 

132
00:05:30,430 --> 00:05:32,810
Using these numbers, can anyone remind me
使用这些数字，谁能提醒我

133
00:05:32,810 --> 00:05:36,189
what we said the costs for these methods are?
我们说这些方法的成本是多少？ 

134
00:05:36,189 --> 00:05:38,689
And we didn't analyze count frequency,
而且我们没有分析计数频率

135
00:05:38,689 --> 00:05:40,740
so it's OK to not take my word for it
所以不要相信我的话

136
00:05:40,740 --> 00:05:42,800
and not tell me what I said last time.
不要告诉我我上次说的话

137
00:05:42,800 --> 00:05:46,009
But I would like numbers for word frequencies from file,
但是我想从文件中获取单词频率的数字， 

138
00:05:46,009 --> 00:05:50,084
get word from line list, vector angle, and inner product.
从行列表，矢量角度和内积中获取单词。 

139
00:05:50,084 --> 00:05:51,915
AUDIENCE: Was that mu squared?
听众：那个亩平方吗？ 

140
00:05:51,915 --> 00:05:53,160
That was last time.
那是最后一次。 

141
00:05:53,160 --> 00:05:55,180
PROFESSOR: OK.
教授：好的。 

142
00:05:55,379 --> 00:05:57,149
Which-- which one?
哪个-哪个？ 

143
00:05:57,149 --> 00:06:01,409
Does anyone-- does anyone else want to try?
是否有人-其他人想要尝试吗？ 

144
00:06:01,410 --> 00:06:03,579
Let's not do guessing.
我们不要猜测。 

145
00:06:03,779 --> 00:06:08,289
I'll pull them up if nobody remembers.
如果没人记得，我会把它们拉起来。 

146
00:06:08,290 --> 00:06:10,910
I spent an entire hour on that, and you guys did too.
我花了整整一个小时，你们也做了。 

147
00:06:10,910 --> 00:06:11,574
It was painful.
真痛苦

148
00:06:11,574 --> 00:06:12,081
AUDIENCE: I know.
听众：我知道。 

149
00:06:12,281 --> 00:06:14,923
But we had to, like, you know, add them up, and then--
但是我们必须像您所知道的那样将它们加起来，然后- 

150
00:06:14,923 --> 00:06:15,589
PROFESSOR: Yeah.
教授：是的。 

151
00:06:15,589 --> 00:06:17,339
So we did a lot of work for those numbers.
因此，我们为这些数字做了很多工作。 

152
00:06:17,339 --> 00:06:20,279



153
00:06:20,279 --> 00:06:24,349
So get word from line list was order of W squared.
因此从行列表中得到单词是W的平方。 

154
00:06:24,350 --> 00:06:26,490
Does anyone remember why?
有谁记得为什么？ 

155
00:06:26,490 --> 00:06:29,220
What made it take so much time?
是什么导致了这么长时间？ 

156
00:06:29,220 --> 00:06:33,819



157
00:06:34,019 --> 00:06:36,899
AUDIENCE: 'Cause you append it to the word list.
听众：因为您将它附加到单词列表中。 

158
00:06:36,899 --> 00:06:39,466
For, like, you add it to the end to go through.
例如，您可以将其添加到末尾进行操作。 

159
00:06:39,466 --> 00:06:40,050
PROFESSOR: OK.
教授：好的。 

160
00:06:40,050 --> 00:06:43,819



161
00:06:43,819 --> 00:06:44,529
So you add it.
因此，您添加了它。 

162
00:06:44,529 --> 00:06:45,919
So what?
所以呢？ 

163
00:06:45,920 --> 00:06:47,922
AUDIENCE: So, like, every time you need it,
听众：因此，就像您每次需要时一样， 

164
00:06:47,922 --> 00:06:52,060
you, like, do word list equals word list plus words in line.
您喜欢单词列表等于单词列表加上行中的单词。 

165
00:06:52,259 --> 00:06:53,069
PROFESSOR: OK.
教授：好的。 

166
00:06:53,069 --> 00:06:55,300
Excellent.
优秀的。 

167
00:06:55,300 --> 00:06:58,199
So get words from line list, line five.
因此，从第五行的行列表中获取单词。 

168
00:06:58,199 --> 00:06:59,579
There's a plus there.
有一个加号。 

169
00:06:59,579 --> 00:07:03,629
And that plus sign messes up the performance.
那个加号会破坏性能。 

170
00:07:03,629 --> 00:07:06,889
So that's why it's w squared.
这就是为什么它平方的原因。 

171
00:07:06,889 --> 00:07:08,800
Count frequency, we didn't cover it,
计算频率，我们没有涵盖它， 

172
00:07:08,800 --> 00:07:10,160
you had to take my word for it.
你必须相信我的话。 

173
00:07:10,160 --> 00:07:12,199
So we will cover it now.
因此，我们现在将进行介绍。 

174
00:07:12,399 --> 00:07:15,144
And, inner product.
而且，内部产品。 

175
00:07:15,144 --> 00:07:26,060



176
00:07:26,060 --> 00:07:29,610
So suppose you have two vectors of line-- length L1 and L2.
因此，假设您有两个线向量-长度L1和L2。 

177
00:07:29,610 --> 00:07:32,699
How much time does it take to compute the inner product?
计算内积需要多少时间？ 

178
00:07:32,699 --> 00:07:34,491
AUDIENCE: L1, L2 time.
听众：L1，L2时间。 

179
00:07:34,492 --> 00:07:34,875
PROFESSOR: OK.
教授：好的。 

180
00:07:35,074 --> 00:07:38,879



181
00:07:38,879 --> 00:07:40,969
So how much time does vector angle take?
那么矢量角度需要多少时间？ 

182
00:07:40,970 --> 00:07:48,134



183
00:07:48,334 --> 00:07:49,317
AUDIENCE: L1 L2 time.
听众：L1 L2时间。 

184
00:07:49,317 --> 00:07:53,750



185
00:07:53,750 --> 00:07:56,509
PROFESSOR: L1 L2.
教授：L1 L2。 

186
00:07:56,509 --> 00:07:57,800
So it makes three calls, right?
这样就打了三个电话，对不对？ 

187
00:07:57,800 --> 00:07:59,069
You get the two things.
您得到两件事。 

188
00:07:59,269 --> 00:08:02,449
First, it computes the inner product of the two lists.
首先，它计算两个列表的内积。 

189
00:08:02,449 --> 00:08:05,889
And then it has to compute the inner product of each vector--
然后它必须计算每个向量的内积

190
00:08:05,889 --> 00:08:08,358
of each document vector with itself.
每个文档向量本身。 

191
00:08:08,358 --> 00:08:10,524
Because that's what's on the bottom of the fraction.
因为那是分数的底部。 

192
00:08:10,524 --> 00:08:13,329



193
00:08:13,329 --> 00:08:15,209
So what's the running time for that?
那么，这是什么时间？ 

194
00:08:15,209 --> 00:08:18,709
AUDIENCE: Plus L1 squared, plus L2 squared.
听众：加L1平方，加L2平方。 

195
00:08:18,709 --> 00:08:22,879
PROFESSOR: Plus L1 squared, plus L2 squared.
教授：加L1平方，加L2平方。 

196
00:08:22,879 --> 00:08:25,379
So someone was really helpful last time and asked me,
所以上次有人真的很有帮助，问我， 

197
00:08:25,379 --> 00:08:27,600
can you make this simpler with some math?
您可以通过一些数学使它更简单吗？ 

198
00:08:27,600 --> 00:08:29,879
And I said, I don't know so I don't think I will.
我说，我不知道，所以我认为我不会。 

199
00:08:30,079 --> 00:08:32,819
But I looked at-- my, I looked at my high school math
但是我看着-我看着高中数学

200
00:08:32,820 --> 00:08:37,348
afterwards, and it turns out that these-- so L1 squared
之后，事实证明这些-所以L1平方

201
00:08:37,548 --> 00:08:40,829
plus L2 squared are guaranteed to be greater than L1 L2
加上L2平方保证大于L1 L2 

202
00:08:40,830 --> 00:08:43,009
as long as these numbers are positive.
只要这些数字为正。 

203
00:08:43,009 --> 00:08:44,349
And we're working with document list,
我们正在处理文件清单， 

204
00:08:44,549 --> 00:08:46,349
so they're always positive.
所以他们总是很积极的。 

205
00:08:46,350 --> 00:08:49,154
So this will go away.
因此，这将消失。 

206
00:08:49,154 --> 00:08:54,319



207
00:08:54,320 --> 00:09:00,080
So let's assume count frequency is w squared or smaller.
因此，假设计数频率为w平方或更小。 

208
00:09:00,080 --> 00:09:03,109
So the total running time for word frequencies from file
因此，文件中单词频率的总运行时间

209
00:09:03,309 --> 00:09:06,579
is w squared.
 w平方。 

210
00:09:06,580 --> 00:09:08,099
What's the running time for everything?
一切的运行时间是多少？ 

211
00:09:08,299 --> 00:09:13,113



212
00:09:13,114 --> 00:09:14,579
AUDIENCE: Would just be, like, w squared
听众：就像

213
00:09:14,779 --> 00:09:17,409
plus L1 squared plus L2 squared?
加L1平方加L2平方？ 

214
00:09:17,409 --> 00:09:18,159
PROFESSOR: Almost.
教授：差不多了。 

215
00:09:18,159 --> 00:09:20,329
AUDIENCE: Actually, it depends on which one's greater, right?
听众：实际上，取决于哪个更大，对吗？ 

216
00:09:20,330 --> 00:09:21,330
PROFESSOR: Well, almost.
教授：好吧，差不多。 

217
00:09:21,330 --> 00:09:27,580
So here W works, assuming you get one document with W words.
因此，这里W工作，假设您得到一个包含W个单词的文档。 

218
00:09:27,580 --> 00:09:30,230
But word frequencies from files is called twice, once
但是文件中的单词频率被调用两次，一次

219
00:09:30,230 --> 00:09:31,870
for each document.
对于每个文档。 

220
00:09:31,870 --> 00:09:35,859
First document has W1 words, second document has W2 words.
第一个文档具有W1个单词，第二个文档具有W2个单词。 

221
00:09:36,059 --> 00:09:38,973
So what's the running time?
那么，运行时间是多少？ 

222
00:09:38,974 --> 00:09:42,750
AUDIENCE: W1 squared plus W2 squared.
听众：W1平方加W2平方。 

223
00:09:42,750 --> 00:09:48,000
PROFESSOR: W1 squared plus W2 squared.
教授：W1平方加W2平方。 

224
00:09:48,000 --> 00:09:50,200
So I take this, and I add this.
因此，我接受了这个，并添加了这个。 

225
00:09:50,200 --> 00:09:51,590
Right?
对？ 

226
00:09:51,590 --> 00:09:55,379
Except when I add this, if I want to add L1 squared,
除了添加时，如果要添加L1平方， 

227
00:09:55,379 --> 00:09:58,289
I know L1 is the number of unique documents--
我知道L1是唯一文档的数量- 

228
00:09:58,289 --> 00:10:00,599
of unique words in the document.
文档中唯一词的集合。 

229
00:10:00,600 --> 00:10:04,450
And W1 is the total number of words in the document.
 W1是文档中单词的总数。 

230
00:10:04,450 --> 00:10:07,177
W1 guaranteed to be greater or equal than L1,
 W1保证大于或等于L1， 

231
00:10:07,177 --> 00:10:08,259
so it's going to dominate.
因此它将占主导地位。 

232
00:10:08,259 --> 00:10:09,439
I don't need to add it.
我不需要添加它。 

233
00:10:09,440 --> 00:10:11,360
Same for L2.
与L2相同。 

234
00:10:11,360 --> 00:10:12,177
This is it.
就是这个。 

235
00:10:12,177 --> 00:10:15,200



236
00:10:15,200 --> 00:10:15,700
OK.
好。 

237
00:10:15,700 --> 00:10:17,853
You guys don't seem to remember the numbers for these.
你们似乎不记得这些数字了。 

238
00:10:18,053 --> 00:10:20,220
So that means I didn't torture you enough last time.
所以这意味着我上次没有对你施加足够的酷刑。 

239
00:10:20,220 --> 00:10:21,830
So let's do more.
因此，让我们做更多。 

240
00:10:21,830 --> 00:10:23,069
Let's look at count frequency.
让我们看一下计数频率。 

241
00:10:23,269 --> 00:10:27,750
And let's compute the cost for that.
然后，我们为此计算成本。 

242
00:10:27,750 --> 00:10:36,830



243
00:10:36,830 --> 00:10:40,730
So what we did last time was, we went through each line of code.
因此，上次我们要做的是，遍历了每一行代码。 

244
00:10:40,730 --> 00:10:42,820
We thought, how much time does it
我们认为，要花多少时间

245
00:10:42,820 --> 00:10:44,349
take to execute the line once?
需要执行一次该行？ 

246
00:10:44,549 --> 00:10:46,709
And how many times does the line run?
线路运行多少次？ 

247
00:10:46,710 --> 00:10:49,618
And then we compute the product of that, add everything up,
然后我们计算其乘积，将所有内容相加， 

248
00:10:49,818 --> 00:10:51,360
and that's the cost for the function.
这就是功能的成本。 

249
00:10:51,360 --> 00:10:55,940



250
00:10:55,940 --> 00:10:58,059
First off, before I put numbers here,
首先，在我把数字放在这里之前， 

251
00:10:58,259 --> 00:10:59,539
what does the method to do?
该怎么办？ 

252
00:10:59,539 --> 00:11:09,480



253
00:11:09,480 --> 00:11:12,039
AUDIENCE: It takes a list of words--
听众：它需要一个单词列表- 

254
00:11:12,039 --> 00:11:12,730
PROFESSOR: OK.
教授：好的。 

255
00:11:12,730 --> 00:11:16,149
AUDIENCE: For each item in that list,
听众：对于该列表中的每个项目， 

256
00:11:16,149 --> 00:11:17,870
checks to see if it's-- you know,
检查是否是-您知道， 

257
00:11:17,870 --> 00:11:25,407
list of words that it's-- counted, right?
它是的单词列表，对不对？ 

258
00:11:25,407 --> 00:11:25,990
PROFESSOR: OK.
教授：好的。 

259
00:11:25,990 --> 00:11:28,289
So you're telling me what the code does.
所以你告诉我代码是做什么的。 

260
00:11:28,289 --> 00:11:29,009
AUDIENCE: Yeah.
听众：是的。 

261
00:11:29,009 --> 00:11:31,069
PROFESSOR: Try to look at Main or try
教授：尝试看一下Main或尝试

262
00:11:31,070 --> 00:11:33,219
to look at word frequencies for files.
查看文件的字频。 

263
00:11:33,419 --> 00:11:36,539
So look at it top-down, and tell me what the purpose of it is.
因此，请自上而下查看它，并告诉我它的用途是什么。 

264
00:11:36,539 --> 00:11:38,309
What's the goal?
目标是什么？ 

265
00:11:38,309 --> 00:11:45,107
AUDIENCE: Making a list of-- and each object
听众：列出-和每个对象

266
00:11:45,107 --> 00:11:47,399
is a list with a word and a number.
是一个带有单词和数字的列表。 

267
00:11:47,399 --> 00:11:48,220
PROFESSOR: OK.
教授：好的。 

268
00:11:48,220 --> 00:11:49,100
Excellent.
优秀的。 

269
00:11:49,100 --> 00:11:51,589
So big picture, I have the first document.
太大了，我有了第一个文件。 

270
00:11:51,789 --> 00:11:52,639
I read it in.
我读了。 

271
00:11:52,639 --> 00:11:54,105
I break it up into words.
我把它分解成文字。 

272
00:11:54,105 --> 00:11:55,230
And I have a list of words.
我有一个词表。 

273
00:11:55,230 --> 00:11:58,379
That's what word frequencies for file
那就是文件的单词频率

274
00:11:58,379 --> 00:12:00,919
gives me-- sorry, that's what you get words from line list
给我-抱歉，这就是您从行列表中得到的单词

275
00:12:00,919 --> 00:12:02,189
gives me.
给我。 

276
00:12:02,190 --> 00:12:02,689
List of words.
单词列表。 

277
00:12:02,889 --> 00:12:08,720



278
00:12:08,720 --> 00:12:16,000
The fox is in the hat.
狐狸在帽子里。 

279
00:12:16,000 --> 00:12:18,679



280
00:12:18,679 --> 00:12:21,599
And this gets passed to count frequency,
然后传递给计数频率， 

281
00:12:21,600 --> 00:12:24,700
and count frequency gives me, you said,
你说频率可以给我

282
00:12:24,700 --> 00:12:27,229
an object, which is a list.
一个对象，它是一个列表。 

283
00:12:27,429 --> 00:12:30,179
Of lists, where each of them has the word
在列表中，每个列表都有一个单词

284
00:12:30,179 --> 00:12:31,589
and how many times it shows up.
以及它出现了多少次。 

285
00:12:31,590 --> 00:12:39,509
So I would have "the" shows up twice, "fox" shows up
所以我会让“ the”出现两次，“ fox”出现

286
00:12:39,509 --> 00:12:51,110
once, "is" shows up once, "in" shows up once,
一次，“是”显示一次，“中”显示一次， 

287
00:12:51,110 --> 00:12:56,110
and-- I need a shorter example-- "hat" shows up once.
并且-我需要一个简短的例子-“帽子”出现一次。 

288
00:12:56,110 --> 00:12:58,154
So it takes this and turns it into that.
因此，它需要把它变成那个。 

289
00:12:58,154 --> 00:13:01,839



290
00:13:01,840 --> 00:13:05,090
So on line 2, I have a list L that's initialized.
因此，在第2行上，我有一个已初始化的列表L。 

291
00:13:05,090 --> 00:13:06,769
And then, at the end, it's returned.
然后，最后将其返回。 

292
00:13:06,769 --> 00:13:09,840
So I'm going to guess that L is going to look like this.
因此，我将猜测L会看起来像这样。 

293
00:13:09,840 --> 00:13:13,350



294
00:13:13,350 --> 00:13:16,849
Line 3, for new word in word list, iterates over the input.
第3行，对于单词列表中的新单词，遍历输入。 

295
00:13:17,049 --> 00:13:19,429
So iterates over this.
因此，对此进行迭代。 

296
00:13:19,429 --> 00:13:23,339
And then, line 4 checks to see, for each new word,
然后，第4行检查每个新单词， 

297
00:13:23,340 --> 00:13:26,149
it looks at the list that I have under construction.
它会查看我正在构建的列表。 

298
00:13:26,149 --> 00:13:30,949
So exam-- for example, if I ran through all the words
所以考试-例如，如果我读完所有单词

299
00:13:30,950 --> 00:13:33,360
and then I'm trying to put in hat right now,
然后我现在想戴上帽子， 

300
00:13:33,360 --> 00:13:35,250
I wouldn't have it here.
我不会在这里。 

301
00:13:35,250 --> 00:13:39,889
What line 4 does is, it looks at all the entries.
第4行所做的是，它查看所有条目。 

302
00:13:39,889 --> 00:13:42,710
And it says, if I can find the words--
它说，如果我能找到这些话， 

303
00:13:42,710 --> 00:13:44,979
so if I can find the word hat somewhere here--
所以如果我在这里的某个地方找到帽子一词- 

304
00:13:45,179 --> 00:13:47,089
then increment the number.
然后增加数字。 

305
00:13:47,090 --> 00:13:49,642
If I can't, then make a new entry
如果不能，请重新输入

306
00:13:49,642 --> 00:13:52,100
and say that the word shows up once, because it's the first
说这个词出现一次，因为它是第一个

307
00:13:52,100 --> 00:13:52,600
I see it.
我看到了。 

308
00:13:52,600 --> 00:13:56,340



309
00:13:56,340 --> 00:13:57,590
So this is what the code does.
这就是代码的作用。 

310
00:13:57,590 --> 00:14:01,639
Now let's see how fast it does that.
现在让我们看看它的执行速度。 

311
00:14:01,639 --> 00:14:07,449
So line 2 initialize the output to an empty list.
因此，第2行将输出初始化为一个空列表。 

312
00:14:07,450 --> 00:14:10,071
What's the cost for that?
这要花多少钱？ 

313
00:14:10,071 --> 00:14:10,988
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

314
00:14:10,988 --> 00:14:11,661
PROFESSOR: Very good.
教授：非常好。 

315
00:14:11,861 --> 00:14:12,579
How many times?
多少次？ 

316
00:14:12,580 --> 00:14:18,370



317
00:14:18,370 --> 00:14:19,609
For new word in word lists.
对于单词列表中的新单词。 

318
00:14:19,809 --> 00:14:20,309
Cost?
成本？ 

319
00:14:20,309 --> 00:14:23,725



320
00:14:23,725 --> 00:14:26,679
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

321
00:14:26,679 --> 00:14:29,069
I know the cost is 1.
我知道费用是1。 

322
00:14:29,070 --> 00:14:32,330
PROFESSOR: OK, so we are-- here, it's a bit confusing, right?
教授：好的，我们在这里，这有点令人困惑，对吧？ 

323
00:14:32,330 --> 00:14:35,610
We're saying that, oh, there's does iteration over a list.
我们的意思是，哦，列表上有迭代。 

324
00:14:35,610 --> 00:14:37,919
And each step of the iteration is constant time,
迭代的每一步都是恒定的时间， 

325
00:14:37,919 --> 00:14:42,209
but the iteration happens L times.
但是迭代发生了L次。 

326
00:14:42,210 --> 00:14:43,509
I'm sorry, not L times.
对不起，不是L次。 

327
00:14:43,509 --> 00:14:45,399
The length of the list times.
列表时间的长度。 

328
00:14:45,399 --> 00:14:48,120
How many-- how many elements are in word lists?
单词列表中有多少个元素？ 

329
00:14:48,120 --> 00:14:53,090



330
00:14:53,090 --> 00:14:57,730
I heard a very low W, so I will pretend I heard it.
我听到了非常低的W，所以我假装听到了。 

331
00:14:57,730 --> 00:15:01,350
Or I hope I heard W. So word list, the words I
还是希望我听到W。所以单词列表，我

332
00:15:01,350 --> 00:15:06,690
got from the document, W. How about the if.
从文档中得到W。 

333
00:15:06,690 --> 00:15:13,570
So, it looks at the word that I have-- oh.
因此，它着眼于我所拥有的单词-哦。 

334
00:15:13,570 --> 00:15:16,479
This code is confusing because I forgot a line, right?
这段代码令人困惑，因为我忘了一行，对吗？ 

335
00:15:16,679 --> 00:15:20,579
Pretend that between line-- oh, no, sorry, I didn't.
假装在两行之间-哦，不，对不起，我没有。 

336
00:15:20,580 --> 00:15:23,311
New word is-- new word is assigned in line 3.
新单词是-在第3行中分配了新单词。 

337
00:15:23,511 --> 00:15:29,029
So new word in line 3 is compared to the first element
因此，将第3行中的新单词与第一个元素进行比较

338
00:15:29,029 --> 00:15:31,279
of the entry that's assigned in line 4.
在第4行中分配的条目的

339
00:15:31,279 --> 00:15:36,959
So hat is compared with the, fox, so on, so forth.
因此，将帽子与狐狸等进行比较，依此类推。 

340
00:15:36,960 --> 00:15:41,329
And if the comparison is true, it runs line 6 and 7.
如果比较正确，则运行第6行和第7行。 

341
00:15:41,529 --> 00:15:45,230
And if not, it keeps looping.
如果没有，它将一直循环播放。 

342
00:15:45,230 --> 00:15:50,099
So line 5, the if how, many times does it run?
那么第5行，如果运行多少次？ 

343
00:15:50,299 --> 00:15:52,497
Just the comparison.
只是比较。 

344
00:15:52,498 --> 00:15:53,609
AUDIENCE: W.
听众：W. 

345
00:15:53,809 --> 00:15:55,106
PROFESSOR: W.
教授：W. 

346
00:15:55,106 --> 00:15:56,148
AUDIENCE: Oh, no, no, no.
听众：哦，不，不，不。 

347
00:15:56,148 --> 00:15:57,072
No.
没有。 

348
00:15:57,072 --> 00:15:58,919
I'm thinking of line 4.
我在想第4行。 

349
00:15:58,919 --> 00:15:59,940
PROFESSOR: Oh.
教授：哦。 

350
00:15:59,941 --> 00:16:00,440
Yeah.
是的

351
00:16:00,440 --> 00:16:02,059
I'm getting confused too.
我也很困惑。 

352
00:16:02,259 --> 00:16:03,539
So let's start with line 4.
因此，让我们从第4行开始。 

353
00:16:03,539 --> 00:16:04,519
Sorry.
抱歉。 

354
00:16:04,519 --> 00:16:05,881
Shouldn't do line 5.
不应该做第5行。 

355
00:16:05,881 --> 00:16:08,058
AUDIENCE: --new word, then you're not-- like,
听众：-新单词，那么你不是-喜欢， 

356
00:16:08,058 --> 00:16:09,850
you're not going to run through that again.
您不会再经历那个。 

357
00:16:09,850 --> 00:16:10,315
PROFESSOR: Yeah.
教授：是的。 

358
00:16:10,515 --> 00:16:12,529
Let's worry about that right afterwards.
那就让我们担心吧。 

359
00:16:12,529 --> 00:16:13,759
Let's do line 4 first.
让我们先做第4行。 

360
00:16:13,759 --> 00:16:15,789
Sorry, I jumped over line 4.
抱歉，我跳过了第4行。 

361
00:16:15,789 --> 00:16:19,519
So, line 4 definitely runs W times
因此，第4行肯定会运行W次

362
00:16:19,519 --> 00:16:23,970
because it's inside the for loop from line 3 to line 9.
因为它在从第3行到第9行的for循环内。 

363
00:16:23,970 --> 00:16:29,509
So everything here will definitely run W times.
因此，这里的所有内容肯定会运行W次。 

364
00:16:29,509 --> 00:16:31,909
But how many times does it run overall?
但是它整体运行了多少次？ 

365
00:16:31,909 --> 00:16:36,376
So, line 4 iterates over all the entries here.
因此，第4行会遍历此处的所有条目。 

366
00:16:36,376 --> 00:16:37,709
How many times does that happen?
这会发生多少次？ 

367
00:16:37,710 --> 00:16:40,960



368
00:16:41,160 --> 00:16:47,569
AUDIENCE: 1 plus W over-- times 10/2,
观众：1加W胜过– 10/2， 

369
00:16:47,570 --> 00:16:54,387
because it's just worst case, L-- the length of L increases
因为这是最坏的情况，L-L的长度增加

370
00:16:54,587 --> 00:16:56,829
by 1 every time.
每次减1。 

371
00:16:56,830 --> 00:16:58,950
[INAUDIBLE]
 [听不清] 

372
00:16:58,950 --> 00:17:02,350
PROFESSOR: OK, so I like that you started with worst case.
教授：好的，所以我喜欢您以最坏的情况开始。 

373
00:17:02,350 --> 00:17:04,130
Normally I would say exactly that.
通常我会这样说。 

374
00:17:04,130 --> 00:17:07,418
Worst case or W. But we had a different constant
最坏的情况还是W。但是我们有一个不同的常数

375
00:17:07,618 --> 00:17:11,480
for the number of words that you have in the end.
最后的单词数。 

376
00:17:11,480 --> 00:17:16,230
So let's say something a little bit better than W. Let's say,
所以我们说一些比W更好的例子。 

377
00:17:16,230 --> 00:17:17,880
let's put the lower bound on it.
让我们把它的下限。 

378
00:17:17,880 --> 00:17:20,036
So yeah, worst case, all the words are different.
是的，在最坏的情况下，所有单词都是不同的。 

379
00:17:20,036 --> 00:17:21,418
But what if they're not all different?
但是，如果它们不是全部一样，该怎么办？ 

380
00:17:21,618 --> 00:17:25,631
And what if in the end I know I have L words?
如果最后我知道我有L个单词怎么办？ 

381
00:17:25,632 --> 00:17:27,653
CLASS: [INAUDIBLE].
班级：[听不清]。 

382
00:17:27,653 --> 00:17:28,568
PROFESSOR: Worst case.
教授：最坏的情况。 

383
00:17:28,568 --> 00:17:33,000



384
00:17:33,000 --> 00:17:33,500
Almost.
几乎。 

385
00:17:33,500 --> 00:17:36,339



386
00:17:36,339 --> 00:17:39,939
So, I know I have a W from the outer loop.
因此，我知道我在外部循环中有W。 

387
00:17:39,940 --> 00:17:42,680
For each word in the outer loop, how many times
对于外循环中的每个单词，多少次

388
00:17:42,680 --> 00:17:46,799
does the inner loop execute?
内循环执行吗？ 

389
00:17:46,799 --> 00:17:49,210
How many times do I have to go through something
我必须经历几次

390
00:17:49,210 --> 00:17:50,250
in the inner list?
在内部列表中？ 

391
00:17:50,250 --> 00:17:53,089
So I know here I have W words, suppose here I
所以我知道我这里有W字，假设我在这里

392
00:17:53,089 --> 00:17:55,480
have L elements in the vector.
向量中有L个元素。 

393
00:17:55,480 --> 00:17:58,194
For each one of these, how many times
对于其中的每一个，多少次

394
00:17:58,194 --> 00:18:02,439
do I have to go through-- So how many elements do I
我必须经历吗-所以我要多少个元素

395
00:18:02,440 --> 00:18:03,745
have to go through here?
必须经过这里？ 

396
00:18:03,945 --> 00:18:05,763
AUDIENCE: Depends on where you are, though.
听众：不过要看你在哪里。 

397
00:18:05,763 --> 00:18:07,929
For the first word, you only have to go through one.
对于第一个单词，您只需要经过一个。 

398
00:18:07,930 --> 00:18:08,230
PROFESSOR: Yep.
教授：是的。 

399
00:18:08,230 --> 00:18:08,529
But--
但 - 

400
00:18:08,529 --> 00:18:09,589
AUDIENCE: For the second word, you have to through--
听众：第二个字，您必须- 

401
00:18:09,589 --> 00:18:09,869
PROFESSOR: Yep.
教授：是的。 

402
00:18:09,869 --> 00:18:11,279
But I heard the worst case.
但是我听到了最坏的情况。 

403
00:18:11,279 --> 00:18:12,779
And I like that, because it's easier
我喜欢，因为它更容易

404
00:18:12,779 --> 00:18:14,070
to reason about the worst case.
推断最坏的情况。 

405
00:18:14,070 --> 00:18:17,480
And most of the time it's sort of like the average case.
在大多数情况下，这有点像普通情况。 

406
00:18:17,480 --> 00:18:21,200
AUDIENCE: So then, length of list-- L.
听众：那么，清单的长度-L。 

407
00:18:21,200 --> 00:18:25,529
PROFESSOR: The length of the list, and that's L. Worst case,
教授：清单的长度，这是L。最坏的情况是， 

408
00:18:25,529 --> 00:18:27,975
the first words that I see will be L different words.
我看到的第一个单词将是L个不同的单词。 

409
00:18:27,976 --> 00:18:29,149
And then all the words that I see
然后我看到的所有单词

410
00:18:29,349 --> 00:18:32,839
will be the same as the words that I saw before.
将与我之前看到的词相同。 

411
00:18:32,839 --> 00:18:36,079
So worst case, the list will grow to L very fast,
所以最坏的情况是，列表会很快增长到L， 

412
00:18:36,079 --> 00:18:39,085
and then I'll keep seeing L L L. And I'll
然后我会继续看到LLL。然后

413
00:18:39,085 --> 00:18:40,710
ignore what was there in the beginning,
忽略一开始的东西， 

414
00:18:40,710 --> 00:18:44,460
and I'll say L times.
我会说L次

415
00:18:44,460 --> 00:18:47,319
So I know the second list is bounded by L in length,
所以我知道第二个列表的长度是L 

416
00:18:47,319 --> 00:18:49,470
the first list is bounded by W in length.
第一个列表的长度为W。 

417
00:18:49,470 --> 00:18:53,960
So worst case this runs L times W times.
因此，最坏的情况是L倍W倍。 

418
00:18:53,960 --> 00:18:56,394
And what's the cost of iterating?
迭代的成本是多少？ 

419
00:18:56,394 --> 00:18:58,854
AUDIENCE: What is the difference between L and W?
听众：L和W有什么区别？ 

420
00:18:58,854 --> 00:19:01,764
L is the document vector length, and W is the number of words.
 L是文档矢量长度，W是单词数。 

421
00:19:01,964 --> 00:19:04,802
But isn't the number of elements in the document vector
但是文档向量中的元素数量不是

422
00:19:04,803 --> 00:19:07,598
the number of words?
字数？ 

423
00:19:07,798 --> 00:19:09,089
PROFESSOR: How about this case?
教授：这种情况怎么样？ 

424
00:19:09,089 --> 00:19:09,809
What's W?
什么是W？ 

425
00:19:09,809 --> 00:19:15,134



426
00:19:15,134 --> 00:19:15,909
AUDIENCE: 6, yeah.
听众：6，是的。 

427
00:19:16,109 --> 00:19:20,139



428
00:19:20,140 --> 00:19:23,589
PROFESSOR: So L is the number of unique words in a document.
教授：L是文档中唯一词的数量。 

429
00:19:23,789 --> 00:19:25,579
And I heard a really cool argument
我听到了一个很酷的论点

430
00:19:25,579 --> 00:19:28,159
that I liked last time.
我上次喜欢的

431
00:19:28,160 --> 00:19:28,919
Does anyone remember?
有人记得吗？ 

432
00:19:29,119 --> 00:19:29,839
About L?
关于L？ 

433
00:19:29,839 --> 00:19:33,449



434
00:19:33,450 --> 00:19:37,160
If we're really dealing with a natural language like English,
如果我们真的在处理自然语言，例如英语， 

435
00:19:37,160 --> 00:19:39,435
how many words do I have in English?
我有几个英语单词？ 

436
00:19:39,635 --> 00:19:41,134
AUDIENCE: Well, I think, at the max,
听众：嗯，我认为

437
00:19:41,134 --> 00:19:43,997
there's actually around 250,000, but a lot of them
实际上大约有25万，但其中很多

438
00:19:43,997 --> 00:19:44,956
are not used anymore.
不再使用。 

439
00:19:45,156 --> 00:19:45,740
PROFESSOR: OK.
教授：好的。 

440
00:19:45,740 --> 00:19:47,720
So 250,000, right?
所以250,000对吧？ 

441
00:19:47,720 --> 00:19:48,819
Max.
最高

442
00:19:48,819 --> 00:19:50,480
So that's a constant.
所以这是一个常数。 

443
00:19:50,480 --> 00:19:52,930
If I have a document that contains
如果我的文件包含

444
00:19:52,930 --> 00:19:55,859
all the writings of all the authors that were ever done,
所有作者的所有著作， 

445
00:19:56,059 --> 00:20:02,770
and say that's a billion words, L is still going to be 250,000.
并说那是十亿个单词，L仍将是250,000。 

446
00:20:02,770 --> 00:20:03,269
Right?
对？ 

447
00:20:03,269 --> 00:20:04,882
So L can be very different from W.
因此L可以与W截然不同。 

448
00:20:04,882 --> 00:20:06,764
That's why we're keeping track of them separately.
这就是为什么我们要分别跟踪它们。 

449
00:20:06,964 --> 00:20:11,509



450
00:20:11,509 --> 00:20:14,910
One W L times W. What's the cost of iterating?
 WL乘以W。迭代的成本是多少？ 

451
00:20:14,910 --> 00:20:19,190



452
00:20:19,190 --> 00:20:21,529
So we know how many times line 4 runs,
因此，我们知道第4行运行了多少次， 

453
00:20:21,529 --> 00:20:26,930
but what's the cost of one step of iterating in the list?
但是在列表中进行一步迭代的成本是多少？ 

454
00:20:26,930 --> 00:20:27,430
1.
 1。 

455
00:20:27,430 --> 00:20:27,930
Very good.
很好。 

456
00:20:27,930 --> 00:20:31,529



457
00:20:31,529 --> 00:20:32,036
Line 5.
第5行。 

458
00:20:32,036 --> 00:20:33,160
How many times does it run?
它运行多少次？ 

459
00:20:33,160 --> 00:20:37,420



460
00:20:37,420 --> 00:20:39,230
AUDIENCE: W times L?
听众：W乘L？ 

461
00:20:39,230 --> 00:20:39,990
PROFESSOR: Yep.
教授：是的。 

462
00:20:39,990 --> 00:20:41,579
Same as line 4, right?
与第4行相同，对吗？ 

463
00:20:41,579 --> 00:20:43,799
The if is run all the time.
 if一直运行。 

464
00:20:43,799 --> 00:20:47,859
And lines 5 and 6 only run sometimes, but-- sorry,
第5和第6行有时只运行，但是-对不起， 

465
00:20:47,859 --> 00:20:53,750
line 6 and 7 only run sometimes, but line 5 runs all the time.
第6和7行有时只运行，而第5行则一直运行。 

466
00:20:53,750 --> 00:20:54,740
What is the cost?
费用是多少？ 

467
00:20:54,740 --> 00:21:01,642



468
00:21:01,642 --> 00:21:03,279
AUDIENCE: We can say it's constant.
听众：我们可以说它是不变的。 

469
00:21:03,279 --> 00:21:04,779
PROFESSOR: We can say it's constant.
教授：我们可以说它是不变的。 

470
00:21:04,779 --> 00:21:07,559
I like we can say it's constant, but why
我喜欢我们可以说它是常数，但是为什么

471
00:21:07,559 --> 00:21:10,019
is it that we can say it's constant?
我们可以说它是常数吗？ 

472
00:21:10,019 --> 00:21:12,480
Why don't I just say 1, if-- this is an empty list.
我为什么不只说1，如果-这是一个空列表。 

473
00:21:12,480 --> 00:21:13,279
This is a number.
这是一个数字。 

474
00:21:13,279 --> 00:21:14,339
AUDIENCE: Depends on the word length.
听众：取决于单词的长度。 

475
00:21:14,339 --> 00:21:14,923
PROFESSOR: OK.
教授：好的。 

476
00:21:14,923 --> 00:21:17,065
It depends on the word lis-- length, very good.
这取决于lis这个词-长度，很好。 

477
00:21:17,065 --> 00:21:18,690
AUDIENCE: And we're assuming that words
听众：我们假设这句话

478
00:21:18,690 --> 00:21:20,170
are all the same length.
都是一样的长度。 

479
00:21:20,170 --> 00:21:21,436
PROFESSOR: OK.
教授：好的。 

480
00:21:21,636 --> 00:21:22,220
AUDIENCE: And?
听众：还有？ 

481
00:21:22,220 --> 00:21:26,190
So, 1 times L W. Little w.
因此，L W的1倍。 

482
00:21:26,190 --> 00:21:28,390
PROFESSOR: OK, very good.
教授：好的，很好。 

483
00:21:28,390 --> 00:21:30,980
So we do assume that all the words are the same length.
因此，我们确实假设所有单词的长度都相同。 

484
00:21:30,980 --> 00:21:34,920
But unless I tell you that the length is really small,
但是除非我告诉你长度真的很小， 

485
00:21:34,920 --> 00:21:37,630
which I did, you can't say 1.
我做到了，你不能说1。 

486
00:21:37,630 --> 00:21:41,000
So, when you said we can say it's constant, it's right.
所以，当您说我们可以说它是常数时，它是正确的。 

487
00:21:41,000 --> 00:21:42,769
We can say, but we also have to say why,
我们可以说，但我们还必须说为什么， 

488
00:21:42,769 --> 00:21:44,889
or at least think why, that's the case.
或至少认为是这样。 

489
00:21:44,890 --> 00:21:48,759
So it's W-- we're going to use W here and when we copy it here,
所以是W-我们将在这里使用W，并在此处复制时， 

490
00:21:48,759 --> 00:21:51,144
we're going to forget about it.
我们将忘记它。 

491
00:21:51,144 --> 00:21:52,852
AUDIENCE: Can you put a top bar on the W,
观众：您能在W上放一个顶栏吗？ 

492
00:21:52,852 --> 00:21:56,629
just so I can tell that it's not the other W.
只是为了让我知道不是其他W。 

493
00:21:56,829 --> 00:22:07,949
PROFESSOR: OK But you have to be responsible for reminding
教授：好的，但是您必须负责提醒

494
00:22:07,950 --> 00:22:08,769
me to put that.
我把那个。 

495
00:22:08,769 --> 00:22:10,160
AUDIENCE: OK.
听众：好的。 

496
00:22:10,160 --> 00:22:12,240
PROFESSOR: OK.
教授：好的。 

497
00:22:12,240 --> 00:22:15,470
So string comparison, not constant.
所以字符串比较，不是常数。 

498
00:22:15,470 --> 00:22:17,769
If I have two very long strings that
如果我有两个很长的琴弦

499
00:22:17,769 --> 00:22:19,549
only differ in the last character,
只是最后一个字符有所不同， 

500
00:22:19,549 --> 00:22:21,549
I have to go through them character by character
我必须一个个地经历

501
00:22:21,549 --> 00:22:24,809
by character until I find the last character that's
按字符，直到找到最后一个

502
00:22:24,809 --> 00:22:25,579
different.
不同。 

503
00:22:25,579 --> 00:22:28,769
Because until I look at that, the strings might be equal.
因为在我看那之前，字符串可能是相等的。 

504
00:22:28,769 --> 00:22:30,925
So comparing two long strings takes
所以比较两个长字符串需要

505
00:22:30,925 --> 00:22:33,174
time that's proportional to the length of the strings.
时间与弦的长度成正比。 

506
00:22:33,174 --> 00:22:36,680



507
00:22:36,680 --> 00:22:40,130
OK, so line 5 costs w, tricky part,
好，所以第5行的费用为w，棘手的部分， 

508
00:22:40,130 --> 00:22:44,420
runs L times W part-- L times W times.
运行L乘以W倍-L乘以W倍。 

509
00:22:44,420 --> 00:22:46,149
How about line 6 and 7?
第六和第七行怎么样？ 

510
00:22:46,349 --> 00:22:52,859



511
00:22:52,859 --> 00:22:56,279
I didn't ask line 6, I asked line 6 and 7 together,
我没有问过第6行，而是一起问过第6行和第7行， 

512
00:22:56,279 --> 00:22:57,690
because there is a trick there.
因为那里有个把戏。 

513
00:22:57,690 --> 00:23:05,690



514
00:23:05,690 --> 00:23:09,190
AUDIENCE: I think it's constant for line 6, right?
听众：我认为第6行是不变的，对吧？ 

515
00:23:09,190 --> 00:23:10,518
PROFESSOR: Why?
教授：为什么？ 

516
00:23:10,518 --> 00:23:12,857
AUDIENCE: 'Cause it's a number.
听众：因为是数字。 

517
00:23:12,857 --> 00:23:14,714
And one place in the entry.
并在条目中放置一个。 

518
00:23:14,714 --> 00:23:16,279
We've already grabbed the entry.
我们已经获取了条目。 

519
00:23:16,279 --> 00:23:20,420
PROFESSOR: So the cost of running it once is 1.
教授：因此，运行一次的成本为1。 

520
00:23:20,420 --> 00:23:21,700
Good.
好。 

521
00:23:21,700 --> 00:23:25,190
I can tell you that that's the same case for 7.
我可以告诉你，这与7相同。 

522
00:23:25,190 --> 00:23:26,559
How many times do they run?
他们运行多少次？ 

523
00:23:26,559 --> 00:23:30,119



524
00:23:30,119 --> 00:23:32,489
This is the hard part.
这是困难的部分。 

525
00:23:32,490 --> 00:23:34,980
AUDIENCE: Wait, does break line break out of one loop?
听众：等等，断线会跳出一个循环吗？ 

526
00:23:34,980 --> 00:23:35,605
PROFESSOR: Yep.
教授：是的。 

527
00:23:35,605 --> 00:23:39,940
Break breaks out of the loop between lines 4 and 7.
 Break在第4行和第7行之间跳出循环。 

528
00:23:39,940 --> 00:23:41,299
I have a question.
我有个问题。 

529
00:23:41,299 --> 00:23:46,349
AUDIENCE: Is L supposed to be not in line with if?
听众：L应该和if不符合吗？ 

530
00:23:46,349 --> 00:23:46,849
Yes.
是。 

531
00:23:46,849 --> 00:23:49,579
PROFESSOR: It is supposed to be where it is.
教授：应该在那儿。 

532
00:23:49,579 --> 00:23:50,639
I will talk-- yes.
我会说-是的。 

533
00:23:50,640 --> 00:23:53,880
So what happens is, that else is in line with a for.
所以发生的是，其他与for一致。 

534
00:23:53,880 --> 00:23:57,430
And if the for loop runs to completion,
如果for循环运行完成， 

535
00:23:57,430 --> 00:24:00,659
then it does get executed.
然后它会被执行。 

536
00:24:00,859 --> 00:24:04,096
If there's a break somewhere inside the for,
如果for内某处有休息， 

537
00:24:04,096 --> 00:24:05,305
then it doesn't get executed.
那么它就不会执行。 

538
00:24:05,305 --> 00:24:08,140



539
00:24:08,140 --> 00:24:10,650
So the idea behind that is, usually
所以背后的想法通常是

540
00:24:10,650 --> 00:24:12,509
use this for finding stuff.
用它来寻找东西。 

541
00:24:12,509 --> 00:24:15,759
So you iterate over a list, and when you find something,
因此，您遍历一个列表，当您找到某项内容时， 

542
00:24:15,759 --> 00:24:17,516
break out of the loop.
打破循环。 

543
00:24:17,516 --> 00:24:19,390
You did something, you break out of the loop.
您做了一些事情，就跳出了循环。 

544
00:24:19,390 --> 00:24:21,234
If you didn't find it, you can put an else
如果找不到，可以放另一个

545
00:24:21,434 --> 00:24:23,166
and then say what code happens.
然后说出发生什么代码。 

546
00:24:23,166 --> 00:24:25,000
And you don't have to write code on your own
而且您不必自己编写代码

547
00:24:25,000 --> 00:24:29,420
to check if you broke out of the loop.
检查您是否跳出循环。 

548
00:24:29,420 --> 00:24:32,230
So if break executes, then it's going
因此，如果执行中断，那么它将继续

549
00:24:32,230 --> 00:24:34,569
to take us out of the loop.
把我们带出循环。 

550
00:24:34,569 --> 00:24:35,929
It's going to ignore the else.
它将忽略其他情况。 

551
00:24:35,930 --> 00:24:38,081
And it's going to run the loop on line 3 again.
并且它将再次在第3行运行循环。 

552
00:24:38,281 --> 00:24:39,865
So it's going to do another iteration.
因此，它将进行另一次迭代。 

553
00:24:39,865 --> 00:24:42,470



554
00:24:42,470 --> 00:24:44,279
So line 6 and 7, how many times?
那么第6行和第7行多少次？ 

555
00:24:44,279 --> 00:24:47,119
AUDIENCE: W minus L?
听众：W减去L？ 

556
00:24:47,119 --> 00:24:48,449
PROFESSOR: W minus L.
教授：W减去L。 

557
00:24:48,450 --> 00:24:50,526
AUDIENCE: Like, if it's the difference
听众：就像，如果有所不同

558
00:24:50,526 --> 00:24:54,961
in number of words and number of-- unique words.
字数和唯一字数。 

559
00:24:54,961 --> 00:24:55,670
PROFESSOR: Smart.
教授：聪明。 

560
00:24:55,670 --> 00:25:00,519
You gave the precise answer right the first time.
您是第一次给出正确的答案。 

561
00:25:00,519 --> 00:25:02,230
W minus L. Very good.
 W负L。很好。 

562
00:25:02,230 --> 00:25:06,829



563
00:25:06,829 --> 00:25:13,960
And what happens once-- what happens once this runs?
一次会发生什么-一次运行会发生什么？ 

564
00:25:13,960 --> 00:25:21,730
Why do I know-- why do I know that the if won't be-- Oh.
为什么我知道-为什么我知道如果不是-哦。 

565
00:25:21,730 --> 00:25:23,660
Sorry, I'm getting myself confused.
抱歉，我感到困惑。 

566
00:25:23,660 --> 00:25:27,950
So it's going to run W minus L times total, right?
所以它将运行W减去L乘以，对吧？ 

567
00:25:27,950 --> 00:25:31,569
Total times overall without this W thing here,
这里没有W总的总时间， 

568
00:25:31,569 --> 00:25:33,547
so I should put an arrow and say--
所以我应该放一支箭说- 

569
00:25:33,547 --> 00:25:38,319



570
00:25:38,319 --> 00:25:41,069
Now suppose I didn't notice this.
现在假设我没有注意到这一点。 

571
00:25:41,069 --> 00:25:43,509
Is there another way I can get the decent bounds?
有没有其他方法可以使我达到体面的境界？ 

572
00:25:43,509 --> 00:25:45,164
So this is the right, perfect answer.
因此，这是正确的，完美的答案。 

573
00:25:45,164 --> 00:25:46,289
You have this, you're done.
有了这个，就完成了。 

574
00:25:46,289 --> 00:25:47,623
You don't need to think further.
您无需再考虑。 

575
00:25:47,623 --> 00:25:49,420
Suppose you don't have this.
假设您没有这个。 

576
00:25:49,420 --> 00:25:50,149
What else can you do?
你还能做什么？ 

577
00:25:50,349 --> 00:25:53,478



578
00:25:53,479 --> 00:25:55,069
AUDIENCE: But we don't have what?
听众：但是我们没有什么？ 

579
00:25:55,069 --> 00:25:57,769
PROFESSOR: If I didn't notice that, hey, there
教授：如果我没有注意到，嘿，那里

580
00:25:57,769 --> 00:26:03,329
are L words-- There are L new words,
是L个字-有L个新词， 

581
00:26:03,329 --> 00:26:07,689
W words total, so W minus L words repeat themselves.
共有W个字，所以W个减去L个字会重复自己。 

582
00:26:07,690 --> 00:26:11,230
So this is how many times the if is going to be true.
因此，这是if满足的次数。 

583
00:26:11,230 --> 00:26:13,329
If I didn't have that, then I could
如果我没有那个，那我可以

584
00:26:13,329 --> 00:26:16,750
see that line 7 breaks out of the loop.
看到第7行跳出循环。 

585
00:26:16,750 --> 00:26:19,314
So if that if runs once, then we're done.
因此，如果运行一次，那么我们就完成了。 

586
00:26:19,314 --> 00:26:20,230
We're out of the loop.
我们不在循环中。 

587
00:26:20,230 --> 00:26:22,430
It's not going to run again.
它不会再次运行。 

588
00:26:22,430 --> 00:26:26,210
So a bound that's not as precise as the one you gave me
这样的界限并不像你给我的界限那么精确

589
00:26:26,210 --> 00:26:31,265
is 1 times W, because it runs, at most, once per loop.
是W的1倍，因为它最多每个循环运行一次。 

590
00:26:31,265 --> 00:26:39,829



591
00:26:40,029 --> 00:26:42,720
Does people see this?
人们看到了吗？ 

592
00:26:42,720 --> 00:26:45,809
So this is an easy way to cop out of thinking.
因此，这是解决问题的一种简单方法。 

593
00:26:45,809 --> 00:26:48,230
And I don't like to think more than necessary, because you
而且我不喜欢思考不必要的事情，因为您

594
00:26:48,230 --> 00:26:50,099
have finite time on a test or in life,
在测试或生活中有有限的时间， 

595
00:26:50,099 --> 00:26:52,719
and you don't want to spend too much time on one thing.
而且您不想在一件事情上花费太多时间。 

596
00:26:52,720 --> 00:26:55,640



597
00:26:55,640 --> 00:26:56,670
We covered the loop.
我们涵盖了循环。 

598
00:26:56,670 --> 00:26:59,009
Let's look at else and append.
让我们看看其他并追加。 

599
00:26:59,009 --> 00:27:00,509
I already got a helpful question,
我已经有一个有用的问题， 

600
00:27:00,509 --> 00:27:03,940
so I explained when the else would run.
所以我解释了其他时候什么时候运行。 

601
00:27:03,940 --> 00:27:05,240
The running time for else.
其他的运行时间。 

602
00:27:05,240 --> 00:27:07,569
Else is a flow-- control flow statement.
其他是流程控制流语句。 

603
00:27:07,569 --> 00:27:10,243
It's like break, so Python will keep
就像休息一样，Python会继续

604
00:27:10,243 --> 00:27:11,909
track of whether a loop completed or not
跟踪循环是否完成

605
00:27:11,910 --> 00:27:12,698
in constant time.
在恒定的时间内。 

606
00:27:12,898 --> 00:27:13,689
I'll give you that.
我给你

607
00:27:13,690 --> 00:27:16,750
That's in the cost model.
这就是成本模型。 

608
00:27:16,750 --> 00:27:21,170
How many times does this else run, at most?
其他最多最多运行几次？ 

609
00:27:21,170 --> 00:27:22,639
OK, L. Good.
好，L。 

610
00:27:22,839 --> 00:27:25,545



611
00:27:25,546 --> 00:27:26,865
Perfect.
完善。 

612
00:27:26,865 --> 00:27:27,573
How about line 9?
第9行如何？ 

613
00:27:27,573 --> 00:27:35,811



614
00:27:36,011 --> 00:27:36,975
Loop stops here.
循环在这里停止。 

615
00:27:36,976 --> 00:27:39,890



616
00:27:39,890 --> 00:27:42,200
How about line 9?
第9行如何？ 

617
00:27:42,200 --> 00:27:43,500
How many times does it run?
它运行多少次？ 

618
00:27:43,500 --> 00:27:44,885
That's easy.
这很容易。 

619
00:27:44,885 --> 00:27:46,289
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

620
00:27:46,289 --> 00:27:47,799
PROFESSOR: Yep.
教授：是的。 

621
00:27:47,799 --> 00:27:48,819
And what does it do?
它是做什么的？ 

622
00:27:48,819 --> 00:27:49,589
It's an append.
这是一个附录。 

623
00:27:49,589 --> 00:27:53,110
What's the cost for append?
追加费用是多少？ 

624
00:27:53,111 --> 00:27:53,902
AUDIENCE: Constant.
听众：不变。 

625
00:27:53,902 --> 00:27:57,380



626
00:27:57,380 --> 00:27:59,680
PROFESSOR: OK Line 10 runs how many times?
教授：好的，第10行运行了多少次？ 

627
00:27:59,680 --> 00:28:02,554
What's the cost?
费用是多少？ 

628
00:28:02,554 --> 00:28:03,054
AUDIENCE: 1?
听众：1？ 

629
00:28:03,054 --> 00:28:07,307



630
00:28:07,307 --> 00:28:09,390
PROFESSOR: You guys didn't listen to me last time.
教授：你们上次没有听我说。 

631
00:28:09,390 --> 00:28:10,819
So I was saying you have to look at the notes
所以我说你必须看笔记

632
00:28:11,019 --> 00:28:12,269
and you have to practice this.
而你必须练习

633
00:28:12,269 --> 00:28:14,480
Because you have to have this model in your mind.
因为您必须牢记这种模型。 

634
00:28:14,480 --> 00:28:16,160
So that when you're writing code,
这样，当您编写代码时， 

635
00:28:16,160 --> 00:28:17,710
this has to happen automatically.
这必须自动发生。 

636
00:28:17,710 --> 00:28:20,306
You shouldn't have to think explicitly about it.
您不必明确考虑它。 

637
00:28:20,306 --> 00:28:22,180
Because if you do, you're not going to do it.
因为如果这样做，您就不会这样做。 

638
00:28:22,180 --> 00:28:23,679
AUDIENCE: For the else, shouldn't it
听众：不然不应该

639
00:28:23,679 --> 00:28:28,612
be W tim-- I mean, it would be called W times not L times?
是W tim-我的意思是，它将被称为W乘而不是L乘？ 

640
00:28:28,612 --> 00:28:30,543
Because you want to look at the outer loop and not
因为你想看外循环而不是

641
00:28:30,743 --> 00:28:32,059
the inner loop?
内循环？ 

642
00:28:32,059 --> 00:28:35,942
So it can-- you call all-- once at the end of the total--
因此，您可以-调用全部-在总计末尾一次- 

643
00:28:35,942 --> 00:28:37,079
the inner for.
内在的。 

644
00:28:37,079 --> 00:28:37,579
Right?
对？ 

645
00:28:37,579 --> 00:28:43,589
So, so it could be-- happen W times, maximum, not L times.
因此，可能会发生-最大次数W次，而不是L次。 

646
00:28:43,589 --> 00:28:47,959
'Cause the L is the for loop that the else coincides with.
因为L是for循环，其他循环与此重合。 

647
00:28:47,960 --> 00:28:50,501
And the else would only happen once
否则只会发生一次

648
00:28:50,501 --> 00:28:53,409
for every total iteration of that.
对于每个总迭代。 

649
00:28:53,410 --> 00:28:55,400
PROFESSOR: OK so you're proposing W
教授：好的，所以您建议W 

650
00:28:55,400 --> 00:28:57,869
as the bound for the else, right?
作为其他的约束，对吗？ 

651
00:28:58,069 --> 00:28:59,643
Here.
这里。 

652
00:28:59,643 --> 00:29:00,939
AUDIENCE: Yeah.
听众：是的。 

653
00:29:00,939 --> 00:29:02,980
PROFESSOR: So I could say, hey, it runs, at most,
教授：所以我可以说，嘿，它最多可以运行， 

654
00:29:02,980 --> 00:29:04,140
once for outer loop.
一次用于外循环。 

655
00:29:04,140 --> 00:29:06,430
So it's, at most, W times.
因此，最多是W次。 

656
00:29:06,430 --> 00:29:08,019
This is a nice, easy argument.
这是一个很好的，简单的论点。 

657
00:29:08,019 --> 00:29:09,680
We have a bound.
我们有一个界限。 

658
00:29:09,680 --> 00:29:10,670
L is a tighter bound.
 L是一个更严格的界限。 

659
00:29:10,670 --> 00:29:14,730
And when I got L, what happened here
当我拿到L时，这里发生了什么

660
00:29:14,730 --> 00:29:17,630
was the same kind of thinking that you did earlier
与您之前的想法相同

661
00:29:17,630 --> 00:29:18,960
to get this.
得到这个。 

662
00:29:18,960 --> 00:29:21,579
So this bound is good, this bound is tighter.
所以这个界限很好，这个界限更严格。 

663
00:29:21,579 --> 00:29:24,259
This bound is good, this bound is tighter.
这个界限很好，这个界限更严格。 

664
00:29:24,259 --> 00:29:27,849
And the argument behind this one is that, hey, this
这个论点的背后是

665
00:29:27,849 --> 00:29:30,569
else only happens for new words.
否则只会发生新词。 

666
00:29:30,569 --> 00:29:33,299
If there's no new-- if the word that I looked at is old,
如果没有新的东西-如果我看着的单词是旧的， 

667
00:29:33,299 --> 00:29:36,899
then break is going to execute.
然后中断将要执行。 

668
00:29:36,900 --> 00:29:38,839
And else is not going to execute.
否则将无法执行。 

669
00:29:39,039 --> 00:29:41,619



670
00:29:41,619 --> 00:29:45,329
So that's why I can say L.
这就是为什么我可以说L。 

671
00:29:45,329 --> 00:29:47,259
The beauty of asymptotics is that I
渐近之美在于我

672
00:29:47,259 --> 00:29:49,289
can use either of the bounds and I'll still
可以使用任何一个边界，我仍然

673
00:29:49,289 --> 00:29:50,950
get the correct running time.
获得正确的运行时间。 

674
00:29:50,950 --> 00:29:53,509
So I'm not going to fuss over it too much.
因此，我不会对此大惊小怪。 

675
00:29:53,509 --> 00:29:56,289
I like the tighter ones, because it means you guys are thinking.
我喜欢紧身的衣服，因为这意味着你们正在思考。 

676
00:29:56,289 --> 00:29:57,789
And you're looking at the algorithm,
您正在查看算法， 

677
00:29:57,789 --> 00:29:59,329
and you're understanding it.
并且您了解它。 

678
00:29:59,329 --> 00:30:00,829
But if you don't have them, you'll
但是，如果没有它们，您将

679
00:30:00,829 --> 00:30:02,328
still get the correct running times.
仍然获得正确的运行时间。 

680
00:30:02,328 --> 00:30:04,639
So I think that's nice.
所以我认为很好。 

681
00:30:04,640 --> 00:30:07,339
PROFESSOR: OK, let's get the running time for everything.
教授：好的，让我们获取所有内容的运行时间。 

682
00:30:07,539 --> 00:30:08,799
Can someone do it in one step?
有人可以一步一步做到吗？ 

683
00:30:08,799 --> 00:30:13,889



684
00:30:13,890 --> 00:30:15,629
Then let's do it step by step.
然后，逐步进行操作。 

685
00:30:15,829 --> 00:30:17,710
So let's compute partial products.
因此，让我们计算部分乘积。 

686
00:30:17,710 --> 00:30:20,660
What are they?
这些是什么？ 

687
00:30:20,660 --> 00:30:21,917
AUDIENCE: 1.
听众：1。 

688
00:30:22,117 --> 00:30:25,519
W. LW.
 W. LW。 

689
00:30:25,519 --> 00:30:29,894
L, W, little w-- with the bar.
 L，W，小w--带杠。 

690
00:30:29,894 --> 00:30:31,839
AUDIENCE: (LAUGHING) With the bar.
听众：（笑）带酒吧。 

691
00:30:31,839 --> 00:30:32,630
PROFESSOR: Awesome.
教授：太好了。 

692
00:30:32,631 --> 00:30:39,258
AUDIENCE: W minus L. W. L, L, 1.
听众：W减去LW L，L，1。 

693
00:30:39,258 --> 00:30:42,130



694
00:30:42,130 --> 00:30:44,819
PROFESSOR: OK, so if I add them up, this is all asymptotic.
教授：好的，因此，如果我将它们加起来，这都是渐近的。 

695
00:30:45,019 --> 00:30:47,529
So the biggest one will dominate.
因此最大的将占主导地位。 

696
00:30:47,529 --> 00:30:49,190
In general, I can just take a max
一般来说，我最多只能

697
00:30:49,190 --> 00:30:51,899
instead of doing actual addition.
而不是进行实际加法。 

698
00:30:52,099 --> 00:30:54,295
So who dominates here?
那么谁在这里占主导地位呢？ 

699
00:30:54,296 --> 00:30:57,581
AUDIENCE: The fourth one down?
听众：第四倒？ 

700
00:30:57,781 --> 00:30:59,779
PROFESSOR: Fourth-- OK.
教授：第四-好。 

701
00:30:59,779 --> 00:31:01,680
Yep.
是的

702
00:31:01,680 --> 00:31:08,619
So line 5 is the biggest time consumer in this algorithm.
因此，第5行是该算法中最大的时间消耗。 

703
00:31:08,819 --> 00:31:11,429
And I know it's W times w-bar.
我知道这是W倍w-bar。 

704
00:31:11,430 --> 00:31:12,940
So now I'm going to copy it here.
所以现在我要在这里复制它。 

705
00:31:12,940 --> 00:31:16,575
What did I say I'll do when I'm copying it here?
我在这里复制时会说什么？ 

706
00:31:16,575 --> 00:31:18,029
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

707
00:31:18,029 --> 00:31:18,720
PROFESSOR: Yep.
教授：是的。 

708
00:31:18,720 --> 00:31:22,640
So I'm assuming English five- to ten-character words.
所以我假设英语是5到10个字符的单词。 

709
00:31:22,640 --> 00:31:26,119
W L. And W L is smaller than w squared,
 WL。WL小于w平方， 

710
00:31:26,319 --> 00:31:28,779
so the assumption that I had before is correct.
所以我以前的假设是正确的。 

711
00:31:28,779 --> 00:31:30,789
I don't have to change anything here.
我不需要在这里进行任何更改。 

712
00:31:30,789 --> 00:31:31,596
That is good.
那很好。 

713
00:31:31,596 --> 00:31:38,559



714
00:31:38,559 --> 00:31:42,190
So we noticed last time, and already forgot by now,
所以我们上次注意到了，现在已经忘记了， 

715
00:31:42,190 --> 00:31:46,230
that the biggest problem in this whole implementation
在整个实施过程中最大的问题

716
00:31:46,230 --> 00:31:50,799
was the plus in get words from line list.
是从行列表中获取单词的加号。 

717
00:31:50,799 --> 00:31:54,299
Suppose we forgot about it and we have this big pile of code,
假设我们忘记了它，并且有大量的代码， 

718
00:31:54,299 --> 00:31:56,099
how do I go about making it faster?
我如何才能使其更快？ 

719
00:31:56,099 --> 00:31:59,079



720
00:31:59,079 --> 00:32:01,720
Method one, go through every method.
方法一，经历每种方法。 

721
00:32:01,720 --> 00:32:03,680
Do this.
做这个。 

722
00:32:03,680 --> 00:32:06,740
Compute the running times, and see which one's the slowest.
计算运行时间，看看哪一个是最慢的。 

723
00:32:06,740 --> 00:32:10,190
Does this scale to 1,000 lines of code?
这会扩展到1,000行代码吗？ 

724
00:32:10,190 --> 00:32:11,730
Not so much.
没那么多。 

725
00:32:11,730 --> 00:32:14,700
We're going to be giving you roughly 1,000 lines of code
我们将为您提供大约1000行代码

726
00:32:14,700 --> 00:32:17,960
for PSET2, and we're going to ask it to make it faster.
 PSET2，我们将要求它使其更快。 

727
00:32:17,960 --> 00:32:19,559
Do want to understand everything?
是否想了解一切？ 

728
00:32:19,559 --> 00:32:22,349
No.
没有。 

729
00:32:22,349 --> 00:32:24,589
Instead what you want to do is run the code
相反，您要做的就是运行代码

730
00:32:24,589 --> 00:32:25,823
through a profiler.
通过探查器。 

731
00:32:25,824 --> 00:32:26,740
So we have a computer.
因此，我们有一台计算机。 

732
00:32:26,740 --> 00:32:28,769
The computer can tell you which line
电脑可以告诉你哪条线

733
00:32:28,769 --> 00:32:30,876
takes the most time to run.
需要最多的时间来运行。 

734
00:32:30,876 --> 00:32:32,710
So you don't have to do it on pen and paper.
因此，您不必用笔和纸做。 

735
00:32:32,710 --> 00:32:34,940
Whenever we can automate, do so.
只要我们可以自动化，就可以做到。 

736
00:32:34,940 --> 00:32:36,629
So we'll teach you how to run a profiler.
因此，我们将教您如何运行探查器。 

737
00:32:36,829 --> 00:32:38,109
It's in the notes.
在笔记中。 

738
00:32:38,109 --> 00:32:40,869
And if you look in the code outputs right
如果您查看代码输出正确

739
00:32:40,869 --> 00:32:45,079
after [INAUDIBLE], you'll see a profiler output.
在[音频不清晰]之后，您会看到分析器输出。 

740
00:32:45,079 --> 00:32:47,579
So what that tells you is for each function,
因此，告诉您的是每个功能， 

741
00:32:47,579 --> 00:32:51,980
how much time does it take-- that's the total time?
这需要多少时间-那就是总时间？ 

742
00:32:51,980 --> 00:32:53,670
And there's the cumulative time, which
还有累计时间， 

743
00:32:53,670 --> 00:32:56,099
is how much does it take together with its children?
它和孩子一起需要多少钱？ 

744
00:32:56,299 --> 00:32:59,680



745
00:32:59,680 --> 00:33:04,380
In this case for word frequencies from file, order
在这种情况下，对于文件中的词频，按顺序

746
00:33:04,380 --> 00:33:06,159
of W-- this is how much time it takes
 W-这是需要多少时间

747
00:33:06,359 --> 00:33:07,859
including the functions it's called.
包括它所调用的功能。 

748
00:33:07,859 --> 00:33:10,539
So this is the cumulative time.
这就是累积时间。 

749
00:33:10,539 --> 00:33:13,940
Cumulative time is useful if I'm during runtime analysis.
如果我正在运行时分析中，则累积时间很有用。 

750
00:33:13,940 --> 00:33:16,919
Is not so useful if I'm looking at where's
如果我在看哪里不是那么有用

751
00:33:17,119 --> 00:33:18,744
the slowness in my program?
我的程序运行缓慢吗？ 

752
00:33:18,744 --> 00:33:20,369
Because if you look at cumulative time,
因为如果您查看累计时间， 

753
00:33:20,369 --> 00:33:24,509
you might see the slowness in one of the functions that
您可能会看到其中一种功能的缓慢性

754
00:33:24,509 --> 00:33:27,930
get-- that word frequencies from file called.
从文件中获取-单词频率称为。 

755
00:33:27,930 --> 00:33:30,359
So the cumulative time for this is really big,
因此，此操作的累计时间非常长， 

756
00:33:30,559 --> 00:33:35,139
but the total time-- the time that's spent inside it--
但是总时间-在其中花费的时间- 

757
00:33:35,140 --> 00:33:36,824
is not that bad.
还不错

758
00:33:36,824 --> 00:33:38,240
Instead if you look at total time,
相反，如果您查看总时间， 

759
00:33:38,240 --> 00:33:41,519
you'll see that the worst function is-- surprise,
您会发现最差的功能是-惊讶， 

760
00:33:41,519 --> 00:33:44,670
surprise-- get words from line list.
惊喜-从行列表中获取单词。 

761
00:33:44,670 --> 00:33:48,150
So 5 lines to look at-- hey, there's a plus there.
所以要看5行-嘿，那里有一个加号。 

762
00:33:48,150 --> 00:33:50,900
I remember from lecture that plus copies over lists,
我记得在演讲中，加上复制过的清单， 

763
00:33:50,900 --> 00:33:54,700
and it's kind of slow, so maybe I should use something else.
而且有点慢，所以也许我应该使用其他东西。 

764
00:33:54,700 --> 00:33:57,139
Does d remember what else we should use?
 d还记得我们还应该使用什么吗？ 

765
00:33:57,339 --> 00:34:00,289
We talked about that last recitation.
我们谈到了最后一次朗诵。 

766
00:34:00,289 --> 00:34:02,200
Extend.
延伸。 

767
00:34:02,200 --> 00:34:03,379
Document distance 2 .
文件距离2。 

768
00:34:03,579 --> 00:34:06,579
The only difference between it an document distance 1
两者之间唯一的区别是文件距离1 

769
00:34:06,579 --> 00:34:09,639
is get words from line list, line 5.
是从第5行的行列表中获取单词。 

770
00:34:09,639 --> 00:34:12,579
That plus turned into an extend.
加上变成了扩展。 

771
00:34:12,579 --> 00:34:16,329
One character turned to six, so about eight keystrokes,
一个字符变成六个字符，所以大约八次击键， 

772
00:34:16,329 --> 00:34:18,440
30% runtime improvement.
运行时间提高30％。 

773
00:34:18,440 --> 00:34:20,500
Very good return on investment.
很好的投资回报率。 

774
00:34:20,500 --> 00:34:24,530
Everything else is going to be harder.
其他一切都会变得更加困难。 

775
00:34:24,530 --> 00:34:26,840
So let's look at that line, because that line dominated
让我们看一下这条线，因为那条线占主导地位

776
00:34:26,840 --> 00:34:29,769
the running time of get words from line list.
从行列表中获取单词的运行时间。 

777
00:34:29,769 --> 00:34:32,440
And think what's, then, your running time for it
然后想想您的运行时间

778
00:34:32,440 --> 00:34:33,449
now that I have extend?
现在我已经扩展了吗？ 

779
00:34:33,449 --> 00:35:05,440



780
00:35:05,440 --> 00:35:07,800
Does anyone remember what get words from line list does?
有谁记得行列表中的单词是什么？ 

781
00:35:07,800 --> 00:35:16,130



782
00:35:16,130 --> 00:35:19,565
AUDIENCE: It gets the words out of the document.
听众：它使单词从文档中脱颖而出。 

783
00:35:19,764 --> 00:35:20,389
PROFESSOR: OK .
教授：好的。 

784
00:35:20,389 --> 00:35:22,109
It gets the word out of the document.
它使单词从文档中脱颖而出。 

785
00:35:22,110 --> 00:35:25,519
So it reads a document that looks like a regular text file,
因此它会读取一个看起来像普通文本文件的文档， 

786
00:35:25,719 --> 00:35:30,239
and it gets this out of it.
它使它摆脱了困境。 

787
00:35:30,239 --> 00:35:33,189
The way it does that is it goes through each line,
这样做的方式是遍及每一行， 

788
00:35:33,190 --> 00:35:36,639
reads the line as a string, breaks up the string
将该行读取为字符串，将其分解

789
00:35:36,639 --> 00:35:39,309
into a list of words, and then combines
变成单词列表，然后合并

790
00:35:39,309 --> 00:35:42,239
all those lists of words together.
所有这些单词列表。 

791
00:35:42,239 --> 00:35:44,419
Get words from string, line 4, returns
从字符串第4行获取单词，返回

792
00:35:44,420 --> 00:35:47,114
the number of words in a line.
一行中的单词数。 

793
00:35:47,114 --> 00:35:49,030
Sorry, the list of words in the line, and then
抱歉，该行中的单词列表，然后

794
00:35:49,030 --> 00:35:51,510
extend combines the lists together.
扩展将列表合并在一起。 

795
00:35:51,510 --> 00:35:55,940
Let's add some constants that we had last time.
让我们添加上次使用的常量。 

796
00:35:56,139 --> 00:36:08,219
I think we had that K is the number of words per line.
我认为我们有K是每行的单词数。 

797
00:36:08,219 --> 00:36:16,849
And Z is the number of total lines.
 Z是总行数。 

798
00:36:16,849 --> 00:36:29,491
So this K is actually-- W over Z. No, I don't like that.
所以这个K实际上是-W超过Z。不，我不喜欢那样。 

799
00:36:29,492 --> 00:36:29,992
That's work.
辛苦了

800
00:36:29,992 --> 00:36:32,690



801
00:36:32,889 --> 00:36:43,730
So Z is K W over K. And we argued
所以Z是KW超过K。 

802
00:36:43,730 --> 00:36:45,369
that we're not going to talk about K
我们不会谈论K 

803
00:36:45,369 --> 00:36:48,489
too much, because a document needs to fit on a screen
太多，因为文档需要放在屏幕上

804
00:36:48,489 --> 00:36:50,819
or needs to fit on a piece of paper.
或需要放在一张纸上。 

805
00:36:50,820 --> 00:36:52,539
So the line length has to be finite, right?
所以线长必须是有限的，对吧？ 

806
00:36:52,739 --> 00:36:56,068
Otherwise, if I have a document that has 10,000 character
否则，如果我有一个包含10,000个字符的文档

807
00:36:56,068 --> 00:36:57,860
lines, I can't even write it on this board.
行，我什至不能在板上写下它。 

808
00:36:57,860 --> 00:36:59,940
Even though it's really long.
即使很长。 

809
00:36:59,940 --> 00:37:03,300
So K, the number of words in a line, is going to be finite.
因此，K（一行中的单词数）将是有限的。 

810
00:37:03,300 --> 00:37:06,269
But we'll need it for this analysis.
但是我们将需要此分析。 

811
00:37:06,269 --> 00:37:10,650
So line 4 returns a list with the words on a line.
因此，第4行返回一个包含一行文字的列表。 

812
00:37:10,650 --> 00:37:12,224
How many elements in that list?
该列表中有多少个元素？ 

813
00:37:12,224 --> 00:37:19,009



814
00:37:19,010 --> 00:37:22,460
This returns a list with how many elements?
这将返回包含多少个元素的列表？ 

815
00:37:22,659 --> 00:37:28,407



816
00:37:28,407 --> 00:37:31,458
AUDIENCE: Could K [INAUDIBLE] words on line.
听众：可以在线上输入[音频不清晰]个字。 

817
00:37:31,458 --> 00:37:33,250
PROFESSOR: So even if I ask easy questions,
教授：所以即使我问一些简单的问题， 

818
00:37:33,250 --> 00:37:34,248
you guys have to answer.
你们必须回答。 

819
00:37:34,248 --> 00:37:36,899
Because otherwise I'll stall until you do.
因为否则我会拖延直到你这样做。 

820
00:37:36,900 --> 00:37:39,039
So 4 gives me a list with K elements,
所以4给我一个包含K个元素的列表， 

821
00:37:39,239 --> 00:37:43,059
and 5 appends that small list to the big list of words
和5将这个小清单附加到大词清单

822
00:37:43,059 --> 00:37:45,039
in the entire document.
在整个文档中。 

823
00:37:45,039 --> 00:37:47,309
Before I used plus and that did something bad.
在我使用plus之前，那做得不好。 

824
00:37:47,309 --> 00:37:48,460
Now I'm using extend.
现在我正在使用扩展。 

825
00:37:48,460 --> 00:37:53,248
What's the cost of one extend called?
一次延期的费用是多少？ 

826
00:37:53,248 --> 00:37:54,706
AUDIENCE: Constant?
听众：持续吗？ 

827
00:37:54,706 --> 00:37:55,711
Order of K?
 K阶？ 

828
00:37:55,911 --> 00:37:58,119
PROFESSOR: I want to know your Python implementation.
教授：我想知道您的Python实现。 

829
00:37:58,119 --> 00:38:02,288



830
00:38:02,288 --> 00:38:04,708
AUDIENCE: If Python did it like a linked list ,
听众：如果Python像链表一样， 

831
00:38:04,708 --> 00:38:08,476
like doubly linked lists, could be order constant?
像双链表一样，顺序可以恒定吗？ 

832
00:38:08,476 --> 00:38:09,809
PROFESSOR: I like your question.
教授：我喜欢你的问题。 

833
00:38:09,809 --> 00:38:13,719
So if Python lists were actually linked lists--
因此，如果Python列表实际上是链接列表， 

834
00:38:13,719 --> 00:38:16,059
so if the name wasn't confusing--
所以如果这个名字不令人困惑- 

835
00:38:16,059 --> 00:38:18,320
then yes, merging two lists would be constant.
那么是的，合并两个列表将保持不变。 

836
00:38:18,320 --> 00:38:21,519
But then accessing one element in the middle of a list
但是然后访问列表中间的一个元素

837
00:38:21,519 --> 00:38:24,159
would not be constant anymore.
将不再是恒定的。 

838
00:38:24,159 --> 00:38:25,909
Say I want to access element number
说我要访问元素编号

839
00:38:25,909 --> 00:38:29,159
200 in a list of 10,000 elements.
 10,000个元素列表中的200个。 

840
00:38:29,159 --> 00:38:31,164
I have to go through 200 elements.
我必须经历200个要素。 

841
00:38:31,164 --> 00:38:32,539
We didn't do linked lists when we
我们没有链接列表

842
00:38:32,539 --> 00:38:33,929
ran it, so don't worry about it.
运行它，所以不用担心。 

843
00:38:33,929 --> 00:38:36,230
So they decided that it's less confusing to have
因此，他们认为拥有它不那么令人困惑

844
00:38:36,230 --> 00:38:39,710
lists actually be arrays.
列表实际上是数组。 

845
00:38:39,710 --> 00:38:42,500
So Python lists, array in CLRS.
因此Python列出了CLRS中的数组。 

846
00:38:42,500 --> 00:38:45,175



847
00:38:45,175 --> 00:38:47,300
AUDIENCE: That can use their storage contiguously?
听众：那可以连续使用它们的存储空间吗？ 

848
00:38:47,300 --> 00:38:48,000
PROFESSOR: Yep.
教授：是的。 

849
00:38:48,199 --> 00:38:50,929
AUDIENCE: So when you copy, why can't you copy a block?
听众：那么，当您复制时，为什么不能复制块？ 

850
00:38:50,929 --> 00:38:52,730
Why do you have to access each other?
为什么您必须互相访问？ 

851
00:38:52,731 --> 00:38:54,519
Does that make sense?
那有意义吗？ 

852
00:38:54,719 --> 00:38:56,929
PROFESSOR: So, you can copy a block,
教授：因此，您可以复制一个图块， 

853
00:38:56,929 --> 00:38:58,599
but in order to copy a block, you still
但是为了复制一个区块，您仍然

854
00:38:58,599 --> 00:39:00,269
have to move everything.
必须移动一切。 

855
00:39:00,269 --> 00:39:03,769
So if your block is 10,000 elements,
因此，如果您的区块是10,000个元素， 

856
00:39:03,769 --> 00:39:08,369
you still have to move 10,000 bytes times element size.
您仍然必须移动10,000字节乘以元素大小。 

857
00:39:08,369 --> 00:39:11,489
And the CPU works on 4 bytes at a time or 8 bytes at a time.
 CPU一次处理4个字节，一次处理8个字节。 

858
00:39:11,489 --> 00:39:13,989



859
00:39:13,989 --> 00:39:14,489
OK.
好。 

860
00:39:14,489 --> 00:39:16,149
But this is the right kind of thing
但这是正确的事情

861
00:39:16,150 --> 00:39:17,710
to be thinking about when you're doing the cost model.
考虑何时进行成本模型。 

862
00:39:17,909 --> 00:39:19,299
And this is what you want to have in your head
这就是您想拥有的

863
00:39:19,300 --> 00:39:20,423
when you're writing Python.
在编写Python时。 

864
00:39:20,423 --> 00:39:21,610
So, good.
这么好。 

865
00:39:21,610 --> 00:39:23,492
I like your question.
我喜欢你的问题。 

866
00:39:23,492 --> 00:39:24,750
I wanted to say that at some point,
我想说的是， 

867
00:39:24,949 --> 00:39:26,365
but I didn't get the occasion yet.
但我还没有得到机会。 

868
00:39:26,365 --> 00:39:28,050
Lists in Python are not lists in CLRS.
 Python中的列表不是CLRS中的列表。 

869
00:39:28,050 --> 00:39:30,561



870
00:39:30,561 --> 00:39:31,059
OK.
好。 

871
00:39:31,059 --> 00:39:35,029
So with that long explanation, an extend
因此，有了这么长的解释， 

872
00:39:35,030 --> 00:39:37,590
is a list-- is a sequence of appends, right?
是列表-是附加序列，对吗？ 

873
00:39:37,590 --> 00:39:39,019
If you have two lists and you want
如果您有两个列表，并且想要

874
00:39:39,019 --> 00:39:41,980
to extend the first list to the second list,
将第一个列表扩展到第二个列表， 

875
00:39:41,980 --> 00:39:44,639
extend basically goes through each element in the second list
扩展基本上遍历第二个列表中的每个元素

876
00:39:44,639 --> 00:39:47,799
and calls append on the first list.
并将通话追加到第一个列表上。 

877
00:39:47,800 --> 00:39:50,380
The list is length K, the second list is length K,
清单是长度K，第二个清单是长度K， 

878
00:39:50,380 --> 00:39:52,510
so K appends are going to happen.
因此，将发生K个追加。 

879
00:39:52,510 --> 00:39:54,000
And append is constant time.
而追加是固定时间。 

880
00:39:54,199 --> 00:39:55,909
Total cost, K.
总费用，K。 

881
00:39:55,909 --> 00:39:58,000
Now many times does line 5 run?
现在第5行运行了很多次吗？ 

882
00:39:58,000 --> 00:40:01,226



883
00:40:01,226 --> 00:40:03,264
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

884
00:40:03,264 --> 00:40:04,139
PROFESSOR: Very good.
教授：非常好。 

885
00:40:04,139 --> 00:40:07,139



886
00:40:07,139 --> 00:40:09,199
So what is the total running cost
那么总的运行成本是多少

887
00:40:09,199 --> 00:40:12,469
of the algorithm if this is the line that dominates?
的算法（如果这是主导线）？ 

888
00:40:12,469 --> 00:40:13,969
I don't want to do every other line,
我不想做其他任何事情， 

889
00:40:13,969 --> 00:40:16,250
so I'll promise that this is the line that dominates.
所以我保证这是支配地位的生产线。 

890
00:40:16,250 --> 00:40:19,300
What is the total running time?
总运行时间是多少？ 

891
00:40:19,300 --> 00:40:20,177
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

892
00:40:20,376 --> 00:40:20,960
PROFESSOR: OK.
教授：好的。 

893
00:40:20,960 --> 00:40:22,230
Very good.
很好。 

894
00:40:22,230 --> 00:40:23,389
K times L. And that is?
 K乘以L。那是吗？ 

895
00:40:23,389 --> 00:40:27,529



896
00:40:27,530 --> 00:40:32,960
Oh, K. So I shouldn't have said K times L, sorry.
哦，K。所以我不应该说K乘L，对不起。 

897
00:40:33,159 --> 00:40:35,429
L is not the number of lines.
 L不是行数。 

898
00:40:35,429 --> 00:40:40,250
L is the number here, so Z is the number of lines.
 L是这里的数字，所以Z是行数。 

899
00:40:40,250 --> 00:40:45,719
So it's K times Z. Which means I'm using bad letters,
所以它是K乘以Z。这意味着我使用的是错误的字母， 

900
00:40:45,719 --> 00:40:47,119
so please bear with me.
所以请多多包涵

901
00:40:47,119 --> 00:40:48,829
We'll forget about them in a minute.
我们将在一分钟内忘记它们。 

902
00:40:48,829 --> 00:40:50,829
So K times Z equals?
那么K乘以Z等于？ 

903
00:40:50,829 --> 00:40:53,469
AUDIENCE: W.
听众：W. 

904
00:40:53,469 --> 00:40:57,659
PROFESSOR: W. So what do I write here?
教授：W.那么我在这里写什么？ 

905
00:40:57,659 --> 00:41:01,993



906
00:41:01,994 --> 00:41:02,710
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

907
00:41:02,909 --> 00:41:03,529
PROFESSOR: OK.
教授：好的。 

908
00:41:03,530 --> 00:41:04,760
Good.
好。 

909
00:41:04,760 --> 00:41:05,630
Very good.
很好。 

910
00:41:05,829 --> 00:41:08,799
What do I write here?
我在这里写什么？ 

911
00:41:08,800 --> 00:41:11,862
Word frequencies from file.
文件中的单词频率。 

912
00:41:11,862 --> 00:41:13,137
AUDIENCE: W L.
听众：W L. 

913
00:41:13,137 --> 00:41:13,519
PROFESSOR: OK.
教授：好的。 

914
00:41:13,719 --> 00:41:16,459



915
00:41:16,460 --> 00:41:17,335
What do I write here?
我在这里写什么？ 

916
00:41:17,335 --> 00:41:21,407



917
00:41:21,407 --> 00:41:21,789
AUDIENCE: W 1.
听众：W 1。 

918
00:41:21,989 --> 00:41:35,149



919
00:41:35,150 --> 00:41:38,237
AUDIENCE: We have to-- put L 1 squared and L 2 squared back
观众：我们必须-将L 1平方和L 2平方放回

920
00:41:38,237 --> 00:41:38,750
in.
在。 

921
00:41:38,949 --> 00:41:40,159
PROFESSOR: OK, do we?
教授：好，好吗？ 

922
00:41:40,159 --> 00:41:43,059
Well, the-- No.
好吧-不

923
00:41:43,059 --> 00:41:45,534
W, you want to always be bigger than L. I hope.
 W，你想一直大于L。我希望。 

924
00:41:45,534 --> 00:41:46,159
PROFESSOR: Yep.
教授：是的。 

925
00:41:46,159 --> 00:41:48,679
So if I put it in, L 1 squared is
所以如果我放进去，L 1平方是

926
00:41:48,679 --> 00:41:53,569
L 1 L 1, which is smaller than W 1 L 1.
 L 1 L 1，小于W 1 L 1。 

927
00:41:53,570 --> 00:41:55,559
But I have to think about it before doing that.
但是我必须先考虑一下。 

928
00:41:55,559 --> 00:41:58,259
I can't ignore this completely.
我不能完全忽略这一点。 

929
00:41:58,260 --> 00:42:02,039



930
00:42:02,239 --> 00:42:04,209
So this is document distance 2.
这就是文档距离2。 

931
00:42:04,210 --> 00:42:07,206
The asymptotic complexity improved, the running time
渐近复杂度提高，运行时间

932
00:42:07,206 --> 00:42:07,706
improved.
改善。 

933
00:42:07,706 --> 00:42:14,529



934
00:42:14,530 --> 00:42:16,210
Next thing that happens to make this faster
接下来的事情使它变得更快

935
00:42:16,409 --> 00:42:19,179
is-- I'm not giving you the profiler output,
是-我没有给您分析器输出， 

936
00:42:19,179 --> 00:42:23,039
but you have to take my word for it that the longest methods are
但你必须相信我的意思，最长的方法是

937
00:42:23,039 --> 00:42:27,170
count frequency and inner product.
计算频率和内积。 

938
00:42:27,170 --> 00:42:29,769
So what I'm going to do first is I'm
所以我首先要做的是

939
00:42:29,769 --> 00:42:32,320
going to make inner product faster.
将使内部产品更快。 

940
00:42:32,320 --> 00:42:34,400
But in order to do that, I have to make
但是为了做到这一点，我必须

941
00:42:34,400 --> 00:42:36,550
word frequencies for file slower.
文件的字频变慢。 

942
00:42:36,550 --> 00:42:38,050
And that is because I happen to know
那是因为我碰巧知道

943
00:42:38,050 --> 00:42:44,030
an algorithm for inner product that is a lot faster, if only
内部产品的算法要快得多（如果有的话） 

944
00:42:44,030 --> 00:42:47,375
you can promise me that in this list, the words are ordered.
您可以向我保证，在此列表中，单词是有序的。 

945
00:42:47,574 --> 00:42:48,449
The words are sorted.
单词被排序。 

946
00:42:48,449 --> 00:42:51,210



947
00:42:51,210 --> 00:42:57,000
So what happens in that list 1 is, the moment I see a word,
所以清单1中发生的是，当我看到一个字时， 

948
00:42:57,000 --> 00:42:59,510
if it's not in the list I add it at the end.
如果不在列表中，请在最后添加。 

949
00:42:59,510 --> 00:43:01,820
So the words here show up pretty much in the order
因此，这里的单词几乎按顺序显示

950
00:43:01,820 --> 00:43:03,710
that they show up in the file.
他们出现在文件中。 

951
00:43:03,710 --> 00:43:05,679
Well, if instead I could have something
好吧，如果我可以有一些东西

952
00:43:05,679 --> 00:43:11,089
that looks like-- what is it?
看起来像什么？ 

953
00:43:11,090 --> 00:43:12,269
Fox.
狐狸。 

954
00:43:12,469 --> 00:43:13,730
In.
在。 

955
00:43:13,731 --> 00:43:14,230
His.
他的

956
00:43:14,230 --> 00:43:16,889



957
00:43:16,889 --> 00:43:19,849
Hat is somewhere here.
帽子在这里。 

958
00:43:19,849 --> 00:43:22,650
So if these words would be in this order,
因此，如果这些词按此顺序排列， 

959
00:43:22,650 --> 00:43:25,210
together with the word that I'm missing,
加上我想念的词， 

960
00:43:25,210 --> 00:43:27,269
then I can combine two lists.
然后我可以合并两个列表。 

961
00:43:27,469 --> 00:43:31,619
I can do an inner product a lot faster.
我可以更快地制作内部产品。 

962
00:43:31,619 --> 00:43:34,130
Let's see how that would work.
让我们看看这将如何工作。 

963
00:43:34,130 --> 00:43:37,360
And I'm already getting confused my words, so let's do a trick.
而且我已经迷惑了我的话，所以让我们做个窍门。 

964
00:43:37,360 --> 00:43:39,809
Let's say that instead of words, we'll use numbers.
假设我们将使用数字而不是文字。 

965
00:43:39,809 --> 00:43:41,570
So instead of saying "the," I'm going
所以我要说的不是“ the” 

966
00:43:41,570 --> 00:43:45,059
to say the is the 50th word in the dictionary.
可以说是字典中的第50个字。 

967
00:43:45,059 --> 00:43:47,956
So I'm going to use number 50.
所以我将使用数字50。 

968
00:43:47,956 --> 00:43:49,289
Because I want to write numbers.
因为我想写数字。 

969
00:43:49,289 --> 00:43:50,940
The numbers are easier to deal with.
数字更容易处理。 

970
00:43:50,940 --> 00:43:53,460
So say the first document that I have--
所以说我拥有的第一份文件- 

971
00:43:53,460 --> 00:43:59,840
the fox is in the hat-- as words number 3, 4, 6, 8, and 9.
狐狸戴着帽子-分别是数字3、4、6、8和9。 

972
00:43:59,840 --> 00:44:02,940
And they show up twice, once, once, once.
他们出现两次，一次，一次，一次。 

973
00:44:03,139 --> 00:44:06,359



974
00:44:06,360 --> 00:44:08,519
9, once.
 9，一次。 

975
00:44:08,719 --> 00:44:17,159
And say I'm trying to compute the inner product of this
并说我正在尝试计算这个的内积

976
00:44:17,159 --> 00:44:19,369
with a document that has word number 2
带有2号字的文档

977
00:44:19,369 --> 00:44:23,289
showing up once, word number 3 showing up once, word number
出现一次，单词编号3出现一次，单词编号

978
00:44:23,289 --> 00:44:28,349
6 showing up once, word number 7 showing up once,
 6出现一次，单词编号7出现一次， 

979
00:44:28,349 --> 00:44:30,173
word number 8 showing up once.
单词8出现一次。 

980
00:44:30,173 --> 00:44:33,737



981
00:44:33,737 --> 00:44:35,820
OK, the algorithm for inner product that we talked
好，我们谈到的内积算法

982
00:44:35,820 --> 00:44:39,050
about last time was, go through each element in one
大约是最后一次，遍历每个元素

983
00:44:39,050 --> 00:44:42,710
of the vectors, find an element with the same word
向量中，找到具有相同单词的元素

984
00:44:42,710 --> 00:44:45,409
in the second vector, and if you can find it,
在第二个向量中，如果可以找到它， 

985
00:44:45,409 --> 00:44:47,369
then take the number of times the words show up
然后计算单词出现的次数

986
00:44:47,369 --> 00:44:48,799
and multiply them.
并乘以它们。 

987
00:44:48,800 --> 00:44:50,360
So here I have a 3, 2.
所以我这里有3、2 

988
00:44:50,559 --> 00:44:54,204
I would find this element here that has 3, 1.
我会在这里找到具有3、1的元素。 

989
00:44:54,204 --> 00:44:55,204
I have these everywhere.
我到处都有这些。 

990
00:44:55,204 --> 00:44:58,029



991
00:44:58,030 --> 00:45:00,170
And I take the 2 and the 1 and I multiply them.
然后我取2和1，然后乘以它们。 

992
00:45:00,369 --> 00:45:03,920
So the 3s have to be the same, then I think the 2 and the 1,
因此3必须相同，然后我认为2和1 

993
00:45:03,920 --> 00:45:05,500
and I multiply them.
然后我将它们相乘。 

994
00:45:05,500 --> 00:45:08,269
And for all the elements where that's case,
对于所有这种情况， 

995
00:45:08,269 --> 00:45:10,429
I add up the results of the multiplication.
我将乘法结果相加。 

996
00:45:10,429 --> 00:45:13,419



997
00:45:13,420 --> 00:45:16,730
So step one, go through each element in a vector.
所以第一步，遍历向量中的每个元素。 

998
00:45:16,929 --> 00:45:20,094
That's not going to get faster if this other vector is
如果这个其他向量是

999
00:45:20,094 --> 00:45:21,259
sorted, right?
排序吧？ 

1000
00:45:21,260 --> 00:45:27,539
But the step of looking up the second element can be sped up.
但是可以加快查找第二个元素的步骤。 

1001
00:45:27,739 --> 00:45:31,429
The first and easiest way I can speed this up is, hey,
我加快速度的第一个也是最简单的方法是

1002
00:45:31,429 --> 00:45:32,250
this is sorted.
这是排序的。 

1003
00:45:32,250 --> 00:45:37,340
If I'm looking up three, why not do a binary search?
如果我要查找三个，为什么不进行二进制搜索？ 

1004
00:45:37,340 --> 00:45:39,440
What would be the cost if I do that?
如果这样做我要花多少钱？ 

1005
00:45:39,639 --> 00:45:43,670
So here I have L1 element, here I have L2 elements.
所以这里有L1元素，这里有L2元素。 

1006
00:45:43,670 --> 00:45:47,400
What's the cost of doing one binary search here?
在这里进行一次二进制搜索的费用是多少？ 

1007
00:45:47,400 --> 00:45:48,940
AUDIENCE: Log of L2?
听众：L2的对数？ 

1008
00:45:48,940 --> 00:45:51,659
PROFESSOR: OK.
教授：好的。 

1009
00:45:51,659 --> 00:45:55,201
And how many times do I do a binary search?
我要进行几次二进制搜索？ 

1010
00:45:55,201 --> 00:45:57,481
AUDIENCE: [INAUDIBLE].
听众：[听不清]。 

1011
00:45:57,681 --> 00:45:59,639
PROFESSOR: So if I go through each element here
教授：所以，如果我在这里介绍每个要素

1012
00:45:59,639 --> 00:46:02,138
and I do a binary search, which is a nice and easy algorithm
我进行了二进制搜索，这是一个很好的算法

1013
00:46:02,139 --> 00:46:03,800
that I can explain in 10 seconds,
我可以在10秒内解释一下， 

1014
00:46:03,800 --> 00:46:06,519
I'm already faster than L1 L2.
我已经快过L1 L2。 

1015
00:46:06,519 --> 00:46:08,679
So it's worth sorting.
因此，值得进行排序。 

1016
00:46:08,679 --> 00:46:11,199
Now, the algorithm that we use in class
现在，我们在课堂上使用的算法

1017
00:46:11,199 --> 00:46:15,789
takes time proportional to L1 plus L2.
需要的时间与L1加L2成正比。 

1018
00:46:15,789 --> 00:46:17,590
So that's even trickier, and it's
所以这更加棘手，而且

1019
00:46:17,590 --> 00:46:19,300
going to take a bit more time to explain.
需要更多时间来解释。 

1020
00:46:19,300 --> 00:46:21,769



1021
00:46:21,969 --> 00:46:24,250
Does-- did anyone understand the algorithm for class
是否-有没有人了解上课的算法

1022
00:46:24,250 --> 00:46:25,690
and wants to help me explain it?
想帮我解释一下吗？ 

1023
00:46:25,690 --> 00:46:30,579



1024
00:46:30,579 --> 00:46:32,789
Didn't think so.
不这么认为。 

1025
00:46:32,789 --> 00:46:34,139
OK.
好。 

1026
00:46:34,139 --> 00:46:39,230
So idea is that both of these vectors are sorted.
因此，我们认为这两个向量都已排序。 

1027
00:46:39,230 --> 00:46:46,389
So if I have a 3 here and I found my 3 here, next time when
因此，如果我在这里有一个3，而我在这里找到我的3，则下次

1028
00:46:46,389 --> 00:46:49,849
I get to 4, I know for sure that 4 is not
我达到4，我确定4不是

1029
00:46:49,849 --> 00:46:54,369
going to be anywhere here, because this vector is sorted.
将会在这里的任何地方，因为此向量已排序。 

1030
00:46:54,369 --> 00:46:57,549
Say I couldn't find 4, then I go to 6.
假设我找不到4，然后转到6。 

1031
00:46:57,550 --> 00:47:00,650
If 6 is here, when I have to look for 8,
如果6在这里，当我必须寻找8时

1032
00:47:00,849 --> 00:47:04,259
I know for sure that 8 is not going to be anywhere up here.
我肯定知道8不会在这里。 

1033
00:47:04,260 --> 00:47:07,210



1034
00:47:07,210 --> 00:47:11,289
So what I do is, I have a pointer here that remembers,
所以我要做的是，这里有一个指针可以记住

1035
00:47:11,289 --> 00:47:15,683
where's the last element that I have seen?
我见过的最后一个元素在哪里？ 

1036
00:47:15,684 --> 00:47:16,775
Does this make sense to people?
这对人们有意义吗？ 

1037
00:47:16,974 --> 00:47:19,889



1038
00:47:19,889 --> 00:47:22,500
So when I start here and I look at 3,
所以当我从这里开始看3 

1039
00:47:22,500 --> 00:47:26,300
I have a pointer here that says, I didn't see anything here.
我在这里有一个指针，说，我在这里什么都没看见。 

1040
00:47:26,300 --> 00:47:28,170
I look at 2, it's not 3.
我看2，不是3。 

1041
00:47:28,170 --> 00:47:29,050
It's smaller.
更小

1042
00:47:29,050 --> 00:47:29,940
I look at 3.
我看3。 

1043
00:47:29,940 --> 00:47:30,750
I found it, good.
我找到了，很好。 

1044
00:47:30,949 --> 00:47:32,719
I do my product.
我做我的产品。 

1045
00:47:32,719 --> 00:47:35,609
Then I go look for the next element here, 4.
然后我在这里寻找下一个元素4。 

1046
00:47:35,610 --> 00:47:36,644
I look at 6.
我看6。 

1047
00:47:36,844 --> 00:47:38,839
6 is bigger than 4.
 6大于4。 

1048
00:47:38,840 --> 00:47:42,980
So I know for sure that nothing below it is going to be 4.
因此，我可以肯定的是，下面没有任何东西将是4。 

1049
00:47:42,980 --> 00:47:46,139
So I can stop right here and keep my pointer here.
所以我可以在这里停下来，将指针放在这里。 

1050
00:47:46,139 --> 00:47:47,839
Then I go to 6 here.
然后我在这里转到6。 

1051
00:47:47,840 --> 00:47:48,579
And I look here.
我看这里。 

1052
00:47:48,579 --> 00:47:49,299
Where did I stop?
我在哪停了

1053
00:47:49,300 --> 00:47:50,519
I stop here.
我在这里停止。 

1054
00:47:50,519 --> 00:47:52,030
This element matches this.
该元素与此匹配。 

1055
00:47:52,030 --> 00:47:53,750
I do my product.
我做我的产品。 

1056
00:47:53,750 --> 00:47:56,150
Keep it in.
保持它。 

1057
00:47:56,150 --> 00:47:58,030
Now I go to 8 here.
现在我去这里8。 

1058
00:47:58,030 --> 00:47:59,110
I was at 6.
我六岁

1059
00:47:59,309 --> 00:48:01,320
6 is smaller than 8.
 6小于8。 

1060
00:48:01,320 --> 00:48:03,036
7 is smaller than 8.
 7小于8。 

1061
00:48:03,235 --> 00:48:04,420
8 is equal to 8.
 8等于8 

1062
00:48:04,420 --> 00:48:05,630
I found something.
我发现了

1063
00:48:05,630 --> 00:48:06,849
Sweet.
甜。 

1064
00:48:06,849 --> 00:48:08,500
I do a product.
我做一个产品。 

1065
00:48:08,500 --> 00:48:09,730
And then I stop.
然后我停下来。 

1066
00:48:09,730 --> 00:48:12,320
And I look at the next element.
我看下一个要素。 

1067
00:48:12,320 --> 00:48:15,630
I know for sure that nothing here is going to be 9,
我肯定知道这里不会是9， 

1068
00:48:15,829 --> 00:48:17,610
so I can keep looking down.
所以我可以继续低头

1069
00:48:17,610 --> 00:48:19,960
I hit the end of my list.
我打到列表的末尾。 

1070
00:48:20,159 --> 00:48:21,309
OK.
好。 

1071
00:48:21,309 --> 00:48:25,068
Whatever I have down here-- it's going 9, 10, 11, 12--
无论我在这里遇到的什么-即将发生9、10、11、12， 

1072
00:48:25,068 --> 00:48:27,360
is not going to be in this list, because it was sorted.
由于已排序，因此不会出现在此列表中。 

1073
00:48:27,360 --> 00:48:30,474
So I can stop.
所以我可以停下来。 

1074
00:48:30,474 --> 00:48:34,339
AUDIENCE: How do you keep going--
听众：您如何继续前进- 

1075
00:48:34,340 --> 00:48:37,340
What algorithm so you use to keep looking down on L2?
那么您使用什么算法来继续看不起L2？ 

1076
00:48:37,340 --> 00:48:38,204
PROFESSOR: Plus 1.
教授：加1。 

1077
00:48:38,204 --> 00:48:38,920
AUDIENCE: So what if--
听众：如果…… 

1078
00:48:39,119 --> 00:48:40,327
PROFESSOR: I keep going down.
教授：我一直下去。 

1079
00:48:40,327 --> 00:48:46,360
AUDIENCE: What if the left side was 3, 4, 6, 9243?
听众：如果左侧是3、4、6、9243，该怎么办？ 

1080
00:48:46,360 --> 00:48:47,170
PROFESSOR: 9,000, what?
教授：9,000，什么？ 

1081
00:48:47,369 --> 00:48:48,469
AUDIENCE: Just a big number.
听众：人数很多。 

1082
00:48:48,469 --> 00:48:49,135
AUDIENCE: Right.
听众：对。 

1083
00:48:49,135 --> 00:48:52,713
Then you have to increment by 1 each time--
然后，您每次必须增加1- 

1084
00:48:52,713 --> 00:48:54,130
PROFESSOR: So I'm not incrementing
教授：所以我没有增加

1085
00:48:54,130 --> 00:48:56,079
the number I'm looking at.
我在看的号码。 

1086
00:48:56,079 --> 00:48:57,710
Here, I looked at 6.
在这里，我看着6。 

1087
00:48:57,710 --> 00:48:59,610
Then I'm looking for 8.
然后我正在寻找8。 

1088
00:48:59,610 --> 00:49:02,980
And after I found 8, I'm looking for 19,000.
我找到8后，我正在寻找19,000。 

1089
00:49:03,179 --> 00:49:06,799
So I'm going to go down, either until I find 90,000
所以我要下去，直到找到90,000 

1090
00:49:06,800 --> 00:49:07,710
or until I stop.
或直到我停下来。 

1091
00:49:07,710 --> 00:49:10,382
AUDIENCE: So are you going to go down one at a time,
听众：那么你一次要走下去吗？ 

1092
00:49:10,382 --> 00:49:11,007
PROFESSOR: Yep.
教授：是的。 

1093
00:49:11,007 --> 00:49:13,840
AUDIENCE: --why not do a binary search?
听众：-为什么不进行二进制搜索？ 

1094
00:49:13,840 --> 00:49:16,559
PROFESSOR: Because if I do a binary search,
教授：因为如果我执行二进制搜索， 

1095
00:49:16,559 --> 00:49:20,549
the analysis that says it's fast is not going to work.
表示速度很快的分析将无法进行。 

1096
00:49:20,550 --> 00:49:23,550
It turns out that this gives me the optimal running time.
事实证明，这给了我最佳的运行时间。 

1097
00:49:23,550 --> 00:49:28,630
If I do a binary search, suppose I have a list that's like this.
如果我执行二进制搜索，假设我有一个像这样的列表。 

1098
00:49:28,829 --> 00:49:33,509
1, 2, 3, 4, 5, all the way down to 10,000.
 1，2，3，4，5，一直下降到10,000 

1099
00:49:33,509 --> 00:49:36,750
Ugh, I can't write.
 gh，我不会写。 

1100
00:49:36,750 --> 00:49:39,920
And I have another list that's like this- 1, 2, 3, 4,
我还有另一个像这样的列表-1，2，3，4， 

1101
00:49:39,920 --> 00:49:42,800
all the way down to 10,000.
一路下降到10,000。 

1102
00:49:42,800 --> 00:49:44,519
1, 1.
 1、1 

1103
00:49:44,719 --> 00:49:49,829
I do a binary search, takes log N. I look at 2.
我执行二进制搜索，并取日志N。我看一下2。 

1104
00:49:49,829 --> 00:49:53,230
I do a binary search, takes almost log N. I look at 3,
我进行了二进制搜索，几乎耗费了日志N。我看一下3， 

1105
00:49:53,230 --> 00:49:56,351
do a binary search, takes almost log N. So on, so forth.
进行二进制搜索，几乎需要N日志。依此类推。 

1106
00:49:56,351 --> 00:49:59,549



1107
00:49:59,550 --> 00:50:00,505
So this is--
所以这是- 

1108
00:50:00,704 --> 00:50:03,213
AUDIENCE: But if your left list had been
观众：但是如果您的左清单是

1109
00:50:03,213 --> 00:50:04,380
PROFESSOR: Log N plus log N.
教授：日志N加日志N。 

1110
00:50:04,380 --> 00:50:06,034
AUDIENCE: --10,000.
观众：--10,000。 

1111
00:50:06,034 --> 00:50:06,500
PROFESSOR: Yeah.
教授：是的。 

1112
00:50:06,699 --> 00:50:09,769
AUDIENCE: You'd have taken N time.
听众：您会花N时间。 

1113
00:50:09,769 --> 00:50:10,630
PROFESSOR: Yes.
教授：是的。 

1114
00:50:10,630 --> 00:50:13,030
Well, this algorithm takes N time,
嗯，这个算法要花N个时间， 

1115
00:50:13,030 --> 00:50:15,800
even if I have to list like this.
即使我必须这样列出。 

1116
00:50:15,800 --> 00:50:19,289
It takes 10,000 plus 10,000 time.
这需要10,000加10,000时间。 

1117
00:50:19,489 --> 00:50:21,699
Whereas this algorithm will take time that's actually
而此算法实际上需要花费时间

1118
00:50:21,699 --> 00:50:29,909
proportional to 10,000 log 10,000.
与10,000 log 10,000成正比。 

1119
00:50:29,909 --> 00:50:30,739
You believe me.
你相信我

1120
00:50:30,739 --> 00:50:34,479
So, a way to look at this is to do bounds and say,
因此，一种看待此问题的方法是做边界并说， 

1121
00:50:34,480 --> 00:50:37,139
for the elements 1 through 5,000,
对于元素1到5,000， 

1122
00:50:37,139 --> 00:50:41,469
it's going to do a binary search for more than 5,000 elements.
它将对5,000多个元素进行二进制搜索。 

1123
00:50:41,469 --> 00:50:44,169
So, the time-- the running time is definitely bigger
因此，时间-运行时间肯定更大

1124
00:50:44,170 --> 00:50:48,365
than N over 2 log N over 2.
 N大于2 log N大于2 

1125
00:50:48,365 --> 00:50:51,840



1126
00:50:51,840 --> 00:50:52,630
Constant.
不变。 

1127
00:50:52,630 --> 00:51:00,710
This becomes log N minus 1 and log N.
这将成为log N减去1并得到logN。 

1128
00:51:00,710 --> 00:51:01,900
That is a good question.
这是一个好问题。 

1129
00:51:01,900 --> 00:51:04,340
I wondered about that the first time I saw merge-sort too.
我第一次也看到合并排序就在想这个问题。 

1130
00:51:04,340 --> 00:51:05,809
And I was thinking, hey, I'm going
我在想，嘿，我要去

1131
00:51:05,809 --> 00:51:07,768
to do a binary search here because it's faster,
在这里进行二进制搜索，因为它速度更快， 

1132
00:51:07,768 --> 00:51:10,510
and I'm going to make a faster algorithm than anyone has ever
我将制定一个比任何人都更快的算法

1133
00:51:10,510 --> 00:51:11,190
seen.
看过。 

1134
00:51:11,389 --> 00:51:13,319
Well, if you do the analysis, not so much.
好吧，如果您进行分析，则不需要太多。 

1135
00:51:13,320 --> 00:51:14,460
But you need to think about it, and you
但是你需要考虑一下，你

1136
00:51:14,659 --> 00:51:16,659
need to know why that's true or that's not true.
需要知道为什么这是正确的还是错误的。 

1137
00:51:16,659 --> 00:51:17,670
So I like your question.
所以我喜欢你的问题。 

1138
00:51:17,670 --> 00:51:20,139
Thank you.
谢谢。 

1139
00:51:20,139 --> 00:51:22,519
So now let's get down so the plain old merge-sort
所以现在让我们开始吧，简单的旧合并排序

1140
00:51:22,519 --> 00:51:26,860
that everyone-- sorry, merge that everyone knows.
所有人-抱歉，大家知道的合并。 

1141
00:51:26,860 --> 00:51:30,610
So if we go through these one by one,
所以，如果我们一个接一个地经历这些， 

1142
00:51:30,610 --> 00:51:33,880
how many times am I going to be advancing this pointer?
我该指针前进多少次？ 

1143
00:51:33,880 --> 00:51:35,498
In total?
总共？ 

1144
00:51:35,498 --> 00:51:36,920
AUDIENCE: L2?
听众：L2？ 

1145
00:51:36,920 --> 00:51:38,159
PROFESSOR: L2 times.
教授：L2次。 

1146
00:51:38,159 --> 00:51:42,539
So this pointer can only go down, right?
所以这个指针只能下降，对吗？ 

1147
00:51:42,539 --> 00:51:45,659
So worst case is going to go down L2 times.
因此，最坏的情况将下降L2倍。 

1148
00:51:45,659 --> 00:51:48,549
And then I'm done with the list, return.
然后我完成了列表，返回。 

1149
00:51:48,550 --> 00:51:50,380
How many elements am I going to look through?
我要浏览多少个元素？ 

1150
00:51:50,579 --> 00:51:53,300
So how many times does this pointer going to advance?
那么该指针将前进多少次？ 

1151
00:51:53,300 --> 00:51:53,842
AUDIENCE: L1?
听众：L1？ 

1152
00:51:53,842 --> 00:51:56,500



1153
00:51:56,699 --> 00:51:59,079
PROFESSOR: This one.
教授：这个。 

1154
00:51:59,079 --> 00:52:00,549
AUDIENCE: But I thought, like--
听众：但是我想， 

1155
00:52:00,550 --> 00:52:03,289
AUDIENCE: Then you get extra ones in between.
听众：然后您会在两者之间得到额外的好处。 

1156
00:52:03,489 --> 00:52:05,559
PROFESSOR: What if L2 is bigger than L1?
教授：如果L2大于L1怎么办？ 

1157
00:52:05,559 --> 00:52:06,779
What if--
如果 - 

1158
00:52:06,780 --> 00:52:07,460
AUDIENCE: Oh, right.
听众：哦，对。 

1159
00:52:07,659 --> 00:52:08,539
OK, never mind.
好吧，那算了。 

1160
00:52:08,539 --> 00:52:10,498
The reason I said L2 was because--
我说L2的原因是- 

1161
00:52:10,498 --> 00:52:13,039
PROFESSOR: You're thinking after I'm going through this list,
教授：您在考虑这份清单之后， 

1162
00:52:13,039 --> 00:52:13,699
I'm out, right?
我出去了吧？ 

1163
00:52:13,699 --> 00:52:15,324
AUDIENCE: Right, that's what I thought.
听众：对，这就是我的想法。 

1164
00:52:15,324 --> 00:52:17,639
PROFESSOR: So, your answer works if this list, say, has
教授：所以，如果这个清单有

1165
00:52:17,639 --> 00:52:19,619
10 elements and this has 10,000.
 10个元素，这个有10,000个。 

1166
00:52:19,619 --> 00:52:22,230
And I go through this one really quickly.
我真的很快经历了这一步。 

1167
00:52:22,230 --> 00:52:25,697
But if this list has 10 elements and this list has 10,000,
但是，如果此列表包含10个元素，并且此列表包含10,000个元素， 

1168
00:52:25,697 --> 00:52:27,280
and they both start with 1 through 10,
他们都以1到10开头， 

1169
00:52:27,280 --> 00:52:31,460
I have to say a 1 because that's a better bound.
我必须说1，因为这是一个更好的界限。 

1170
00:52:31,659 --> 00:52:33,596
So I have to say this.
所以我必须这样说。 

1171
00:52:33,596 --> 00:52:35,344
AUDIENCE: Could you say the opposite value
听众：你能说相反的价值吗？ 

1172
00:52:35,344 --> 00:52:37,449
of the difference between the two of them?
他们两个之间的区别是什么？ 

1173
00:52:37,449 --> 00:52:39,485
Because if you're going to stop at 1 has 10
因为如果您要在1停下来，则有10 

1174
00:52:39,485 --> 00:52:43,119
and the other one has 10,000, and let's say
另一个有10,000，比方说

1175
00:52:43,119 --> 00:52:46,578
that only the first ten are actually equal,
实际上只有前十个相等

1176
00:52:46,579 --> 00:52:48,670
then you're going to go through that list, find all 10,
然后您将遍历该列表，找到全部10个， 

1177
00:52:48,869 --> 00:52:50,109
and you stop.
然后你停下来

1178
00:52:50,110 --> 00:52:51,059
That would be 9,000--
那将是9,000- 

1179
00:52:51,059 --> 00:52:53,150
PROFESSOR: I could say about that if I'm looking at one
教授：如果我看着一个，我可以说

1180
00:52:53,349 --> 00:52:56,159
case, but the magic trick is-- let's-- we're looking
的情况，但魔术是-让我们-我们正在寻找

1181
00:52:56,159 --> 00:52:57,679
at the worst case.
在最坏的情况下。 

1182
00:52:57,679 --> 00:52:59,844
So worst case, if I have 10 elements,
所以最坏的情况是，如果我有10个元素， 

1183
00:52:59,844 --> 00:53:01,760
they'll be all the way down in the other list.
他们将一直排在其他列表中。 

1184
00:53:01,760 --> 00:53:03,010
Or they won't be there at all.
否则他们根本不会在那里。 

1185
00:53:03,010 --> 00:53:04,769
And I have to go down through all the list.
我必须浏览所有列表。 

1186
00:53:04,969 --> 00:53:07,669
AUDIENCE: OK.
听众：好的。 

1187
00:53:07,670 --> 00:53:09,639
PROFESSOR: So worst case, L1 plus L2.
教授：最糟糕的情况是L1加L2。 

1188
00:53:09,639 --> 00:53:15,000



1189
00:53:15,000 --> 00:53:18,760
Let me see if I have any time left.
让我看看是否还有时间。 

1190
00:53:18,760 --> 00:53:19,519
Nope.
不。 

1191
00:53:19,719 --> 00:53:25,049
So, what I would like you to do is go through insertion sort.
因此，我希望您要做的是进行插入排序。 

1192
00:53:25,050 --> 00:53:27,500
Insertion sort matches the textbook.
插入排序与教科书匹配。 

1193
00:53:27,699 --> 00:53:30,539
Look at the definition in the textbook, look at the code,
看课本中的定义，看代码， 

1194
00:53:30,539 --> 00:53:32,009
convince yourself it's the same.
说服自己是一样的。 

1195
00:53:32,009 --> 00:53:33,800
Look at the running time, convince yourself
看一下跑步时间，说服自己

1196
00:53:33,800 --> 00:53:35,280
it's N squared.
它是N平方的。 

1197
00:53:35,280 --> 00:53:38,880
Then look at inner product and convince yourself
然后看一下内部产品并说服自己

1198
00:53:38,880 --> 00:53:41,360
that this is what it does.
这就是它的作用。 

1199
00:53:41,360 --> 00:53:44,820
Go through this line by line, see where they match,
逐行浏览，查看它们的匹配位置， 

1200
00:53:44,820 --> 00:53:45,900
put the cost on.
付出代价。 

1201
00:53:46,099 --> 00:53:49,039
Make sure that the cost is L1 plus L2.
确保成本为L1加L2。 

1202
00:53:49,039 --> 00:53:52,809
And last, go through merge-sort and notice
最后，进行合并排序并注意

1203
00:53:52,809 --> 00:53:56,659
that merge in [INAUDIBLE] 6 is exactly the same
 [音频不清晰] 6中的合并完全相同

1204
00:53:56,659 --> 00:53:57,879
as inner product.
作为内部产品。 

1205
00:53:57,880 --> 00:54:00,019
So this pointer magic that I did here
所以我在这里做的指针魔术

1206
00:54:00,019 --> 00:54:02,440
is exactly what's happening inside merge.
正是合并内部发生的事情。 

1207
00:54:02,440 --> 00:54:03,570
And understand merge-sort.
并了解合并排序。 

1208
00:54:03,570 --> 00:54:05,630
Look at the textbook, look at the notes,
看课本，看笔记， 

1209
00:54:05,630 --> 00:54:08,269
and see how they match.
并查看它们如何匹配。 

1210
00:54:08,269 --> 00:54:08,869
OK.
好。 

1211
00:54:08,869 --> 00:54:13,869
Thanks, guys.
多谢你们。 

